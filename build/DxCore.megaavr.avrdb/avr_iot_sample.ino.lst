
C:\Users\bobm\AppData\Local\Temp\arduino\sketches\DA0FA9569B76E7AC40DDB4090925BE98/avr_iot_sample.ino.elf:     file format elf32-avr


Disassembly of section .text:

00000000 <__vectors>:
__vectors():
../../../../crt1/gcrt1.S:61
       0:	b6 c1       	rjmp	.+876    	; 0x36e <__ctors_end>
       2:	00 00       	nop
../../../../crt1/gcrt1.S:67
       4:	ea c1       	rjmp	.+980    	; 0x3da <__bad_interrupt>
       6:	00 00       	nop
../../../../crt1/gcrt1.S:68
       8:	e8 c1       	rjmp	.+976    	; 0x3da <__bad_interrupt>
       a:	00 00       	nop
../../../../crt1/gcrt1.S:69
       c:	e6 c1       	rjmp	.+972    	; 0x3da <__bad_interrupt>
       e:	00 00       	nop
../../../../crt1/gcrt1.S:70
      10:	e4 c1       	rjmp	.+968    	; 0x3da <__bad_interrupt>
      12:	00 00       	nop
../../../../crt1/gcrt1.S:71
      14:	e2 c1       	rjmp	.+964    	; 0x3da <__bad_interrupt>
      16:	00 00       	nop
../../../../crt1/gcrt1.S:72
      18:	0c 94 dc 33 	jmp	0x67b8	; 0x67b8 <__vector_6>
../../../../crt1/gcrt1.S:73
      1c:	de c1       	rjmp	.+956    	; 0x3da <__bad_interrupt>
      1e:	00 00       	nop
../../../../crt1/gcrt1.S:74
      20:	0c 94 e8 30 	jmp	0x61d0	; 0x61d0 <__vector_8>
../../../../crt1/gcrt1.S:75
      24:	da c1       	rjmp	.+948    	; 0x3da <__bad_interrupt>
      26:	00 00       	nop
../../../../crt1/gcrt1.S:76
      28:	d8 c1       	rjmp	.+944    	; 0x3da <__bad_interrupt>
      2a:	00 00       	nop
../../../../crt1/gcrt1.S:77
      2c:	d6 c1       	rjmp	.+940    	; 0x3da <__bad_interrupt>
      2e:	00 00       	nop
../../../../crt1/gcrt1.S:78
      30:	d4 c1       	rjmp	.+936    	; 0x3da <__bad_interrupt>
      32:	00 00       	nop
../../../../crt1/gcrt1.S:79
      34:	d2 c1       	rjmp	.+932    	; 0x3da <__bad_interrupt>
      36:	00 00       	nop
../../../../crt1/gcrt1.S:80
      38:	d0 c1       	rjmp	.+928    	; 0x3da <__bad_interrupt>
      3a:	00 00       	nop
../../../../crt1/gcrt1.S:81
      3c:	ce c1       	rjmp	.+924    	; 0x3da <__bad_interrupt>
      3e:	00 00       	nop
../../../../crt1/gcrt1.S:82
      40:	cc c1       	rjmp	.+920    	; 0x3da <__bad_interrupt>
      42:	00 00       	nop
../../../../crt1/gcrt1.S:83
      44:	ca c1       	rjmp	.+916    	; 0x3da <__bad_interrupt>
      46:	00 00       	nop
../../../../crt1/gcrt1.S:84
      48:	0c 94 e9 31 	jmp	0x63d2	; 0x63d2 <__vector_18>
../../../../crt1/gcrt1.S:85
      4c:	c6 c1       	rjmp	.+908    	; 0x3da <__bad_interrupt>
      4e:	00 00       	nop
../../../../crt1/gcrt1.S:86
      50:	c4 c1       	rjmp	.+904    	; 0x3da <__bad_interrupt>
      52:	00 00       	nop
../../../../crt1/gcrt1.S:87
      54:	c2 c1       	rjmp	.+900    	; 0x3da <__bad_interrupt>
      56:	00 00       	nop
../../../../crt1/gcrt1.S:88
      58:	c0 c1       	rjmp	.+896    	; 0x3da <__bad_interrupt>
      5a:	00 00       	nop
../../../../crt1/gcrt1.S:89
      5c:	be c1       	rjmp	.+892    	; 0x3da <__bad_interrupt>
      5e:	00 00       	nop
../../../../crt1/gcrt1.S:90
      60:	0c 94 df 30 	jmp	0x61be	; 0x61be <__vector_24>
../../../../crt1/gcrt1.S:91
      64:	ba c1       	rjmp	.+884    	; 0x3da <__bad_interrupt>
      66:	00 00       	nop
../../../../crt1/gcrt1.S:92
      68:	b8 c1       	rjmp	.+880    	; 0x3da <__bad_interrupt>
      6a:	00 00       	nop
../../../../crt1/gcrt1.S:93
      6c:	b6 c1       	rjmp	.+876    	; 0x3da <__bad_interrupt>
      6e:	00 00       	nop
../../../../crt1/gcrt1.S:94
      70:	b4 c1       	rjmp	.+872    	; 0x3da <__bad_interrupt>
      72:	00 00       	nop
../../../../crt1/gcrt1.S:95
      74:	b2 c1       	rjmp	.+868    	; 0x3da <__bad_interrupt>
      76:	00 00       	nop
../../../../crt1/gcrt1.S:96
      78:	0c 94 e2 30 	jmp	0x61c4	; 0x61c4 <__vector_30>
../../../../crt1/gcrt1.S:97
      7c:	0c 94 bd 30 	jmp	0x617a	; 0x617a <__vector_31>
../../../../crt1/gcrt1.S:98
      80:	0c 94 51 32 	jmp	0x64a2	; 0x64a2 <__vector_32>
../../../../crt1/gcrt1.S:99
      84:	0c 94 13 32 	jmp	0x6426	; 0x6426 <__vector_33>
../../../../crt1/gcrt1.S:100
      88:	a8 c1       	rjmp	.+848    	; 0x3da <__bad_interrupt>
      8a:	00 00       	nop
../../../../crt1/gcrt1.S:101
      8c:	0c 94 d9 30 	jmp	0x61b2	; 0x61b2 <__vector_35>
../../../../crt1/gcrt1.S:102
      90:	a4 c1       	rjmp	.+840    	; 0x3da <__bad_interrupt>
      92:	00 00       	nop
../../../../crt1/gcrt1.S:103
      94:	a2 c1       	rjmp	.+836    	; 0x3da <__bad_interrupt>
      96:	00 00       	nop
../../../../crt1/gcrt1.S:104
      98:	a0 c1       	rjmp	.+832    	; 0x3da <__bad_interrupt>
      9a:	00 00       	nop
../../../../crt1/gcrt1.S:105
      9c:	9e c1       	rjmp	.+828    	; 0x3da <__bad_interrupt>
      9e:	00 00       	nop
../../../../crt1/gcrt1.S:106
      a0:	9c c1       	rjmp	.+824    	; 0x3da <__bad_interrupt>
      a2:	00 00       	nop
../../../../crt1/gcrt1.S:107
      a4:	9a c1       	rjmp	.+820    	; 0x3da <__bad_interrupt>
      a6:	00 00       	nop
../../../../crt1/gcrt1.S:108
      a8:	0c 94 bf 31 	jmp	0x637e	; 0x637e <__vector_42>
../../../../crt1/gcrt1.S:109
      ac:	96 c1       	rjmp	.+812    	; 0x3da <__bad_interrupt>
      ae:	00 00       	nop
../../../../crt1/gcrt1.S:110
      b0:	94 c1       	rjmp	.+808    	; 0x3da <__bad_interrupt>
      b2:	00 00       	nop
../../../../crt1/gcrt1.S:111
      b4:	0c 94 e5 30 	jmp	0x61ca	; 0x61ca <__vector_45>
../../../../crt1/gcrt1.S:112
      b8:	0c 94 dc 30 	jmp	0x61b8	; 0x61b8 <__vector_46>
../../../../crt1/gcrt1.S:113
      bc:	8e c1       	rjmp	.+796    	; 0x3da <__bad_interrupt>
      be:	00 00       	nop
../../../../crt1/gcrt1.S:114
      c0:	8c c1       	rjmp	.+792    	; 0x3da <__bad_interrupt>
      c2:	00 00       	nop
../../../../crt1/gcrt1.S:115
      c4:	8a c1       	rjmp	.+788    	; 0x3da <__bad_interrupt>
      c6:	00 00       	nop
../../../../crt1/gcrt1.S:116
      c8:	88 c1       	rjmp	.+784    	; 0x3da <__bad_interrupt>
      ca:	00 00       	nop
../../../../crt1/gcrt1.S:117
      cc:	86 c1       	rjmp	.+780    	; 0x3da <__bad_interrupt>
      ce:	00 00       	nop
../../../../crt1/gcrt1.S:118
      d0:	84 c1       	rjmp	.+776    	; 0x3da <__bad_interrupt>
      d2:	00 00       	nop
../../../../crt1/gcrt1.S:119
      d4:	0c 94 3c 31 	jmp	0x6278	; 0x6278 <__vector_53>
../../../../crt1/gcrt1.S:120
      d8:	0c 94 36 31 	jmp	0x626c	; 0x626c <__vector_54>
../../../../crt1/gcrt1.S:121
      dc:	0c 94 42 31 	jmp	0x6284	; 0x6284 <__vector_55>
../../../../crt1/gcrt1.S:122
      e0:	7c c1       	rjmp	.+760    	; 0x3da <__bad_interrupt>
      e2:	00 00       	nop
../../../../crt1/gcrt1.S:123
      e4:	7a c1       	rjmp	.+756    	; 0x3da <__bad_interrupt>
      e6:	00 00       	nop
../../../../crt1/gcrt1.S:124
      e8:	78 c1       	rjmp	.+752    	; 0x3da <__bad_interrupt>
      ea:	00 00       	nop
../../../../crt1/gcrt1.S:125
      ec:	76 c1       	rjmp	.+748    	; 0x3da <__bad_interrupt>
      ee:	00 00       	nop
../../../../crt1/gcrt1.S:126
      f0:	74 c1       	rjmp	.+744    	; 0x3da <__bad_interrupt>
      f2:	00 00       	nop
      f4:	08 00       	.word	0x0008	; ????
      f6:	00 00       	nop
      f8:	be 92       	st	-X, r11
      fa:	24 49       	sbci	r18, 0x94	; 148
      fc:	12 3e       	cpi	r17, 0xE2	; 226
      fe:	ab aa       	std	Y+51, r10	; 0x33
     100:	aa 2a       	or	r10, r26
     102:	be cd       	rjmp	.-1156   	; 0xfffffc80 <__eeprom_end+0xff7efc80>
     104:	cc cc       	rjmp	.-1640   	; 0xfffffa9e <__eeprom_end+0xff7efa9e>
     106:	4c 3e       	cpi	r20, 0xEC	; 236
     108:	00 00       	nop
     10a:	00 80       	ld	r0, Z
     10c:	be ab       	std	Y+54, r27	; 0x36
     10e:	aa aa       	std	Y+50, r10	; 0x32
     110:	aa 3e       	cpi	r26, 0xEA	; 234
     112:	00 00       	nop
     114:	00 00       	nop
     116:	bf 00       	.word	0x00bf	; ????
     118:	00 00       	nop
     11a:	80 3f       	cpi	r24, 0xF0	; 240
     11c:	00 00       	nop
     11e:	00 00       	nop
     120:	00 08       	sbc	r0, r0
     122:	41 78       	andi	r20, 0x81	; 129
     124:	d3 bb       	out	0x13, r29	; 19
     126:	43 87       	std	Z+11, r20	; 0x0b
     128:	d1 13       	cpse	r29, r17
     12a:	3d 19       	sub	r19, r13
     12c:	0e 3c       	cpi	r16, 0xCE	; 206
     12e:	c3 bd       	out	0x23, r28	; 35
     130:	42 82       	std	Z+2, r4	; 0x02
     132:	ad 2b       	or	r26, r29
     134:	3e 68       	ori	r19, 0x8E	; 142
     136:	ec 82       	std	Y+4, r14	; 0x04
     138:	76 be       	out	0x36, r7	; 54
     13a:	d9 8f       	std	Y+25, r29	; 0x19
     13c:	e1 a9       	ldd	r30, Z+49	; 0x31
     13e:	3e 4c       	sbci	r19, 0xCE	; 206
     140:	80 ef       	ldi	r24, 0xF0	; 240
     142:	ff be       	out	0x3f, r15	; 63
     144:	01 c4       	rjmp	.+2050   	; 0x948 <TwoWire::flush()+0x12>
     146:	ff 7f       	andi	r31, 0xFF	; 255
     148:	3f 00       	.word	0x003f	; ????
     14a:	00 00       	nop
	...

0000014e <__trampolines_end>:
__trampolines_start():
     14e:	6e 61       	ori	r22, 0x1E	; 30
     150:	6e 00       	.word	0x006e	; ????

00000152 <__c.2228>:
     152:	69 6e 66 00                                         inf.

00000156 <pstr_nan>:
     156:	4e 41 4e                                            NAN

00000159 <pstr_inity>:
     159:	49 4e 49 54 59                                      INITY

0000015e <pstr_inf>:
     15e:	49 4e 46                                            INF

00000161 <pwr_m10>:
     161:	cd cc cc 3d 0a d7 23 3c 17 b7 d1 38 77 cc 2b 32     ...=..#<...8w.+2
     171:	95 95 e6 24 1f b1 4f 0a                             ...$..O.

00000179 <pwr_p10>:
     179:	00 00 20 41 00 00 c8 42 00 40 1c 46 20 bc be 4c     .. A...B.@.F ..L
     189:	ca 1b 0e 5a ae c5 9d 74 00 40 7a 10 f3 5a 00 a0     ...Z...t.@z..Z..
     199:	72 4e 18 09 00 10 a5 d4 e8 00 00 e8 76 48 17 00     rN..........vH..
     1a9:	00 e4 0b 54 02 00 00 ca 9a 3b 00 00 00 e1 f5 05     ...T.....;......
     1b9:	00 00 80 96 98 00 00 00 40 42 0f 00 00 00 a0 86     ........@B......
     1c9:	01 00 00 00 10 27 00 00 00 00 e8 03 00 00 00 00     .....'..........
     1d9:	64 00 00 00 00 00 0a 00 00 00 00 00 01 00 00 00     d...............
     1e9:	00 00 2c 76 d8 88 dc 67 4f 08 23 df c1 df ae 59     ..,v...gO.#....Y
     1f9:	e1 b1 b7 96 e5 e3 e4 53 c6 3a e6 51 99 76 96 e8     .......S.:.Q.v..
     209:	e6 c2 84 26 eb 89 8c 9b 62 ed 40 7c 6f fc ef bc     ...&....b.@|o...
     219:	9c 9f 40 f2 ba a5 6f a5 f4 90 05 5a 2a f7 5c 93     ..@...o....Z*.\.
     229:	6b 6c f9 67 6d c1 1b fc e0 e4 0d 47 fe f5 20 e6     kl.gm......G.. .
     239:	b5 00 d0 ed 90 2e 03 00 94 35 77 05 00 80 84 1e     .........5w.....
     249:	08 00 00 20 4e 0a 00 00 00 c8 0c 33 33 33 33 0f     ... N......3333.
     259:	98 6e 12 83 11 41 ef 8d 21 14 89 3b e6 55 16 cf     .n...A..!..;.U..
     269:	fe e6 db 18 d1 84 4b 38 1b f7 7c 1d 90 1d a4 bb     ......K8..|.....
     279:	e4 24 20 32 84 72 5e 22 81 00 c9 f1 24 ec a1 e5     .$ 2.r^"....$...
     289:	3d 27                                               ='

0000028b <__c.2370>:
     28b:	63 64 69 6e 6f 70 73 75 78 58 5b 00                 cdinopsuxX[.

00000297 <_usart3_pins>:
     297:	00 08 0a 40 0c ff c0 00 c0                          ...@.....

000002a0 <strfmonths>:
     2a0:	4a 61 6e 75 61 72 79 20 46 65 62 72 75 61 72 79     January February
     2b0:	20 4d 61 72 63 68 20 41 70 72 69 6c 20 4d 61 79      March April May
     2c0:	20 4a 75 6e 65 20 4a 75 6c 79 20 41 75 67 75 73      June July Augus
     2d0:	74 20 53 65 70 74 65 6d 62 65 72 20 4f 63 74 6f     t September Octo
     2e0:	62 65 72 20 4e 6f 76 65 6d 62 65 72 20 44 65 63     ber November Dec
     2f0:	65 6d 62 65 72 20 00                                ember .

000002f7 <strfwkdays>:
     2f7:	53 75 6e 64 61 79 20 4d 6f 6e 64 61 79 20 54 75     Sunday Monday Tu
     307:	65 73 64 61 79 20 57 65 64 6e 65 73 64 61 79 20     esday Wednesday 
     317:	54 68 75 72 73 64 61 79 20 46 72 69 64 61 79 20     Thursday Friday 
     327:	53 61 74 75 72 64 61 79 20 00                       Saturday .

00000331 <ascdays>:
     331:	53 75 6e 4d 6f 6e 54 75 65 57 65 64 54 68 75 46     SunMonTueWedThuF
     341:	72 69 53 61 74 00                                   riSat.

00000347 <ascmonths>:
     347:	4a 61 6e 46 65 62 4d 61 72 41 70 72 4d 61 79 4a     JanFebMarAprMayJ
     357:	75 6e 4a 75 6c 41 75 67 53 65 70 4f 63 74 4e 6f     unJulAugSepOctNo
     367:	76 44 65 63 00                                      vDec.

0000036c <__ctors_start>:
__ctors_start():
     36c:	08 3e       	cpi	r16, 0xE8	; 232

0000036e <__ctors_end>:
__dtors_end():
../../../../crt1/gcrt1.S:230
     36e:	11 24       	eor	r1, r1
../../../../crt1/gcrt1.S:231
     370:	1f be       	out	0x3f, r1	; 63
../../../../crt1/gcrt1.S:232
     372:	cf ef       	ldi	r28, 0xFF	; 255
../../../../crt1/gcrt1.S:234
     374:	cd bf       	out	0x3d, r28	; 61
../../../../crt1/gcrt1.S:236
     376:	df e7       	ldi	r29, 0x7F	; 127
../../../../crt1/gcrt1.S:237
     378:	de bf       	out	0x3e, r29	; 62

0000037a <_initThreeStuff()>:
init_reset_flags():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:103

  /* Minimum: Reset if we wound up here through malfunction - this relies on user clearing the  *
   * register on startup, which is rarely done in Arduino land.                                 */
  void __attribute__((weak)) init_reset_flags() ;
  void __attribute__((weak)) init_reset_flags() {
    uint8_t flags = RSTCTRL.RSTFR;
     37a:	80 91 40 00 	lds	r24, 0x0040	; 0x800040 <__TEXT_REGION_LENGTH__+0x7e0040>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:104
    RSTCTRL.RSTFR = flags;
     37e:	80 93 40 00 	sts	0x0040, r24	; 0x800040 <__TEXT_REGION_LENGTH__+0x7e0040>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:105
    if (flags == 0) {
     382:	81 11       	cpse	r24, r1
     384:	05 c0       	rjmp	.+10     	; 0x390 <_initThreeStuff()+0x16>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:106
      _PROTECTED_WRITE(RSTCTRL.SWRR, 1);
     386:	98 ed       	ldi	r25, 0xD8	; 216
     388:	21 e0       	ldi	r18, 0x01	; 1
     38a:	94 bf       	out	0x34, r25	; 52
     38c:	20 93 41 00 	sts	0x0041, r18	; 0x800041 <__TEXT_REGION_LENGTH__+0x7e0041>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:108
    }
    GPIOR0 = flags;
     390:	8c bb       	out	0x1c, r24	; 28

00000392 <__do_copy_data>:
__do_copy_data():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2373
     392:	12 e6       	ldi	r17, 0x62	; 98
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2374
     394:	a0 e0       	ldi	r26, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2375
     396:	b0 e4       	ldi	r27, 0x40	; 64
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2376
     398:	ea e4       	ldi	r30, 0x4A	; 74
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2377
     39a:	f6 eb       	ldi	r31, 0xB6	; 182
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2378
     39c:	00 e0       	ldi	r16, 0x00	; 0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2379
     39e:	0b bf       	out	0x3b, r16	; 59
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2380
     3a0:	02 c0       	rjmp	.+4      	; 0x3a6 <__do_copy_data+0x14>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2382
     3a2:	07 90       	elpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2383
     3a4:	0d 92       	st	X+, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2385
     3a6:	ac 31       	cpi	r26, 0x1C	; 28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2386
     3a8:	b1 07       	cpc	r27, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2387
     3aa:	d9 f7       	brne	.-10     	; 0x3a2 <__do_copy_data+0x10>

000003ac <__do_clear_bss>:
__do_clear_bss():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2441
     3ac:	20 e7       	ldi	r18, 0x70	; 112
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2442
     3ae:	ac e1       	ldi	r26, 0x1C	; 28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2443
     3b0:	b2 e6       	ldi	r27, 0x62	; 98
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2444
     3b2:	01 c0       	rjmp	.+2      	; 0x3b6 <.do_clear_bss_start>

000003b4 <.do_clear_bss_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2446
     3b4:	1d 92       	st	X+, r1

000003b6 <.do_clear_bss_start>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2448
     3b6:	af 39       	cpi	r26, 0x9F	; 159
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2449
     3b8:	b2 07       	cpc	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2450
     3ba:	e1 f7       	brne	.-8      	; 0x3b4 <.do_clear_bss_loop>

000003bc <__do_global_ctors>:
__do_global_ctors():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2466
     3bc:	11 e0       	ldi	r17, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2467
     3be:	c7 eb       	ldi	r28, 0xB7	; 183
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2468
     3c0:	d1 e0       	ldi	r29, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2472
     3c2:	04 c0       	rjmp	.+8      	; 0x3cc <__do_global_ctors+0x10>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2474
     3c4:	21 97       	sbiw	r28, 0x01	; 1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2480
     3c6:	fe 01       	movw	r30, r28
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2481
     3c8:	0e 94 95 54 	call	0xa92a	; 0xa92a <__tablejump2__>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2483
     3cc:	c6 3b       	cpi	r28, 0xB6	; 182
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2484
     3ce:	d1 07       	cpc	r29, r17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2489
     3d0:	c9 f7       	brne	.-14     	; 0x3c4 <__do_global_ctors+0x8>
../../../../crt1/gcrt1.S:314
     3d2:	0e 94 a3 3e 	call	0x7d46	; 0x7d46 <main>
../../../../crt1/gcrt1.S:315
     3d6:	0c 94 23 5b 	jmp	0xb646	; 0xb646 <_exit>

000003da <__bad_interrupt>:
__vector_38():
../../../../crt1/gcrt1.S:209
     3da:	12 ce       	rjmp	.-988    	; 0x0 <__vectors>

000003dc <printf_putchar(char, __file*)>:
printf_putchar():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:25
#error "INCOMPATIBLE_DEVICE_SELECTED"
#endif
#endif

int16_t printf_putchar(char c, FILE* fp) {
    ((class Print*)(fdev_get_udata(fp)))->write((uint8_t)c);
     3dc:	fb 01       	movw	r30, r22
     3de:	a4 85       	ldd	r26, Z+12	; 0x0c
     3e0:	b5 85       	ldd	r27, Z+13	; 0x0d
     3e2:	ed 91       	ld	r30, X+
     3e4:	fc 91       	ld	r31, X
     3e6:	11 97       	sbiw	r26, 0x01	; 1
     3e8:	01 90       	ld	r0, Z+
     3ea:	f0 81       	ld	r31, Z
     3ec:	e0 2d       	mov	r30, r0
     3ee:	68 2f       	mov	r22, r24
     3f0:	cd 01       	movw	r24, r26
     3f2:	09 95       	icall
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:27
    return 0;
}
     3f4:	90 e0       	ldi	r25, 0x00	; 0
     3f6:	80 e0       	ldi	r24, 0x00	; 0
     3f8:	08 95       	ret

000003fa <printf_putchar(char, __file*)>:
_ZL14printf_putcharcP6__file():
     3fa:	f0 cf       	rjmp	.-32     	; 0x3dc <printf_putchar(char, __file*)>

000003fc <TWI_MasterSetBaud.part.3.constprop.23>:
TWI_MasterSetBaud.part.3():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:204
 *
 *@param      struct twiData *_data is a pointer to the structure that holds the Wire variables
 *
 *@return     uint8_t 1 - something went wrong; 0 - new frequency set.
 */
uint8_t TWI_MasterSetBaud(struct twiData *_data, uint32_t frequency) {
     3fc:	cf 92       	push	r12
     3fe:	df 92       	push	r13
     400:	ef 92       	push	r14
     402:	ff 92       	push	r15
     404:	6b 01       	movw	r12, r22
     406:	7c 01       	movw	r14, r24
     408:	60 e0       	ldi	r22, 0x00	; 0
     40a:	7b e1       	ldi	r23, 0x1B	; 27
     40c:	87 eb       	ldi	r24, 0xB7	; 183
     40e:	90 e0       	ldi	r25, 0x00	; 0
     410:	a7 01       	movw	r20, r14
     412:	96 01       	movw	r18, r12
     414:	0e 94 79 52 	call	0xa4f2	; 0xa4f2 <__udivmodsi4>
TWI_MasterCalcBaud():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:258
      baud = TWI_BAUD(frequency, 350);
    } else {                            // assuming 4.7kOhm
      baud = TWI_BAUD(frequency, 600);  // 300kHz will be off at 10MHz. Trade-off between size and accuracy
    }
  #else
    if (frequency >= 600000) {          // assuming 1.5kOhm
     418:	80 ec       	ldi	r24, 0xC0	; 192
     41a:	c8 16       	cp	r12, r24
     41c:	87 e2       	ldi	r24, 0x27	; 39
     41e:	d8 06       	cpc	r13, r24
     420:	89 e0       	ldi	r24, 0x09	; 9
     422:	e8 06       	cpc	r14, r24
     424:	f1 04       	cpc	r15, r1
     426:	38 f0       	brcs	.+14     	; 0x436 <__LOCK_REGION_LENGTH__+0x36>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:259
      baud = TWI_BAUD(frequency, 250);
     428:	28 50       	subi	r18, 0x08	; 8
     42a:	31 09       	sbc	r19, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:275
    const uint8_t baudlimit = 1;
  #else
    const uint8_t baudlimit = 0;
  #endif

  if (baud < baudlimit) {
     42c:	22 30       	cpi	r18, 0x02	; 2
     42e:	31 05       	cpc	r19, r1
     430:	64 f4       	brge	.+24     	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
TWI_MasterSetBaud.part.3():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:276
    return baudlimit;
     432:	22 e0       	ldi	r18, 0x02	; 2
     434:	0a c0       	rjmp	.+20     	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
TWI_MasterCalcBaud():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:260
      baud = TWI_BAUD(frequency, 600);  // 300kHz will be off at 10MHz. Trade-off between size and accuracy
    }
  #else
    if (frequency >= 600000) {          // assuming 1.5kOhm
      baud = TWI_BAUD(frequency, 250);
    } else if (frequency >= 400000) {   // assuming 2.2kOhm
     436:	80 e8       	ldi	r24, 0x80	; 128
     438:	c8 16       	cp	r12, r24
     43a:	8a e1       	ldi	r24, 0x1A	; 26
     43c:	d8 06       	cpc	r13, r24
     43e:	86 e0       	ldi	r24, 0x06	; 6
     440:	e8 06       	cpc	r14, r24
     442:	f1 04       	cpc	r15, r1
     444:	10 f1       	brcs	.+68     	; 0x48a <__LOCK_REGION_LENGTH__+0x8a>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:261
      baud = TWI_BAUD(frequency, 400);
     446:	29 50       	subi	r18, 0x09	; 9
     448:	31 09       	sbc	r19, r1
TWI_MasterSetBaud.part.3():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:217
      return 1;
    }
  }
  if (_data->_bools._hostEnabled == 1) {                  // Do something only if the host is enabled.
    uint8_t newBaud = TWI_MasterCalcBaud(frequency);      // get the new Baud value
    uint8_t oldBaud = _data->_module->MBAUD;              // load the old Baud value
     44a:	e0 91 9d 6e 	lds	r30, 0x6E9D	; 0x806e9d <Wire+0x8>
     44e:	f0 91 9e 6e 	lds	r31, 0x6E9E	; 0x806e9e <Wire+0x9>
     452:	86 81       	ldd	r24, Z+6	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:218
    if (newBaud != oldBaud) {                             // compare both, in case the code is issuing this before every transmission.
     454:	82 17       	cp	r24, r18
     456:	99 f0       	breq	.+38     	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:219
      uint8_t restore = _data->_module->MCTRLA;           // Save the old Master state
     458:	93 81       	ldd	r25, Z+3	; 0x03
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:220
      _data->_module->MCTRLA    = 0;                      // Disable Master
     45a:	13 82       	std	Z+3, r1	; 0x03
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:221
      _data->_module->MBAUD     = newBaud;                // update Baud register
     45c:	26 83       	std	Z+6, r18	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:222
      if (frequency > 400000) {
     45e:	81 e8       	ldi	r24, 0x81	; 129
     460:	c8 16       	cp	r12, r24
     462:	8a e1       	ldi	r24, 0x1A	; 26
     464:	d8 06       	cpc	r13, r24
     466:	86 e0       	ldi	r24, 0x06	; 6
     468:	e8 06       	cpc	r14, r24
     46a:	f1 04       	cpc	r15, r1
     46c:	c8 f0       	brcs	.+50     	; 0x4a0 <__LOCK_REGION_LENGTH__+0xa0>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:223
        _data->_module->CTRLA  |=  TWI_FMPEN_bm;          // Enable FastMode+
     46e:	80 81       	ld	r24, Z
     470:	82 60       	ori	r24, 0x02	; 2
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:225
      } else {
        _data->_module->CTRLA  &= ~TWI_FMPEN_bm;          // Disable FastMode+
     472:	80 83       	st	Z, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:227
      }
      _data->_module->MCTRLA    = restore;                // restore the old register, thus enabling it again
     474:	93 83       	std	Z+3, r25	; 0x03
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:228
      if (restore & TWI_ENABLE_bm) {                      // If the TWI was enabled,
     476:	90 ff       	sbrs	r25, 0
     478:	02 c0       	rjmp	.+4      	; 0x47e <__LOCK_REGION_LENGTH__+0x7e>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:229
        _data->_module->MSTATUS   = TWI_BUSSTATE_IDLE_gc;   // Force the state machine into IDLE according to the data sheet
     47a:	81 e0       	ldi	r24, 0x01	; 1
     47c:	85 83       	std	Z+5, r24	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:235
      }
    }
    return 0;
  }
  return 1;
}
     47e:	80 e0       	ldi	r24, 0x00	; 0
     480:	ff 90       	pop	r15
     482:	ef 90       	pop	r14
     484:	df 90       	pop	r13
     486:	cf 90       	pop	r12
     488:	08 95       	ret
TWI_MasterCalcBaud():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:263
    if (frequency >= 600000) {          // assuming 1.5kOhm
      baud = TWI_BAUD(frequency, 250);
    } else if (frequency >= 400000) {   // assuming 2.2kOhm
      baud = TWI_BAUD(frequency, 400);
    } else {                            // assuming 4.7kOhm
      baud = TWI_BAUD(frequency, 600);
     48a:	2c 50       	subi	r18, 0x0C	; 12
     48c:	31 09       	sbc	r19, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:275
    const uint8_t baudlimit = 1;
  #else
    const uint8_t baudlimit = 0;
  #endif

  if (baud < baudlimit) {
     48e:	22 30       	cpi	r18, 0x02	; 2
     490:	31 05       	cpc	r19, r1
     492:	7c f2       	brlt	.-98     	; 0x432 <__LOCK_REGION_LENGTH__+0x32>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:277
    return baudlimit;
  } else if (baud > 255) {
     494:	2f 3f       	cpi	r18, 0xFF	; 255
     496:	31 05       	cpc	r19, r1
     498:	c1 f2       	breq	.-80     	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
     49a:	bc f2       	brlt	.-82     	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
TWI_MasterSetBaud.part.3():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:278
    return 255;
     49c:	2f ef       	ldi	r18, 0xFF	; 255
     49e:	d5 cf       	rjmp	.-86     	; 0x44a <__LOCK_REGION_LENGTH__+0x4a>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:225
      _data->_module->MCTRLA    = 0;                      // Disable Master
      _data->_module->MBAUD     = newBaud;                // update Baud register
      if (frequency > 400000) {
        _data->_module->CTRLA  |=  TWI_FMPEN_bm;          // Enable FastMode+
      } else {
        _data->_module->CTRLA  &= ~TWI_FMPEN_bm;          // Disable FastMode+
     4a0:	80 81       	ld	r24, Z
     4a2:	8d 7f       	andi	r24, 0xFD	; 253
     4a4:	e6 cf       	rjmp	.-52     	; 0x472 <__LOCK_REGION_LENGTH__+0x72>

000004a6 <micros>:
micros():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:467
      #else /* TCA */
        uint8_t ticks;
      #endif
      uint8_t flags;
      /* Save current state and disable interrupts */
      uint8_t oldSREG = SREG;
     4a6:	9f b7       	in	r25, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:468
      cli(); /* INTERRUPTS OFF */
     4a8:	f8 94       	cli
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:484
        while (!(TCD0.STATUS & TCD_CMDRDY_bm)); // wait for sync - should be only one iteration of this loop
        flags = TCD0.INTFLAGS;
        ticks = TCD0.CAPTUREA;
        */
      #else /* = defined(MILLIS_USE_TCB) */
        ticks = _timer->CNT;
     4aa:	e0 91 2a 0b 	lds	r30, 0x0B2A	; 0x800b2a <__TEXT_REGION_LENGTH__+0x7e0b2a>
     4ae:	f0 91 2b 0b 	lds	r31, 0x0B2B	; 0x800b2b <__TEXT_REGION_LENGTH__+0x7e0b2b>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:485
        flags = _timer->INTFLAGS;
     4b2:	80 91 26 0b 	lds	r24, 0x0B26	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:493
       * ISR has not fired. If we already read a high value of ticks, either we read it just before the overflow,
       * so we shouldn't increment overflows, or interrupts are disabled and micros isn't expected to work so it
       * doesn't matter.
       * Get current number of overflows and timer count */
      #if defined(MILLIS_USE_TCB)
        overflows = timingStruct.timer_millis;
     4b6:	20 91 85 66 	lds	r18, 0x6685	; 0x806685 <timingStruct>
     4ba:	30 91 86 66 	lds	r19, 0x6686	; 0x806686 <timingStruct+0x1>
     4be:	40 91 87 66 	lds	r20, 0x6687	; 0x806687 <timingStruct+0x2>
     4c2:	50 91 88 66 	lds	r21, 0x6688	; 0x806688 <timingStruct+0x3>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:498
      #else
        overflows = timingStruct.timer_overflow_count;
      #endif
      /* Turn interrupts back on, assuming they were on when micros was called. */
      SREG = oldSREG; /* INTERRUPTS ON */
     4c6:	9f bf       	out	0x3f, r25	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:508
      */
      #if defined(MILLIS_USE_TCA)
        ticks = (TIME_TRACKING_TIMER_PERIOD) - ticks;
        if ((flags & TCA_SPLIT_HUNF_bm) && (ticks < 0x03)) {
      #else /* = defined(MILLIS_USE_TCB) */
        if ((flags & TCB_CAPT_bm) && !(ticks & 0xFF00)) {
     4c8:	80 ff       	sbrs	r24, 0
     4ca:	08 c0       	rjmp	.+16     	; 0x4dc <micros+0x36>
     4cc:	cf 01       	movw	r24, r30
     4ce:	88 27       	eor	r24, r24
     4d0:	89 2b       	or	r24, r25
     4d2:	21 f4       	brne	.+8      	; 0x4dc <micros+0x36>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:513
      #endif
      #if (defined(MILLIS_USE_TCB) && (F_CPU <= 2000000UL))
        overflows += 2;
      #else
        overflows++;
     4d4:	2f 5f       	subi	r18, 0xFF	; 255
     4d6:	3f 4f       	sbci	r19, 0xFF	; 255
     4d8:	4f 4f       	sbci	r20, 0xFF	; 255
     4da:	5f 4f       	sbci	r21, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:662
         * 57 replaced with 30 save 27 clocks @ 12 = 2 us saved
         * 67 replaced with 32 save 35 clocks @ 24 = 1.5us saved
         * 77 replaced with 34 save 43 clocks @ 48 = 1 us saved
         */
        #elif (F_CPU == 48000000UL || F_CPU == 24000000UL || F_CPU == 12000000UL || F_CPU == 6000000UL || F_CPU == 3000000UL)
          __asm__ __volatile__(
     4dc:	0f 01       	movw	r0, r30
     4de:	16 94       	lsr	r1
     4e0:	07 94       	ror	r0
     4e2:	16 94       	lsr	r1
     4e4:	07 94       	ror	r0
     4e6:	16 94       	lsr	r1
     4e8:	07 94       	ror	r0
     4ea:	16 94       	lsr	r1
     4ec:	07 94       	ror	r0
     4ee:	f0 01       	movw	r30, r0
     4f0:	16 94       	lsr	r1
     4f2:	07 94       	ror	r0
     4f4:	e0 0d       	add	r30, r0
     4f6:	f1 1d       	adc	r31, r1
     4f8:	16 94       	lsr	r1
     4fa:	07 94       	ror	r0
     4fc:	10 2c       	mov	r1, r0
     4fe:	16 94       	lsr	r1
     500:	01 18       	sub	r0, r1
     502:	16 94       	lsr	r1
     504:	01 0c       	add	r0, r1
     506:	16 94       	lsr	r1
     508:	01 18       	sub	r0, r1
     50a:	16 94       	lsr	r1
     50c:	01 0c       	add	r0, r1
     50e:	16 94       	lsr	r1
     510:	01 18       	sub	r0, r1
     512:	16 94       	lsr	r1
     514:	16 94       	lsr	r1
     516:	01 0c       	add	r0, r1
     518:	11 24       	eor	r1, r1
     51a:	e0 19       	sub	r30, r0
     51c:	f1 09       	sbc	r31, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:707
            "add r0,r1"     "\n\t"  // + ticks >> 9
            "eor r1,r1"     "\n\t"  // clear out r1
            "sub %A0,r0"    "\n\t"  // Add the sum of terms that fit in a byte to what was ticks in old code.
            "sbc %B0,r1"    "\n"    // carry - see,this is why AVR needs a known zero.
            : "+r" (ticks));        // Do the rest in C. ticks is a read/write operand.
          microseconds = overflows * 1000 + ticks; // nice and clean.
     51e:	a8 ee       	ldi	r26, 0xE8	; 232
     520:	b3 e0       	ldi	r27, 0x03	; 3
     522:	0e 94 bd 52 	call	0xa57a	; 0xa57a <__muluhisi3>
     526:	6e 0f       	add	r22, r30
     528:	7f 1f       	adc	r23, r31
     52a:	81 1d       	adc	r24, r1
     52c:	91 1d       	adc	r25, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:877
          microseconds = ((overflows * millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF))
                        + (ticks * (millisClockCyclesToMicroseconds(TIME_TRACKING_CYCLES_PER_OVF) / TIME_TRACKING_TIMER_PERIOD)));
        #endif
      #endif // end of timer-specific part of micros calculations
      return microseconds;
    }
     52e:	08 95       	ret

00000530 <delay>:
delay():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:939

#if (!(defined(MILLIS_USE_TIMERNONE) || defined(MILLIS_USE_TIMERRTC) || (F_CPU == 7000000L || F_CPU == 14000000)))
  // delay implementation when we do have micros() - we know it won't work at 7 or 14, and those can be generated
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
     530:	cf 92       	push	r12
     532:	df 92       	push	r13
     534:	ef 92       	push	r14
     536:	ff 92       	push	r15
     538:	cf 93       	push	r28
     53a:	df 93       	push	r29
     53c:	6b 01       	movw	r12, r22
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:940
    uint16_t start = (uint16_t)micros();
     53e:	7c 01       	movw	r14, r24
     540:	b2 df       	rcall	.-156    	; 0x4a6 <micros>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:944
    while (true) {
      if (ms == 0) break;
      yield();
      uint16_t us_passed = (uint16_t)micros() - start;
     542:	eb 01       	movw	r28, r22
     544:	b0 df       	rcall	.-160    	; 0x4a6 <micros>
     546:	6c 1b       	sub	r22, r28
     548:	7d 0b       	sbc	r23, r29
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:945
      if (us_passed >= 1000) {
     54a:	68 3e       	cpi	r22, 0xE8	; 232
     54c:	73 40       	sbci	r23, 0x03	; 3
     54e:	d0 f3       	brcs	.-12     	; 0x544 <delay+0x14>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:946
        ms--;
     550:	81 e0       	ldi	r24, 0x01	; 1
     552:	c8 1a       	sub	r12, r24
     554:	d1 08       	sbc	r13, r1
     556:	e1 08       	sbc	r14, r1
     558:	f1 08       	sbc	r15, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:947
        start += 1000;
     55a:	c8 51       	subi	r28, 0x18	; 24
     55c:	dc 4f       	sbci	r29, 0xFC	; 252
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:942
  // from internal, and switch logic is in even though micros isn't.
  void delay(unsigned long ms)
  {
    uint16_t start = (uint16_t)micros();
    while (true) {
      if (ms == 0) break;
     55e:	c1 14       	cp	r12, r1
     560:	d1 04       	cpc	r13, r1
     562:	e1 04       	cpc	r14, r1
     564:	f1 04       	cpc	r15, r1
     566:	71 f7       	brne	.-36     	; 0x544 <delay+0x14>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:950
      if (us_passed >= 1000) {
        ms--;
        start += 1000;
      }
    }
  }
     568:	df 91       	pop	r29
     56a:	cf 91       	pop	r28
     56c:	ff 90       	pop	r15
     56e:	ef 90       	pop	r14
     570:	df 90       	pop	r13
     572:	cf 90       	pop	r12
     574:	08 95       	ret

00000576 <millis>:
millis():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:398
  unsigned long millis() {
    // return timer_overflow_count; // for debugging timekeeping issues where these variables are out of scope from the sketch
    unsigned long m;
    // disable interrupts while we read timer_millis or we might get an
    // inconsistent value (e.g. in the middle of a write to timer_millis)
    uint8_t oldSREG = SREG;
     576:	2f b7       	in	r18, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:399
    cli();
     578:	f8 94       	cli
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:450
        "adc %D0, %D1"    "\n\t"
        : "+r" (m), "+r" (temp), "+d" (cnt)
        );
      */
    #else
      m = timingStruct.timer_millis;
     57a:	60 91 85 66 	lds	r22, 0x6685	; 0x806685 <timingStruct>
     57e:	70 91 86 66 	lds	r23, 0x6686	; 0x806686 <timingStruct+0x1>
     582:	80 91 87 66 	lds	r24, 0x6687	; 0x806687 <timingStruct+0x2>
     586:	90 91 88 66 	lds	r25, 0x6688	; 0x806688 <timingStruct+0x3>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:451
      SREG = oldSREG;
     58a:	2f bf       	out	0x3f, r18	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:454
    #endif
    return m;
  }
     58c:	08 95       	ret

0000058e <on_lte_disconnect()>:
on_lte_disconnect():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:129
    iotconnect_sdk_send_packet(str); // underlying code will report an error
    iotcl_destroy_serialized(str);
}

static void on_lte_disconnect(void) {
  connecteded_to_network = false;
     58e:	10 92 02 66 	sts	0x6602, r1	; 0x806602 <connecteded_to_network>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:130
}
     592:	08 95       	ret

00000594 <timezoneCallback(char*)>:
timezoneCallback():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:100
        }
    }
}

static void timezoneCallback(__attribute__((unused)) char* buffer) {
    got_timezone = true;
     594:	81 e0       	ldi	r24, 0x01	; 1
     596:	80 93 8c 66 	sts	0x668C, r24	; 0x80668c <got_timezone>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:101
}
     59a:	08 95       	ret

0000059c <on_mqtt_connected()>:
on_mqtt_connected():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:59
        }
    }
}

static void on_mqtt_connected(void) {
    if (c->status_cb) {
     59c:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
     5a0:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
     5a4:	04 80       	ldd	r0, Z+4	; 0x04
     5a6:	f5 81       	ldd	r31, Z+5	; 0x05
     5a8:	e0 2d       	mov	r30, r0
     5aa:	30 97       	sbiw	r30, 0x00	; 0
     5ac:	19 f0       	breq	.+6      	; 0x5b4 <on_mqtt_connected()+0x18>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:60
        c->status_cb(IOTC_CS_MQTT_CONNECTED);
     5ae:	81 e0       	ldi	r24, 0x01	; 1
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	09 94       	ijmp
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:62
    }
}
     5b4:	08 95       	ret

000005b6 <on_mqtt_disconnected()>:
on_mqtt_disconnected():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:64
static void on_mqtt_disconnected(void) {
    disconnect_received = true;
     5b6:	81 e0       	ldi	r24, 0x01	; 1
     5b8:	80 93 2c 64 	sts	0x642C, r24	; 0x80642c <disconnect_received>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:65
    if (c->status_cb) {
     5bc:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
     5c0:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
     5c4:	04 80       	ldd	r0, Z+4	; 0x04
     5c6:	f5 81       	ldd	r31, Z+5	; 0x05
     5c8:	e0 2d       	mov	r30, r0
     5ca:	30 97       	sbiw	r30, 0x00	; 0
     5cc:	19 f0       	breq	.+6      	; 0x5d4 <on_mqtt_disconnected()+0x1e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:66
        c->status_cb(IOTC_CS_MQTT_DISCONNECTED);
     5ce:	82 e0       	ldi	r24, 0x02	; 2
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	09 94       	ijmp
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:68
    }
}
     5d4:	08 95       	ret

000005d6 <Print::write(unsigned char const*, unsigned int)>:
write():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.cpp:29
#include "Print.h"

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size) {
     5d6:	af 92       	push	r10
     5d8:	bf 92       	push	r11
     5da:	cf 92       	push	r12
     5dc:	df 92       	push	r13
     5de:	ef 92       	push	r14
     5e0:	ff 92       	push	r15
     5e2:	0f 93       	push	r16
     5e4:	1f 93       	push	r17
     5e6:	cf 93       	push	r28
     5e8:	df 93       	push	r29
     5ea:	6c 01       	movw	r12, r24
     5ec:	7b 01       	movw	r14, r22
     5ee:	8b 01       	movw	r16, r22
     5f0:	04 0f       	add	r16, r20
     5f2:	15 1f       	adc	r17, r21
     5f4:	eb 01       	movw	r28, r22
     5f6:	5e 01       	movw	r10, r28
     5f8:	ae 18       	sub	r10, r14
     5fa:	bf 08       	sbc	r11, r15
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.cpp:31
  size_t n = 0;
  while (size--) {
     5fc:	c0 17       	cp	r28, r16
     5fe:	d1 07       	cpc	r29, r17
     600:	59 f0       	breq	.+22     	; 0x618 <Print::write(unsigned char const*, unsigned int)+0x42>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.cpp:32
    if (write(*buffer++)) {
     602:	69 91       	ld	r22, Y+
     604:	d6 01       	movw	r26, r12
     606:	ed 91       	ld	r30, X+
     608:	fc 91       	ld	r31, X
     60a:	01 90       	ld	r0, Z+
     60c:	f0 81       	ld	r31, Z
     60e:	e0 2d       	mov	r30, r0
     610:	c6 01       	movw	r24, r12
     612:	09 95       	icall
     614:	89 2b       	or	r24, r25
     616:	79 f7       	brne	.-34     	; 0x5f6 <Print::write(unsigned char const*, unsigned int)+0x20>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.cpp:39
    } else {
      break;
    }
  }
  return n;
}
     618:	c5 01       	movw	r24, r10
     61a:	df 91       	pop	r29
     61c:	cf 91       	pop	r28
     61e:	1f 91       	pop	r17
     620:	0f 91       	pop	r16
     622:	ff 90       	pop	r15
     624:	ef 90       	pop	r14
     626:	df 90       	pop	r13
     628:	cf 90       	pop	r12
     62a:	bf 90       	pop	r11
     62c:	af 90       	pop	r10
     62e:	08 95       	ret

00000630 <detachInterrupt.part.1>:
detachInterrupt.part.1():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:323
#endif


  void detachInterrupt(uint8_t pin) {
    /* Get bit position and check pin validity */
    uint8_t bitpos = digitalPinToBitPosition(pin);
     630:	90 e0       	ldi	r25, 0x00	; 0
     632:	fc 01       	movw	r30, r24
     634:	eb 56       	subi	r30, 0x6B	; 107
     636:	fd 4b       	sbci	r31, 0xBD	; 189
     638:	20 81       	ld	r18, Z
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:324
    if (bitpos == NOT_A_PIN) {
     63a:	2f 3f       	cpi	r18, 0xFF	; 255
     63c:	69 f1       	breq	.+90     	; 0x698 <detachInterrupt.part.1+0x68>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:327
      return;
    }
    uint8_t port = digitalPinToPort(pin);
     63e:	84 59       	subi	r24, 0x94	; 148
     640:	9d 4b       	sbci	r25, 0xBD	; 189
     642:	fc 01       	movw	r30, r24
     644:	80 81       	ld	r24, Z
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:328
    uint8_t p = (port << 5) + bitpos;
     646:	e8 2f       	mov	r30, r24
     648:	e2 95       	swap	r30
     64a:	ee 0f       	add	r30, r30
     64c:	e0 7e       	andi	r30, 0xE0	; 224
     64e:	e2 0f       	add	r30, r18
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:329
    *(((volatile uint8_t*) &PORTA_PIN0CTRL) + p) &= 0xF1; // int off....
     650:	f0 e0       	ldi	r31, 0x00	; 0
     652:	e0 5f       	subi	r30, 0xF0	; 240
     654:	fb 4f       	sbci	r31, 0xFB	; 251
     656:	90 81       	ld	r25, Z
     658:	91 7f       	andi	r25, 0xF1	; 241
     65a:	90 83       	st	Z, r25
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:330
    *((volatile uint8_t*) ((uint16_t)((port << 4) + 3)))  = (1 << bitpos);// flag clear
     65c:	90 e0       	ldi	r25, 0x00	; 0
     65e:	fc 01       	movw	r30, r24
     660:	34 e0       	ldi	r19, 0x04	; 4
     662:	ee 0f       	add	r30, r30
     664:	ff 1f       	adc	r31, r31
     666:	3a 95       	dec	r19
     668:	e1 f7       	brne	.-8      	; 0x662 <detachInterrupt.part.1+0x32>
     66a:	42 2f       	mov	r20, r18
     66c:	50 e0       	ldi	r21, 0x00	; 0
     66e:	61 e0       	ldi	r22, 0x01	; 1
     670:	70 e0       	ldi	r23, 0x00	; 0
     672:	01 c0       	rjmp	.+2      	; 0x676 <detachInterrupt.part.1+0x46>
     674:	66 0f       	add	r22, r22
     676:	2a 95       	dec	r18
     678:	ea f7       	brpl	.-6      	; 0x674 <detachInterrupt.part.1+0x44>
     67a:	63 83       	std	Z+3, r22	; 0x03
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:331
    intFunc[port][bitpos] = 0; // clear pointer
     67c:	88 0f       	add	r24, r24
     67e:	99 1f       	adc	r25, r25
     680:	fc 01       	movw	r30, r24
     682:	ec 50       	subi	r30, 0x0C	; 12
     684:	fe 4b       	sbci	r31, 0xBE	; 190
     686:	44 0f       	add	r20, r20
     688:	55 1f       	adc	r21, r21
     68a:	01 90       	ld	r0, Z+
     68c:	f0 81       	ld	r31, Z
     68e:	e0 2d       	mov	r30, r0
     690:	e4 0f       	add	r30, r20
     692:	f5 1f       	adc	r31, r21
     694:	10 82       	st	Z, r1
     696:	11 82       	std	Z+1, r1	; 0x01
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:332
  }
     698:	08 95       	ret

0000069a <HardwareSerial::availableForWrite()>:
availableForWrite():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:727
      int HardwareSerial::availableForWrite(void) {
        tx_buffer_index_t head;
        tx_buffer_index_t tail;

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
     69a:	fc 01       	movw	r30, r24
     69c:	51 89       	ldd	r21, Z+17	; 0x11
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:728
          tail = _tx_buffer_tail;
     69e:	42 89       	ldd	r20, Z+18	; 0x12
     6a0:	25 2f       	mov	r18, r21
     6a2:	30 e0       	ldi	r19, 0x00	; 0
     6a4:	84 2f       	mov	r24, r20
     6a6:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:731
        }
        if (head >= tail) {
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     6a8:	82 1b       	sub	r24, r18
     6aa:	93 0b       	sbc	r25, r19
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:730

        TX_BUFFER_ATOMIC {
          head = _tx_buffer_head;
          tail = _tx_buffer_tail;
        }
        if (head >= tail) {
     6ac:	54 17       	cp	r21, r20
     6ae:	10 f0       	brcs	.+4      	; 0x6b4 <HardwareSerial::availableForWrite()+0x1a>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:731
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
     6b0:	cf 96       	adiw	r24, 0x3f	; 63
     6b2:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:733
        }
        return tail - head - 1;
     6b4:	01 97       	sbiw	r24, 0x01	; 1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:734
      }
     6b6:	08 95       	ret

000006b8 <HardwareSerial::read()>:
read():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:711
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }

    int HardwareSerial::read(void) {
     6b8:	fc 01       	movw	r30, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:713
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
     6ba:	97 85       	ldd	r25, Z+15	; 0x0f
     6bc:	80 89       	ldd	r24, Z+16	; 0x10
     6be:	98 17       	cp	r25, r24
     6c0:	61 f0       	breq	.+24     	; 0x6da <HardwareSerial::read()+0x22>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:716
        return -1;
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
     6c2:	a0 89       	ldd	r26, Z+16	; 0x10
     6c4:	ae 0f       	add	r26, r30
     6c6:	bf 2f       	mov	r27, r31
     6c8:	b1 1d       	adc	r27, r1
     6ca:	53 96       	adiw	r26, 0x13	; 19
     6cc:	8c 91       	ld	r24, X
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:717
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
     6ce:	90 89       	ldd	r25, Z+16	; 0x10
     6d0:	9f 5f       	subi	r25, 0xFF	; 255
     6d2:	9f 73       	andi	r25, 0x3F	; 63
     6d4:	90 8b       	std	Z+16, r25	; 0x10
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:718
        return c;
     6d6:	90 e0       	ldi	r25, 0x00	; 0
     6d8:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:714
    }

    int HardwareSerial::read(void) {
      // if the head isn't ahead of the tail, we don't have any characters
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     6da:	8f ef       	ldi	r24, 0xFF	; 255
     6dc:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:720
      } else {
        unsigned char c = _rx_buffer[_rx_buffer_tail];
        _rx_buffer_tail = (rx_buffer_index_t)(_rx_buffer_tail + 1) & (SERIAL_RX_BUFFER_SIZE - 1);   // % SERIAL_RX_BUFFER_SIZE;
        return c;
      }
    }
     6de:	08 95       	ret

000006e0 <HardwareSerial::peek()>:
peek():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:703

    int HardwareSerial::available(void) {
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
     6e0:	fc 01       	movw	r30, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:704
      if (_rx_buffer_head == _rx_buffer_tail) {
     6e2:	97 85       	ldd	r25, Z+15	; 0x0f
     6e4:	80 89       	ldd	r24, Z+16	; 0x10
     6e6:	98 17       	cp	r25, r24
     6e8:	31 f0       	breq	.+12     	; 0x6f6 <HardwareSerial::peek()+0x16>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:707
        return -1;
      } else {
        return _rx_buffer[_rx_buffer_tail];
     6ea:	80 89       	ldd	r24, Z+16	; 0x10
     6ec:	e8 0f       	add	r30, r24
     6ee:	f1 1d       	adc	r31, r1
     6f0:	83 89       	ldd	r24, Z+19	; 0x13
     6f2:	90 e0       	ldi	r25, 0x00	; 0
     6f4:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:705
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
    }

    int HardwareSerial::peek(void) {
      if (_rx_buffer_head == _rx_buffer_tail) {
        return -1;
     6f6:	8f ef       	ldi	r24, 0xFF	; 255
     6f8:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:709
      } else {
        return _rx_buffer[_rx_buffer_tail];
      }
    }
     6fa:	08 95       	ret

000006fc <HardwareSerial::available()>:
available():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:699
      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    }

    int HardwareSerial::available(void) {
     6fc:	fc 01       	movw	r30, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:700
      return ((unsigned int)(SERIAL_RX_BUFFER_SIZE + _rx_buffer_head - _rx_buffer_tail)) & (SERIAL_RX_BUFFER_SIZE - 1);   //% SERIAL_RX_BUFFER_SIZE;
     6fe:	97 85       	ldd	r25, Z+15	; 0x0f
     700:	20 89       	ldd	r18, Z+16	; 0x10
     702:	89 2f       	mov	r24, r25
     704:	90 e0       	ldi	r25, 0x00	; 0
     706:	80 5c       	subi	r24, 0xC0	; 192
     708:	9f 4f       	sbci	r25, 0xFF	; 255
     70a:	82 1b       	sub	r24, r18
     70c:	91 09       	sbc	r25, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:701
    }
     70e:	8f 73       	andi	r24, 0x3F	; 63
     710:	99 27       	eor	r25, r25
     712:	08 95       	ret

00000714 <HardwareSerial::_poll_tx_data_empty()>:
_poll_tx_data_empty():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:426
        HardwareSerial._tx_buffer_tail = txTail;
      }
    #endif

    // To invoke data empty "interrupt" via a call, use this method
    void HardwareSerial::_poll_tx_data_empty(void) {
     714:	fc 01       	movw	r30, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:427
      if ((!(SREG & CPU_I_bm)) ||  CPUINT.STATUS) {
     716:	0f b6       	in	r0, 0x3f	; 63
     718:	07 fe       	sbrs	r0, 7
     71a:	04 c0       	rjmp	.+8      	; 0x724 <HardwareSerial::_poll_tx_data_empty()+0x10>
     71c:	80 91 11 01 	lds	r24, 0x0111	; 0x800111 <__TEXT_REGION_LENGTH__+0x7e0111>
     720:	88 23       	and	r24, r24
     722:	a9 f0       	breq	.+42     	; 0x74e <_poll_dre_done>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:444
        // so we'll have to poll the "data register empty" flag ourselves.
        // If it is set, pretend an interrupt has happened and call the handler
        // to free up space for us.
        // -Spence 10/23/20
        // Invoke interrupt handler only if conditions data register is empty
        if ((*_hwserial_module).STATUS & USART_DREIF_bm) {
     724:	a0 85       	ldd	r26, Z+8	; 0x08
     726:	b1 85       	ldd	r27, Z+9	; 0x09
     728:	14 96       	adiw	r26, 0x04	; 4
     72a:	8c 91       	ld	r24, X
     72c:	14 97       	sbiw	r26, 0x04	; 4
     72e:	85 ff       	sbrs	r24, 5
     730:	0e c0       	rjmp	.+28     	; 0x74e <_poll_dre_done>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:445
          if (_tx_buffer_head == _tx_buffer_tail) {
     732:	91 89       	ldd	r25, Z+17	; 0x11
     734:	82 89       	ldd	r24, Z+18	; 0x12
     736:	98 13       	cpse	r25, r24
     738:	07 c0       	rjmp	.+14     	; 0x748 <HardwareSerial::_poll_tx_data_empty()+0x34>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:447
            // Buffer empty, so disable "data register empty" interrupt
            (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
     73a:	15 96       	adiw	r26, 0x05	; 5
     73c:	8c 91       	ld	r24, X
     73e:	15 97       	sbiw	r26, 0x05	; 5
     740:	8f 7d       	andi	r24, 0xDF	; 223
     742:	15 96       	adiw	r26, 0x05	; 5
     744:	8c 93       	st	X, r24
     746:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:465
      #else
                    "rjmp _poll_dre"    "\n\t"
      #endif
                    "_poll_dre_done:"    "\n"
                    ::"z"((uint16_t)thisSerial)
                    : "r18","r19","r24","r25","r26","r27"); // these got saved and restored in the ISR context, but here we don't need top and in many cases no action is needed.
     748:	e8 94       	clt
     74a:	0c 94 4f 31 	jmp	0x629e	; 0x629e <_poll_dre>

0000074e <_poll_dre_done>:
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:474
        }
      }
      // In case interrupts are enabled, the interrupt routine will be invoked by itself
      // Note that this currently does not handle cases where the DRE interruopt becomes
      // disabled, yet you are actually attempting to send. I don't think it can happen.
    }
     74e:	08 95       	ret

00000750 <HardwareSerial::write(unsigned char)>:
write():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:767
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }


      size_t HardwareSerial::write(uint8_t c) {
     750:	0f 93       	push	r16
     752:	1f 93       	push	r17
     754:	cf 93       	push	r28
     756:	df 93       	push	r29
     758:	ec 01       	movw	r28, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:768
        _state |= 1; // Record that we have written to serial since it was begun.
     75a:	8e 85       	ldd	r24, Y+14	; 0x0e
     75c:	81 60       	ori	r24, 0x01	; 1
     75e:	8e 87       	std	Y+14, r24	; 0x0e
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:773
        // If the buffer and the data register is empty, just write the byte
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
     760:	99 89       	ldd	r25, Y+17	; 0x11
     762:	8a 89       	ldd	r24, Y+18	; 0x12
     764:	98 13       	cpse	r25, r24
     766:	0b c0       	rjmp	.+22     	; 0x77e <HardwareSerial::write(unsigned char)+0x2e>
     768:	e8 85       	ldd	r30, Y+8	; 0x08
     76a:	f9 85       	ldd	r31, Y+9	; 0x09
     76c:	84 81       	ldd	r24, Z+4	; 0x04
     76e:	85 ff       	sbrs	r24, 5
     770:	06 c0       	rjmp	.+12     	; 0x77e <HardwareSerial::write(unsigned char)+0x2e>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:774
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     772:	8e 85       	ldd	r24, Y+14	; 0x0e
     774:	81 fd       	sbrc	r24, 1
     776:	0d c0       	rjmp	.+26     	; 0x792 <HardwareSerial::write(unsigned char)+0x42>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:781
            ctrla &= ~USART_RXCIE_bm;
            ctrla |=  USART_TXCIE_bm;
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
            (*_hwserial_module).CTRLA = ctrla;
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     778:	80 e4       	ldi	r24, 0x40	; 64
     77a:	84 83       	std	Z+4, r24	; 0x04
     77c:	12 c0       	rjmp	.+36     	; 0x7a2 <HardwareSerial::write(unsigned char)+0x52>
     77e:	06 2f       	mov	r16, r22
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:802
           * // that the interrupt handler is called in this situation
           * (*_hwserial_module).CTRLA &= (~USART_DREIE_bm);
           */
          return 1;
        }
        tx_buffer_index_t i = (_tx_buffer_head + 1) & (SERIAL_TX_BUFFER_SIZE - 1);  // % SERIAL_TX_BUFFER_SIZE;
     780:	19 89       	ldd	r17, Y+17	; 0x11
     782:	1f 5f       	subi	r17, 0xFF	; 255
     784:	1f 73       	andi	r17, 0x3F	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:806

        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
     786:	8a 89       	ldd	r24, Y+18	; 0x12
     788:	81 13       	cpse	r24, r17
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:807
          _poll_tx_data_empty();
     78a:	15 c0       	rjmp	.+42     	; 0x7b6 <HardwareSerial::write(unsigned char)+0x66>
     78c:	ce 01       	movw	r24, r28
     78e:	c2 df       	rcall	.-124    	; 0x714 <HardwareSerial::_poll_tx_data_empty()>
     790:	fa cf       	rjmp	.-12     	; 0x786 <HardwareSerial::write(unsigned char)+0x36>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:775
        // to the data register and be done. This shortcut helps
        // significantly improve the effective data rate at high (>
        // 500kbit/s) bit rates, where interrupt overhead becomes a slowdown.
        if ((_tx_buffer_head == _tx_buffer_tail) && ((*_hwserial_module).STATUS & USART_DREIF_bm)) {
          if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
            uint8_t ctrla = (*_hwserial_module).CTRLA;
     792:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:776
            ctrla &= ~USART_RXCIE_bm;
     794:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:777
            ctrla |=  USART_TXCIE_bm;
     796:	80 64       	ori	r24, 0x40	; 64
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:778
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
     798:	90 e4       	ldi	r25, 0x40	; 64
     79a:	94 83       	std	Z+4, r25	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:779
            (*_hwserial_module).CTRLA = ctrla;
     79c:	e8 85       	ldd	r30, Y+8	; 0x08
     79e:	f9 85       	ldd	r31, Y+9	; 0x09
     7a0:	85 83       	std	Z+5, r24	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:784
          } else {
            (*_hwserial_module).STATUS = USART_TXCIF_bm;
          }
          // MUST clear TXCIF **before** writing new char, otherwise ill-timed interrupt can cause it to erase the flag after the new charchter has been sent!
          (*_hwserial_module).TXDATAL = c;
     7a2:	e8 85       	ldd	r30, Y+8	; 0x08
     7a4:	f9 85       	ldd	r31, Y+9	; 0x09
     7a6:	62 83       	std	Z+2, r22	; 0x02
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:822
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
        }
        return 1;
      }
     7a8:	81 e0       	ldi	r24, 0x01	; 1
     7aa:	90 e0       	ldi	r25, 0x00	; 0
     7ac:	df 91       	pop	r29
     7ae:	cf 91       	pop	r28
     7b0:	1f 91       	pop	r17
     7b2:	0f 91       	pop	r16
     7b4:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:809
        // If the output buffer is full, there's nothing we can do other than to
        // wait for the interrupt handler to empty it a bit (or emulate interrupts)
        while (i == _tx_buffer_tail) {
          _poll_tx_data_empty();
        }
        _tx_buffer[_tx_buffer_head] = c;
     7b6:	e9 89       	ldd	r30, Y+17	; 0x11
     7b8:	ec 0f       	add	r30, r28
     7ba:	fd 2f       	mov	r31, r29
     7bc:	f1 1d       	adc	r31, r1
     7be:	ed 5a       	subi	r30, 0xAD	; 173
     7c0:	ff 4f       	sbci	r31, 0xFF	; 255
     7c2:	00 83       	st	Z, r16
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:810
        _tx_buffer_head = i;
     7c4:	19 8b       	std	Y+17, r17	; 0x11
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:811
        if (_state & 2) { // in half duplex mode, we turn off RXC interrupt
     7c6:	8e 85       	ldd	r24, Y+14	; 0x0e
     7c8:	e8 85       	ldd	r30, Y+8	; 0x08
     7ca:	f9 85       	ldd	r31, Y+9	; 0x09
     7cc:	81 ff       	sbrs	r24, 1
     7ce:	09 c0       	rjmp	.+18     	; 0x7e2 <HardwareSerial::write(unsigned char)+0x92>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:812
          uint8_t ctrla = (*_hwserial_module).CTRLA;
     7d0:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:813
          ctrla &= ~USART_RXCIE_bm;
     7d2:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:814
          ctrla |= USART_TXCIE_bm | USART_DREIE_bm;
     7d4:	80 66       	ori	r24, 0x60	; 96
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:815
          (*_hwserial_module).STATUS = USART_TXCIF_bm;
     7d6:	90 e4       	ldi	r25, 0x40	; 64
     7d8:	94 83       	std	Z+4, r25	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:816
          (*_hwserial_module).CTRLA = ctrla;
     7da:	e8 85       	ldd	r30, Y+8	; 0x08
     7dc:	f9 85       	ldd	r31, Y+9	; 0x09
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:819
        } else {
          // Enable "data register empty interrupt"
          (*_hwserial_module).CTRLA |= USART_DREIE_bm;
     7de:	85 83       	std	Z+5, r24	; 0x05
     7e0:	e3 cf       	rjmp	.-58     	; 0x7a8 <HardwareSerial::write(unsigned char)+0x58>
     7e2:	85 81       	ldd	r24, Z+5	; 0x05
     7e4:	80 62       	ori	r24, 0x20	; 32
     7e6:	fb cf       	rjmp	.-10     	; 0x7de <HardwareSerial::write(unsigned char)+0x8e>

000007e8 <HardwareSerial::flush()>:
flush():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:736
          return SERIAL_TX_BUFFER_SIZE - 1 - head + tail;
        }
        return tail - head - 1;
      }

      void HardwareSerial::flush() {
     7e8:	cf 93       	push	r28
     7ea:	df 93       	push	r29
     7ec:	ec 01       	movw	r28, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:740
        // If we have never written a byte, no need to flush. This special
        // case is needed since there is no way to force the TXCIF (transmit
        // complete) bit to 1 during initialization
        if (!_state & 1) {
     7ee:	8e 85       	ldd	r24, Y+14	; 0x0e
     7f0:	88 23       	and	r24, r24
     7f2:	59 f0       	breq	.+22     	; 0x80a <HardwareSerial::flush()+0x22>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:755
        // it's appropriate to use for applications where it has only very small benefits, and significant risk of surprising the user and causing
        // breakage of code that would otherwise work. Finally, the previous implementation didn't check if it was called from the current lvl1 ISR
        // and in that case flush(), and write() with full buffer would just straight up hang...

        // Spin until the data-register-empty-interrupt is disabled and TX complete interrupt flag is raised
        while (((*_hwserial_module).CTRLA & USART_DREIE_bm) || (!((*_hwserial_module).STATUS & USART_TXCIF_bm))) {
     7f4:	e8 85       	ldd	r30, Y+8	; 0x08
     7f6:	f9 85       	ldd	r31, Y+9	; 0x09
     7f8:	85 81       	ldd	r24, Z+5	; 0x05
     7fa:	85 fd       	sbrc	r24, 5
     7fc:	03 c0       	rjmp	.+6      	; 0x804 <HardwareSerial::flush()+0x1c>
     7fe:	84 81       	ldd	r24, Z+4	; 0x04
     800:	86 fd       	sbrc	r24, 6
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:760

          // If interrupts are globally disabled or the and DR empty interrupt is disabled,
          // poll the "data register empty" interrupt flag to prevent deadlock

          _poll_tx_data_empty();
     802:	03 c0       	rjmp	.+6      	; 0x80a <HardwareSerial::flush()+0x22>
     804:	ce 01       	movw	r24, r28
     806:	86 df       	rcall	.-244    	; 0x714 <HardwareSerial::_poll_tx_data_empty()>
     808:	f5 cf       	rjmp	.-22     	; 0x7f4 <HardwareSerial::flush()+0xc>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:764
        }
        // When we get here, nothing is queued anymore (DREIE is disabled) and
        // the hardware finished transmission (TXCIF is set).
      }
     80a:	df 91       	pop	r29
     80c:	cf 91       	pop	r28
     80e:	08 95       	ret

00000810 <popSleep>:
popSleep():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:678
  #endif
}

void popSleep() {
  #if defined(TWI_USING_WIRE1)
    uint8_t sleepStackLoc = sleepStack;
     810:	80 91 25 64 	lds	r24, 0x6425	; 0x806425 <sleepStack>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:679
    if (sleepStackLoc > 0) {      // only do something if sleep was enabled
     814:	88 23       	and	r24, r24
     816:	29 f0       	breq	.+10     	; 0x822 <popSleep+0x12>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:680
      if (sleepStackLoc > 0x10) {   // only decrement if pushed once before
     818:	81 31       	cpi	r24, 0x11	; 17
     81a:	20 f0       	brcs	.+8      	; 0x824 <popSleep+0x14>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:681
        sleepStackLoc = (sleepStackLoc - 0x10);   // upper nibble
     81c:	80 51       	subi	r24, 0x10	; 16
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:686
      } else {                    // at 0 we are about to put sleep back
        SLPCTRL.CTRLA = sleepStackLoc;  // restore sleep
        sleepStackLoc = 0;              // reset everything
      }
      sleepStack = sleepStackLoc;
     81e:	80 93 25 64 	sts	0x6425, r24	; 0x806425 <sleepStack>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:691
    }
  #else
    SLPCTRL.CTRLA = sleepStack;
  #endif
}
     822:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:683
    uint8_t sleepStackLoc = sleepStack;
    if (sleepStackLoc > 0) {      // only do something if sleep was enabled
      if (sleepStackLoc > 0x10) {   // only decrement if pushed once before
        sleepStackLoc = (sleepStackLoc - 0x10);   // upper nibble
      } else {                    // at 0 we are about to put sleep back
        SLPCTRL.CTRLA = sleepStackLoc;  // restore sleep
     824:	80 93 50 00 	sts	0x0050, r24	; 0x800050 <__TEXT_REGION_LENGTH__+0x7e0050>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:684
        sleepStackLoc = 0;              // reset everything
     828:	80 e0       	ldi	r24, 0x00	; 0
     82a:	f9 cf       	rjmp	.-14     	; 0x81e <popSleep+0xe>

0000082c <TWI_HandleSlaveIRQ>:
TWI_HandleSlaveIRQ():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:513
 *@param      struct twiData *_data is a pointer to the structure that holds the Wire variables
 *
 *@return     void
 */

void TWI_HandleSlaveIRQ(struct twiData *_data) {
     82c:	1f 93       	push	r17
     82e:	cf 93       	push	r28
     830:	df 93       	push	r29
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:521
  // used as a frame pointer and the compiler avoids using it. So, using it comes with a price of pushing/popping
  // r28/r29, as well as ldi the address of the struct into those, so it only makes sense in a few cases like this.
  // Since the Y register is not call-clobbered, it can be considered persistent in this function and has not to
  // be restored after the icall to the user callbacks, unlike Z (which is used for _module and icall).

  _fastPtr_y(_data,_data);  // force _data into Y and instruct to not change Y
     832:	ec 01       	movw	r28, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:563
  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
  uint8_t clientStatus = _data->_module->SSTATUS;
     834:	e8 81       	ld	r30, Y
     836:	f9 81       	ldd	r31, Y+1	; 0x01
     838:	83 85       	ldd	r24, Z+11	; 0x0b
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:565

  if (clientStatus & TWI_APIF_bm) {  // Address/Stop Bit set
     83a:	86 ff       	sbrs	r24, 6
     83c:	47 c0       	rjmp	.+142    	; 0x8cc <TWI_HandleSlaveIRQ+0xa0>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:566
    if (clientStatus & TWI_AP_bm) {    // Address bit set
     83e:	80 ff       	sbrs	r24, 0
     840:	35 c0       	rjmp	.+106    	; 0x8ac <TWI_HandleSlaveIRQ+0x80>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:567
      uint8_t payload = _data->_module->SDATA;  // read address from data register
     842:	15 85       	ldd	r17, Z+13	; 0x0d
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:568
      if (clientStatus & TWI_DIR_bm) {  // Master is reading
     844:	81 ff       	sbrs	r24, 1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:569
        if ((*rxHead) > 0) {                    // There is no way to identify a REPSTART,
     846:	25 c0       	rjmp	.+74     	; 0x892 <TWI_HandleSlaveIRQ+0x66>
     848:	8e 81       	ldd	r24, Y+6	; 0x06
     84a:	88 23       	and	r24, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:570
          popSleep();                           // (have to treat REPSTART as another pop for sleep)
     84c:	41 f0       	breq	.+16     	; 0x85e <TWI_HandleSlaveIRQ+0x32>
     84e:	e0 df       	rcall	.-64     	; 0x810 <popSleep>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:571
          if (_data->user_onReceive != NULL) {  // so when a Master Read occurs after a Master write
     850:	eb 85       	ldd	r30, Y+11	; 0x0b
     852:	fc 85       	ldd	r31, Y+12	; 0x0c
     854:	30 97       	sbiw	r30, 0x00	; 0
     856:	19 f0       	breq	.+6      	; 0x85e <TWI_HandleSlaveIRQ+0x32>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:572
            _data->user_onReceive((*rxHead));   // issue a call to the user callback first
     858:	8e 81       	ldd	r24, Y+6	; 0x06
     85a:	90 e0       	ldi	r25, 0x00	; 0
     85c:	09 95       	icall
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:575
          }
        }
        (*address) = payload;                   // saving address to expose to the user sketch
     85e:	1c 83       	std	Y+4, r17	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:576
        (*txHead) = 0;                          // reset buffer positions so the Master can start writing at zero.
     860:	1d 82       	std	Y+5, r1	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:577
        (*txTail) = 0;
     862:	18 86       	std	Y+8, r1	; 0x08
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:579

        if (_data->user_onRequest != NULL) {
     864:	e9 85       	ldd	r30, Y+9	; 0x09
     866:	fa 85       	ldd	r31, Y+10	; 0x0a
     868:	30 97       	sbiw	r30, 0x00	; 0
     86a:	09 f0       	breq	.+2      	; 0x86e <TWI_HandleSlaveIRQ+0x42>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:580
          _data->user_onRequest();
     86c:	09 95       	icall
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:582
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
     86e:	8d 81       	ldd	r24, Y+5	; 0x05
     870:	88 23       	and	r24, r24
     872:	99 f0       	breq	.+38     	; 0x89a <TWI_HandleSlaveIRQ+0x6e>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:588
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // NACK + "Wait for any Start (S/Sr) condition"
        } else {
          action = TWI_SCMD_RESPONSE_gc;        // "Execute Acknowledge Action succeeded by reception of next byte"
        }
      } else {                          // Master is writing
        action = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
     874:	83 e0       	ldi	r24, 0x03	; 3
pushSleep():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:662
 *
 *@return     void
 */
void pushSleep() {
  #if defined(TWI_USING_WIRE1)
    uint8_t sleepStackLoc = sleepStack;
     876:	90 91 25 64 	lds	r25, 0x6425	; 0x806425 <sleepStack>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:663
    if (sleepStackLoc > 0) {                // Increment only if sleep was enabled
     87a:	99 23       	and	r25, r25
     87c:	81 f0       	breq	.+32     	; 0x89e <TWI_HandleSlaveIRQ+0x72>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:664
      sleepStackLoc = (sleepStackLoc + 0x10); // use upper nibble to count - max 15 pushes
     87e:	90 5f       	subi	r25, 0xF0	; 240
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:669
    } else {
      sleepStackLoc = SLPCTRL.CTRLA;        // save sleep settings to sleepStack
      SLPCTRL.CTRLA = sleepStackLoc & 0x01; // Set to IDLE if sleep was enabled
    }
    sleepStack = sleepStackLoc;
     880:	90 93 25 64 	sts	0x6425, r25	; 0x806425 <sleepStack>
TWI_HandleSlaveIRQ():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:638
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
        }
      }
    }
  }
  _data->_module->SCTRLB = action;  // using local variable (register) reduces the amount of loading _module
     884:	e8 81       	ld	r30, Y
     886:	f9 81       	ldd	r31, Y+1	; 0x01
     888:	82 87       	std	Z+10, r24	; 0x0a
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:642
  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x00;
  #endif
}
     88a:	df 91       	pop	r29
     88c:	cf 91       	pop	r28
     88e:	1f 91       	pop	r17
     890:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:589
        } else {
          action = TWI_SCMD_RESPONSE_gc;        // "Execute Acknowledge Action succeeded by reception of next byte"
        }
      } else {                          // Master is writing
        action = TWI_SCMD_RESPONSE_gc;  // "Execute Acknowledge Action succeeded by reception of next byte"
        (*address) = payload;           // saving address to expose to the user sketch
     892:	1c 83       	std	Y+4, r17	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:590
        (*rxHead) = 0;                  // reset buffer positions so the Master can start writing at zero.
     894:	1e 82       	std	Y+6, r1	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:591
        (*rxTail) = 0;
     896:	1f 82       	std	Y+7, r1	; 0x07
     898:	ed cf       	rjmp	.-38     	; 0x874 <TWI_HandleSlaveIRQ+0x48>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:583

        if (_data->user_onRequest != NULL) {
          _data->user_onRequest();
        }
        if ((*txHead) == 0) {                   // If no data to transmit, send NACK
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // NACK + "Wait for any Start (S/Sr) condition"
     89a:	86 e0       	ldi	r24, 0x06	; 6
     89c:	ec cf       	rjmp	.-40     	; 0x876 <TWI_HandleSlaveIRQ+0x4a>
pushSleep():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:666
  #if defined(TWI_USING_WIRE1)
    uint8_t sleepStackLoc = sleepStack;
    if (sleepStackLoc > 0) {                // Increment only if sleep was enabled
      sleepStackLoc = (sleepStackLoc + 0x10); // use upper nibble to count - max 15 pushes
    } else {
      sleepStackLoc = SLPCTRL.CTRLA;        // save sleep settings to sleepStack
     89e:	90 91 50 00 	lds	r25, 0x0050	; 0x800050 <__TEXT_REGION_LENGTH__+0x7e0050>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:667
      SLPCTRL.CTRLA = sleepStackLoc & 0x01; // Set to IDLE if sleep was enabled
     8a2:	29 2f       	mov	r18, r25
     8a4:	21 70       	andi	r18, 0x01	; 1
     8a6:	20 93 50 00 	sts	0x0050, r18	; 0x800050 <__TEXT_REGION_LENGTH__+0x7e0050>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:595
        (*rxHead) = 0;                  // reset buffer positions so the Master can start writing at zero.
        (*rxTail) = 0;
      }
      pushSleep();
    } else {                            // Stop bit set
      popSleep();
     8aa:	ea cf       	rjmp	.-44     	; 0x880 <TWI_HandleSlaveIRQ+0x54>
TWI_HandleSlaveIRQ():
     8ac:	b1 df       	rcall	.-158    	; 0x810 <popSleep>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:596
      if (_data->user_onReceive != NULL) {
     8ae:	eb 85       	ldd	r30, Y+11	; 0x0b
     8b0:	fc 85       	ldd	r31, Y+12	; 0x0c
     8b2:	30 97       	sbiw	r30, 0x00	; 0
     8b4:	29 f0       	breq	.+10     	; 0x8c0 <TWI_HandleSlaveIRQ+0x94>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:597
        if ((*rxHead) > 0) {
     8b6:	8e 81       	ldd	r24, Y+6	; 0x06
     8b8:	88 23       	and	r24, r24
     8ba:	11 f0       	breq	.+4      	; 0x8c0 <TWI_HandleSlaveIRQ+0x94>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:598
          _data->user_onReceive((*rxHead));
     8bc:	90 e0       	ldi	r25, 0x00	; 0
     8be:	09 95       	icall
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:602
        }
      }
      action = TWI_SCMD_COMPTRANS_gc;  // "Wait for any Start (S/Sr) condition"
      (*rxHead) = 0;
     8c0:	1e 82       	std	Y+6, r1	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:603
      (*txHead) = 0;
     8c2:	1d 82       	std	Y+5, r1	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:604
      (*rxTail) = 0;
     8c4:	1f 82       	std	Y+7, r1	; 0x07
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:605
      (*txTail) = 0;
     8c6:	18 86       	std	Y+8, r1	; 0x08
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:622
        if ((*txTail) < (*txHead)) {            // Data is available
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
          (*txTail)++;                            // Increment counter for sent bytes
          action = TWI_SCMD_RESPONSE_gc;          // "Execute a byte read operation followed by Acknowledge Action"
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
     8c8:	82 e0       	ldi	r24, 0x02	; 2
     8ca:	dc cf       	rjmp	.-72     	; 0x884 <TWI_HandleSlaveIRQ+0x58>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:607
      (*rxHead) = 0;
      (*txHead) = 0;
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
     8cc:	87 ff       	sbrs	r24, 7
     8ce:	31 c0       	rjmp	.+98     	; 0x932 <TWI_HandleSlaveIRQ+0x106>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:608
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
     8d0:	81 ff       	sbrs	r24, 1
     8d2:	1e c0       	rjmp	.+60     	; 0x910 <TWI_HandleSlaveIRQ+0xe4>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:609
      if ((clientStatus & (TWI_COLL_bm | TWI_RXACK_bm)) &&  // If a collision was detected, or RXACK bit is set AND
     8d4:	88 71       	andi	r24, 0x18	; 24
     8d6:	39 f0       	breq	.+14     	; 0x8e6 <TWI_HandleSlaveIRQ+0xba>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:610
          (true == _data->_bools._ackMatters)) {            // And we have to check for it
     8d8:	8a 81       	ldd	r24, Y+2	; 0x02
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:609
      (*rxTail) = 0;
      (*txTail) = 0;
    }
  } else if (clientStatus & TWI_DIF_bm) { // Data bit set
    if (clientStatus & TWI_DIR_bm) {        // Master is reading
      if ((clientStatus & (TWI_COLL_bm | TWI_RXACK_bm)) &&  // If a collision was detected, or RXACK bit is set AND
     8da:	83 ff       	sbrs	r24, 3
     8dc:	04 c0       	rjmp	.+8      	; 0x8e6 <TWI_HandleSlaveIRQ+0xba>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:611
          (true == _data->_bools._ackMatters)) {            // And we have to check for it
        (*txHead) = 0;                          // Abort further data writes
     8de:	1d 82       	std	Y+5, r1	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:612
        _data->_bools._ackMatters = false;      // stop checking for NACK
     8e0:	87 7f       	andi	r24, 0xF7	; 247
     8e2:	8a 83       	std	Y+2, r24	; 0x02
     8e4:	f1 cf       	rjmp	.-30     	; 0x8c8 <TWI_HandleSlaveIRQ+0x9c>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:615
        action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
      } else {                                // RXACK bit not set, no COLL
        _data->_bytesTransmittedS++;            // increment bytes transmitted counter (for register model)
     8e6:	8b 81       	ldd	r24, Y+3	; 0x03
     8e8:	8f 5f       	subi	r24, 0xFF	; 255
     8ea:	8b 83       	std	Y+3, r24	; 0x03
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:616
        _data->_bools._ackMatters = true;       // start checking for NACK
     8ec:	8a 81       	ldd	r24, Y+2	; 0x02
     8ee:	88 60       	ori	r24, 0x08	; 8
     8f0:	8a 83       	std	Y+2, r24	; 0x02
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:617
        if ((*txTail) < (*txHead)) {            // Data is available
     8f2:	a8 85       	ldd	r26, Y+8	; 0x08
     8f4:	8d 81       	ldd	r24, Y+5	; 0x05
     8f6:	a8 17       	cp	r26, r24
     8f8:	38 f7       	brcc	.-50     	; 0x8c8 <TWI_HandleSlaveIRQ+0x9c>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:618
          _data->_module->SDATA = txBuffer[(*txTail)];  // Writing to the register to send data
     8fa:	ac 0f       	add	r26, r28
     8fc:	bd 2f       	mov	r27, r29
     8fe:	b1 1d       	adc	r27, r1
     900:	1d 96       	adiw	r26, 0x0d	; 13
     902:	8c 91       	ld	r24, X
     904:	85 87       	std	Z+13, r24	; 0x0d
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:619
          (*txTail)++;                            // Increment counter for sent bytes
     906:	88 85       	ldd	r24, Y+8	; 0x08
     908:	8f 5f       	subi	r24, 0xFF	; 255
     90a:	88 87       	std	Y+8, r24	; 0x08
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:631
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
        rxBuffer[(*rxHead)] = payload;              // save data
        (*rxHead)++;                                  // Advance Head
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
     90c:	83 e0       	ldi	r24, 0x03	; 3
     90e:	ba cf       	rjmp	.-140    	; 0x884 <TWI_HandleSlaveIRQ+0x58>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:626
        } else {                                // No more data available
          action = TWI_SCMD_COMPTRANS_gc;         // "Wait for any Start (S/Sr) condition"
        }
      }
    } else {                                  // Master is writing
      uint8_t payload = _data->_module->SDATA;      // reading SDATA will clear the DATA IRQ flag
     910:	85 85       	ldd	r24, Z+13	; 0x0d
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:627
      if ((*rxHead) < BUFFER_LENGTH) {              // make sure that we don't have a buffer overflow in case Master ignores NACK
     912:	ee 81       	ldd	r30, Y+6	; 0x06
     914:	e2 38       	cpi	r30, 0x82	; 130
     916:	68 f4       	brcc	.+26     	; 0x932 <TWI_HandleSlaveIRQ+0x106>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:628
        rxBuffer[(*rxHead)] = payload;              // save data
     918:	ec 0f       	add	r30, r28
     91a:	fd 2f       	mov	r31, r29
     91c:	f1 1d       	adc	r31, r1
     91e:	e1 57       	subi	r30, 0x71	; 113
     920:	ff 4f       	sbci	r31, 0xFF	; 255
     922:	80 83       	st	Z, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:629
        (*rxHead)++;                                  // Advance Head
     924:	8e 81       	ldd	r24, Y+6	; 0x06
     926:	8f 5f       	subi	r24, 0xFF	; 255
     928:	8e 83       	std	Y+6, r24	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:630
        if ((*rxHead) < BUFFER_LENGTH) {              // if buffer is not yet full
     92a:	82 38       	cpi	r24, 0x82	; 130
     92c:	78 f3       	brcs	.-34     	; 0x90c <TWI_HandleSlaveIRQ+0xe0>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:633
          action = TWI_SCMD_RESPONSE_gc;                // "Execute Acknowledge Action succeeded by reception of next byte"
        } else {                                      // else buffer would overflow with next byte
          action = TWI_ACKACT_bm | TWI_SCMD_COMPTRANS_gc;  // "Execute ACK Action succeeded by waiting for any Start (S/Sr) condition"
     92e:	86 e0       	ldi	r24, 0x06	; 6
     930:	a9 cf       	rjmp	.-174    	; 0x884 <TWI_HandleSlaveIRQ+0x58>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:562

  #if defined(TWI_MANDS)
    _data->_bools._toggleStreamFn = 0x01;
  #endif

  uint8_t action = 0;
     932:	80 e0       	ldi	r24, 0x00	; 0
     934:	a7 cf       	rjmp	.-178    	; 0x884 <TWI_HandleSlaveIRQ+0x58>

00000936 <TwoWire::flush()>:
TWI_Flush():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:130
 */
void TWI_Flush(struct twiData *_data) {
  #if defined(ERRATA_TWI_FLUSH)
    // badCall("The AVR DA-series parts are impacted by an errata that leaves the TWI peripheral in a non-functioning state when using flush.");
    // restarting TWI hardware by hand. Extra size shouldn't matter on DA series
    uint8_t temp_MCTRLA     = _data->_module->MCTRLA;
     936:	dc 01       	movw	r26, r24
     938:	18 96       	adiw	r26, 0x08	; 8
     93a:	ed 91       	ld	r30, X+
     93c:	fc 91       	ld	r31, X
     93e:	93 81       	ldd	r25, Z+3	; 0x03
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:131
    uint8_t temp_SCTRLA     = _data->_module->SCTRLA;
     940:	81 85       	ldd	r24, Z+9	; 0x09
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:132
    _data->_module->MCTRLA  = 0x00;
     942:	13 82       	std	Z+3, r1	; 0x03
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:133
    _data->_module->SCTRLA  = 0x00;
     944:	11 86       	std	Z+9, r1	; 0x09
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:134
    _data->_module->MCTRLA  = temp_MCTRLA;
     946:	93 83       	std	Z+3, r25	; 0x03
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:135
    _data->_module->MSTATUS = 0x01;  // force TWI state machine into idle state
     948:	91 e0       	ldi	r25, 0x01	; 1
     94a:	95 83       	std	Z+5, r25	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:136
    _data->_module->SCTRLA  = temp_SCTRLA;
     94c:	81 87       	std	Z+9, r24	; 0x09
flush():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:748
 *@return     void
 */
void TwoWire::flush(void) {
  /* Turn off and on TWI module */
  TWI_Flush(&vars);
}
     94e:	08 95       	ret

00000950 <TwoWire::peek()>:
peek():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:726
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
     950:	9c 01       	movw	r18, r24
     952:	29 56       	subi	r18, 0x69	; 105
     954:	3f 4f       	sbci	r19, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:730
    #endif
  }

  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
     956:	dc 01       	movw	r26, r24
     958:	1f 96       	adiw	r26, 0x0f	; 15
     95a:	ec 91       	ld	r30, X
     95c:	1f 97       	sbiw	r26, 0x0f	; 15
     95e:	1e 96       	adiw	r26, 0x0e	; 14
     960:	8c 91       	ld	r24, X
     962:	e8 17       	cp	r30, r24
     964:	30 f4       	brcc	.+12     	; 0x972 <TwoWire::peek()+0x22>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:731
    return rxBuffer[(*rxTail)];
     966:	e2 0f       	add	r30, r18
     968:	f3 2f       	mov	r31, r19
     96a:	f1 1d       	adc	r31, r1
     96c:	80 81       	ld	r24, Z
     96e:	90 e0       	ldi	r25, 0x00	; 0
     970:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:733
  } else {      // No bytes to read
    return -1;
     972:	8f ef       	ldi	r24, 0xFF	; 255
     974:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:735
  }
}
     976:	08 95       	ret

00000978 <TwoWire::read()>:
read():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:635
 *@param      void
 *
 *@return     int
 *@retval     byte in the buffer or -1 if buffer is empty
 */
int TwoWire::read(void) {
     978:	fc 01       	movw	r30, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:653
      rxTail   = &(vars._bytesReadWritten);
      rxBuffer =   vars._trBuffer;
    #else                                        // Separate tx/rx Buffers
      rxHead   = &(vars._bytesToRead);
      rxTail   = &(vars._bytesRead);
      rxBuffer =   vars._rxBuffer;
     97a:	dc 01       	movw	r26, r24
     97c:	a9 56       	subi	r26, 0x69	; 105
     97e:	bf 4f       	sbci	r27, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:658
    #endif
  }


  if ((*rxTail) < (*rxHead)) {   // if there are bytes to read
     980:	97 85       	ldd	r25, Z+15	; 0x0f
     982:	86 85       	ldd	r24, Z+14	; 0x0e
     984:	98 17       	cp	r25, r24
     986:	40 f4       	brcc	.+16     	; 0x998 <TwoWire::read()+0x20>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:659
    uint8_t c = rxBuffer[(*rxTail)];
     988:	a9 0f       	add	r26, r25
     98a:	b1 1d       	adc	r27, r1
     98c:	2c 91       	ld	r18, X
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:660
    (*rxTail)++;
     98e:	9f 5f       	subi	r25, 0xFF	; 255
     990:	97 87       	std	Z+15, r25	; 0x0f
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:661
    return c;
     992:	82 2f       	mov	r24, r18
     994:	90 e0       	ldi	r25, 0x00	; 0
     996:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:663
  } else {                      // No bytes to read. At this point, rxTail moved up to
    return -1;                  // rxHead. To reset both to 0, a MasterRead or AddrWrite has to be called
     998:	8f ef       	ldi	r24, 0xFF	; 255
     99a:	9f ef       	ldi	r25, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:665
  }
}
     99c:	08 95       	ret

0000099e <TwoWire::available()>:
available():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:603
 *@param      void
 *
 *@return     int
 *@retval     amount of bytes available to read from the host buffer
 */
int TwoWire::available(void) {
     99e:	fc 01       	movw	r30, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:614
  #endif
  {
    #if defined(TWI_MERGE_BUFFERS)                // Same Buffers for tx/rx
      rxHead  = vars._bytesToReadWrite - vars._bytesReadWritten;
    #else                                         // Separate tx/rx Buffers
      rxHead  = vars._bytesToRead - vars._bytesRead;
     9a0:	86 85       	ldd	r24, Z+14	; 0x0e
     9a2:	97 85       	ldd	r25, Z+15	; 0x0f
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:618
    #endif
  }
  return rxHead;
}
     9a4:	89 1b       	sub	r24, r25
     9a6:	99 0b       	sbc	r25, r25
     9a8:	08 95       	ret

000009aa <TwoWire::write(unsigned char)>:
write():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:536
 *
 *
 *@return     uint8_t
 *@retval     1 if successful, 0 if the buffer is full
 */
size_t TwoWire::write(uint8_t data) {
     9aa:	fc 01       	movw	r30, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:557
    #endif
  }

  /* Put byte in txBuffer */

  if ((*txHead) < BUFFER_LENGTH) {      // while buffer not full, write to it
     9ac:	a5 85       	ldd	r26, Z+13	; 0x0d
     9ae:	a2 38       	cpi	r26, 0x82	; 130
     9b0:	58 f4       	brcc	.+22     	; 0x9c8 <TwoWire::write(unsigned char)+0x1e>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:558
    txBuffer[(*txHead)] = data;             // Load data into the buffer
     9b2:	a8 0f       	add	r26, r24
     9b4:	b9 2f       	mov	r27, r25
     9b6:	b1 1d       	adc	r27, r1
     9b8:	55 96       	adiw	r26, 0x15	; 21
     9ba:	6c 93       	st	X, r22
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:559
    (*txHead)++;                            // advancing the head
     9bc:	85 85       	ldd	r24, Z+13	; 0x0d
     9be:	8f 5f       	subi	r24, 0xFF	; 255
     9c0:	85 87       	std	Z+13, r24	; 0x0d
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:560
    return 1;
     9c2:	81 e0       	ldi	r24, 0x01	; 1
     9c4:	90 e0       	ldi	r25, 0x00	; 0
     9c6:	08 95       	ret
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:562
  } else {
    return 0;
     9c8:	90 e0       	ldi	r25, 0x00	; 0
     9ca:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:564
  }
}
     9cc:	08 95       	ret

000009ce <TwoWire::write(unsigned char const*, unsigned int)>:
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:579
 *
 *
 *@return     uint8_t
 *@retval     amount of bytes copied
 */
size_t TwoWire::write(const uint8_t *data, size_t quantity) {
     9ce:	bf 92       	push	r11
     9d0:	cf 92       	push	r12
     9d2:	df 92       	push	r13
     9d4:	ef 92       	push	r14
     9d6:	ff 92       	push	r15
     9d8:	0f 93       	push	r16
     9da:	1f 93       	push	r17
     9dc:	cf 93       	push	r28
     9de:	df 93       	push	r29
     9e0:	7c 01       	movw	r14, r24
     9e2:	6a 01       	movw	r12, r20
     9e4:	b6 2e       	mov	r11, r22
     9e6:	eb 01       	movw	r28, r22
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:581
  twi_buffer_index_t i = 0;
  for (; i < quantity; i++) {
     9e8:	0c 2f       	mov	r16, r28
     9ea:	0b 19       	sub	r16, r11
     9ec:	10 e0       	ldi	r17, 0x00	; 0
     9ee:	0c 15       	cp	r16, r12
     9f0:	1d 05       	cpc	r17, r13
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:582
    if (TwoWire::write(*(data++)) == 0)
     9f2:	28 f4       	brcc	.+10     	; 0x9fe <TwoWire::write(unsigned char const*, unsigned int)+0x30>
     9f4:	69 91       	ld	r22, Y+
     9f6:	c7 01       	movw	r24, r14
     9f8:	d8 df       	rcall	.-80     	; 0x9aa <TwoWire::write(unsigned char)>
     9fa:	89 2b       	or	r24, r25
     9fc:	a9 f7       	brne	.-22     	; 0x9e8 <TwoWire::write(unsigned char const*, unsigned int)+0x1a>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:587
      break;   // break if buffer full
  }

  return i;
}
     9fe:	c8 01       	movw	r24, r16
     a00:	df 91       	pop	r29
     a02:	cf 91       	pop	r28
     a04:	1f 91       	pop	r17
     a06:	0f 91       	pop	r16
     a08:	ff 90       	pop	r15
     a0a:	ef 90       	pop	r14
     a0c:	df 90       	pop	r13
     a0e:	cf 90       	pop	r12
     a10:	bf 90       	pop	r11
     a12:	08 95       	ret

00000a14 <Print::availableForWrite()>:
availableForWrite():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.h:65
      return write((const uint8_t *)buffer, size);
    }

    // default to zero, meaning "a single write may block"
    // should be overridden by subclasses with buffering
    virtual int availableForWrite() { return 0; }
     a14:	90 e0       	ldi	r25, 0x00	; 0
     a16:	80 e0       	ldi	r24, 0x00	; 0
     a18:	08 95       	ret

00000a1a <is_valid_string>:
is_valid_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:85
    return true;
}


/************************ CJSON IMPLEMENTATION **************************/
static inline bool is_valid_string(const cJSON *json) {
     a1a:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:86
    return (NULL != json && cJSON_IsString(json) && json->valuestring != NULL);
     a1c:	89 2b       	or	r24, r25
     a1e:	41 f0       	breq	.+16     	; 0xa30 <is_valid_string+0x16>
cJSON_IsString():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2944
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_String;
     a20:	86 81       	ldd	r24, Z+6	; 0x06
is_valid_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:86
     a22:	80 31       	cpi	r24, 0x10	; 16
     a24:	29 f4       	brne	.+10     	; 0xa30 <is_valid_string+0x16>
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	20 85       	ldd	r18, Z+8	; 0x08
     a2a:	31 85       	ldd	r19, Z+9	; 0x09
     a2c:	23 2b       	or	r18, r19
     a2e:	09 f4       	brne	.+2      	; 0xa32 <is_valid_string+0x18>
     a30:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:87
}
     a32:	81 70       	andi	r24, 0x01	; 1
     a34:	08 95       	ret

00000a36 <cJSON_free>:
cJSON_free():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:3109
    return global_hooks.allocate(size);
}

CJSON_PUBLIC(void) cJSON_free(void *object)
{
    global_hooks.deallocate(object);
     a36:	e0 91 04 42 	lds	r30, 0x4204	; 0x804204 <global_hooks+0x2>
     a3a:	f0 91 05 42 	lds	r31, 0x4205	; 0x804205 <global_hooks+0x3>
     a3e:	09 94       	ijmp

00000a40 <add_item_to_array>:
add_item_to_array():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1953
    reference->next = reference->prev = NULL;
    return reference;
}

static cJSON_bool add_item_to_array(cJSON *array, cJSON *item)
{
     a40:	cf 93       	push	r28
     a42:	df 93       	push	r29
     a44:	fb 01       	movw	r30, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1956
    cJSON *child = NULL;

    if ((item == NULL) || (array == NULL) || (array == item))
     a46:	30 97       	sbiw	r30, 0x00	; 0
     a48:	11 f1       	breq	.+68     	; 0xa8e <add_item_to_array+0x4e>
     a4a:	00 97       	sbiw	r24, 0x00	; 0
     a4c:	01 f1       	breq	.+64     	; 0xa8e <add_item_to_array+0x4e>
     a4e:	68 17       	cp	r22, r24
     a50:	79 07       	cpc	r23, r25
     a52:	e9 f0       	breq	.+58     	; 0xa8e <add_item_to_array+0x4e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1961
    {
        return false;
    }

    child = array->child;
     a54:	ec 01       	movw	r28, r24
     a56:	ac 81       	ldd	r26, Y+4	; 0x04
     a58:	bd 81       	ldd	r27, Y+5	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1965
    /*
     * To find the last item in array quickly, we use prev in array
     */
    if (child == NULL)
     a5a:	10 97       	sbiw	r26, 0x00	; 0
     a5c:	49 f4       	brne	.+18     	; 0xa70 <add_item_to_array+0x30>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1968
    {
        /* list is empty, start new one */
        array->child = item;
     a5e:	6c 83       	std	Y+4, r22	; 0x04
     a60:	7d 83       	std	Y+5, r23	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1969
        item->prev = item;
     a62:	62 83       	std	Z+2, r22	; 0x02
     a64:	73 83       	std	Z+3, r23	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1970
        item->next = NULL;
     a66:	10 82       	st	Z, r1
     a68:	11 82       	std	Z+1, r1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1975
    }
    else
    {
        /* append to the end */
        if (child->prev)
     a6a:	81 e0       	ldi	r24, 0x01	; 1
     a6c:	90 e0       	ldi	r25, 0x00	; 0
     a6e:	11 c0       	rjmp	.+34     	; 0xa92 <add_item_to_array+0x52>
     a70:	12 96       	adiw	r26, 0x02	; 2
     a72:	cd 91       	ld	r28, X+
     a74:	dc 91       	ld	r29, X
     a76:	13 97       	sbiw	r26, 0x03	; 3
     a78:	20 97       	sbiw	r28, 0x00	; 0
     a7a:	b9 f3       	breq	.-18     	; 0xa6a <add_item_to_array+0x2a>
suffix_object():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1926
}

/* Utility for array list handling. */
static void suffix_object(cJSON *prev, cJSON *item)
{
    prev->next = item;
     a7c:	68 83       	st	Y, r22
     a7e:	79 83       	std	Y+1, r23	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1927
    item->prev = prev;
     a80:	c2 83       	std	Z+2, r28	; 0x02
     a82:	d3 83       	std	Z+3, r29	; 0x03
add_item_to_array():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1978
    {
        /* append to the end */
        if (child->prev)
        {
            suffix_object(child->prev, item);
            array->child->prev = item;
     a84:	12 96       	adiw	r26, 0x02	; 2
     a86:	6d 93       	st	X+, r22
     a88:	7c 93       	st	X, r23
     a8a:	13 97       	sbiw	r26, 0x03	; 3
     a8c:	ee cf       	rjmp	.-36     	; 0xa6a <add_item_to_array+0x2a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1958
{
    cJSON *child = NULL;

    if ((item == NULL) || (array == NULL) || (array == item))
    {
        return false;
     a8e:	90 e0       	ldi	r25, 0x00	; 0
     a90:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1983
            array->child->prev = item;
        }
    }

    return true;
}
     a92:	df 91       	pop	r29
     a94:	cf 91       	pop	r28
     a96:	08 95       	ret

00000a98 <buffer_skip_whitespace>:
buffer_skip_whitespace():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1035
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer);
static cJSON_bool print_object(const cJSON * const item, printbuffer * const output_buffer);

/* Utility to jump whitespace and cr/lf */
static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
{
     a98:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1036
    if ((buffer == NULL) || (buffer->content == NULL))
     a9a:	89 2b       	or	r24, r25
     a9c:	61 f0       	breq	.+24     	; 0xab6 <buffer_skip_whitespace+0x1e>
     a9e:	40 81       	ld	r20, Z
     aa0:	51 81       	ldd	r21, Z+1	; 0x01
     aa2:	41 15       	cp	r20, r1
     aa4:	51 05       	cpc	r21, r1
     aa6:	01 f1       	breq	.+64     	; 0xae8 <buffer_skip_whitespace+0x50>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1041
    {
        return NULL;
    }

    if (cannot_access_at_index(buffer, 0))
     aa8:	82 81       	ldd	r24, Z+2	; 0x02
     aaa:	93 81       	ldd	r25, Z+3	; 0x03
     aac:	24 81       	ldd	r18, Z+4	; 0x04
     aae:	35 81       	ldd	r19, Z+5	; 0x05
     ab0:	28 17       	cp	r18, r24
     ab2:	39 07       	cpc	r19, r25
     ab4:	30 f0       	brcs	.+12     	; 0xac2 <buffer_skip_whitespace+0x2a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1057
    {
        buffer->offset--;
    }

    return buffer;
}
     ab6:	cf 01       	movw	r24, r30
     ab8:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1048
        return buffer;
    }

    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
    {
       buffer->offset++;
     aba:	2f 5f       	subi	r18, 0xFF	; 255
     abc:	3f 4f       	sbci	r19, 0xFF	; 255
     abe:	24 83       	std	Z+4, r18	; 0x04
     ac0:	35 83       	std	Z+5, r19	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1046
    if (cannot_access_at_index(buffer, 0))
    {
        return buffer;
    }

    while (can_access_at_index(buffer, 0) && (buffer_at_offset(buffer)[0] <= 32))
     ac2:	24 81       	ldd	r18, Z+4	; 0x04
     ac4:	35 81       	ldd	r19, Z+5	; 0x05
     ac6:	28 17       	cp	r18, r24
     ac8:	39 07       	cpc	r19, r25
     aca:	38 f4       	brcc	.+14     	; 0xada <buffer_skip_whitespace+0x42>
     acc:	da 01       	movw	r26, r20
     ace:	a2 0f       	add	r26, r18
     ad0:	b3 1f       	adc	r27, r19
     ad2:	6c 91       	ld	r22, X
     ad4:	61 32       	cpi	r22, 0x21	; 33
     ad6:	88 f3       	brcs	.-30     	; 0xaba <buffer_skip_whitespace+0x22>
     ad8:	ee cf       	rjmp	.-36     	; 0xab6 <buffer_skip_whitespace+0x1e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1051
    {
       buffer->offset++;
    }

    if (buffer->offset == buffer->length)
     ada:	82 17       	cp	r24, r18
     adc:	93 07       	cpc	r25, r19
     ade:	59 f7       	brne	.-42     	; 0xab6 <buffer_skip_whitespace+0x1e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1053
    {
        buffer->offset--;
     ae0:	01 97       	sbiw	r24, 0x01	; 1
     ae2:	84 83       	std	Z+4, r24	; 0x04
     ae4:	95 83       	std	Z+5, r25	; 0x05
     ae6:	e7 cf       	rjmp	.-50     	; 0xab6 <buffer_skip_whitespace+0x1e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1038
/* Utility to jump whitespace and cr/lf */
static parse_buffer *buffer_skip_whitespace(parse_buffer * const buffer)
{
    if ((buffer == NULL) || (buffer->content == NULL))
    {
        return NULL;
     ae8:	f0 e0       	ldi	r31, 0x00	; 0
     aea:	e0 e0       	ldi	r30, 0x00	; 0
     aec:	e4 cf       	rjmp	.-56     	; 0xab6 <buffer_skip_whitespace+0x1e>

00000aee <parse_hex4>:
parse_hex4():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:612
    return true;
}

/* parse 4 digit hexadecimal number */
static unsigned parse_hex4(const unsigned char * const input)
{
     aee:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:616
    unsigned int h = 0;
    size_t i = 0;

    for (i = 0; i < 4; i++)
     af0:	50 e0       	ldi	r21, 0x00	; 0
     af2:	40 e0       	ldi	r20, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:613
}

/* parse 4 digit hexadecimal number */
static unsigned parse_hex4(const unsigned char * const input)
{
    unsigned int h = 0;
     af4:	90 e0       	ldi	r25, 0x00	; 0
     af6:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:619
    size_t i = 0;

    for (i = 0; i < 4; i++)
    {
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
     af8:	21 91       	ld	r18, Z+
     afa:	30 ed       	ldi	r19, 0xD0	; 208
     afc:	32 0f       	add	r19, r18
     afe:	3a 30       	cpi	r19, 0x0A	; 10
     b00:	88 f4       	brcc	.+34     	; 0xb24 <parse_hex4+0x36>
     b02:	c0 97       	sbiw	r24, 0x30	; 48
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:629
        {
            h += (unsigned int) 10 + input[i] - 'A';
        }
        else if ((input[i] >= 'a') && (input[i] <= 'f'))
        {
            h += (unsigned int) 10 + input[i] - 'a';
     b04:	82 0f       	add	r24, r18
     b06:	91 1d       	adc	r25, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:636
        else /* invalid */
        {
            return 0;
        }

        if (i < 3)
     b08:	43 30       	cpi	r20, 0x03	; 3
     b0a:	51 05       	cpc	r21, r1
     b0c:	29 f0       	breq	.+10     	; 0xb18 <parse_hex4+0x2a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:639
        {
            /* shift left to make place for the next nibble */
            h = h << 4;
     b0e:	24 e0       	ldi	r18, 0x04	; 4
     b10:	88 0f       	add	r24, r24
     b12:	99 1f       	adc	r25, r25
     b14:	2a 95       	dec	r18
     b16:	e1 f7       	brne	.-8      	; 0xb10 <parse_hex4+0x22>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:616
static unsigned parse_hex4(const unsigned char * const input)
{
    unsigned int h = 0;
    size_t i = 0;

    for (i = 0; i < 4; i++)
     b18:	4f 5f       	subi	r20, 0xFF	; 255
     b1a:	5f 4f       	sbci	r21, 0xFF	; 255
     b1c:	44 30       	cpi	r20, 0x04	; 4
     b1e:	51 05       	cpc	r21, r1
     b20:	59 f7       	brne	.-42     	; 0xaf8 <parse_hex4+0xa>
     b22:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:623
        /* parse digit */
        if ((input[i] >= '0') && (input[i] <= '9'))
        {
            h += (unsigned int) input[i] - '0';
        }
        else if ((input[i] >= 'A') && (input[i] <= 'F'))
     b24:	3f eb       	ldi	r19, 0xBF	; 191
     b26:	32 0f       	add	r19, r18
     b28:	36 30       	cpi	r19, 0x06	; 6
     b2a:	10 f4       	brcc	.+4      	; 0xb30 <parse_hex4+0x42>
     b2c:	c7 97       	sbiw	r24, 0x37	; 55
     b2e:	ea cf       	rjmp	.-44     	; 0xb04 <parse_hex4+0x16>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:627
        {
            h += (unsigned int) 10 + input[i] - 'A';
        }
        else if ((input[i] >= 'a') && (input[i] <= 'f'))
     b30:	3f e9       	ldi	r19, 0x9F	; 159
     b32:	32 0f       	add	r19, r18
     b34:	36 30       	cpi	r19, 0x06	; 6
     b36:	18 f4       	brcc	.+6      	; 0xb3e <parse_hex4+0x50>
     b38:	87 55       	subi	r24, 0x57	; 87
     b3a:	91 09       	sbc	r25, r1
     b3c:	e3 cf       	rjmp	.-58     	; 0xb04 <parse_hex4+0x16>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:633
        {
            h += (unsigned int) 10 + input[i] - 'a';
        }
        else /* invalid */
        {
            return 0;
     b3e:	90 e0       	ldi	r25, 0x00	; 0
     b40:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:644
            h = h << 4;
        }
    }

    return h;
}
     b42:	08 95       	ret

00000b44 <parse_string>:
parse_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:770
    return 0;
}

/* Parse the input text into an unescaped cinput, and populate item. */
static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
{
     b44:	2f 92       	push	r2
     b46:	3f 92       	push	r3
     b48:	4f 92       	push	r4
     b4a:	5f 92       	push	r5
     b4c:	6f 92       	push	r6
     b4e:	7f 92       	push	r7
     b50:	8f 92       	push	r8
     b52:	9f 92       	push	r9
     b54:	af 92       	push	r10
     b56:	bf 92       	push	r11
     b58:	cf 92       	push	r12
     b5a:	df 92       	push	r13
     b5c:	ef 92       	push	r14
     b5e:	ff 92       	push	r15
     b60:	0f 93       	push	r16
     b62:	1f 93       	push	r17
     b64:	cf 93       	push	r28
     b66:	df 93       	push	r29
     b68:	3c 01       	movw	r6, r24
     b6a:	4b 01       	movw	r8, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:771
    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
     b6c:	db 01       	movw	r26, r22
     b6e:	4d 91       	ld	r20, X+
     b70:	5c 91       	ld	r21, X
     b72:	11 97       	sbiw	r26, 0x01	; 1
     b74:	14 96       	adiw	r26, 0x04	; 4
     b76:	ed 91       	ld	r30, X+
     b78:	fc 91       	ld	r31, X
     b7a:	15 97       	sbiw	r26, 0x05	; 5
     b7c:	8f 01       	movw	r16, r30
     b7e:	0f 5f       	subi	r16, 0xFF	; 255
     b80:	1f 4f       	sbci	r17, 0xFF	; 255
     b82:	04 0f       	add	r16, r20
     b84:	15 1f       	adc	r17, r21
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:777
    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
    unsigned char *output_pointer = NULL;
    unsigned char *output = NULL;

    /* not a string */
    if (buffer_at_offset(input_buffer)[0] != '\"')
     b86:	e4 0f       	add	r30, r20
     b88:	f5 1f       	adc	r31, r21
     b8a:	80 81       	ld	r24, Z
     b8c:	82 32       	cpi	r24, 0x22	; 34
     b8e:	09 f0       	breq	.+2      	; 0xb92 <parse_string+0x4e>
     b90:	87 c0       	rjmp	.+270    	; 0xca0 <parse_string+0x15c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:786

    {
        /* calculate approximate size of the output (overestimate) */
        size_t allocation_length = 0;
        size_t skipped_bytes = 0;
        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
     b92:	12 96       	adiw	r26, 0x02	; 2
     b94:	2d 91       	ld	r18, X+
     b96:	3c 91       	ld	r19, X
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:772

/* Parse the input text into an unescaped cinput, and populate item. */
static cJSON_bool parse_string(cJSON * const item, parse_buffer * const input_buffer)
{
    const unsigned char *input_pointer = buffer_at_offset(input_buffer) + 1;
    const unsigned char *input_end = buffer_at_offset(input_buffer) + 1;
     b98:	68 01       	movw	r12, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:785
    }

    {
        /* calculate approximate size of the output (overestimate) */
        size_t allocation_length = 0;
        size_t skipped_bytes = 0;
     b9a:	70 e0       	ldi	r23, 0x00	; 0
     b9c:	60 e0       	ldi	r22, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:786
        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
     b9e:	c6 01       	movw	r24, r12
     ba0:	84 1b       	sub	r24, r20
     ba2:	95 0b       	sbc	r25, r21
     ba4:	82 17       	cp	r24, r18
     ba6:	93 07       	cpc	r25, r19
     ba8:	08 f0       	brcs	.+2      	; 0xbac <parse_string+0x68>
     baa:	7a c0       	rjmp	.+244    	; 0xca0 <parse_string+0x15c>
     bac:	d6 01       	movw	r26, r12
     bae:	8c 91       	ld	r24, X
     bb0:	82 32       	cpi	r24, 0x22	; 34
     bb2:	09 f0       	breq	.+2      	; 0xbb6 <parse_string+0x72>
     bb4:	43 c0       	rjmp	.+134    	; 0xc3c <parse_string+0xf8>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:807
        {
            goto fail; /* string ended unexpectedly */
        }

        /* This is at most how much we need for the output */
        allocation_length = (size_t) (input_end - buffer_at_offset(input_buffer)) - skipped_bytes;
     bb6:	c6 01       	movw	r24, r12
     bb8:	8e 1b       	sub	r24, r30
     bba:	9f 0b       	sbc	r25, r31
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:808
        output = (unsigned char*)input_buffer->hooks.allocate(allocation_length + sizeof(""));
     bbc:	86 1b       	sub	r24, r22
     bbe:	97 0b       	sbc	r25, r23
     bc0:	d4 01       	movw	r26, r8
     bc2:	18 96       	adiw	r26, 0x08	; 8
     bc4:	ed 91       	ld	r30, X+
     bc6:	fc 91       	ld	r31, X
     bc8:	01 96       	adiw	r24, 0x01	; 1
     bca:	09 95       	icall
     bcc:	5c 01       	movw	r10, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:809
        if (output == NULL)
     bce:	00 97       	sbiw	r24, 0x00	; 0
     bd0:	09 f4       	brne	.+2      	; 0xbd4 <parse_string+0x90>
     bd2:	66 c0       	rjmp	.+204    	; 0xca0 <parse_string+0x15c>
     bd4:	ec 01       	movw	r28, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:844
                    break;
                case 'n':
                    *output_pointer++ = '\n';
                    break;
                case 'r':
                    *output_pointer++ = '\r';
     bd6:	ed e0       	ldi	r30, 0x0D	; 13
     bd8:	5e 2e       	mov	r5, r30
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:847
                    break;
                case 't':
                    *output_pointer++ = '\t';
     bda:	f9 e0       	ldi	r31, 0x09	; 9
     bdc:	4f 2e       	mov	r4, r31
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:841
                    break;
                case 'f':
                    *output_pointer++ = '\f';
                    break;
                case 'n':
                    *output_pointer++ = '\n';
     bde:	aa e0       	ldi	r26, 0x0A	; 10
     be0:	3a 2e       	mov	r3, r26
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:835
            }

            switch (input_pointer[1])
            {
                case 'b':
                    *output_pointer++ = '\b';
     be2:	b8 e0       	ldi	r27, 0x08	; 8
     be4:	2b 2e       	mov	r2, r27
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:817
        }
    }

    output_pointer = output;
    /* loop through the string literal */
    while (input_pointer < input_end)
     be6:	0c 15       	cp	r16, r12
     be8:	1d 05       	cpc	r17, r13
     bea:	c8 f1       	brcs	.+114    	; 0xc5e <parse_string+0x11a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:873
            input_pointer += sequence_length;
        }
    }

    /* zero terminate the output */
    *output_pointer = '\0';
     bec:	18 82       	st	Y, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:875

    item->type = cJSON_String;
     bee:	80 e1       	ldi	r24, 0x10	; 16
     bf0:	90 e0       	ldi	r25, 0x00	; 0
     bf2:	f3 01       	movw	r30, r6
     bf4:	86 83       	std	Z+6, r24	; 0x06
     bf6:	97 83       	std	Z+7, r25	; 0x07
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:876
    item->valuestring = (char*)output;
     bf8:	a0 86       	std	Z+8, r10	; 0x08
     bfa:	b1 86       	std	Z+9, r11	; 0x09
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:878

    input_buffer->offset = (size_t) (input_end - input_buffer->content);
     bfc:	d4 01       	movw	r26, r8
     bfe:	8d 91       	ld	r24, X+
     c00:	9c 91       	ld	r25, X
     c02:	c8 1a       	sub	r12, r24
     c04:	d9 0a       	sbc	r13, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:879
    input_buffer->offset++;
     c06:	bf ef       	ldi	r27, 0xFF	; 255
     c08:	cb 1a       	sub	r12, r27
     c0a:	db 0a       	sbc	r13, r27
     c0c:	f4 01       	movw	r30, r8
     c0e:	c4 82       	std	Z+4, r12	; 0x04
     c10:	d5 82       	std	Z+5, r13	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:881

    return true;
     c12:	81 e0       	ldi	r24, 0x01	; 1
     c14:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:895
    {
        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
    }

    return false;
}
     c16:	df 91       	pop	r29
     c18:	cf 91       	pop	r28
     c1a:	1f 91       	pop	r17
     c1c:	0f 91       	pop	r16
     c1e:	ff 90       	pop	r15
     c20:	ef 90       	pop	r14
     c22:	df 90       	pop	r13
     c24:	cf 90       	pop	r12
     c26:	bf 90       	pop	r11
     c28:	af 90       	pop	r10
     c2a:	9f 90       	pop	r9
     c2c:	8f 90       	pop	r8
     c2e:	7f 90       	pop	r7
     c30:	6f 90       	pop	r6
     c32:	5f 90       	pop	r5
     c34:	4f 90       	pop	r4
     c36:	3f 90       	pop	r3
     c38:	2f 90       	pop	r2
     c3a:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:789
        size_t allocation_length = 0;
        size_t skipped_bytes = 0;
        while (((size_t)(input_end - input_buffer->content) < input_buffer->length) && (*input_end != '\"'))
        {
            /* is escape sequence */
            if (input_end[0] == '\\')
     c3c:	8c 35       	cpi	r24, 0x5C	; 92
     c3e:	59 f4       	brne	.+22     	; 0xc56 <parse_string+0x112>
     c40:	bf ef       	ldi	r27, 0xFF	; 255
     c42:	cb 1a       	sub	r12, r27
     c44:	db 0a       	sbc	r13, r27
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:791
            {
                if ((size_t)(input_end + 1 - input_buffer->content) >= input_buffer->length)
     c46:	c6 01       	movw	r24, r12
     c48:	84 1b       	sub	r24, r20
     c4a:	95 0b       	sbc	r25, r21
     c4c:	82 17       	cp	r24, r18
     c4e:	93 07       	cpc	r25, r19
     c50:	38 f5       	brcc	.+78     	; 0xca0 <parse_string+0x15c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:796
                {
                    /* prevent buffer overflow when last input character is a backslash */
                    goto fail;
                }
                skipped_bytes++;
     c52:	6f 5f       	subi	r22, 0xFF	; 255
     c54:	7f 4f       	sbci	r23, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:799
                input_end++;
            }
            input_end++;
     c56:	8f ef       	ldi	r24, 0xFF	; 255
     c58:	c8 1a       	sub	r12, r24
     c5a:	d8 0a       	sbc	r13, r24
     c5c:	a0 cf       	rjmp	.-192    	; 0xb9e <parse_string+0x5a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:819

    output_pointer = output;
    /* loop through the string literal */
    while (input_pointer < input_end)
    {
        if (*input_pointer != '\\')
     c5e:	f8 01       	movw	r30, r16
     c60:	80 81       	ld	r24, Z
     c62:	8c 35       	cpi	r24, 0x5C	; 92
     c64:	29 f0       	breq	.+10     	; 0xc70 <parse_string+0x12c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:821
        {
            *output_pointer++ = *input_pointer++;
     c66:	0f 5f       	subi	r16, 0xFF	; 255
     c68:	1f 4f       	sbci	r17, 0xFF	; 255
     c6a:	88 83       	st	Y, r24
     c6c:	21 96       	adiw	r28, 0x01	; 1
     c6e:	bb cf       	rjmp	.-138    	; 0xbe6 <parse_string+0xa2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:827
        }
        /* escape sequence */
        else
        {
            unsigned char sequence_length = 2;
            if ((input_end - input_pointer) < 1)
     c70:	96 01       	movw	r18, r12
     c72:	20 1b       	sub	r18, r16
     c74:	31 0b       	sbc	r19, r17
     c76:	12 16       	cp	r1, r18
     c78:	13 06       	cpc	r1, r19
     c7a:	64 f4       	brge	.+24     	; 0xc94 <parse_string+0x150>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:832
            {
                goto fail;
            }

            switch (input_pointer[1])
     c7c:	81 81       	ldd	r24, Z+1	; 0x01
     c7e:	86 36       	cpi	r24, 0x66	; 102
     c80:	09 f4       	brne	.+2      	; 0xc84 <parse_string+0x140>
     c82:	80 c0       	rjmp	.+256    	; 0xd84 <parse_string+0x240>
     c84:	28 f5       	brcc	.+74     	; 0xcd0 <parse_string+0x18c>
     c86:	8f 32       	cpi	r24, 0x2F	; 47
     c88:	09 f4       	brne	.+2      	; 0xc8c <parse_string+0x148>
     c8a:	83 c0       	rjmp	.+262    	; 0xd92 <parse_string+0x24e>
     c8c:	b0 f4       	brcc	.+44     	; 0xcba <parse_string+0x176>
     c8e:	82 32       	cpi	r24, 0x22	; 34
     c90:	09 f4       	brne	.+2      	; 0xc94 <parse_string+0x150>
     c92:	7f c0       	rjmp	.+254    	; 0xd92 <parse_string+0x24e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:886
    return true;

fail:
    if (output != NULL)
    {
        input_buffer->hooks.deallocate(output);
     c94:	d4 01       	movw	r26, r8
     c96:	1a 96       	adiw	r26, 0x0a	; 10
     c98:	ed 91       	ld	r30, X+
     c9a:	fc 91       	ld	r31, X
     c9c:	c5 01       	movw	r24, r10
     c9e:	09 95       	icall
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:889
    }

    if (input_pointer != NULL)
     ca0:	01 15       	cp	r16, r1
     ca2:	11 05       	cpc	r17, r1
     ca4:	39 f0       	breq	.+14     	; 0xcb4 <parse_string+0x170>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:891
    {
        input_buffer->offset = (size_t)(input_pointer - input_buffer->content);
     ca6:	f4 01       	movw	r30, r8
     ca8:	80 81       	ld	r24, Z
     caa:	91 81       	ldd	r25, Z+1	; 0x01
     cac:	08 1b       	sub	r16, r24
     cae:	19 0b       	sbc	r17, r25
     cb0:	04 83       	std	Z+4, r16	; 0x04
     cb2:	15 83       	std	Z+5, r17	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:894
    }

    return false;
     cb4:	90 e0       	ldi	r25, 0x00	; 0
     cb6:	80 e0       	ldi	r24, 0x00	; 0
     cb8:	ae cf       	rjmp	.-164    	; 0xc16 <parse_string+0xd2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:832
            if ((input_end - input_pointer) < 1)
            {
                goto fail;
            }

            switch (input_pointer[1])
     cba:	8c 35       	cpi	r24, 0x5C	; 92
     cbc:	09 f4       	brne	.+2      	; 0xcc0 <parse_string+0x17c>
     cbe:	69 c0       	rjmp	.+210    	; 0xd92 <parse_string+0x24e>
     cc0:	82 36       	cpi	r24, 0x62	; 98
     cc2:	41 f7       	brne	.-48     	; 0xc94 <parse_string+0x150>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:835
            {
                case 'b':
                    *output_pointer++ = '\b';
     cc4:	28 82       	st	Y, r2
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:838
                    break;
                case 'f':
                    *output_pointer++ = '\f';
     cc6:	21 96       	adiw	r28, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:826
            *output_pointer++ = *input_pointer++;
        }
        /* escape sequence */
        else
        {
            unsigned char sequence_length = 2;
     cc8:	22 e0       	ldi	r18, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:868
                    break;

                default:
                    goto fail;
            }
            input_pointer += sequence_length;
     cca:	02 0f       	add	r16, r18
     ccc:	11 1d       	adc	r17, r1
     cce:	8b cf       	rjmp	.-234    	; 0xbe6 <parse_string+0xa2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:832
            if ((input_end - input_pointer) < 1)
            {
                goto fail;
            }

            switch (input_pointer[1])
     cd0:	82 37       	cpi	r24, 0x72	; 114
     cd2:	09 f4       	brne	.+2      	; 0xcd6 <parse_string+0x192>
     cd4:	5a c0       	rjmp	.+180    	; 0xd8a <parse_string+0x246>
     cd6:	20 f4       	brcc	.+8      	; 0xce0 <parse_string+0x19c>
     cd8:	8e 36       	cpi	r24, 0x6E	; 110
     cda:	e1 f6       	brne	.-72     	; 0xc94 <parse_string+0x150>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:841
                    break;
                case 'f':
                    *output_pointer++ = '\f';
                    break;
                case 'n':
                    *output_pointer++ = '\n';
     cdc:	38 82       	st	Y, r3
     cde:	f3 cf       	rjmp	.-26     	; 0xcc6 <parse_string+0x182>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:832
            if ((input_end - input_pointer) < 1)
            {
                goto fail;
            }

            switch (input_pointer[1])
     ce0:	84 37       	cpi	r24, 0x74	; 116
     ce2:	09 f4       	brne	.+2      	; 0xce6 <parse_string+0x1a2>
     ce4:	54 c0       	rjmp	.+168    	; 0xd8e <parse_string+0x24a>
     ce6:	85 37       	cpi	r24, 0x75	; 117
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:658
    unsigned char utf8_length = 0;
    unsigned char utf8_position = 0;
    unsigned char sequence_length = 0;
    unsigned char first_byte_mark = 0;

    if ((input_end - first_sequence) < 6)
     ce8:	a9 f6       	brne	.-86     	; 0xc94 <parse_string+0x150>
utf16_literal_to_utf8():
     cea:	26 30       	cpi	r18, 0x06	; 6
     cec:	31 05       	cpc	r19, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:665
        /* input ends unexpectedly */
        goto fail;
    }

    /* get the first utf16 sequence */
    first_code = parse_hex4(first_sequence + 2);
     cee:	94 f2       	brlt	.-92     	; 0xc94 <parse_string+0x150>
     cf0:	c8 01       	movw	r24, r16
     cf2:	02 96       	adiw	r24, 0x02	; 2
     cf4:	fc de       	rcall	.-520    	; 0xaee <parse_hex4>
     cf6:	7c 01       	movw	r14, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:668

    /* check that the code is valid */
    if (((first_code >= 0xDC00) && (first_code <= 0xDFFF)))
     cf8:	9c 5d       	subi	r25, 0xDC	; 220
     cfa:	81 15       	cp	r24, r1
     cfc:	e4 e0       	ldi	r30, 0x04	; 4
     cfe:	9e 07       	cpc	r25, r30
     d00:	48 f2       	brcs	.-110    	; 0xc94 <parse_string+0x150>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:674
    {
        goto fail;
    }

    /* UTF16 surrogate pair */
    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
     d02:	9c 5f       	subi	r25, 0xFC	; 252
     d04:	81 15       	cp	r24, r1
     d06:	94 40       	sbci	r25, 0x04	; 4
     d08:	08 f0       	brcs	.+2      	; 0xd0c <parse_string+0x1c8>
     d0a:	45 c0       	rjmp	.+138    	; 0xd96 <parse_string+0x252>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:680
    {
        const unsigned char *second_sequence = first_sequence + 6;
        unsigned int second_code = 0;
        sequence_length = 12; /* \uXXXX\uXXXX */

        if ((input_end - second_sequence) < 6)
     d0c:	c8 01       	movw	r24, r16
     d0e:	06 96       	adiw	r24, 0x06	; 6
     d10:	96 01       	movw	r18, r12
     d12:	28 1b       	sub	r18, r24
     d14:	39 0b       	sbc	r19, r25
     d16:	26 30       	cpi	r18, 0x06	; 6
     d18:	31 05       	cpc	r19, r1
     d1a:	0c f4       	brge	.+2      	; 0xd1e <parse_string+0x1da>
     d1c:	bb cf       	rjmp	.-138    	; 0xc94 <parse_string+0x150>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:686
        {
            /* input ends unexpectedly */
            goto fail;
        }

        if ((second_sequence[0] != '\\') || (second_sequence[1] != 'u'))
     d1e:	d8 01       	movw	r26, r16
     d20:	16 96       	adiw	r26, 0x06	; 6
     d22:	8c 91       	ld	r24, X
     d24:	16 97       	sbiw	r26, 0x06	; 6
     d26:	8c 35       	cpi	r24, 0x5C	; 92
     d28:	09 f0       	breq	.+2      	; 0xd2c <parse_string+0x1e8>
     d2a:	b4 cf       	rjmp	.-152    	; 0xc94 <parse_string+0x150>
     d2c:	17 96       	adiw	r26, 0x07	; 7
     d2e:	8c 91       	ld	r24, X
     d30:	85 37       	cpi	r24, 0x75	; 117
     d32:	09 f0       	breq	.+2      	; 0xd36 <parse_string+0x1f2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:693
            /* missing second half of the surrogate pair */
            goto fail;
        }

        /* get the second utf16 sequence */
        second_code = parse_hex4(second_sequence + 2);
     d34:	af cf       	rjmp	.-162    	; 0xc94 <parse_string+0x150>
     d36:	c8 01       	movw	r24, r16
     d38:	08 96       	adiw	r24, 0x08	; 8
     d3a:	d9 de       	rcall	.-590    	; 0xaee <parse_hex4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:695
        /* check that the code is valid */
        if ((second_code < 0xDC00) || (second_code > 0xDFFF))
     d3c:	9c 01       	movw	r18, r24
     d3e:	3c 5d       	subi	r19, 0xDC	; 220
     d40:	21 15       	cp	r18, r1
     d42:	34 40       	sbci	r19, 0x04	; 4
     d44:	08 f0       	brcs	.+2      	; 0xd48 <parse_string+0x204>
     d46:	a6 cf       	rjmp	.-180    	; 0xc94 <parse_string+0x150>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:703
            goto fail;
        }


        /* calculate the unicode codepoint from the surrogate pair */
        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
     d48:	fe 2c       	mov	r15, r14
     d4a:	ee 24       	eor	r14, r14
     d4c:	ff 0c       	add	r15, r15
     d4e:	ff 0c       	add	r15, r15
     d50:	93 70       	andi	r25, 0x03	; 3
     d52:	8e 29       	or	r24, r14
     d54:	9f 29       	or	r25, r15
     d56:	b0 e0       	ldi	r27, 0x00	; 0
     d58:	a0 e0       	ldi	r26, 0x00	; 0
     d5a:	11 96       	adiw	r26, 0x01	; 1
parse_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:678
    /* UTF16 surrogate pair */
    if ((first_code >= 0xD800) && (first_code <= 0xDBFF))
    {
        const unsigned char *second_sequence = first_sequence + 6;
        unsigned int second_code = 0;
        sequence_length = 12; /* \uXXXX\uXXXX */
     d5c:	2c e0       	ldi	r18, 0x0C	; 12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:735
    }
    else if (codepoint <= 0x10FFFF)
    {
        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
        utf8_length = 4;
        first_byte_mark = 0xF0; /* 11110000 */
     d5e:	40 ef       	ldi	r20, 0xF0	; 240
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:734
        first_byte_mark = 0xE0; /* 11100000 */
    }
    else if (codepoint <= 0x10FFFF)
    {
        /* four bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx 10xxxxxx */
        utf8_length = 4;
     d60:	34 e0       	ldi	r19, 0x04	; 4
utf16_literal_to_utf8():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:744
        /* invalid unicode codepoint */
        goto fail;
    }

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
     d62:	5f ef       	ldi	r21, 0xFF	; 255
     d64:	53 0f       	add	r21, r19
     d66:	e5 2f       	mov	r30, r21
     d68:	f0 e0       	ldi	r31, 0x00	; 0
     d6a:	31 96       	adiw	r30, 0x01	; 1
     d6c:	ec 0f       	add	r30, r28
     d6e:	fd 1f       	adc	r31, r29
     d70:	68 2f       	mov	r22, r24
     d72:	51 11       	cpse	r21, r1
     d74:	26 c0       	rjmp	.+76     	; 0xdc2 <parse_string+0x27e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:751
        /* 10xxxxxx */
        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
        codepoint >>= 6;
    }
    /* encode first byte */
    if (utf8_length > 1)
     d76:	31 30       	cpi	r19, 0x01	; 1
     d78:	89 f1       	breq	.+98     	; 0xddc <parse_string+0x298>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:753
    {
        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
     d7a:	48 2b       	or	r20, r24
     d7c:	48 83       	st	Y, r20
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:760
    else
    {
        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
    }

    *output_pointer += utf8_length;
     d7e:	c3 0f       	add	r28, r19
     d80:	d1 1d       	adc	r29, r1
     d82:	a3 cf       	rjmp	.-186    	; 0xcca <parse_string+0x186>
parse_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:838
            {
                case 'b':
                    *output_pointer++ = '\b';
                    break;
                case 'f':
                    *output_pointer++ = '\f';
     d84:	bc e0       	ldi	r27, 0x0C	; 12
     d86:	b8 83       	st	Y, r27
     d88:	9e cf       	rjmp	.-196    	; 0xcc6 <parse_string+0x182>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:844
                    break;
                case 'n':
                    *output_pointer++ = '\n';
                    break;
                case 'r':
                    *output_pointer++ = '\r';
     d8a:	58 82       	st	Y, r5
     d8c:	9c cf       	rjmp	.-200    	; 0xcc6 <parse_string+0x182>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:847
                    break;
                case 't':
                    *output_pointer++ = '\t';
     d8e:	48 82       	st	Y, r4
     d90:	9a cf       	rjmp	.-204    	; 0xcc6 <parse_string+0x182>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:852
                    break;
                case '\"':
                case '\\':
                case '/':
                    *output_pointer++ = input_pointer[1];
     d92:	88 83       	st	Y, r24
     d94:	98 cf       	rjmp	.-208    	; 0xcc6 <parse_string+0x182>
utf16_literal_to_utf8():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:708
        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
    }
    else
    {
        sequence_length = 6; /* \uXXXX */
        codepoint = first_code;
     d96:	c7 01       	movw	r24, r14
     d98:	b0 e0       	ldi	r27, 0x00	; 0
     d9a:	a0 e0       	ldi	r26, 0x00	; 0
parse_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:707
        /* calculate the unicode codepoint from the surrogate pair */
        codepoint = 0x10000 + (((first_code & 0x3FF) << 10) | (second_code & 0x3FF));
    }
    else
    {
        sequence_length = 6; /* \uXXXX */
     d9c:	26 e0       	ldi	r18, 0x06	; 6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:656
    unsigned int first_code = 0;
    const unsigned char *first_sequence = input_pointer;
    unsigned char utf8_length = 0;
    unsigned char utf8_position = 0;
    unsigned char sequence_length = 0;
    unsigned char first_byte_mark = 0;
     d9e:	40 e0       	ldi	r20, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:717
     * takes at maximum 4 bytes to encode:
     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    if (codepoint < 0x80)
    {
        /* normal ascii, encoding 0xxxxxxx */
        utf8_length = 1;
     da0:	31 e0       	ldi	r19, 0x01	; 1
utf16_literal_to_utf8():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:714
    }

    /* encode as UTF-8
     * takes at maximum 4 bytes to encode:
     * 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx */
    if (codepoint < 0x80)
     da2:	80 38       	cpi	r24, 0x80	; 128
     da4:	91 05       	cpc	r25, r1
     da6:	a1 05       	cpc	r26, r1
     da8:	b1 05       	cpc	r27, r1
     daa:	d8 f2       	brcs	.-74     	; 0xd62 <parse_string+0x21e>
parse_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:723
    }
    else if (codepoint < 0x800)
    {
        /* two bytes, encoding 110xxxxx 10xxxxxx */
        utf8_length = 2;
        first_byte_mark = 0xC0; /* 11000000 */
     dac:	40 ec       	ldi	r20, 0xC0	; 192
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:722
        utf8_length = 1;
    }
    else if (codepoint < 0x800)
    {
        /* two bytes, encoding 110xxxxx 10xxxxxx */
        utf8_length = 2;
     dae:	32 e0       	ldi	r19, 0x02	; 2
utf16_literal_to_utf8():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:719
    if (codepoint < 0x80)
    {
        /* normal ascii, encoding 0xxxxxxx */
        utf8_length = 1;
    }
    else if (codepoint < 0x800)
     db0:	81 15       	cp	r24, r1
     db2:	f8 e0       	ldi	r31, 0x08	; 8
     db4:	9f 07       	cpc	r25, r31
     db6:	a1 05       	cpc	r26, r1
     db8:	b1 05       	cpc	r27, r1
     dba:	98 f2       	brcs	.-90     	; 0xd62 <parse_string+0x21e>
parse_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:729
    }
    else if (codepoint < 0x10000)
    {
        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        utf8_length = 3;
        first_byte_mark = 0xE0; /* 11100000 */
     dbc:	40 ee       	ldi	r20, 0xE0	; 224
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:728
        first_byte_mark = 0xC0; /* 11000000 */
    }
    else if (codepoint < 0x10000)
    {
        /* three bytes, encoding 1110xxxx 10xxxxxx 10xxxxxx */
        utf8_length = 3;
     dbe:	33 e0       	ldi	r19, 0x03	; 3
     dc0:	d0 cf       	rjmp	.-96     	; 0xd62 <parse_string+0x21e>
utf16_literal_to_utf8():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:747

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
    {
        /* 10xxxxxx */
        (*output_pointer)[utf8_position] = (unsigned char)((codepoint | 0x80) & 0xBF);
     dc2:	68 2f       	mov	r22, r24
     dc4:	6f 73       	andi	r22, 0x3F	; 63
     dc6:	60 68       	ori	r22, 0x80	; 128
     dc8:	62 93       	st	-Z, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:748
        codepoint >>= 6;
     dca:	66 e0       	ldi	r22, 0x06	; 6
     dcc:	b6 95       	lsr	r27
     dce:	a7 95       	ror	r26
     dd0:	97 95       	ror	r25
     dd2:	87 95       	ror	r24
     dd4:	6a 95       	dec	r22
     dd6:	d1 f7       	brne	.-12     	; 0xdcc <parse_string+0x288>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:744
        /* invalid unicode codepoint */
        goto fail;
    }

    /* encode as utf8 */
    for (utf8_position = (unsigned char)(utf8_length - 1); utf8_position > 0; utf8_position--)
     dd8:	51 50       	subi	r21, 0x01	; 1
     dda:	ca cf       	rjmp	.-108    	; 0xd70 <parse_string+0x22c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:757
    {
        (*output_pointer)[0] = (unsigned char)((codepoint | first_byte_mark) & 0xFF);
    }
    else
    {
        (*output_pointer)[0] = (unsigned char)(codepoint & 0x7F);
     ddc:	6f 77       	andi	r22, 0x7F	; 127
     dde:	68 83       	st	Y, r22
     de0:	ce cf       	rjmp	.-100    	; 0xd7e <parse_string+0x23a>

00000de2 <cJSON_Delete>:
cJSON_Delete():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:254
    return node;
}

/* Delete a cJSON structure. */
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
{
     de2:	0f 93       	push	r16
     de4:	1f 93       	push	r17
     de6:	cf 93       	push	r28
     de8:	df 93       	push	r29
     dea:	ec 01       	movw	r28, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:256
    cJSON *next = NULL;
    while (item != NULL)
     dec:	20 97       	sbiw	r28, 0x00	; 0
     dee:	29 f4       	brne	.+10     	; 0xdfa <cJSON_Delete+0x18>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:274
            global_hooks.deallocate(item->string);
        }
        global_hooks.deallocate(item);
        item = next;
    }
}
     df0:	df 91       	pop	r29
     df2:	cf 91       	pop	r28
     df4:	1f 91       	pop	r17
     df6:	0f 91       	pop	r16
     df8:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:258
CJSON_PUBLIC(void) cJSON_Delete(cJSON *item)
{
    cJSON *next = NULL;
    while (item != NULL)
    {
        next = item->next;
     dfa:	08 81       	ld	r16, Y
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:259
        if (!(item->type & cJSON_IsReference) && (item->child != NULL))
     dfc:	19 81       	ldd	r17, Y+1	; 0x01
     dfe:	8e 81       	ldd	r24, Y+6	; 0x06
     e00:	9f 81       	ldd	r25, Y+7	; 0x07
     e02:	90 fd       	sbrc	r25, 0
     e04:	05 c0       	rjmp	.+10     	; 0xe10 <cJSON_Delete+0x2e>
     e06:	8c 81       	ldd	r24, Y+4	; 0x04
     e08:	9d 81       	ldd	r25, Y+5	; 0x05
     e0a:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:261
        {
            cJSON_Delete(item->child);
     e0c:	09 f0       	breq	.+2      	; 0xe10 <cJSON_Delete+0x2e>
     e0e:	e9 df       	rcall	.-46     	; 0xde2 <cJSON_Delete>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:263
        }
        if (!(item->type & cJSON_IsReference) && (item->valuestring != NULL))
     e10:	8e 81       	ldd	r24, Y+6	; 0x06
     e12:	9f 81       	ldd	r25, Y+7	; 0x07
     e14:	90 fd       	sbrc	r25, 0
     e16:	09 c0       	rjmp	.+18     	; 0xe2a <cJSON_Delete+0x48>
     e18:	88 85       	ldd	r24, Y+8	; 0x08
     e1a:	99 85       	ldd	r25, Y+9	; 0x09
     e1c:	00 97       	sbiw	r24, 0x00	; 0
     e1e:	29 f0       	breq	.+10     	; 0xe2a <cJSON_Delete+0x48>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:265
        {
            global_hooks.deallocate(item->valuestring);
     e20:	e0 91 04 42 	lds	r30, 0x4204	; 0x804204 <global_hooks+0x2>
     e24:	f0 91 05 42 	lds	r31, 0x4205	; 0x804205 <global_hooks+0x3>
     e28:	09 95       	icall
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:267
        }
        if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
     e2a:	8e 81       	ldd	r24, Y+6	; 0x06
     e2c:	9f 81       	ldd	r25, Y+7	; 0x07
     e2e:	91 fd       	sbrc	r25, 1
     e30:	09 c0       	rjmp	.+18     	; 0xe44 <cJSON_Delete+0x62>
     e32:	88 89       	ldd	r24, Y+16	; 0x10
     e34:	99 89       	ldd	r25, Y+17	; 0x11
     e36:	00 97       	sbiw	r24, 0x00	; 0
     e38:	29 f0       	breq	.+10     	; 0xe44 <cJSON_Delete+0x62>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:269
        {
            global_hooks.deallocate(item->string);
     e3a:	e0 91 04 42 	lds	r30, 0x4204	; 0x804204 <global_hooks+0x2>
     e3e:	f0 91 05 42 	lds	r31, 0x4205	; 0x804205 <global_hooks+0x3>
     e42:	09 95       	icall
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:271
        }
        global_hooks.deallocate(item);
     e44:	e0 91 04 42 	lds	r30, 0x4204	; 0x804204 <global_hooks+0x2>
     e48:	f0 91 05 42 	lds	r31, 0x4205	; 0x804205 <global_hooks+0x3>
     e4c:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:272
        item = next;
     e4e:	09 95       	icall
     e50:	e8 01       	movw	r28, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:9

TimeoutTimer::TimeoutTimer(const uint32_t ms) : interval_ms(ms) {
    start_ms = millis();
}

bool TimeoutTimer::hasTimedOut(void) const {
     e52:	cc cf       	rjmp	.-104    	; 0xdec <cJSON_Delete+0xa>

00000e54 <TimeoutTimer::hasTimedOut() const>:
hasTimedOut():
     e54:	cf 92       	push	r12
     e56:	df 92       	push	r13
     e58:	ef 92       	push	r14
     e5a:	ff 92       	push	r15
     e5c:	cf 93       	push	r28
     e5e:	df 93       	push	r29
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:10
    return millis() - start_ms > interval_ms;
     e60:	ec 01       	movw	r28, r24
     e62:	89 db       	rcall	.-2286   	; 0x576 <millis>
     e64:	cc 80       	ldd	r12, Y+4	; 0x04
     e66:	dd 80       	ldd	r13, Y+5	; 0x05
     e68:	ee 80       	ldd	r14, Y+6	; 0x06
     e6a:	ff 80       	ldd	r15, Y+7	; 0x07
     e6c:	6c 19       	sub	r22, r12
     e6e:	7d 09       	sbc	r23, r13
     e70:	8e 09       	sbc	r24, r14
     e72:	9f 09       	sbc	r25, r15
     e74:	21 e0       	ldi	r18, 0x01	; 1
     e76:	c8 80       	ld	r12, Y
     e78:	d9 80       	ldd	r13, Y+1	; 0x01
     e7a:	ea 80       	ldd	r14, Y+2	; 0x02
     e7c:	fb 80       	ldd	r15, Y+3	; 0x03
     e7e:	c6 16       	cp	r12, r22
     e80:	d7 06       	cpc	r13, r23
     e82:	e8 06       	cpc	r14, r24
     e84:	f9 06       	cpc	r15, r25
     e86:	08 f0       	brcs	.+2      	; 0xe8a <TimeoutTimer::hasTimedOut() const+0x36>
     e88:	20 e0       	ldi	r18, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:11
     e8a:	82 2f       	mov	r24, r18
     e8c:	df 91       	pop	r29
     e8e:	cf 91       	pop	r28
     e90:	ff 90       	pop	r15
     e92:	ef 90       	pop	r14
     e94:	df 90       	pop	r13
     e96:	cf 90       	pop	r12
     e98:	08 95       	ret

00000e9a <CTSInterrupt()>:
CTSInterrupt():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:291
    got_wait_for_urc_callback = true;
}

void CTSInterrupt(void) {

    if (VPORTC.INTFLAGS & CTS_INT_bm) {
     e9a:	5c 9b       	sbis	0x0b, 4	; 11
     e9c:	09 c0       	rjmp	.+18     	; 0xeb0 <CTSInterrupt()+0x16>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:293

        if (VPORTC.IN & CTS_PIN_bm) {
     e9e:	54 9b       	sbis	0x0a, 4	; 10
     ea0:	08 c0       	rjmp	.+16     	; 0xeb2 <CTSInterrupt()+0x18>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:296
            // CTS is not asserted (active low) so disable USART data register
            // empty interrupt where the logic is to send more data
            HWSERIALAT.CTRLA &= (~USART_DREIE_bm);
     ea2:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
     ea6:	8f 7d       	andi	r24, 0xDF	; 223
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:300
        } else {
            // CTS is asserted so we enable the USART data register empty
            // interrupt so more data can be sent
            HWSERIALAT.CTRLA |= USART_DREIE_bm;
     ea8:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:303
        }

        VPORTC.INTFLAGS = CTS_INT_bm;
     eac:	80 e1       	ldi	r24, 0x10	; 16
     eae:	8b b9       	out	0x0b, r24	; 11
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:305
    }
}
     eb0:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:300
            // empty interrupt where the logic is to send more data
            HWSERIALAT.CTRLA &= (~USART_DREIE_bm);
        } else {
            // CTS is asserted so we enable the USART data register empty
            // interrupt so more data can be sent
            HWSERIALAT.CTRLA |= USART_DREIE_bm;
     eb2:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
     eb6:	80 62       	ori	r24, 0x20	; 32
     eb8:	f7 cf       	rjmp	.-18     	; 0xea8 <CTSInterrupt()+0xe>

00000eba <ctsUpdate()>:
ctsUpdate():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:274
 * falling flank is sometimes missed due to having to use Arduino's
 * attachInterrupt() system. This adds quite a lot of instructions and the CTS
 * pulse is short (some microseconds), which leads to missing the flank.
 */
static inline void ctsUpdate(void) {
    if (!(HWSERIALAT.CTRLA & USART_DREIE_bm) && !(VPORTC.IN & CTS_PIN_bm) &&
     eba:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
     ebe:	85 fd       	sbrc	r24, 5
     ec0:	0d c0       	rjmp	.+26     	; 0xedc <ctsUpdate()+0x22>
     ec2:	54 99       	sbic	0x0a, 4	; 10
     ec4:	0b c0       	rjmp	.+22     	; 0xedc <ctsUpdate()+0x22>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:275
        tx_num_elements > 0) {
     ec6:	80 91 b1 6a 	lds	r24, 0x6AB1	; 0x806ab1 <tx_num_elements>
     eca:	90 91 b2 6a 	lds	r25, 0x6AB2	; 0x806ab2 <tx_num_elements+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:274
 * falling flank is sometimes missed due to having to use Arduino's
 * attachInterrupt() system. This adds quite a lot of instructions and the CTS
 * pulse is short (some microseconds), which leads to missing the flank.
 */
static inline void ctsUpdate(void) {
    if (!(HWSERIALAT.CTRLA & USART_DREIE_bm) && !(VPORTC.IN & CTS_PIN_bm) &&
     ece:	89 2b       	or	r24, r25
     ed0:	29 f0       	breq	.+10     	; 0xedc <ctsUpdate()+0x22>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:276
        tx_num_elements > 0) {
        HWSERIALAT.CTRLA |= USART_DREIE_bm;
     ed2:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
     ed6:	80 62       	ori	r24, 0x20	; 32
     ed8:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:278
    }
}
     edc:	08 95       	ret

00000ede <rtsUpdate()>:
rtsUpdate():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:243
 * target that no more data should be sent
 */
static inline void rtsUpdate(void) {
    // If we are in a power save mode, flow control is disabled until we get a
    // RING0 ack
    if (power_save_mode == 1) {
     ede:	80 91 7f 62 	lds	r24, 0x627F	; 0x80627f <power_save_mode>
     ee2:	81 30       	cpi	r24, 0x01	; 1
     ee4:	71 f0       	breq	.+28     	; 0xf02 <rtsUpdate()+0x24>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:247
        return;
    }

    if (critical_section_enabled) {
     ee6:	80 91 89 66 	lds	r24, 0x6689	; 0x806689 <critical_section_enabled>
     eea:	81 11       	cpse	r24, r1
     eec:	0a c0       	rjmp	.+20     	; 0xf02 <rtsUpdate()+0x24>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:253
        return;
    }

    // We prefer to not use arduino's digitalWrite here to reduce code in the
    // ISR
    if (rx_num_elements < RX_BUFFER_ALMOST_FULL) {
     eee:	80 91 7a 6d 	lds	r24, 0x6D7A	; 0x806d7a <rx_num_elements>
     ef2:	90 91 7b 6d 	lds	r25, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
     ef6:	8e 3f       	cpi	r24, 0xFE	; 254
     ef8:	91 40       	sbci	r25, 0x01	; 1
     efa:	10 f4       	brcc	.+4      	; 0xf00 <rtsUpdate()+0x22>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:255
        // Space for more data, assert RTS line (active low)
        VPORTC.OUT &= (~RTS_PIN_bm);
     efc:	4f 98       	cbi	0x09, 7	; 9
     efe:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:259
    } else {
        // Buffer is filling up, tell the target to stop sending data
        // for now by de-asserting RTS
        VPORTC.OUT |= RTS_PIN_bm;
     f00:	4f 9a       	sbi	0x09, 7	; 9
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:261
    }
}
     f02:	08 95       	ret

00000f04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>:
clearReceiveBuffer():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:781
    // response. Caller should increase the buffer size.
    return ResponseResult::BUFFER_OVERFLOW;
}

void SequansControllerClass::clearReceiveBuffer(void) {
    cli();
     f04:	f8 94       	cli
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:782
    rx_num_elements = 0;
     f06:	10 92 7a 6d 	sts	0x6D7A, r1	; 0x806d7a <rx_num_elements>
     f0a:	10 92 7b 6d 	sts	0x6D7B, r1	; 0x806d7b <rx_num_elements+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:783
    rx_tail_index   = rx_head_index;
     f0e:	80 91 78 6d 	lds	r24, 0x6D78	; 0x806d78 <rx_head_index>
     f12:	90 91 79 6d 	lds	r25, 0x6D79	; 0x806d79 <rx_head_index+0x1>
     f16:	80 93 76 6d 	sts	0x6D76, r24	; 0x806d76 <rx_tail_index>
     f1a:	90 93 77 6d 	sts	0x6D77, r25	; 0x806d77 <rx_tail_index+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:786
    sei();

    rtsUpdate();
     f1e:	78 94       	sei
     f20:	de cf       	rjmp	.-68     	; 0xede <rtsUpdate()>

00000f22 <SequansControllerClass::readByte() [clone .constprop.117]>:
readByte():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:647
    if (!(VPORTC.IN & CTS_PIN_bm)) {
        HWSERIALAT.CTRLA |= USART_DREIE_bm;
    }
}

int16_t SequansControllerClass::readByte(void) {
     f22:	cf 93       	push	r28
     f24:	df 93       	push	r29
isRxReady():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:573

bool SequansControllerClass::isTxReady(void) {
    return tx_num_elements < TX_BUFFER_SIZE;
}

bool SequansControllerClass::isRxReady(void) { return rx_num_elements > 0; }
     f26:	80 91 7a 6d 	lds	r24, 0x6D7A	; 0x806d7a <rx_num_elements>
     f2a:	90 91 7b 6d 	lds	r25, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
readByte():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:648
        HWSERIALAT.CTRLA |= USART_DREIE_bm;
    }
}

int16_t SequansControllerClass::readByte(void) {
    if (!isRxReady()) {
     f2e:	89 2b       	or	r24, r25
     f30:	e9 f0       	breq	.+58     	; 0xf6c <SequansControllerClass::readByte() [clone .constprop.117]+0x4a>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:654
        return -1;
    }

    // Disable interrupts temporarily here to prevent being interleaved
    // in the middle of updating the tail index
    cli();
     f32:	f8 94       	cli
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:655
    const uint16_t next_tail_index = (rx_tail_index + 1) & RX_BUFFER_MASK;
     f34:	c0 91 76 6d 	lds	r28, 0x6D76	; 0x806d76 <rx_tail_index>
     f38:	d0 91 77 6d 	lds	r29, 0x6D77	; 0x806d77 <rx_tail_index+0x1>
     f3c:	21 96       	adiw	r28, 0x01	; 1
     f3e:	d1 70       	andi	r29, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:656
    rx_tail_index                  = next_tail_index;
     f40:	c0 93 76 6d 	sts	0x6D76, r28	; 0x806d76 <rx_tail_index>
     f44:	d0 93 77 6d 	sts	0x6D77, r29	; 0x806d77 <rx_tail_index+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:657
    rx_num_elements--;
     f48:	80 91 7a 6d 	lds	r24, 0x6D7A	; 0x806d7a <rx_num_elements>
     f4c:	90 91 7b 6d 	lds	r25, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
     f50:	01 97       	sbiw	r24, 0x01	; 1
     f52:	80 93 7a 6d 	sts	0x6D7A, r24	; 0x806d7a <rx_num_elements>
     f56:	90 93 7b 6d 	sts	0x6D7B, r25	; 0x806d7b <rx_num_elements+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:660
    sei();

    rtsUpdate();
     f5a:	78 94       	sei
     f5c:	c0 df       	rcall	.-128    	; 0xede <rtsUpdate()>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:662

    return rx_buffer[next_tail_index];
     f5e:	c1 55       	subi	r28, 0x51	; 81
     f60:	d9 49       	sbci	r29, 0x99	; 153
     f62:	88 81       	ld	r24, Y
     f64:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:663
}
     f66:	df 91       	pop	r29
     f68:	cf 91       	pop	r28
     f6a:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:649
    }
}

int16_t SequansControllerClass::readByte(void) {
    if (!isRxReady()) {
        return -1;
     f6c:	8f ef       	ldi	r24, 0xFF	; 255
     f6e:	9f ef       	ldi	r25, 0xFF	; 255
     f70:	fa cf       	rjmp	.-12     	; 0xf66 <SequansControllerClass::readByte() [clone .constprop.117]+0x44>

00000f72 <SequansControllerClass::waitForByte(unsigned char, unsigned long) [clone .constprop.116]>:
waitForByte():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1054
        strcpy(response_string, "NONE");
        break;
    }
}

bool SequansControllerClass::waitForByte(const uint8_t byte,
     f72:	8f 92       	push	r8
     f74:	9f 92       	push	r9
     f76:	af 92       	push	r10
     f78:	bf 92       	push	r11
     f7a:	ef 92       	push	r14
     f7c:	ff 92       	push	r15
     f7e:	0f 93       	push	r16
     f80:	1f 93       	push	r17
     f82:	cf 93       	push	r28
     f84:	df 93       	push	r29
     f86:	cd b7       	in	r28, 0x3d	; 61
     f88:	de b7       	in	r29, 0x3e	; 62
     f8a:	28 97       	sbiw	r28, 0x08	; 8
     f8c:	cd bf       	out	0x3d, r28	; 61
     f8e:	de bf       	out	0x3e, r29	; 62
     f90:	08 2f       	mov	r16, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1056
                                         const uint32_t timeout) {
    int16_t read_byte = SequansController.readByte();
     f92:	4a 01       	movw	r8, r20
     f94:	5b 01       	movw	r10, r22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:5
#include "timeout_timer.h"

#include <Arduino.h>

TimeoutTimer::TimeoutTimer(const uint32_t ms) : interval_ms(ms) {
     f96:	c5 df       	rcall	.-118    	; 0xf22 <SequansControllerClass::readByte() [clone .constprop.117]>
     f98:	7c 01       	movw	r14, r24
__base_ctor ():
     f9a:	89 82       	std	Y+1, r8	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:6
    start_ms = millis();
     f9c:	9a 82       	std	Y+2, r9	; 0x02
     f9e:	ab 82       	std	Y+3, r10	; 0x03
     fa0:	bc 82       	std	Y+4, r11	; 0x04
     fa2:	e9 da       	rcall	.-2606   	; 0x576 <millis>
     fa4:	6d 83       	std	Y+5, r22	; 0x05
     fa6:	7e 83       	std	Y+6, r23	; 0x06
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1060

    TimeoutTimer timeout_timer(timeout);

    while (read_byte != byte) {
     fa8:	8f 83       	std	Y+7, r24	; 0x07
     faa:	98 87       	std	Y+8, r25	; 0x08
waitForByte():
     fac:	10 e0       	ldi	r17, 0x00	; 0
     fae:	0e 15       	cp	r16, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1061
        read_byte = SequansController.readByte();
     fb0:	1f 05       	cpc	r17, r15
     fb2:	b9 f0       	breq	.+46     	; 0xfe2 <SequansControllerClass::waitForByte(unsigned char, unsigned long) [clone .constprop.116]+0x70>
     fb4:	b6 df       	rcall	.-148    	; 0xf22 <SequansControllerClass::readByte() [clone .constprop.117]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1065

        // We update the CTS here in case the CTS interrupt didn't catch the
        // falling flank
        ctsUpdate();
     fb6:	7c 01       	movw	r14, r24
     fb8:	80 df       	rcall	.-256    	; 0xeba <ctsUpdate()>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1067

        if (timeout_timer.hasTimedOut()) {
     fba:	ce 01       	movw	r24, r28
     fbc:	01 96       	adiw	r24, 0x01	; 1
     fbe:	4a df       	rcall	.-364    	; 0xe54 <TimeoutTimer::hasTimedOut() const>
     fc0:	88 23       	and	r24, r24
     fc2:	a9 f3       	breq	.-22     	; 0xfae <SequansControllerClass::waitForByte(unsigned char, unsigned long) [clone .constprop.116]+0x3c>
     fc4:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1068
            return false;
     fc6:	28 96       	adiw	r28, 0x08	; 8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1073
        }
    }

    return true;
}
     fc8:	cd bf       	out	0x3d, r28	; 61
     fca:	de bf       	out	0x3e, r29	; 62
     fcc:	df 91       	pop	r29
     fce:	cf 91       	pop	r28
     fd0:	1f 91       	pop	r17
     fd2:	0f 91       	pop	r16
     fd4:	ff 90       	pop	r15
     fd6:	ef 90       	pop	r14
     fd8:	bf 90       	pop	r11
     fda:	af 90       	pop	r10
     fdc:	9f 90       	pop	r9
     fde:	8f 90       	pop	r8
     fe0:	08 95       	ret
     fe2:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1072
        if (timeout_timer.hasTimedOut()) {
            return false;
        }
    }

    return true;
     fe4:	f0 cf       	rjmp	.-32     	; 0xfc6 <SequansControllerClass::waitForByte(unsigned char, unsigned long) [clone .constprop.116]+0x54>

00000fe6 <hal_i2c_release>:
TWI_DisableMaster():
     fe6:	80 91 9f 6e 	lds	r24, 0x6E9F	; 0x806e9f <Wire+0xa>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:164
 *@param      struct twiData *_data is a pointer to the structure that holds the Wire variables
 *
 *@return     void
 */
void TWI_DisableMaster(struct twiData *_data) {
  if (true == _data->_bools._hostEnabled) {
     fea:	81 ff       	sbrs	r24, 1
     fec:	0b c0       	rjmp	.+22     	; 0x1004 <hal_i2c_release+0x1e>
     fee:	e0 91 9d 6e 	lds	r30, 0x6E9D	; 0x806e9d <Wire+0x8>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:165
    _data->_module->MCTRLA      = 0x00;
     ff2:	f0 91 9e 6e 	lds	r31, 0x6E9E	; 0x806e9e <Wire+0x9>
     ff6:	13 82       	std	Z+3, r1	; 0x03
     ff8:	16 82       	std	Z+6, r1	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:166
    _data->_module->MBAUD       = 0x00;
     ffa:	80 91 9f 6e 	lds	r24, 0x6E9F	; 0x806e9f <Wire+0xa>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:167
    _data->_bools._hostEnabled  = 0x00;
     ffe:	8d 7f       	andi	r24, 0xFD	; 253
    1000:	80 93 9f 6e 	sts	0x6E9F, r24	; 0x806e9f <Wire+0xa>
TWI_DisableSlave():
    1004:	80 91 9f 6e 	lds	r24, 0x6E9F	; 0x806e9f <Wire+0xa>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:180
 *@param      struct twiData *_data is a pointer to the structure that holds the Wire variables
 *
 *@return     void
 */
void TWI_DisableSlave(struct twiData *_data) {
  if (true == _data->_bools._clientEnabled) {
    1008:	82 ff       	sbrs	r24, 2
    100a:	0d c0       	rjmp	.+26     	; 0x1026 <hal_i2c_release+0x40>
    100c:	e0 91 9d 6e 	lds	r30, 0x6E9D	; 0x806e9d <Wire+0x8>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:181
    _data->_module->SADDR        = 0x00;
    1010:	f0 91 9e 6e 	lds	r31, 0x6E9E	; 0x806e9e <Wire+0x9>
    1014:	14 86       	std	Z+12, r1	; 0x0c
    1016:	11 86       	std	Z+9, r1	; 0x09
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:182
    _data->_module->SCTRLA       = 0x00;
    1018:	16 86       	std	Z+14, r1	; 0x0e
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:183
    _data->_module->SADDRMASK    = 0x00;
    101a:	80 91 9f 6e 	lds	r24, 0x6E9F	; 0x806e9f <Wire+0xa>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:184
    _data->_bools._clientEnabled = 0x00;
    101e:	8b 7f       	andi	r24, 0xFB	; 251
    1020:	80 93 9f 6e 	sts	0x6E9F, r24	; 0x806e9f <Wire+0xa>
    1024:	11 82       	std	Z+1, r1	; 0x01
hal_i2c_release():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:186
    #if defined(TWI_DUALCTRL)
      _data->_module->DUALCTRL   = 0x00;    // Disable pin splitting when available
    1026:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:98
}

ATCA_STATUS hal_i2c_release(void* hal_data) {
    WIRE.end();
    return ATCA_SUCCESS;
}
    1028:	80 e0       	ldi	r24, 0x00	; 0
    102a:	08 95       	ret

0000102c <hal_i2c_control>:
hal_i2c_control():
    102c:	85 ef       	ldi	r24, 0xF5	; 245
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:93
}

ATCA_STATUS
hal_i2c_control(ATCAIface iface, uint8_t option, void* param, size_t paramlen) {
    return ATCA_UNIMPLEMENTED;
}
    102e:	90 e0       	ldi	r25, 0x00	; 0
    1030:	08 95       	ret

00001032 <hal_i2c_receive>:
hal_i2c_receive():
    1032:	cf 92       	push	r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:71
}

ATCA_STATUS hal_i2c_receive(ATCAIface iface,
                            uint8_t word_address,
                            uint8_t* rxdata,
                            uint16_t* rxlength) {
    1034:	df 92       	push	r13
    1036:	ef 92       	push	r14
    1038:	ff 92       	push	r15
    103a:	0f 93       	push	r16
    103c:	1f 93       	push	r17
    103e:	cf 93       	push	r28
    1040:	df 93       	push	r29
    1042:	8a 01       	movw	r16, r20
    1044:	e9 01       	movw	r28, r18
    1046:	58 81       	ld	r21, Y
requestFrom():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:73

    *rxlength = WIRE.requestFrom(word_address, (size_t)(*rxlength));
    1048:	66 0f       	add	r22, r22
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:455
 */
twi_buffer_index_t TwoWire::requestFrom(uint8_t  address,  twi_buffer_index_t quantity,  uint8_t sendStop) {
  if (quantity >= BUFFER_LENGTH) {
    quantity = BUFFER_LENGTH;
  }
  vars._clientAddress = address << 1;
    104a:	60 93 a1 6e 	sts	0x6EA1, r22	; 0x806ea1 <Wire+0xc>
TWI_MasterRead():
    104e:	10 92 a4 6e 	sts	0x6EA4, r1	; 0x806ea4 <Wire+0xf>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:411
    rxHead   = &(_data->_bytesToRead);
    rxTail   = &(_data->_bytesRead);
    rxBuffer =   _data->_rxBuffer;
  #endif

  (*rxTail) = 0;                      // Reset counter
    1052:	e0 91 9d 6e 	lds	r30, 0x6E9D	; 0x806e9d <Wire+0x8>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:413

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
    1056:	f0 91 9e 6e 	lds	r31, 0x6E9E	; 0x806e9e <Wire+0x9>
    105a:	85 81       	ldd	r24, Z+5	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:419
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  twi_buffer_index_t dataRead = 0;

  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    105c:	83 70       	andi	r24, 0x03	; 3
    105e:	09 f4       	brne	.+2      	; 0x1062 <hal_i2c_receive+0x30>
    1060:	52 c0       	rjmp	.+164    	; 0x1106 <hal_i2c_receive+0xd4>
    1062:	61 60       	ori	r22, 0x01	; 1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:427
    uint8_t command  = 0;
    #if defined (TWI_TIMEOUT_ENABLE)
      uint16_t timeout = 0;
    #endif

    module->MADDR = ADD_READ_BIT(_data->_clientAddress);  // Send Address with read bit
    1064:	67 83       	std	Z+7, r22	; 0x07
hal_i2c_receive():
    1066:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:424
  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
    #if defined (TWI_TIMEOUT_ENABLE)
      uint16_t timeout = 0;
    1068:	20 e0       	ldi	r18, 0x00	; 0
    106a:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:422
  twi_buffer_index_t dataRead = 0;

  if ((module->MSTATUS & TWI_BUSSTATE_gm) != TWI_BUSSTATE_UNKNOWN_gc) {
    uint8_t currentSM;
    uint8_t currentStatus;
    uint8_t command  = 0;
    106c:	80 e0       	ldi	r24, 0x00	; 0
TWI_MasterRead():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:417

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  twi_buffer_index_t dataRead = 0;
    106e:	72 e0       	ldi	r23, 0x02	; 2
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:470
            #if defined (TWI_TIMEOUT_ENABLE)
              timeout = 0;                           // reset timeout
            #endif

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
    1070:	45 81       	ldd	r20, Z+5	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:430
    #endif

    module->MADDR = ADD_READ_BIT(_data->_clientAddress);  // Send Address with read bit

    while (true) {
      currentStatus = module->MSTATUS;
    1072:	64 2f       	mov	r22, r20
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:431
      currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
    1074:	63 70       	andi	r22, 0x03	; 3
    1076:	2f 5f       	subi	r18, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:434

      #if defined(TWI_TIMEOUT_ENABLE)
        if (++timeout > (F_CPU/1000)) {
    1078:	3f 4f       	sbci	r19, 0xFF	; 255
    107a:	21 3c       	cpi	r18, 0xC1	; 193
    107c:	ad e5       	ldi	r26, 0x5D	; 93
    107e:	3a 07       	cpc	r19, r26
    1080:	20 f4       	brcc	.+8      	; 0x108a <hal_i2c_receive+0x58>
    1082:	43 ff       	sbrs	r20, 3
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:446
          }
          break;
        }
      #endif

      if (currentStatus & TWI_ARBLOST_bm) {   // Check for Bus error
    1084:	1e c0       	rjmp	.+60     	; 0x10c2 <hal_i2c_receive+0x90>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:447
        module->MSTATUS = TWI_ARBLOST_bm;     // reset error flags
    1086:	98 e0       	ldi	r25, 0x08	; 8
    1088:	95 83       	std	Z+5, r25	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:489
          TWIR_SET_ERROR(TWI_ERR_RXACK);          // set error flag
          command = TWI_MCMD_STOP_gc;             // free the bus
        }
      }
    }
    (*rxHead) = dataRead;
    108a:	80 93 a3 6e 	sts	0x6EA3, r24	; 0x806ea3 <Wire+0xe>
hal_i2c_receive():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:73
    108e:	90 e0       	ldi	r25, 0x00	; 0
    1090:	88 83       	st	Y, r24
    1092:	99 83       	std	Y+1, r25	; 0x01
    1094:	78 01       	movw	r14, r16
    1096:	67 01       	movw	r12, r14
    1098:	c0 1a       	sub	r12, r16
    109a:	d1 0a       	sbc	r13, r17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:78

    int value;
    size_t i = 0;

    while (i < *rxlength) {
    109c:	88 81       	ld	r24, Y
    109e:	99 81       	ldd	r25, Y+1	; 0x01
    10a0:	c8 16       	cp	r12, r24
    10a2:	d9 06       	cpc	r13, r25
    10a4:	90 f5       	brcc	.+100    	; 0x110a <hal_i2c_receive+0xd8>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:79
        value = WIRE.read();
    10a6:	85 e9       	ldi	r24, 0x95	; 149
    10a8:	9e e6       	ldi	r25, 0x6E	; 110
    10aa:	66 dc       	rcall	.-1844   	; 0x978 <TwoWire::read()>
    10ac:	8f 3f       	cpi	r24, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:81

        if (value != -1) {
    10ae:	98 07       	cpc	r25, r24
    10b0:	a9 f3       	breq	.-22     	; 0x109c <hal_i2c_receive+0x6a>
    10b2:	f7 01       	movw	r30, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:82
            rxdata[i] = (uint8_t)value;
    10b4:	81 93       	st	Z+, r24
    10b6:	7f 01       	movw	r14, r30
    10b8:	ee cf       	rjmp	.-36     	; 0x1096 <hal_i2c_receive+0x64>
    10ba:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:466
        if (currentStatus & TWI_RIF_bm) {         // data received
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
            dataRead++;                              // increment read counter
            #if defined (TWI_TIMEOUT_ENABLE)
              timeout = 0;                           // reset timeout
    10bc:	20 e0       	ldi	r18, 0x00	; 0
    10be:	97 e0       	ldi	r25, 0x07	; 7
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:473

            if (dataRead < bytesToRead) {            // expecting more bytes, so
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
            } else {                                 // Otherwise,
              if (send_stop != 0) {
                command = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
    10c0:	d7 cf       	rjmp	.-82     	; 0x1070 <hal_i2c_receive+0x3e>
TWI_MasterRead():
    10c2:	99 23       	and	r25, r25
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:452
        module->MSTATUS = TWI_ARBLOST_bm;     // reset error flags
        TWIR_SET_ERROR(TWI_ERR_BUS_ARB);      // set error flag
        break;                                // leave TX loop
      }

      if (command != 0) {
    10c4:	c1 f0       	breq	.+48     	; 0x10f6 <hal_i2c_receive+0xc4>
    10c6:	62 30       	cpi	r22, 0x02	; 2
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:453
        if (currentSM == TWI_BUSSTATE_OWNER_gc) {
    10c8:	01 f7       	brne	.-64     	; 0x108a <hal_i2c_receive+0x58>
    10ca:	94 83       	std	Z+4, r25	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:454
          module->MCTRLB = command;
    10cc:	47 ff       	sbrs	r20, 7
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:461
          break;
        }
      }

      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
        if (currentStatus & TWI_RIF_bm) {         // data received
    10ce:	17 c0       	rjmp	.+46     	; 0x10fe <hal_i2c_receive+0xcc>
    10d0:	82 38       	cpi	r24, 0x82	; 130
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:462
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
    10d2:	a8 f7       	brcc	.-22     	; 0x10be <hal_i2c_receive+0x8c>
    10d4:	20 85       	ldd	r18, Z+8	; 0x08
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:463
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
    10d6:	a8 2f       	mov	r26, r24
    10d8:	b0 e0       	ldi	r27, 0x00	; 0
    10da:	a4 5d       	subi	r26, 0xD4	; 212
    10dc:	b0 49       	sbci	r27, 0x90	; 144
    10de:	2c 93       	st	X, r18
    10e0:	8f 5f       	subi	r24, 0xFF	; 255
hal_i2c_receive():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:464
            dataRead++;                              // increment read counter
    10e2:	25 2f       	mov	r18, r21
TWI_MasterRead():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:73
ATCA_STATUS hal_i2c_receive(ATCAIface iface,
                            uint8_t word_address,
                            uint8_t* rxdata,
                            uint16_t* rxlength) {

    *rxlength = WIRE.requestFrom(word_address, (size_t)(*rxlength));
    10e4:	53 38       	cpi	r21, 0x83	; 131
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:469
            #if defined (TWI_TIMEOUT_ENABLE)
              timeout = 0;                           // reset timeout
            #endif

            if (dataRead < bytesToRead) {            // expecting more bytes, so
    10e6:	08 f0       	brcs	.+2      	; 0x10ea <hal_i2c_receive+0xb8>
    10e8:	22 e8       	ldi	r18, 0x82	; 130
    10ea:	82 17       	cp	r24, r18
    10ec:	30 f7       	brcc	.-52     	; 0x10ba <hal_i2c_receive+0x88>
    10ee:	74 83       	std	Z+4, r23	; 0x04
hal_i2c_receive():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:470
              module->MCTRLB = TWI_MCMD_RECVTRANS_gc;  // send an ACK so the Slave so it can send the next byte
    10f0:	30 e0       	ldi	r19, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:466
        if (currentStatus & TWI_RIF_bm) {         // data received
          if (dataRead < BUFFER_LENGTH) {          // Buffer still free
            rxBuffer[dataRead] = module->MDATA;      // save byte in the Buffer.
            dataRead++;                              // increment read counter
            #if defined (TWI_TIMEOUT_ENABLE)
              timeout = 0;                           // reset timeout
    10f2:	20 e0       	ldi	r18, 0x00	; 0
    10f4:	bd cf       	rjmp	.-134    	; 0x1070 <hal_i2c_receive+0x3e>
TWI_MasterRead():
    10f6:	62 30       	cpi	r22, 0x02	; 2
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:460
        } else {
          break;
        }
      }

      if (currentSM == TWI_BUSSTATE_OWNER_gc) {  // Address sent, check for WIF/RIF
    10f8:	09 f0       	breq	.+2      	; 0x10fc <hal_i2c_receive+0xca>
    10fa:	ba cf       	rjmp	.-140    	; 0x1070 <hal_i2c_receive+0x3e>
    10fc:	e7 cf       	rjmp	.-50     	; 0x10cc <hal_i2c_receive+0x9a>
    10fe:	46 ff       	sbrs	r20, 6
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:483

          } else {                                        // Buffer overflow with the incoming byte
            TWIR_SET_ERROR(TWI_ERR_BUF_OVERFLOW);         // Set Error and
            command = TWI_ACKACT_bm | TWI_MCMD_STOP_gc;   // send STOP + NACK
          }
        } else if (currentStatus & TWI_WIF_bm) {  // Address NACKed
    1100:	b7 cf       	rjmp	.-146    	; 0x1070 <hal_i2c_receive+0x3e>
hal_i2c_receive():
    1102:	93 e0       	ldi	r25, 0x03	; 3
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:485
          TWIR_SET_ERROR(TWI_ERR_RXACK);          // set error flag
          command = TWI_MCMD_STOP_gc;             // free the bus
    1104:	b5 cf       	rjmp	.-150    	; 0x1070 <hal_i2c_receive+0x3e>
    1106:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:417

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, using a local variable fixes that

  TWIR_INIT_ERROR;             // local variable for errors
  twi_buffer_index_t dataRead = 0;
    1108:	c2 cf       	rjmp	.-124    	; 0x108e <hal_i2c_receive+0x5c>
    110a:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:88
            i++;
        }
    }

    return ATCA_SUCCESS;
}
    110c:	80 e0       	ldi	r24, 0x00	; 0
    110e:	df 91       	pop	r29
    1110:	cf 91       	pop	r28
    1112:	1f 91       	pop	r17
    1114:	0f 91       	pop	r16
    1116:	ff 90       	pop	r15
    1118:	ef 90       	pop	r14
    111a:	df 90       	pop	r13
    111c:	cf 90       	pop	r12
    111e:	08 95       	ret

00001120 <hal_i2c_post_init>:
hal_i2c_post_init():
    1120:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:37
    WIRE.begin();

    return ATCA_SUCCESS;
}

ATCA_STATUS hal_i2c_post_init(ATCAIface iface) { return ATCA_SUCCESS; }
    1122:	80 e0       	ldi	r24, 0x00	; 0
    1124:	08 95       	ret

00001126 <atCRC>:
atCRC():
    1126:	1f 93       	push	r17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:681
 * \param[in]  data    Pointer to the data over which to compute the CRC
 * \param[out] crc_le  Pointer to the place where the two-bytes of CRC will be
 *                     returned in little-endian byte order.
 */
void atCRC(size_t length, const uint8_t *data, uint8_t *crc_le)
{
    1128:	cf 93       	push	r28
    112a:	df 93       	push	r29
    112c:	da 01       	movw	r26, r20
    112e:	fb 01       	movw	r30, r22
    1130:	eb 01       	movw	r28, r22
    1132:	c8 0f       	add	r28, r24
    1134:	d9 1f       	adc	r29, r25
    1136:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:683
    size_t counter;
    uint16_t crc_register = 0;
    1138:	20 e0       	ldi	r18, 0x00	; 0
    113a:	ce 17       	cp	r28, r30
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:688
    uint16_t polynom = 0x8005;
    uint8_t shift_register;
    uint8_t data_bit, crc_bit;

    for (counter = 0; counter < length; counter++)
    113c:	df 07       	cpc	r29, r31
    113e:	39 f4       	brne	.+14     	; 0x114e <atCRC+0x28>
    1140:	2c 93       	st	X, r18
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:701
            {
                crc_register ^= polynom;
            }
        }
    }
    crc_le[0] = (uint8_t)(crc_register & 0x00FF);
    1142:	11 96       	adiw	r26, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:702
    crc_le[1] = (uint8_t)(crc_register >> 8);
    1144:	3c 93       	st	X, r19
    1146:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:703
}
    1148:	cf 91       	pop	r28
    114a:	1f 91       	pop	r17
    114c:	08 95       	ret
    114e:	81 91       	ld	r24, Z+
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:692

    for (counter = 0; counter < length; counter++)
    {
        for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1)
        {
            data_bit = (data[counter] & shift_register) ? 1 : 0;
    1150:	68 e0       	ldi	r22, 0x08	; 8
    1152:	70 e0       	ldi	r23, 0x00	; 0
    1154:	91 e0       	ldi	r25, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:690
    uint8_t shift_register;
    uint8_t data_bit, crc_bit;

    for (counter = 0; counter < length; counter++)
    {
        for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1)
    1156:	13 2f       	mov	r17, r19
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:693
        {
            data_bit = (data[counter] & shift_register) ? 1 : 0;
            crc_bit = crc_register >> 15;
    1158:	11 1f       	adc	r17, r17
    115a:	11 27       	eor	r17, r17
    115c:	11 1f       	adc	r17, r17
    115e:	22 0f       	add	r18, r18
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:694
            crc_register <<= 1;
    1160:	33 1f       	adc	r19, r19
    1162:	41 e0       	ldi	r20, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:692

    for (counter = 0; counter < length; counter++)
    {
        for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1)
        {
            data_bit = (data[counter] & shift_register) ? 1 : 0;
    1164:	58 2f       	mov	r21, r24
    1166:	59 23       	and	r21, r25
    1168:	09 f4       	brne	.+2      	; 0x116c <atCRC+0x46>
    116a:	40 e0       	ldi	r20, 0x00	; 0
    116c:	41 17       	cp	r20, r17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:695
            crc_bit = crc_register >> 15;
            crc_register <<= 1;
            if (data_bit != crc_bit)
    116e:	19 f0       	breq	.+6      	; 0x1176 <atCRC+0x50>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:697
            {
                crc_register ^= polynom;
    1170:	45 e0       	ldi	r20, 0x05	; 5
    1172:	24 27       	eor	r18, r20
    1174:	30 58       	subi	r19, 0x80	; 128
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:690
    uint8_t shift_register;
    uint8_t data_bit, crc_bit;

    for (counter = 0; counter < length; counter++)
    {
        for (shift_register = 0x01; shift_register > 0x00; shift_register <<= 1)
    1176:	99 0f       	add	r25, r25
    1178:	61 50       	subi	r22, 0x01	; 1
    117a:	71 09       	sbc	r23, r1
    117c:	61 f7       	brne	.-40     	; 0x1156 <atCRC+0x30>
    117e:	dd cf       	rjmp	.-70     	; 0x113a <atCRC+0x14>

00001180 <atCalcCrc>:
atCalcCrc():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:718

    packet->param2 = ATCA_UINT16_HOST_TO_LE(packet->param2);

    length = packet->txsize - ATCA_CRC_SIZE;
    // computer pointer to CRC in the packet
    crc = &(packet->txsize) + length;
    1180:	bc 01       	movw	r22, r24
    1182:	6f 5f       	subi	r22, 0xFF	; 255
    1184:	7f 4f       	sbci	r23, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:716
{
    uint8_t length, *crc;

    packet->param2 = ATCA_UINT16_HOST_TO_LE(packet->param2);

    length = packet->txsize - ATCA_CRC_SIZE;
    1186:	fc 01       	movw	r30, r24
    1188:	81 81       	ldd	r24, Z+1	; 0x01
    118a:	82 50       	subi	r24, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:718
    // computer pointer to CRC in the packet
    crc = &(packet->txsize) + length;
    118c:	90 e0       	ldi	r25, 0x00	; 0
    118e:	ab 01       	movw	r20, r22
    1190:	48 0f       	add	r20, r24
    1192:	59 1f       	adc	r21, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:721

    // stuff CRC into packet
    atCRC(length, &(packet->txsize), crc);
    1194:	c8 cf       	rjmp	.-112    	; 0x1126 <atCRC>

00001196 <atca_iface_is_swi>:
atca_iface_is_swi():
    1196:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:375
 */
bool atca_iface_is_swi(ATCAIface ca_iface)
{
    bool ret = false;

    if (ca_iface && ca_iface->mIfaceCFG)
    1198:	71 f0       	breq	.+28     	; 0x11b6 <atca_iface_is_swi+0x20>
    119a:	dc 01       	movw	r26, r24
    119c:	ed 91       	ld	r30, X+
    119e:	fc 91       	ld	r31, X
    11a0:	30 97       	sbiw	r30, 0x00	; 0
    11a2:	49 f0       	breq	.+18     	; 0x11b6 <atca_iface_is_swi+0x20>
    11a4:	20 81       	ld	r18, Z
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:377
    {
        if (ATCA_SWI_IFACE == ca_iface->mIfaceCFG->iface_type || ATCA_SWI_GPIO_IFACE == ca_iface->mIfaceCFG->iface_type)
    11a6:	31 81       	ldd	r19, Z+1	; 0x01
    11a8:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:379
        {
            ret = true;
    11aa:	21 30       	cpi	r18, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:377
{
    bool ret = false;

    if (ca_iface && ca_iface->mIfaceCFG)
    {
        if (ATCA_SWI_IFACE == ca_iface->mIfaceCFG->iface_type || ATCA_SWI_GPIO_IFACE == ca_iface->mIfaceCFG->iface_type)
    11ac:	31 05       	cpc	r19, r1
    11ae:	29 f0       	breq	.+10     	; 0x11ba <atca_iface_is_swi+0x24>
    11b0:	28 30       	cpi	r18, 0x08	; 8
    11b2:	31 05       	cpc	r19, r1
    11b4:	11 f0       	breq	.+4      	; 0x11ba <atca_iface_is_swi+0x24>
    11b6:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:373
/** \brief Check if the given interface is configured as a SWI
 * \return true if the interface is considered a kit
 */
bool atca_iface_is_swi(ATCAIface ca_iface)
{
    bool ret = false;
    11b8:	08 95       	ret
    11ba:	08 95       	ret

000011bc <atca_iface_is_kit>:
atca_iface_is_kit():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:383
        {
            ret = true;
        }
    }
    return ret;
}
    11bc:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:357
 */
bool atca_iface_is_kit(ATCAIface ca_iface)
{
    bool ret = false;

    if (ca_iface && ca_iface->mIfaceCFG)
    11be:	79 f0       	breq	.+30     	; 0x11de <atca_iface_is_kit+0x22>
    11c0:	dc 01       	movw	r26, r24
    11c2:	ed 91       	ld	r30, X+
    11c4:	fc 91       	ld	r31, X
    11c6:	30 97       	sbiw	r30, 0x00	; 0
    11c8:	51 f0       	breq	.+20     	; 0x11de <atca_iface_is_kit+0x22>
    11ca:	20 81       	ld	r18, Z
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:359
    {
        if (ATCA_HID_IFACE == ca_iface->mIfaceCFG->iface_type || ATCA_KIT_IFACE == ca_iface->mIfaceCFG->iface_type
    11cc:	31 81       	ldd	r19, Z+1	; 0x01
    11ce:	c9 01       	movw	r24, r18
    11d0:	04 97       	sbiw	r24, 0x04	; 4
    11d2:	02 97       	sbiw	r24, 0x02	; 2
    11d4:	30 f0       	brcs	.+12     	; 0x11e2 <atca_iface_is_kit+0x26>
    11d6:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:360
            || ATCA_UART_IFACE == ca_iface->mIfaceCFG->iface_type)
    11d8:	22 30       	cpi	r18, 0x02	; 2
    11da:	31 05       	cpc	r19, r1
    11dc:	19 f0       	breq	.+6      	; 0x11e4 <atca_iface_is_kit+0x28>
    11de:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:355
 * transactions are atomic
 * \return true if the interface is considered a kit
 */
bool atca_iface_is_kit(ATCAIface ca_iface)
{
    bool ret = false;
    11e0:	08 95       	ret
    11e2:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:362
    if (ca_iface && ca_iface->mIfaceCFG)
    {
        if (ATCA_HID_IFACE == ca_iface->mIfaceCFG->iface_type || ATCA_KIT_IFACE == ca_iface->mIfaceCFG->iface_type
            || ATCA_UART_IFACE == ca_iface->mIfaceCFG->iface_type)
        {
            ret = true;
    11e4:	08 95       	ret

000011e6 <atcontrol>:
atcontrol():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:366
        }
    }
    return ret;
}
    11e6:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:209
 * \param[in]     paramlen       Length of the parameter
 * \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS atcontrol(ATCAIface ca_iface, uint8_t option, void* param, size_t paramlen)
{
    if (!ca_iface)
    11e8:	61 f0       	breq	.+24     	; 0x1202 <atcontrol+0x1c>
    11ea:	dc 01       	movw	r26, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:215
    {
        return ATCA_BAD_PARAM;
    }


    if (ca_iface->hal && ca_iface->hal->halcontrol)
    11ec:	12 96       	adiw	r26, 0x02	; 2
    11ee:	ed 91       	ld	r30, X+
    11f0:	fc 91       	ld	r31, X
    11f2:	30 97       	sbiw	r30, 0x00	; 0
    11f4:	49 f0       	breq	.+18     	; 0x1208 <atcontrol+0x22>
    11f6:	00 84       	ldd	r0, Z+8	; 0x08
    11f8:	f1 85       	ldd	r31, Z+9	; 0x09
    11fa:	e0 2d       	mov	r30, r0
    11fc:	30 97       	sbiw	r30, 0x00	; 0
    11fe:	21 f0       	breq	.+8      	; 0x1208 <atcontrol+0x22>
    1200:	09 94       	ijmp
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:217
    {
        return ca_iface->hal->halcontrol(ca_iface, option, param, paramlen);
    1202:	82 ee       	ldi	r24, 0xE2	; 226
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:211
 */
ATCA_STATUS atcontrol(ATCAIface ca_iface, uint8_t option, void* param, size_t paramlen)
{
    if (!ca_iface)
    {
        return ATCA_BAD_PARAM;
    1204:	90 e0       	ldi	r25, 0x00	; 0
    1206:	08 95       	ret
    1208:	8d ef       	ldi	r24, 0xFD	; 253
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:221
    {
        return ca_iface->hal->halcontrol(ca_iface, option, param, paramlen);
    }
    else
    {
        return ATCA_NOT_INITIALIZED;
    120a:	90 e0       	ldi	r25, 0x00	; 0
    120c:	08 95       	ret

0000120e <atreceive>:
atreceive():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:223
    }
}
    120e:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:184
 *                               As output, the number of bytes received.
 * \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS atreceive(ATCAIface ca_iface, uint8_t word_address, uint8_t *rxdata, uint16_t *rxlength)
{
    if (!ca_iface)
    1210:	61 f0       	breq	.+24     	; 0x122a <atreceive+0x1c>
    1212:	dc 01       	movw	r26, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:189
    {
        return ATCA_BAD_PARAM;
    }

    if (ca_iface->hal && ca_iface->hal->halreceive)
    1214:	12 96       	adiw	r26, 0x02	; 2
    1216:	ed 91       	ld	r30, X+
    1218:	fc 91       	ld	r31, X
    121a:	30 97       	sbiw	r30, 0x00	; 0
    121c:	49 f0       	breq	.+18     	; 0x1230 <atreceive+0x22>
    121e:	06 80       	ldd	r0, Z+6	; 0x06
    1220:	f7 81       	ldd	r31, Z+7	; 0x07
    1222:	e0 2d       	mov	r30, r0
    1224:	30 97       	sbiw	r30, 0x00	; 0
    1226:	21 f0       	breq	.+8      	; 0x1230 <atreceive+0x22>
    1228:	09 94       	ijmp
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:191
    {
        return ca_iface->hal->halreceive(ca_iface, word_address, rxdata, rxlength);
    122a:	82 ee       	ldi	r24, 0xE2	; 226
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:186
 */
ATCA_STATUS atreceive(ATCAIface ca_iface, uint8_t word_address, uint8_t *rxdata, uint16_t *rxlength)
{
    if (!ca_iface)
    {
        return ATCA_BAD_PARAM;
    122c:	90 e0       	ldi	r25, 0x00	; 0
    122e:	08 95       	ret
    1230:	8d ef       	ldi	r24, 0xFD	; 253
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:195
    {
        return ca_iface->hal->halreceive(ca_iface, word_address, rxdata, rxlength);
    }
    else
    {
        return ATCA_NOT_INITIALIZED;
    1232:	90 e0       	ldi	r25, 0x00	; 0
    1234:	08 95       	ret

00001236 <atsend>:
atsend():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:197
    }
}
    1236:	cf 93       	push	r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:146
 * \param[in] txdata         Data to be transmitted to the device.
 * \param[in] txlength       Number of bytes to be transmitted to the device.
 * \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS atsend(ATCAIface ca_iface, uint8_t address, uint8_t *txdata, int txlength)
{
    1238:	df 93       	push	r29
    123a:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:147
    if (!ca_iface)
    123c:	d9 f0       	breq	.+54     	; 0x1274 <atsend+0x3e>
    123e:	dc 01       	movw	r26, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:152
    {
        return ATCA_BAD_PARAM;
    }

    if (ca_iface->hal && ca_iface->hal->halsend)
    1240:	12 96       	adiw	r26, 0x02	; 2
    1242:	ed 91       	ld	r30, X+
    1244:	fc 91       	ld	r31, X
    1246:	13 97       	sbiw	r26, 0x03	; 3
    1248:	30 97       	sbiw	r30, 0x00	; 0
    124a:	c9 f0       	breq	.+50     	; 0x127e <atsend+0x48>
    124c:	04 80       	ldd	r0, Z+4	; 0x04
    124e:	f5 81       	ldd	r31, Z+5	; 0x05
    1250:	e0 2d       	mov	r30, r0
    1252:	30 97       	sbiw	r30, 0x00	; 0
    1254:	a1 f0       	breq	.+40     	; 0x127e <atsend+0x48>
    1256:	0d 90       	ld	r0, X+
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:155
    {
#ifdef ATCA_HAL_I2C
        if (ATCA_I2C_IFACE == ca_iface->mIfaceCFG->iface_type && 0xFF == address)
    1258:	bc 91       	ld	r27, X
    125a:	a0 2d       	mov	r26, r0
    125c:	cd 91       	ld	r28, X+
    125e:	dc 91       	ld	r29, X
    1260:	11 97       	sbiw	r26, 0x01	; 1
    1262:	cd 2b       	or	r28, r29
    1264:	21 f4       	brne	.+8      	; 0x126e <atsend+0x38>
    1266:	6f 3f       	cpi	r22, 0xFF	; 255
    1268:	11 f4       	brne	.+4      	; 0x126e <atsend+0x38>
    126a:	14 96       	adiw	r26, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:160
        {
#ifdef ATCA_ENABLE_DEPRECATED
            address = ATCA_IFACECFG_VALUE(ca_iface->mIfaceCFG, atcai2c.slave_address);
#else
            address = ATCA_IFACECFG_VALUE(ca_iface->mIfaceCFG, atcai2c.address);
    126c:	6c 91       	ld	r22, X
    126e:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:171
    }
    else
    {
        return ATCA_NOT_INITIALIZED;
    }
}
    1270:	cf 91       	pop	r28
    1272:	09 94       	ijmp
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:165
            address = ATCA_IFACECFG_VALUE(ca_iface->mIfaceCFG, atcai2c.address);
#endif
        }
#endif

        return ca_iface->hal->halsend(ca_iface, address, txdata, txlength);
    1274:	82 ee       	ldi	r24, 0xE2	; 226
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:149
 */
ATCA_STATUS atsend(ATCAIface ca_iface, uint8_t address, uint8_t *txdata, int txlength)
{
    if (!ca_iface)
    {
        return ATCA_BAD_PARAM;
    1276:	90 e0       	ldi	r25, 0x00	; 0
    1278:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:171
    }
    else
    {
        return ATCA_NOT_INITIALIZED;
    }
}
    127a:	cf 91       	pop	r28
    127c:	08 95       	ret
    127e:	8d ef       	ldi	r24, 0xFD	; 253
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:169

        return ca_iface->hal->halsend(ca_iface, address, txdata, txlength);
    }
    else
    {
        return ATCA_NOT_INITIALIZED;
    1280:	90 e0       	ldi	r25, 0x00	; 0
    1282:	fa cf       	rjmp	.-12     	; 0x1278 <atsend+0x42>

00001284 <atcab_get_device_address>:
atcab_get_device_address():
    1284:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:234
 * and interface
 * \return the device address if applicable else 0xFF
 */
uint8_t atcab_get_device_address(ATCADevice device)
{
    if (device && device->mIface.mIfaceCFG)
    1286:	59 f0       	breq	.+22     	; 0x129e <atcab_get_device_address+0x1a>
    1288:	dc 01       	movw	r26, r24
    128a:	ed 91       	ld	r30, X+
    128c:	fc 91       	ld	r31, X
    128e:	30 97       	sbiw	r30, 0x00	; 0
    1290:	31 f0       	breq	.+12     	; 0x129e <atcab_get_device_address+0x1a>
    1292:	80 81       	ld	r24, Z
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:236
    {
        switch (device->mIface.mIfaceCFG->iface_type)
    1294:	91 81       	ldd	r25, Z+1	; 0x01
    1296:	89 2b       	or	r24, r25
    1298:	11 f4       	brne	.+4      	; 0x129e <atcab_get_device_address+0x1a>
    129a:	84 81       	ldd	r24, Z+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:242
        {
        case ATCA_I2C_IFACE:
#ifdef ATCA_ENABLE_DEPRECATED
            return ATCA_IFACECFG_VALUE(device->mIface.mIfaceCFG, atcai2c.slave_address);
#else
            return ATCA_IFACECFG_VALUE(device->mIface.mIfaceCFG, atcai2c.address);
    129c:	08 95       	ret
    129e:	8f ef       	ldi	r24, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:248
#endif
        default:
            break;
        }
    }
    return 0xFF;
    12a0:	08 95       	ret

000012a2 <atcab_get_device_type_ext>:
atcab_get_device_type_ext():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:249
}
    12a2:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:213
 */
ATCADeviceType atcab_get_device_type_ext(ATCADevice device)
{
    ATCADeviceType ret = ATCA_DEV_UNKNOWN;

    if (device && device->mIface.mIfaceCFG)
    12a4:	41 f0       	breq	.+16     	; 0x12b6 <atcab_get_device_type_ext+0x14>
    12a6:	dc 01       	movw	r26, r24
    12a8:	ed 91       	ld	r30, X+
    12aa:	fc 91       	ld	r31, X
    12ac:	30 97       	sbiw	r30, 0x00	; 0
    12ae:	19 f0       	breq	.+6      	; 0x12b6 <atcab_get_device_type_ext+0x14>
    12b0:	82 81       	ldd	r24, Z+2	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:215
    {
        ret = device->mIface.mIfaceCFG->devtype;
    12b2:	93 81       	ldd	r25, Z+3	; 0x03
    12b4:	08 95       	ret
    12b6:	8e e7       	ldi	r24, 0x7E	; 126
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:211
 *  \param[in]  device      Device context pointer
 *  \return Device type if basic api is initialized or ATCA_DEV_UNKNOWN.
 */
ATCADeviceType atcab_get_device_type_ext(ATCADevice device)
{
    ATCADeviceType ret = ATCA_DEV_UNKNOWN;
    12b8:	90 e0       	ldi	r25, 0x00	; 0
    12ba:	08 95       	ret

000012bc <iotcl_discovery_free_sync_response.part.1>:
iotcl_discovery_free_sync_response.part.1():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:218
    if (device && device->mIface.mIfaceCFG)
    {
        ret = device->mIface.mIfaceCFG->devtype;
    }
    return ret;
}
    12bc:	cf 93       	push	r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:189
    // we have duplicated strings, so we can now free the result
    cJSON_Delete(sync_json_root);
    return response;
}

void iotcl_discovery_free_sync_response(IotclSyncResponse *response) {
    12be:	df 93       	push	r29
    12c0:	ec 01       	movw	r28, r24
    12c2:	8a 81       	ldd	r24, Y+2	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:193
    if (!response) {
        return;
    }
    free(response->cpid);
    12c4:	9b 81       	ldd	r25, Y+3	; 0x03
    12c6:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    12ca:	8c 81       	ldd	r24, Y+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:194
    free(response->dtg);
    12cc:	9d 81       	ldd	r25, Y+5	; 0x05
    12ce:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    12d2:	88 89       	ldd	r24, Y+16	; 0x10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:195
    free(response->broker.host);
    12d4:	99 89       	ldd	r25, Y+17	; 0x11
    12d6:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    12da:	8c 85       	ldd	r24, Y+12	; 0x0c
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:196
    free(response->broker.client_id);
    12dc:	9d 85       	ldd	r25, Y+13	; 0x0d
    12de:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    12e2:	8a 89       	ldd	r24, Y+18	; 0x12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:197
    free(response->broker.user_name);
    12e4:	9b 89       	ldd	r25, Y+19	; 0x13
    12e6:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    12ea:	8c 89       	ldd	r24, Y+20	; 0x14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:198
    free(response->broker.pass);
    12ec:	9d 89       	ldd	r25, Y+21	; 0x15
    12ee:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    12f2:	8e 85       	ldd	r24, Y+14	; 0x0e
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:199
    free(response->broker.name);
    12f4:	9f 85       	ldd	r25, Y+15	; 0x0f
    12f6:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    12fa:	88 8d       	ldd	r24, Y+24	; 0x18
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:200
    free(response->broker.sub_topic);
    12fc:	99 8d       	ldd	r25, Y+25	; 0x19
    12fe:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    1302:	8e 89       	ldd	r24, Y+22	; 0x16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:201
    free(response->broker.pub_topic);
    1304:	9f 89       	ldd	r25, Y+23	; 0x17
    1306:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    130a:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:202
    free(response);
    130c:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:203
}
    130e:	cf 91       	pop	r28
    1310:	0c 94 54 55 	jmp	0xaaa8	; 0xaaa8 <free>

00001314 <iotcl_discovery_free_discovery_response>:
iotcl_discovery_free_discovery_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:202
    free(response->broker.user_name);
    free(response->broker.pass);
    free(response->broker.name);
    free(response->broker.sub_topic);
    free(response->broker.pub_topic);
    free(response);
    1314:	cf 93       	push	r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:95
    cJSON_Delete(json_root);
    iotcl_discovery_free_discovery_response(response);
    return NULL;
}

void iotcl_discovery_free_discovery_response(IotclDiscoveryResponse *response) {
    1316:	df 93       	push	r29
    1318:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:96
    if (response) {
    131a:	91 f0       	breq	.+36     	; 0x1340 <iotcl_discovery_free_discovery_response+0x2c>
    131c:	ec 01       	movw	r28, r24
    131e:	88 81       	ld	r24, Y
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:97
        free(response->url);
    1320:	99 81       	ldd	r25, Y+1	; 0x01
    1322:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    1326:	8a 81       	ldd	r24, Y+2	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:98
        free(response->host);
    1328:	9b 81       	ldd	r25, Y+3	; 0x03
    132a:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    132e:	8c 81       	ldd	r24, Y+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:99
        free(response->path);
    1330:	9d 81       	ldd	r25, Y+5	; 0x05
    1332:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    1336:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:100
        free(response);
    1338:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:102
    }
}
    133a:	cf 91       	pop	r28
    133c:	0c 94 54 55 	jmp	0xaaa8	; 0xaaa8 <free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:100
void iotcl_discovery_free_discovery_response(IotclDiscoveryResponse *response) {
    if (response) {
        free(response->url);
        free(response->host);
        free(response->path);
        free(response);
    1340:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:102
    }
}
    1342:	cf 91       	pop	r28
    1344:	08 95       	ret

00001346 <update_offset>:
update_offset():
    1346:	cf 93       	push	r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:526
    return newbuffer + p->offset;
}

/* calculate the new length of the string in a printbuffer and update the offset */
static void update_offset(printbuffer * const buffer)
{
    1348:	df 93       	push	r29
    134a:	ec 01       	movw	r28, r24
    134c:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:528
    const unsigned char *buffer_pointer = NULL;
    if ((buffer == NULL) || (buffer->buffer == NULL))
    134e:	99 f0       	breq	.+38     	; 0x1376 <update_offset+0x30>
    1350:	a8 81       	ld	r26, Y
    1352:	b9 81       	ldd	r27, Y+1	; 0x01
    1354:	10 97       	sbiw	r26, 0x00	; 0
    1356:	79 f0       	breq	.+30     	; 0x1376 <update_offset+0x30>
    1358:	8c 81       	ldd	r24, Y+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:532
    {
        return;
    }
    buffer_pointer = buffer->buffer + buffer->offset;
    135a:	9d 81       	ldd	r25, Y+5	; 0x05
    135c:	a8 0f       	add	r26, r24
    135e:	b9 1f       	adc	r27, r25
    1360:	fd 01       	movw	r30, r26
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:534

    buffer->offset += strlen((const char*)buffer_pointer);
    1362:	01 90       	ld	r0, Z+
    1364:	00 20       	and	r0, r0
    1366:	e9 f7       	brne	.-6      	; 0x1362 <update_offset+0x1c>
    1368:	31 97       	sbiw	r30, 0x01	; 1
    136a:	ea 1b       	sub	r30, r26
    136c:	fb 0b       	sbc	r31, r27
    136e:	e8 0f       	add	r30, r24
    1370:	f9 1f       	adc	r31, r25
    1372:	ec 83       	std	Y+4, r30	; 0x04
    1374:	fd 83       	std	Y+5, r31	; 0x05
    1376:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:535
}
    1378:	cf 91       	pop	r28
    137a:	08 95       	ret

0000137c <String::String(char const*)>:
__base_ctor ():
    137c:	ef 92       	push	r14
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:30

/*********************************************/
/*  Constructors                             */
/*********************************************/

String::String(const char *cstr) {
    137e:	ff 92       	push	r15
    1380:	0f 93       	push	r16
    1382:	1f 93       	push	r17
    1384:	cf 93       	push	r28
    1386:	df 93       	push	r29
    1388:	ec 01       	movw	r28, r24
    138a:	7b 01       	movw	r14, r22
_ZN6String4initEv():
    138c:	18 82       	st	Y, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:122
/*********************************************/
/*  Memory Management                        */
/*********************************************/

inline void String::init(void) {
  buffer = NULL;
    138e:	19 82       	std	Y+1, r1	; 0x01
    1390:	1a 82       	std	Y+2, r1	; 0x02
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:123
  capacity = 0;
    1392:	1b 82       	std	Y+3, r1	; 0x03
    1394:	1c 82       	std	Y+4, r1	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:124
  len = 0;
    1396:	1d 82       	std	Y+5, r1	; 0x05
__base_ctor ():
    1398:	fb 01       	movw	r30, r22
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:33
/*********************************************/

String::String(const char *cstr) {
  init();
  if (cstr) {
    copy(cstr, strlen(cstr));
    139a:	01 90       	ld	r0, Z+
    139c:	00 20       	and	r0, r0
    139e:	e9 f7       	brne	.-6      	; 0x139a <String::String(char const*)+0x1e>
    13a0:	31 97       	sbiw	r30, 0x01	; 1
    13a2:	8f 01       	movw	r16, r30
    13a4:	06 1b       	sub	r16, r22
    13a6:	17 0b       	sbc	r17, r23
changeBuffer():
    13a8:	b8 01       	movw	r22, r16
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:149
  }
  return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen) {
  char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
    13aa:	6f 5f       	subi	r22, 0xFF	; 255
    13ac:	7f 4f       	sbci	r23, 0xFF	; 255
    13ae:	90 e0       	ldi	r25, 0x00	; 0
    13b0:	80 e0       	ldi	r24, 0x00	; 0
    13b2:	0e 94 dd 55 	call	0xabba	; 0xabba <realloc>
    13b6:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:150
  if (newbuffer) {
    13b8:	b9 f0       	breq	.+46     	; 0x13e8 <String::String(char const*)+0x6c>
    13ba:	88 83       	st	Y, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:151
    buffer = newbuffer;
    13bc:	99 83       	std	Y+1, r25	; 0x01
    13be:	0a 83       	std	Y+2, r16	; 0x02
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:152
    capacity = maxStrLen;
    13c0:	1b 83       	std	Y+3, r17	; 0x03
reserve():
    13c2:	2c 81       	ldd	r18, Y+4	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:140
unsigned char String::reserve(unsigned int size) {
  if (buffer && capacity >= size) {
    return 1;
  }
  if (changeBuffer(size)) {
    if (len == 0) {
    13c4:	3d 81       	ldd	r19, Y+5	; 0x05
    13c6:	23 2b       	or	r18, r19
    13c8:	11 f4       	brne	.+4      	; 0x13ce <String::String(char const*)+0x52>
    13ca:	fc 01       	movw	r30, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:141
      buffer[0] = 0;
    13cc:	10 82       	st	Z, r1
copy():
    13ce:	0c 83       	std	Y+4, r16	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:167
String &String::copy(const char *cstr, unsigned int length) {
  if (!reserve(length)) {
    invalidate();
    return *this;
  }
  len = length;
    13d0:	1d 83       	std	Y+5, r17	; 0x05
    13d2:	b7 01       	movw	r22, r14
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:168
  strcpy(buffer, cstr);
    13d4:	88 81       	ld	r24, Y
    13d6:	99 81       	ldd	r25, Y+1	; 0x01
__base_ctor ():
    13d8:	df 91       	pop	r29
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:35
String::String(const char *cstr) {
  init();
  if (cstr) {
    copy(cstr, strlen(cstr));
  }
}
    13da:	cf 91       	pop	r28
    13dc:	1f 91       	pop	r17
    13de:	0f 91       	pop	r16
    13e0:	ff 90       	pop	r15
    13e2:	ef 90       	pop	r14
copy():
    13e4:	0c 94 fd 56 	jmp	0xadfa	; 0xadfa <strcpy>
invalidate():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:168
  if (!reserve(length)) {
    invalidate();
    return *this;
  }
  len = length;
  strcpy(buffer, cstr);
    13e8:	88 81       	ld	r24, Y
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:128
  capacity = 0;
  len = 0;
}

void String::invalidate(void) {
  if (buffer) {
    13ea:	99 81       	ldd	r25, Y+1	; 0x01
    13ec:	00 97       	sbiw	r24, 0x00	; 0
    13ee:	11 f0       	breq	.+4      	; 0x13f4 <String::String(char const*)+0x78>
    13f0:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:129
    free(buffer);
    13f4:	18 82       	st	Y, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:131
  }
  buffer = NULL;
    13f6:	19 82       	std	Y+1, r1	; 0x01
    13f8:	1c 82       	std	Y+4, r1	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:132
  capacity = len = 0;
    13fa:	1d 82       	std	Y+5, r1	; 0x05
    13fc:	1a 82       	std	Y+2, r1	; 0x02
    13fe:	1b 82       	std	Y+3, r1	; 0x03
__base_ctor ():
    1400:	df 91       	pop	r29
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:35
String::String(const char *cstr) {
  init();
  if (cstr) {
    copy(cstr, strlen(cstr));
  }
}
    1402:	cf 91       	pop	r28
    1404:	1f 91       	pop	r17
    1406:	0f 91       	pop	r16
    1408:	ff 90       	pop	r15
    140a:	ef 90       	pop	r14
    140c:	08 95       	ret

0000140e <Print::printf(char const*, ...) [clone .constprop.129]>:
printf():
    140e:	cf 93       	push	r28
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.cpp:193
static int16_t printf_putchar(char c, FILE *fp) {
  ((class Print *)(fdev_get_udata(fp)))->write((uint8_t)c);
  return 0;
}

int16_t Print::printf(const char *format, ...) {
    1410:	df 93       	push	r29
    1412:	cd b7       	in	r28, 0x3d	; 61
    1414:	de b7       	in	r29, 0x3e	; 62
    1416:	2e 97       	sbiw	r28, 0x0e	; 14
    1418:	cd bf       	out	0x3d, r28	; 61
    141a:	de bf       	out	0x3e, r29	; 62
    141c:	8d ef       	ldi	r24, 0xFD	; 253
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.cpp:197
  FILE f;
  va_list ap;

  fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
    141e:	91 e0       	ldi	r25, 0x01	; 1
    1420:	89 87       	std	Y+9, r24	; 0x09
    1422:	9a 87       	std	Y+10, r25	; 0x0a
    1424:	1b 86       	std	Y+11, r1	; 0x0b
    1426:	1c 86       	std	Y+12, r1	; 0x0c
    1428:	82 e0       	ldi	r24, 0x02	; 2
    142a:	8c 83       	std	Y+4, r24	; 0x04
    142c:	8b 89       	ldd	r24, Y+19	; 0x13
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.cpp:198
  fdev_set_udata(&f, this);
    142e:	9c 89       	ldd	r25, Y+20	; 0x14
    1430:	8d 87       	std	Y+13, r24	; 0x0d
    1432:	9e 87       	std	Y+14, r25	; 0x0e
    1434:	ae 01       	movw	r20, r28
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.cpp:200
  va_start(ap, format);
  return vfprintf(&f, format, ap);
    1436:	49 5e       	subi	r20, 0xE9	; 233
    1438:	5f 4f       	sbci	r21, 0xFF	; 255
    143a:	6e e6       	ldi	r22, 0x6E	; 110
    143c:	7f e4       	ldi	r23, 0x4F	; 79
    143e:	ce 01       	movw	r24, r28
    1440:	01 96       	adiw	r24, 0x01	; 1
    1442:	0e 94 84 3a 	call	0x7508	; 0x7508 <vfprintf>
    1446:	2e 96       	adiw	r28, 0x0e	; 14
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/Print.cpp:201
}
    1448:	cd bf       	out	0x3d, r28	; 61
    144a:	de bf       	out	0x3e, r29	; 62
    144c:	df 91       	pop	r29
    144e:	cf 91       	pop	r28
    1450:	08 95       	ret

00001452 <LogClass::info(char const*) [clone .constprop.93]>:
info():
    1452:	20 91 6b 70 	lds	r18, 0x706B	; 0x80706b <Log+0x2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:71
void LogClass::begin(const uint32_t baud_rate) { this->uart->begin(baud_rate); }

void LogClass::end(void) { this->uart->end(); }

void LogClass::info(const char str[]) {
    if (log_level >= LogLevel::INFO) {
    1456:	30 91 6c 70 	lds	r19, 0x706C	; 0x80706c <Log+0x3>
    145a:	23 30       	cpi	r18, 0x03	; 3
    145c:	31 05       	cpc	r19, r1
    145e:	b4 f0       	brlt	.+44     	; 0x148c <LogClass::info(char const*) [clone .constprop.93]+0x3a>
print():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:30
    ((class Print*)(fdev_get_udata(fp)))->write((uint8_t)c);
    return 0;
}

void LogClass::print(const char* str, const char level[]) {
    this->uart->printf("%s%s\r\n", level, str);
    1460:	9f 93       	push	r25
    1462:	8f 93       	push	r24
    1464:	83 ef       	ldi	r24, 0xF3	; 243
    1466:	92 e4       	ldi	r25, 0x42	; 66
    1468:	9f 93       	push	r25
    146a:	8f 93       	push	r24
    146c:	8e e6       	ldi	r24, 0x6E	; 110
    146e:	9f e4       	ldi	r25, 0x4F	; 79
    1470:	9f 93       	push	r25
    1472:	8f 93       	push	r24
    1474:	80 91 6a 70 	lds	r24, 0x706A	; 0x80706a <Log+0x1>
    1478:	8f 93       	push	r24
    147a:	80 91 69 70 	lds	r24, 0x7069	; 0x807069 <Log>
    147e:	8f 93       	push	r24
    1480:	c6 df       	rcall	.-116    	; 0x140e <Print::printf(char const*, ...) [clone .constprop.129]>
    1482:	8d b7       	in	r24, 0x3d	; 61
    1484:	9e b7       	in	r25, 0x3e	; 62
    1486:	08 96       	adiw	r24, 0x08	; 8
    1488:	8d bf       	out	0x3d, r24	; 61
    148a:	9e bf       	out	0x3e, r25	; 62
info():
    148c:	08 95       	ret

0000148e <LogClass::error(char const*) [clone .constprop.127]>:
error():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:74

void LogClass::info(const char str[]) {
    if (log_level >= LogLevel::INFO) {
        this->print(str, INFO_LEVEL_FMT);
    }
}
    148e:	20 91 6b 70 	lds	r18, 0x706B	; 0x80706b <Log+0x2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:140
    vfprintf(&f, format, ap);
    va_end(ap);
}

void LogClass::error(const char str[]) {
    if (log_level >= LogLevel::ERROR) {
    1492:	30 91 6c 70 	lds	r19, 0x706C	; 0x80706c <Log+0x3>
    1496:	12 16       	cp	r1, r18
    1498:	13 06       	cpc	r1, r19
    149a:	b4 f4       	brge	.+44     	; 0x14c8 <LogClass::error(char const*) [clone .constprop.127]+0x3a>
print():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:30
    ((class Print*)(fdev_get_udata(fp)))->write((uint8_t)c);
    return 0;
}

void LogClass::print(const char* str, const char level[]) {
    this->uart->printf("%s%s\r\n", level, str);
    149c:	9f 93       	push	r25
    149e:	8f 93       	push	r24
    14a0:	8b ef       	ldi	r24, 0xFB	; 251
    14a2:	92 e4       	ldi	r25, 0x42	; 66
    14a4:	9f 93       	push	r25
    14a6:	8f 93       	push	r24
    14a8:	8e e6       	ldi	r24, 0x6E	; 110
    14aa:	9f e4       	ldi	r25, 0x4F	; 79
    14ac:	9f 93       	push	r25
    14ae:	8f 93       	push	r24
    14b0:	80 91 6a 70 	lds	r24, 0x706A	; 0x80706a <Log+0x1>
    14b4:	8f 93       	push	r24
    14b6:	80 91 69 70 	lds	r24, 0x7069	; 0x807069 <Log>
    14ba:	8f 93       	push	r24
    14bc:	a8 df       	rcall	.-176    	; 0x140e <Print::printf(char const*, ...) [clone .constprop.129]>
    14be:	8d b7       	in	r24, 0x3d	; 61
    14c0:	9e b7       	in	r25, 0x3e	; 62
    14c2:	08 96       	adiw	r24, 0x08	; 8
    14c4:	8d bf       	out	0x3d, r24	; 61
    14c6:	9e bf       	out	0x3e, r25	; 62
error():
    14c8:	08 95       	ret

000014ca <iotc_ecc608_get_string_value_internal(ecc_data_types, char**)>:
iotc_ecc608_get_string_value_internal():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:143

void LogClass::error(const char str[]) {
    if (log_level >= LogLevel::ERROR) {
        this->print(str, ERR_LEVEL_FMT);
    }
}
    14ca:	ac 01       	movw	r20, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:106
    start = append_iotconnect_blank_record(start, IOTC_ECC608_PROV_ENV,  IOTC_ECC608_PROV_ENV_SIZE);
    start->header.type = EMPTY;
    start->header.next = 0;
}

static ATCA_STATUS iotc_ecc608_get_string_value_internal(ecc_data_types data_type, char ** value) {
    14cc:	db 01       	movw	r26, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:108
    DataHeaderUnion* h = (DataHeaderUnion *) data_cache;
    *value = NULL;
    14ce:	1d 92       	st	X+, r1
    14d0:	1c 92       	st	X, r1
    14d2:	06 97       	sbiw	r24, 0x06	; 6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:109
    switch (data_type) {
    14d4:	04 97       	sbiw	r24, 0x04	; 4
    14d6:	c8 f4       	brcc	.+50     	; 0x150a <iotc_ecc608_get_string_value_internal(ecc_data_types, char**)+0x40>
    14d8:	e4 e5       	ldi	r30, 0x54	; 84
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:107
    start->header.type = EMPTY;
    start->header.next = 0;
}

static ATCA_STATUS iotc_ecc608_get_string_value_internal(ecc_data_types data_type, char ** value) {
    DataHeaderUnion* h = (DataHeaderUnion *) data_cache;
    14da:	f4 e6       	ldi	r31, 0x64	; 100
    14dc:	91 81       	ldd	r25, Z+1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:114
    switch (data_type) {
        case IOTC_ECC608_PROV_VER:
        case IOTC_ECC608_PROV_ENV:
        case IOTC_ECC608_PROV_CPID:
        case IOTC_ECC608_PROV_DUID:
            while(h->header.type != EMPTY) {
    14de:	89 2f       	mov	r24, r25
    14e0:	8e 7f       	andi	r24, 0xFE	; 254
    14e2:	c9 f0       	breq	.+50     	; 0x1516 <iotc_ecc608_get_string_value_internal(ecc_data_types, char**)+0x4c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:115
                if (h->header.type == data_type) {
    14e4:	89 2f       	mov	r24, r25
    14e6:	86 95       	lsr	r24
    14e8:	84 17       	cp	r24, r20
    14ea:	15 06       	cpc	r1, r21
    14ec:	39 f4       	brne	.+14     	; 0x14fc <iotc_ecc608_get_string_value_internal(ecc_data_types, char**)+0x32>
ecchdr_data_ptr():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:85
    }
    return (DataHeaderUnion*) &data_cache[h->header.next];
}

static char* ecchdr_data_ptr(DataHeaderUnion* h) {
    return ((char*)h) + sizeof(DataHeaderUnion);
    14ee:	32 96       	adiw	r30, 0x02	; 2
iotc_ecc608_get_string_value_internal():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:116
        case IOTC_ECC608_PROV_ENV:
        case IOTC_ECC608_PROV_CPID:
        case IOTC_ECC608_PROV_DUID:
            while(h->header.type != EMPTY) {
                if (h->header.type == data_type) {
                    *value = ecchdr_data_ptr(h);
    14f0:	db 01       	movw	r26, r22
    14f2:	ed 93       	st	X+, r30
    14f4:	fc 93       	st	X, r31
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:117
                    return ATCA_SUCCESS;
    14f6:	90 e0       	ldi	r25, 0x00	; 0
    14f8:	80 e0       	ldi	r24, 0x00	; 0
    14fa:	08 95       	ret
ecchdr_next():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:81

static DataHeaderUnion* ecchdr_next(DataHeaderUnion* h) {
    if (!h) {
        return (DataHeaderUnion*) data_cache;
    }
    return (DataHeaderUnion*) &data_cache[h->header.next];
    14fc:	20 81       	ld	r18, Z
    14fe:	39 2f       	mov	r19, r25
    1500:	31 70       	andi	r19, 0x01	; 1
    1502:	f9 01       	movw	r30, r18
    1504:	ec 5a       	subi	r30, 0xAC	; 172
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:124
                h = ecchdr_next(h);
            }
            return ATCA_INVALID_ID;

        default:
            Log.error("IOTC_ECC608: Only IOTCONNECT data types are supported. Use copy_string_value instead.");
    1506:	fb 49       	sbci	r31, 0x9B	; 155
    1508:	e9 cf       	rjmp	.-46     	; 0x14dc <iotc_ecc608_get_string_value_internal(ecc_data_types, char**)+0x12>
iotc_ecc608_get_string_value_internal():
    150a:	84 e0       	ldi	r24, 0x04	; 4
    150c:	93 e4       	ldi	r25, 0x43	; 67
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:125
            return ATCA_BAD_PARAM;
    150e:	bf df       	rcall	.-130    	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    1510:	82 ee       	ldi	r24, 0xE2	; 226
    1512:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:121
                    *value = ecchdr_data_ptr(h);
                    return ATCA_SUCCESS;
                }
                h = ecchdr_next(h);
            }
            return ATCA_INVALID_ID;
    1514:	08 95       	ret
    1516:	83 ee       	ldi	r24, 0xE3	; 227
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:127

        default:
            Log.error("IOTC_ECC608: Only IOTCONNECT data types are supported. Use copy_string_value instead.");
            return ATCA_BAD_PARAM;
    }
}
    1518:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:27
static char aws_id_buff[AWS_ID_BUFF_SIZE];
static bool connecteded_to_network = false;

static void on_connection_status(IotConnectConnectionStatus status) {
    // Add your own status handling
    switch (status) {
    151a:	08 95       	ret

0000151c <on_connection_status(IotConnectConnectionStatus)>:
on_connection_status():
    151c:	81 30       	cpi	r24, 0x01	; 1
    151e:	91 05       	cpc	r25, r1
    1520:	29 f0       	breq	.+10     	; 0x152c <on_connection_status(IotConnectConnectionStatus)+0x10>
    1522:	02 97       	sbiw	r24, 0x02	; 2
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:35
            break;
        case IOTC_CS_MQTT_DISCONNECTED:
            Log.info("IoTConnect Client Disconnected");
            break;
        default:
            Log.error("IoTConnect Client ERROR");
    1524:	31 f0       	breq	.+12     	; 0x1532 <on_connection_status(IotConnectConnectionStatus)+0x16>
    1526:	85 e9       	ldi	r24, 0x95	; 149
    1528:	93 e4       	ldi	r25, 0x43	; 67
    152a:	b1 cf       	rjmp	.-158    	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:29

static void on_connection_status(IotConnectConnectionStatus status) {
    // Add your own status handling
    switch (status) {
        case IOTC_CS_MQTT_CONNECTED:
            Log.info("IoTConnect Client Connected");
    152c:	8a e5       	ldi	r24, 0x5A	; 90
    152e:	93 e4       	ldi	r25, 0x43	; 67
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:32
            break;
        case IOTC_CS_MQTT_DISCONNECTED:
            Log.info("IoTConnect Client Disconnected");
    1530:	90 cf       	rjmp	.-224    	; 0x1452 <LogClass::info(char const*) [clone .constprop.93]>
    1532:	86 e7       	ldi	r24, 0x76	; 118
    1534:	93 e4       	ldi	r25, 0x43	; 67
    1536:	fc cf       	rjmp	.-8      	; 0x1530 <on_connection_status(IotConnectConnectionStatus)+0x14>

00001538 <LogClass::warn(char const*) [clone .constprop.124]>:
warn():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:166
        va_end(ap);
    }
}

void LogClass::warn(const char str[]) {
    if (log_level >= LogLevel::WARN) {
    1538:	20 91 6b 70 	lds	r18, 0x706B	; 0x80706b <Log+0x2>
    153c:	30 91 6c 70 	lds	r19, 0x706C	; 0x80706c <Log+0x3>
    1540:	22 30       	cpi	r18, 0x02	; 2
    1542:	31 05       	cpc	r19, r1
    1544:	b4 f0       	brlt	.+44     	; 0x1572 <LogClass::warn(char const*) [clone .constprop.124]+0x3a>
print():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:30
    ((class Print*)(fdev_get_udata(fp)))->write((uint8_t)c);
    return 0;
}

void LogClass::print(const char* str, const char level[]) {
    this->uart->printf("%s%s\r\n", level, str);
    1546:	9f 93       	push	r25
    1548:	8f 93       	push	r24
    154a:	8d ea       	ldi	r24, 0xAD	; 173
    154c:	93 e4       	ldi	r25, 0x43	; 67
    154e:	9f 93       	push	r25
    1550:	8f 93       	push	r24
    1552:	8e e6       	ldi	r24, 0x6E	; 110
    1554:	9f e4       	ldi	r25, 0x4F	; 79
    1556:	9f 93       	push	r25
    1558:	8f 93       	push	r24
    155a:	80 91 6a 70 	lds	r24, 0x706A	; 0x80706a <Log+0x1>
    155e:	8f 93       	push	r24
    1560:	80 91 69 70 	lds	r24, 0x7069	; 0x807069 <Log>
    1564:	8f 93       	push	r24
    1566:	53 df       	rcall	.-346    	; 0x140e <Print::printf(char const*, ...) [clone .constprop.129]>
    1568:	8d b7       	in	r24, 0x3d	; 61
    156a:	9e b7       	in	r25, 0x3e	; 62
    156c:	08 96       	adiw	r24, 0x08	; 8
    156e:	8d bf       	out	0x3d, r24	; 61
    1570:	9e bf       	out	0x3e, r25	; 62
warn():
    1572:	08 95       	ret

00001574 <LogClass::rawf(char const*, ...) [clone .constprop.102]>:
rawf():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:169

void LogClass::warn(const char str[]) {
    if (log_level >= LogLevel::WARN) {
        this->print(str, WARN_LEVEL_FMT);
    }
}
    1574:	cf 93       	push	r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:128

void LogClass::raw(const char str[]) { this->print(str, ""); }

void LogClass::raw(const String str) { this->raw(str.c_str()); }

void LogClass::rawf(const char* format, ...) {
    1576:	df 93       	push	r29
    1578:	cd b7       	in	r28, 0x3d	; 61
    157a:	de b7       	in	r29, 0x3e	; 62
    157c:	2e 97       	sbiw	r28, 0x0e	; 14
    157e:	cd bf       	out	0x3d, r28	; 61
    1580:	de bf       	out	0x3e, r29	; 62
    1582:	8e ee       	ldi	r24, 0xEE	; 238
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:132
    FILE f;
    va_list ap;

    fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
    1584:	91 e0       	ldi	r25, 0x01	; 1
    1586:	89 87       	std	Y+9, r24	; 0x09
    1588:	9a 87       	std	Y+10, r25	; 0x0a
    158a:	1b 86       	std	Y+11, r1	; 0x0b
    158c:	1c 86       	std	Y+12, r1	; 0x0c
    158e:	82 e0       	ldi	r24, 0x02	; 2
    1590:	8c 83       	std	Y+4, r24	; 0x04
    1592:	80 91 69 70 	lds	r24, 0x7069	; 0x807069 <Log>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:133
    fdev_set_udata(&f, this->uart);
    1596:	90 91 6a 70 	lds	r25, 0x706A	; 0x80706a <Log+0x1>
    159a:	8d 87       	std	Y+13, r24	; 0x0d
    159c:	9e 87       	std	Y+14, r25	; 0x0e
    159e:	ae 01       	movw	r20, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:135
    va_start(ap, format);
    vfprintf(&f, format, ap);
    15a0:	49 5e       	subi	r20, 0xE9	; 233
    15a2:	5f 4f       	sbci	r21, 0xFF	; 255
    15a4:	6d 89       	ldd	r22, Y+21	; 0x15
    15a6:	7e 89       	ldd	r23, Y+22	; 0x16
    15a8:	ce 01       	movw	r24, r28
    15aa:	01 96       	adiw	r24, 0x01	; 1
    15ac:	0e 94 84 3a 	call	0x7508	; 0x7508 <vfprintf>
    15b0:	2e 96       	adiw	r28, 0x0e	; 14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:137
    va_end(ap);
}
    15b2:	cd bf       	out	0x3d, r28	; 61
    15b4:	de bf       	out	0x3e, r29	; 62
    15b6:	df 91       	pop	r29
    15b8:	cf 91       	pop	r28
    15ba:	08 95       	ret

000015bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>:
errorf():
    15bc:	cf 92       	push	r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:147
    }
}

void LogClass::error(const String str) { this->error(str.c_str()); }

void LogClass::errorf(const char* format, ...) {
    15be:	df 92       	push	r13
    15c0:	ef 92       	push	r14
    15c2:	ff 92       	push	r15
    15c4:	0f 93       	push	r16
    15c6:	1f 93       	push	r17
    15c8:	cf 93       	push	r28
    15ca:	df 93       	push	r29
    15cc:	cd b7       	in	r28, 0x3d	; 61
    15ce:	de b7       	in	r29, 0x3e	; 62
    15d0:	2e 97       	sbiw	r28, 0x0e	; 14
    15d2:	cd bf       	out	0x3d, r28	; 61
    15d4:	de bf       	out	0x3e, r29	; 62
    15d6:	6b 8d       	ldd	r22, Y+27	; 0x1b
    15d8:	7c 8d       	ldd	r23, Y+28	; 0x1c
    15da:	ed b6       	in	r14, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:163
        fdev_set_udata(&f, this->uart);
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
    }
}
    15dc:	fe b6       	in	r15, 0x3e	; 62
    15de:	80 91 6b 70 	lds	r24, 0x706B	; 0x80706b <Log+0x2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:148
}

void LogClass::error(const String str) { this->error(str.c_str()); }

void LogClass::errorf(const char* format, ...) {
    if (log_level >= LogLevel::ERROR) {
    15e2:	90 91 6c 70 	lds	r25, 0x706C	; 0x80706c <Log+0x3>
    15e6:	18 16       	cp	r1, r24
    15e8:	19 06       	cpc	r1, r25
    15ea:	0c f0       	brlt	.+2      	; 0x15ee <LogClass::errorf(char const*, ...) [clone .constprop.133]+0x32>
    15ec:	42 c0       	rjmp	.+132    	; 0x1672 <LogClass::errorf(char const*, ...) [clone .constprop.133]+0xb6>
    15ee:	cd b6       	in	r12, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:161

        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
        fdev_set_udata(&f, this->uart);
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
    15f0:	de b6       	in	r13, 0x3e	; 62
    15f2:	fb 01       	movw	r30, r22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:151

void LogClass::errorf(const char* format, ...) {
    if (log_level >= LogLevel::ERROR) {

        // Append format with [ERROR]
        char nFormat[strlen(format) + sizeof(ERR_LEVEL_FMT)] = ERR_LEVEL_FMT;
    15f4:	01 90       	ld	r0, Z+
    15f6:	00 20       	and	r0, r0
    15f8:	e9 f7       	brne	.-6      	; 0x15f4 <LogClass::errorf(char const*, ...) [clone .constprop.133]+0x38>
    15fa:	cf 01       	movw	r24, r30
    15fc:	01 97       	sbiw	r24, 0x01	; 1
    15fe:	86 1b       	sub	r24, r22
    1600:	97 0b       	sbc	r25, r23
    1602:	9c 01       	movw	r18, r24
    1604:	27 5f       	subi	r18, 0xF7	; 247
    1606:	3f 4f       	sbci	r19, 0xFF	; 255
    1608:	4d b7       	in	r20, 0x3d	; 61
    160a:	5e b7       	in	r21, 0x3e	; 62
    160c:	42 1b       	sub	r20, r18
    160e:	53 0b       	sbc	r21, r19
    1610:	4d bf       	out	0x3d, r20	; 61
    1612:	5e bf       	out	0x3e, r21	; 62
    1614:	0d b7       	in	r16, 0x3d	; 61
    1616:	1e b7       	in	r17, 0x3e	; 62
    1618:	0f 5f       	subi	r16, 0xFF	; 255
    161a:	1f 4f       	sbci	r17, 0xFF	; 255
    161c:	29 e0       	ldi	r18, 0x09	; 9
    161e:	eb ef       	ldi	r30, 0xFB	; 251
    1620:	f2 e4       	ldi	r31, 0x42	; 66
    1622:	d8 01       	movw	r26, r16
    1624:	01 90       	ld	r0, Z+
    1626:	0d 92       	st	X+, r0
    1628:	2a 95       	dec	r18
    162a:	e1 f7       	brne	.-8      	; 0x1624 <LogClass::errorf(char const*, ...) [clone .constprop.133]+0x68>
    162c:	ed b7       	in	r30, 0x3d	; 61
    162e:	fe b7       	in	r31, 0x3e	; 62
    1630:	3a 96       	adiw	r30, 0x0a	; 10
    1632:	01 97       	sbiw	r24, 0x01	; 1
    1634:	10 f0       	brcs	.+4      	; 0x163a <LogClass::errorf(char const*, ...) [clone .constprop.133]+0x7e>
    1636:	11 92       	st	Z+, r1
    1638:	fc cf       	rjmp	.-8      	; 0x1632 <LogClass::errorf(char const*, ...) [clone .constprop.133]+0x76>
    163a:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:152
        strcpy(nFormat + sizeof(ERR_LEVEL_FMT) - 1, format);
    163c:	08 96       	adiw	r24, 0x08	; 8
    163e:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    1642:	8e ee       	ldi	r24, 0xEE	; 238
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:157

        FILE f;
        va_list ap;

        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
    1644:	91 e0       	ldi	r25, 0x01	; 1
    1646:	89 87       	std	Y+9, r24	; 0x09
    1648:	9a 87       	std	Y+10, r25	; 0x0a
    164a:	1b 86       	std	Y+11, r1	; 0x0b
    164c:	1c 86       	std	Y+12, r1	; 0x0c
    164e:	82 e0       	ldi	r24, 0x02	; 2
    1650:	8c 83       	std	Y+4, r24	; 0x04
    1652:	80 91 69 70 	lds	r24, 0x7069	; 0x807069 <Log>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:158
        fdev_set_udata(&f, this->uart);
    1656:	90 91 6a 70 	lds	r25, 0x706A	; 0x80706a <Log+0x1>
    165a:	8d 87       	std	Y+13, r24	; 0x0d
    165c:	9e 87       	std	Y+14, r25	; 0x0e
    165e:	ae 01       	movw	r20, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:160
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
    1660:	43 5e       	subi	r20, 0xE3	; 227
    1662:	5f 4f       	sbci	r21, 0xFF	; 255
    1664:	b8 01       	movw	r22, r16
    1666:	ce 01       	movw	r24, r28
    1668:	01 96       	adiw	r24, 0x01	; 1
    166a:	0e 94 84 3a 	call	0x7508	; 0x7508 <vfprintf>
    166e:	cd be       	out	0x3d, r12	; 61
    1670:	de be       	out	0x3e, r13	; 62
    1672:	ed be       	out	0x3d, r14	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:163
        va_end(ap);
    }
}
    1674:	fe be       	out	0x3e, r15	; 62
    1676:	2e 96       	adiw	r28, 0x0e	; 14
    1678:	cd bf       	out	0x3d, r28	; 61
    167a:	de bf       	out	0x3e, r29	; 62
    167c:	df 91       	pop	r29
    167e:	cf 91       	pop	r28
    1680:	1f 91       	pop	r17
    1682:	0f 91       	pop	r16
    1684:	ff 90       	pop	r15
    1686:	ef 90       	pop	r14
    1688:	df 90       	pop	r13
    168a:	cf 90       	pop	r12
    168c:	08 95       	ret

0000168e <LedCtrlClass::getLedPin(Led) [clone .constprop.132]>:
getLedPin():
    168e:	81 30       	cpi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/led_ctrl.cpp:51
    this->begin();
}

uint8_t LedCtrlClass::getLedPin(Led led) {
    uint8_t targetPin = 0;
    switch (led) {
    1690:	91 05       	cpc	r25, r1
    1692:	21 f0       	breq	.+8      	; 0x169c <LedCtrlClass::getLedPin(Led) [clone .constprop.132]+0xe>
    1694:	02 97       	sbiw	r24, 0x02	; 2
    1696:	21 f0       	breq	.+8      	; 0x16a0 <LedCtrlClass::getLedPin(Led) [clone .constprop.132]+0x12>
    1698:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/led_ctrl.cpp:53
    case Led::CELL:
        targetPin = LED_CELL_PIN;
    169a:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/led_ctrl.cpp:73
        Log.errorf("attempted to get invalid led pin %d\r\n", led);
        return 200;
    }

    return targetPin;
}
    169c:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/led_ctrl.cpp:56
    switch (led) {
    case Led::CELL:
        targetPin = LED_CELL_PIN;
        break;
    case Led::CON:
        targetPin = LED_CON_PIN;
    169e:	08 95       	ret
    16a0:	82 e0       	ldi	r24, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/led_ctrl.cpp:59
        break;
    case Led::DATA:
        targetPin = LED_DATA_PIN;
    16a2:	08 95       	ret

000016a4 <LogClass::debugf(char const*, ...) [clone .constprop.118]>:
debugf():
    16a4:	cf 92       	push	r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:105
    }
}

void LogClass::debug(const String str) { this->debug(str.c_str()); }

void LogClass::debugf(const char* format, ...) {
    16a6:	df 92       	push	r13
    16a8:	ef 92       	push	r14
    16aa:	ff 92       	push	r15
    16ac:	0f 93       	push	r16
    16ae:	1f 93       	push	r17
    16b0:	cf 93       	push	r28
    16b2:	df 93       	push	r29
    16b4:	cd b7       	in	r28, 0x3d	; 61
    16b6:	de b7       	in	r29, 0x3e	; 62
    16b8:	2e 97       	sbiw	r28, 0x0e	; 14
    16ba:	cd bf       	out	0x3d, r28	; 61
    16bc:	de bf       	out	0x3e, r29	; 62
    16be:	6b 8d       	ldd	r22, Y+27	; 0x1b
    16c0:	7c 8d       	ldd	r23, Y+28	; 0x1c
    16c2:	ed b6       	in	r14, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:122
        fdev_set_udata(&f, this->uart);
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
    }
}
    16c4:	fe b6       	in	r15, 0x3e	; 62
    16c6:	80 91 6b 70 	lds	r24, 0x706B	; 0x80706b <Log+0x2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:106
}

void LogClass::debug(const String str) { this->debug(str.c_str()); }

void LogClass::debugf(const char* format, ...) {
    if (log_level >= LogLevel::DEBUG) {
    16ca:	90 91 6c 70 	lds	r25, 0x706C	; 0x80706c <Log+0x3>
    16ce:	04 97       	sbiw	r24, 0x04	; 4
    16d0:	0c f4       	brge	.+2      	; 0x16d4 <LogClass::debugf(char const*, ...) [clone .constprop.118]+0x30>
    16d2:	42 c0       	rjmp	.+132    	; 0x1758 <LogClass::debugf(char const*, ...) [clone .constprop.118]+0xb4>
    16d4:	cd b6       	in	r12, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:120

        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
        fdev_set_udata(&f, this->uart);
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
    16d6:	de b6       	in	r13, 0x3e	; 62
    16d8:	fb 01       	movw	r30, r22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:109

void LogClass::debugf(const char* format, ...) {
    if (log_level >= LogLevel::DEBUG) {

        // Append format with [ERROR]
        char nFormat[strlen(format) + sizeof(DEBUG_LEVEL_FMT)] =
    16da:	01 90       	ld	r0, Z+
    16dc:	00 20       	and	r0, r0
    16de:	e9 f7       	brne	.-6      	; 0x16da <LogClass::debugf(char const*, ...) [clone .constprop.118]+0x36>
    16e0:	cf 01       	movw	r24, r30
    16e2:	01 97       	sbiw	r24, 0x01	; 1
    16e4:	86 1b       	sub	r24, r22
    16e6:	97 0b       	sbc	r25, r23
    16e8:	9c 01       	movw	r18, r24
    16ea:	27 5f       	subi	r18, 0xF7	; 247
    16ec:	3f 4f       	sbci	r19, 0xFF	; 255
    16ee:	4d b7       	in	r20, 0x3d	; 61
    16f0:	5e b7       	in	r21, 0x3e	; 62
    16f2:	42 1b       	sub	r20, r18
    16f4:	53 0b       	sbc	r21, r19
    16f6:	4d bf       	out	0x3d, r20	; 61
    16f8:	5e bf       	out	0x3e, r21	; 62
    16fa:	0d b7       	in	r16, 0x3d	; 61
    16fc:	1e b7       	in	r17, 0x3e	; 62
    16fe:	0f 5f       	subi	r16, 0xFF	; 255
    1700:	1f 4f       	sbci	r17, 0xFF	; 255
    1702:	29 e0       	ldi	r18, 0x09	; 9
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:110
            DEBUG_LEVEL_FMT;
    1704:	e5 eb       	ldi	r30, 0xB5	; 181
    1706:	f3 e4       	ldi	r31, 0x43	; 67
    1708:	d8 01       	movw	r26, r16
    170a:	01 90       	ld	r0, Z+
    170c:	0d 92       	st	X+, r0
    170e:	2a 95       	dec	r18
    1710:	e1 f7       	brne	.-8      	; 0x170a <LogClass::debugf(char const*, ...) [clone .constprop.118]+0x66>
    1712:	ed b7       	in	r30, 0x3d	; 61
    1714:	fe b7       	in	r31, 0x3e	; 62
    1716:	3a 96       	adiw	r30, 0x0a	; 10
    1718:	01 97       	sbiw	r24, 0x01	; 1
    171a:	10 f0       	brcs	.+4      	; 0x1720 <LogClass::debugf(char const*, ...) [clone .constprop.118]+0x7c>
    171c:	11 92       	st	Z+, r1
    171e:	fc cf       	rjmp	.-8      	; 0x1718 <LogClass::debugf(char const*, ...) [clone .constprop.118]+0x74>
    1720:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:111
        strcpy(nFormat + sizeof(DEBUG_LEVEL_FMT) - 1, format);
    1722:	08 96       	adiw	r24, 0x08	; 8
    1724:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    1728:	8e ee       	ldi	r24, 0xEE	; 238
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:116

        FILE f;
        va_list ap;

        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
    172a:	91 e0       	ldi	r25, 0x01	; 1
    172c:	89 87       	std	Y+9, r24	; 0x09
    172e:	9a 87       	std	Y+10, r25	; 0x0a
    1730:	1b 86       	std	Y+11, r1	; 0x0b
    1732:	1c 86       	std	Y+12, r1	; 0x0c
    1734:	82 e0       	ldi	r24, 0x02	; 2
    1736:	8c 83       	std	Y+4, r24	; 0x04
    1738:	80 91 69 70 	lds	r24, 0x7069	; 0x807069 <Log>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:117
        fdev_set_udata(&f, this->uart);
    173c:	90 91 6a 70 	lds	r25, 0x706A	; 0x80706a <Log+0x1>
    1740:	8d 87       	std	Y+13, r24	; 0x0d
    1742:	9e 87       	std	Y+14, r25	; 0x0e
    1744:	ae 01       	movw	r20, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:119
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
    1746:	43 5e       	subi	r20, 0xE3	; 227
    1748:	5f 4f       	sbci	r21, 0xFF	; 255
    174a:	b8 01       	movw	r22, r16
    174c:	ce 01       	movw	r24, r28
    174e:	01 96       	adiw	r24, 0x01	; 1
    1750:	0e 94 84 3a 	call	0x7508	; 0x7508 <vfprintf>
    1754:	cd be       	out	0x3d, r12	; 61
    1756:	de be       	out	0x3e, r13	; 62
    1758:	ed be       	out	0x3d, r14	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:122
        va_end(ap);
    }
}
    175a:	fe be       	out	0x3e, r15	; 62
    175c:	2e 96       	adiw	r28, 0x0e	; 14
    175e:	cd bf       	out	0x3d, r28	; 61
    1760:	de bf       	out	0x3e, r29	; 62
    1762:	df 91       	pop	r29
    1764:	cf 91       	pop	r28
    1766:	1f 91       	pop	r17
    1768:	0f 91       	pop	r16
    176a:	ff 90       	pop	r15
    176c:	ef 90       	pop	r14
    176e:	df 90       	pop	r13
    1770:	cf 90       	pop	r12
    1772:	08 95       	ret

00001774 <LogClass::warnf(char const*, ...) [clone .constprop.94]>:
warnf():
    1774:	cf 92       	push	r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:173
    }
}

void LogClass::warn(const String str) { this->warn(str.c_str()); }

void LogClass::warnf(const char* format, ...) {
    1776:	df 92       	push	r13
    1778:	ef 92       	push	r14
    177a:	ff 92       	push	r15
    177c:	0f 93       	push	r16
    177e:	1f 93       	push	r17
    1780:	cf 93       	push	r28
    1782:	df 93       	push	r29
    1784:	cd b7       	in	r28, 0x3d	; 61
    1786:	de b7       	in	r29, 0x3e	; 62
    1788:	2e 97       	sbiw	r28, 0x0e	; 14
    178a:	cd bf       	out	0x3d, r28	; 61
    178c:	de bf       	out	0x3e, r29	; 62
    178e:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1790:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1792:	ed b6       	in	r14, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:189
        fdev_set_udata(&f, this->uart);
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
    }
}
    1794:	fe b6       	in	r15, 0x3e	; 62
    1796:	80 91 6b 70 	lds	r24, 0x706B	; 0x80706b <Log+0x2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:174
}

void LogClass::warn(const String str) { this->warn(str.c_str()); }

void LogClass::warnf(const char* format, ...) {
    if (log_level >= LogLevel::WARN) {
    179a:	90 91 6c 70 	lds	r25, 0x706C	; 0x80706c <Log+0x3>
    179e:	02 97       	sbiw	r24, 0x02	; 2
    17a0:	0c f4       	brge	.+2      	; 0x17a4 <LogClass::warnf(char const*, ...) [clone .constprop.94]+0x30>
    17a2:	42 c0       	rjmp	.+132    	; 0x1828 <LogClass::warnf(char const*, ...) [clone .constprop.94]+0xb4>
    17a4:	cd b6       	in	r12, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:187

        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
        fdev_set_udata(&f, this->uart);
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
    17a6:	de b6       	in	r13, 0x3e	; 62
    17a8:	fb 01       	movw	r30, r22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:177

void LogClass::warnf(const char* format, ...) {
    if (log_level >= LogLevel::WARN) {

        // Append format with [ERROR]
        char nFormat[strlen(format) + sizeof(WARN_LEVEL_FMT)] = WARN_LEVEL_FMT;
    17aa:	01 90       	ld	r0, Z+
    17ac:	00 20       	and	r0, r0
    17ae:	e9 f7       	brne	.-6      	; 0x17aa <LogClass::warnf(char const*, ...) [clone .constprop.94]+0x36>
    17b0:	cf 01       	movw	r24, r30
    17b2:	01 97       	sbiw	r24, 0x01	; 1
    17b4:	86 1b       	sub	r24, r22
    17b6:	97 0b       	sbc	r25, r23
    17b8:	9c 01       	movw	r18, r24
    17ba:	28 5f       	subi	r18, 0xF8	; 248
    17bc:	3f 4f       	sbci	r19, 0xFF	; 255
    17be:	4d b7       	in	r20, 0x3d	; 61
    17c0:	5e b7       	in	r21, 0x3e	; 62
    17c2:	42 1b       	sub	r20, r18
    17c4:	53 0b       	sbc	r21, r19
    17c6:	4d bf       	out	0x3d, r20	; 61
    17c8:	5e bf       	out	0x3e, r21	; 62
    17ca:	0d b7       	in	r16, 0x3d	; 61
    17cc:	1e b7       	in	r17, 0x3e	; 62
    17ce:	0f 5f       	subi	r16, 0xFF	; 255
    17d0:	1f 4f       	sbci	r17, 0xFF	; 255
    17d2:	28 e0       	ldi	r18, 0x08	; 8
    17d4:	ed ea       	ldi	r30, 0xAD	; 173
    17d6:	f3 e4       	ldi	r31, 0x43	; 67
    17d8:	d8 01       	movw	r26, r16
    17da:	01 90       	ld	r0, Z+
    17dc:	0d 92       	st	X+, r0
    17de:	2a 95       	dec	r18
    17e0:	e1 f7       	brne	.-8      	; 0x17da <LogClass::warnf(char const*, ...) [clone .constprop.94]+0x66>
    17e2:	ed b7       	in	r30, 0x3d	; 61
    17e4:	fe b7       	in	r31, 0x3e	; 62
    17e6:	39 96       	adiw	r30, 0x09	; 9
    17e8:	01 97       	sbiw	r24, 0x01	; 1
    17ea:	10 f0       	brcs	.+4      	; 0x17f0 <LogClass::warnf(char const*, ...) [clone .constprop.94]+0x7c>
    17ec:	11 92       	st	Z+, r1
    17ee:	fc cf       	rjmp	.-8      	; 0x17e8 <LogClass::warnf(char const*, ...) [clone .constprop.94]+0x74>
    17f0:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:178
        strcpy(nFormat + sizeof(WARN_LEVEL_FMT) - 1, format);
    17f2:	07 96       	adiw	r24, 0x07	; 7
    17f4:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    17f8:	8e ee       	ldi	r24, 0xEE	; 238
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:183

        FILE f;
        va_list ap;

        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
    17fa:	91 e0       	ldi	r25, 0x01	; 1
    17fc:	89 87       	std	Y+9, r24	; 0x09
    17fe:	9a 87       	std	Y+10, r25	; 0x0a
    1800:	1b 86       	std	Y+11, r1	; 0x0b
    1802:	1c 86       	std	Y+12, r1	; 0x0c
    1804:	82 e0       	ldi	r24, 0x02	; 2
    1806:	8c 83       	std	Y+4, r24	; 0x04
    1808:	80 91 69 70 	lds	r24, 0x7069	; 0x807069 <Log>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:184
        fdev_set_udata(&f, this->uart);
    180c:	90 91 6a 70 	lds	r25, 0x706A	; 0x80706a <Log+0x1>
    1810:	8d 87       	std	Y+13, r24	; 0x0d
    1812:	9e 87       	std	Y+14, r25	; 0x0e
    1814:	ae 01       	movw	r20, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:186
        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
    1816:	43 5e       	subi	r20, 0xE3	; 227
    1818:	5f 4f       	sbci	r21, 0xFF	; 255
    181a:	b8 01       	movw	r22, r16
    181c:	ce 01       	movw	r24, r28
    181e:	01 96       	adiw	r24, 0x01	; 1
    1820:	0e 94 84 3a 	call	0x7508	; 0x7508 <vfprintf>
    1824:	cd be       	out	0x3d, r12	; 61
    1826:	de be       	out	0x3e, r13	; 62
    1828:	ed be       	out	0x3d, r14	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:189
        va_end(ap);
    }
}
    182a:	fe be       	out	0x3e, r15	; 62
    182c:	2e 96       	adiw	r28, 0x0e	; 14
    182e:	cd bf       	out	0x3d, r28	; 61
    1830:	de bf       	out	0x3e, r29	; 62
    1832:	df 91       	pop	r29
    1834:	cf 91       	pop	r28
    1836:	1f 91       	pop	r17
    1838:	0f 91       	pop	r16
    183a:	ff 90       	pop	r15
    183c:	ef 90       	pop	r14
    183e:	df 90       	pop	r13
    1840:	cf 90       	pop	r12
    1842:	08 95       	ret

00001844 <LogClass::infof(char const*, ...) [clone .constprop.90]>:
infof():
    1844:	cf 92       	push	r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:78
    }
}

void LogClass::info(const String str) { this->info(str.c_str()); }

void LogClass::infof(const char* format, ...) {
    1846:	df 92       	push	r13
    1848:	ef 92       	push	r14
    184a:	ff 92       	push	r15
    184c:	0f 93       	push	r16
    184e:	1f 93       	push	r17
    1850:	cf 93       	push	r28
    1852:	df 93       	push	r29
    1854:	cd b7       	in	r28, 0x3d	; 61
    1856:	de b7       	in	r29, 0x3e	; 62
    1858:	2e 97       	sbiw	r28, 0x0e	; 14
    185a:	cd bf       	out	0x3d, r28	; 61
    185c:	de bf       	out	0x3e, r29	; 62
    185e:	6b 8d       	ldd	r22, Y+27	; 0x1b
    1860:	7c 8d       	ldd	r23, Y+28	; 0x1c
    1862:	ed b6       	in	r14, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:95

        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
    }
}
    1864:	fe b6       	in	r15, 0x3e	; 62
    1866:	80 91 6b 70 	lds	r24, 0x706B	; 0x80706b <Log+0x2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:79
}

void LogClass::info(const String str) { this->info(str.c_str()); }

void LogClass::infof(const char* format, ...) {
    if (log_level >= LogLevel::INFO) {
    186a:	90 91 6c 70 	lds	r25, 0x706C	; 0x80706c <Log+0x3>
    186e:	03 97       	sbiw	r24, 0x03	; 3
    1870:	0c f4       	brge	.+2      	; 0x1874 <LogClass::infof(char const*, ...) [clone .constprop.90]+0x30>
    1872:	42 c0       	rjmp	.+132    	; 0x18f8 <LogClass::infof(char const*, ...) [clone .constprop.90]+0xb4>
    1874:	cd b6       	in	r12, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:93
        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
        fdev_set_udata(&f, this->uart);

        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
        va_end(ap);
    1876:	de b6       	in	r13, 0x3e	; 62
    1878:	fb 01       	movw	r30, r22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:82

void LogClass::infof(const char* format, ...) {
    if (log_level >= LogLevel::INFO) {

        // Append format with [ERROR]
        char nFormat[strlen(format) + sizeof(INFO_LEVEL_FMT)] = INFO_LEVEL_FMT;
    187a:	01 90       	ld	r0, Z+
    187c:	00 20       	and	r0, r0
    187e:	e9 f7       	brne	.-6      	; 0x187a <LogClass::infof(char const*, ...) [clone .constprop.90]+0x36>
    1880:	cf 01       	movw	r24, r30
    1882:	01 97       	sbiw	r24, 0x01	; 1
    1884:	86 1b       	sub	r24, r22
    1886:	97 0b       	sbc	r25, r23
    1888:	9c 01       	movw	r18, r24
    188a:	28 5f       	subi	r18, 0xF8	; 248
    188c:	3f 4f       	sbci	r19, 0xFF	; 255
    188e:	4d b7       	in	r20, 0x3d	; 61
    1890:	5e b7       	in	r21, 0x3e	; 62
    1892:	42 1b       	sub	r20, r18
    1894:	53 0b       	sbc	r21, r19
    1896:	4d bf       	out	0x3d, r20	; 61
    1898:	5e bf       	out	0x3e, r21	; 62
    189a:	0d b7       	in	r16, 0x3d	; 61
    189c:	1e b7       	in	r17, 0x3e	; 62
    189e:	0f 5f       	subi	r16, 0xFF	; 255
    18a0:	1f 4f       	sbci	r17, 0xFF	; 255
    18a2:	28 e0       	ldi	r18, 0x08	; 8
    18a4:	e3 ef       	ldi	r30, 0xF3	; 243
    18a6:	f2 e4       	ldi	r31, 0x42	; 66
    18a8:	d8 01       	movw	r26, r16
    18aa:	01 90       	ld	r0, Z+
    18ac:	0d 92       	st	X+, r0
    18ae:	2a 95       	dec	r18
    18b0:	e1 f7       	brne	.-8      	; 0x18aa <LogClass::infof(char const*, ...) [clone .constprop.90]+0x66>
    18b2:	ed b7       	in	r30, 0x3d	; 61
    18b4:	fe b7       	in	r31, 0x3e	; 62
    18b6:	39 96       	adiw	r30, 0x09	; 9
    18b8:	01 97       	sbiw	r24, 0x01	; 1
    18ba:	10 f0       	brcs	.+4      	; 0x18c0 <LogClass::infof(char const*, ...) [clone .constprop.90]+0x7c>
    18bc:	11 92       	st	Z+, r1
    18be:	fc cf       	rjmp	.-8      	; 0x18b8 <LogClass::infof(char const*, ...) [clone .constprop.90]+0x74>
    18c0:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:83
        strcpy(nFormat + sizeof(INFO_LEVEL_FMT) - 1, format);
    18c2:	07 96       	adiw	r24, 0x07	; 7
    18c4:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    18c8:	8e ee       	ldi	r24, 0xEE	; 238
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:88

        FILE f;
        va_list ap;

        fdev_setup_stream(&f, printf_putchar, NULL, _FDEV_SETUP_WRITE);
    18ca:	91 e0       	ldi	r25, 0x01	; 1
    18cc:	89 87       	std	Y+9, r24	; 0x09
    18ce:	9a 87       	std	Y+10, r25	; 0x0a
    18d0:	1b 86       	std	Y+11, r1	; 0x0b
    18d2:	1c 86       	std	Y+12, r1	; 0x0c
    18d4:	82 e0       	ldi	r24, 0x02	; 2
    18d6:	8c 83       	std	Y+4, r24	; 0x04
    18d8:	80 91 69 70 	lds	r24, 0x7069	; 0x807069 <Log>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:89
        fdev_set_udata(&f, this->uart);
    18dc:	90 91 6a 70 	lds	r25, 0x706A	; 0x80706a <Log+0x1>
    18e0:	8d 87       	std	Y+13, r24	; 0x0d
    18e2:	9e 87       	std	Y+14, r25	; 0x0e
    18e4:	ae 01       	movw	r20, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:92

        va_start(ap, nFormat);
        vfprintf(&f, nFormat, ap);
    18e6:	43 5e       	subi	r20, 0xE3	; 227
    18e8:	5f 4f       	sbci	r21, 0xFF	; 255
    18ea:	b8 01       	movw	r22, r16
    18ec:	ce 01       	movw	r24, r28
    18ee:	01 96       	adiw	r24, 0x01	; 1
    18f0:	0e 94 84 3a 	call	0x7508	; 0x7508 <vfprintf>
    18f4:	cd be       	out	0x3d, r12	; 61
    18f6:	de be       	out	0x3e, r13	; 62
    18f8:	ed be       	out	0x3d, r14	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:95
        va_end(ap);
    }
}
    18fa:	fe be       	out	0x3e, r15	; 62
    18fc:	2e 96       	adiw	r28, 0x0e	; 14
    18fe:	cd bf       	out	0x3d, r28	; 61
    1900:	de bf       	out	0x3e, r29	; 62
    1902:	df 91       	pop	r29
    1904:	cf 91       	pop	r28
    1906:	1f 91       	pop	r17
    1908:	0f 91       	pop	r16
    190a:	ff 90       	pop	r15
    190c:	ef 90       	pop	r14
    190e:	df 90       	pop	r13
    1910:	cf 90       	pop	r12
    1912:	08 95       	ret

00001914 <dump_response(char const*, IotConnectHttpResponse*)>:
dump_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:23

static IotclConfig lib_config = {0};
static IotConnectClientConfig config = {0};
static IotConnectMqttClientConfig mqtt_config = {0};

static void dump_response(const char *message, IotConnectHttpResponse *response) {
    1914:	0f 93       	push	r16
    1916:	1f 93       	push	r17
    1918:	cf 93       	push	r28
    191a:	df 93       	push	r29
    191c:	8b 01       	movw	r16, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:24
    Log.infof("%s", message);
    191e:	9f 93       	push	r25
    1920:	8f 93       	push	r24
    1922:	81 ea       	ldi	r24, 0xA1	; 161
    1924:	95 e4       	ldi	r25, 0x45	; 69
    1926:	9f 93       	push	r25
    1928:	8f 93       	push	r24
    192a:	c9 e6       	ldi	r28, 0x69	; 105
    192c:	d0 e7       	ldi	r29, 0x70	; 112
    192e:	df 93       	push	r29
    1930:	cf 93       	push	r28
    1932:	88 df       	rcall	.-240    	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:25
    if (response->data) {
    1934:	f8 01       	movw	r30, r16
    1936:	80 81       	ld	r24, Z
    1938:	91 81       	ldd	r25, Z+1	; 0x01
    193a:	0f 90       	pop	r0
    193c:	0f 90       	pop	r0
    193e:	0f 90       	pop	r0
    1940:	0f 90       	pop	r0
    1942:	0f 90       	pop	r0
    1944:	0f 90       	pop	r0
    1946:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:26
        Log.infof(" Response was:\r\n----\r\n%s\r\n----\r\n", response->data);
    1948:	a1 f0       	breq	.+40     	; 0x1972 <dump_response(char const*, IotConnectHttpResponse*)+0x5e>
    194a:	9f 93       	push	r25
    194c:	8f 93       	push	r24
    194e:	8e eb       	ldi	r24, 0xBE	; 190
    1950:	93 e4       	ldi	r25, 0x43	; 67
    1952:	9f 93       	push	r25
    1954:	8f 93       	push	r24
    1956:	df 93       	push	r29
    1958:	cf 93       	push	r28
    195a:	74 df       	rcall	.-280    	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
    195c:	0f 90       	pop	r0
    195e:	0f 90       	pop	r0
    1960:	0f 90       	pop	r0
    1962:	0f 90       	pop	r0
    1964:	0f 90       	pop	r0
    1966:	0f 90       	pop	r0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:30
    } else {
        Log.infof(" Response was empty\r\n");
    }
}
    1968:	df 91       	pop	r29
    196a:	cf 91       	pop	r28
    196c:	1f 91       	pop	r17
    196e:	0f 91       	pop	r16
    1970:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:28
static void dump_response(const char *message, IotConnectHttpResponse *response) {
    Log.infof("%s", message);
    if (response->data) {
        Log.infof(" Response was:\r\n----\r\n%s\r\n----\r\n", response->data);
    } else {
        Log.infof(" Response was empty\r\n");
    1972:	8f ed       	ldi	r24, 0xDF	; 223
    1974:	93 e4       	ldi	r25, 0x43	; 67
    1976:	9f 93       	push	r25
    1978:	8f 93       	push	r24
    197a:	df 93       	push	r29
    197c:	cf 93       	push	r28
    197e:	62 df       	rcall	.-316    	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
    1980:	0f 90       	pop	r0
    1982:	0f 90       	pop	r0
    1984:	0f 90       	pop	r0
    1986:	0f 90       	pop	r0
    1988:	ef cf       	rjmp	.-34     	; 0x1968 <dump_response(char const*, IotConnectHttpResponse*)+0x54>

0000198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>:
extractValueFromCommandResponse():
    198a:	4f 92       	push	r4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:789
    sei();

    rtsUpdate();
}

bool SequansControllerClass::extractValueFromCommandResponse(
    198c:	5f 92       	push	r5
    198e:	6f 92       	push	r6
    1990:	7f 92       	push	r7
    1992:	8f 92       	push	r8
    1994:	9f 92       	push	r9
    1996:	af 92       	push	r10
    1998:	bf 92       	push	r11
    199a:	cf 92       	push	r12
    199c:	df 92       	push	r13
    199e:	ef 92       	push	r14
    19a0:	ff 92       	push	r15
    19a2:	0f 93       	push	r16
    19a4:	1f 93       	push	r17
    19a6:	cf 93       	push	r28
    19a8:	df 93       	push	r29
    19aa:	cd b7       	in	r28, 0x3d	; 61
    19ac:	de b7       	in	r29, 0x3e	; 62
    19ae:	16 2f       	mov	r17, r22
    19b0:	4a 01       	movw	r8, r20
    19b2:	39 01       	movw	r6, r18
    19b4:	4d b6       	in	r4, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:879
    }

    strcpy(buffer, start_value_ptr);

    return true;
}
    19b6:	5e b6       	in	r5, 0x3e	; 62
    19b8:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:797
    char* buffer,
    const size_t buffer_size,
    const char start_character) {

    // We need a copy in order to not modify the original
    size_t rcp_size = strlen(response) + 1;
    19ba:	01 90       	ld	r0, Z+
    19bc:	00 20       	and	r0, r0
    19be:	e9 f7       	brne	.-6      	; 0x19ba <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0x30>
    19c0:	31 97       	sbiw	r30, 0x01	; 1
    19c2:	7f 01       	movw	r14, r30
    19c4:	e8 1a       	sub	r14, r24
    19c6:	f9 0a       	sbc	r15, r25
    19c8:	a7 01       	movw	r20, r14
    19ca:	4f 5f       	subi	r20, 0xFF	; 255
    19cc:	5f 4f       	sbci	r21, 0xFF	; 255
    19ce:	2d b7       	in	r18, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:798
    char response_copy[rcp_size];
    19d0:	3e b7       	in	r19, 0x3e	; 62
    19d2:	24 1b       	sub	r18, r20
    19d4:	35 0b       	sbc	r19, r21
    19d6:	2d bf       	out	0x3d, r18	; 61
    19d8:	3e bf       	out	0x3e, r19	; 62
    19da:	ed b7       	in	r30, 0x3d	; 61
    19dc:	fe b7       	in	r31, 0x3e	; 62
    19de:	31 96       	adiw	r30, 0x01	; 1
    19e0:	5f 01       	movw	r10, r30
    19e2:	6f 01       	movw	r12, r30
    19e4:	bc 01       	movw	r22, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:799
    strncpy(response_copy, response, rcp_size);
    19e6:	cf 01       	movw	r24, r30
    19e8:	0e 94 1b 57 	call	0xae36	; 0xae36 <strncpy>
    19ec:	f5 01       	movw	r30, r10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:802

    // Enforce non buffer overflow
    response_copy[rcp_size - 1] = '\0';
    19ee:	ee 0d       	add	r30, r14
    19f0:	ff 1d       	adc	r31, r15
    19f2:	10 82       	st	Z, r1
    19f4:	00 23       	and	r16, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:806

    char* data;

    if (start_character != 0) {
    19f6:	81 f0       	breq	.+32     	; 0x1a18 <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0x8e>
    19f8:	60 2f       	mov	r22, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:810

        // Find the first occurrence of the data start character and move
        // pointer to there
        data = strchr(response_copy, start_character);
    19fa:	00 2e       	mov	r0, r16
    19fc:	00 0c       	add	r0, r0
    19fe:	77 0b       	sbc	r23, r23
    1a00:	c5 01       	movw	r24, r10
    1a02:	0e 94 e9 56 	call	0xadd2	; 0xadd2 <strchr>
    1a06:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:812

        if (data == NULL) {
    1a08:	91 f0       	breq	.+36     	; 0x1a2e <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0xa4>
    1a0a:	fc 01       	movw	r30, r24
    1a0c:	6f 01       	movw	r12, r30
    1a0e:	81 91       	ld	r24, Z+
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:818
            return false;
        }

        // Increment pointer to skip the data start character (and the
        // following space in the start sequence of the data if it is there)
        while (*data == start_character || *data == SPACE_CHARACTER) { data++; }
    1a10:	08 17       	cp	r16, r24
    1a12:	e1 f3       	breq	.-8      	; 0x1a0c <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0x82>
    1a14:	80 32       	cpi	r24, 0x20	; 32
    1a16:	d1 f3       	breq	.-12     	; 0x1a0c <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0x82>
    1a18:	6c e2       	ldi	r22, 0x2C	; 44
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:834
    // take into account empty strings between the delimiter, which can be
    // the case with certain command responses

    // These keep track of the contens between the delimiter
    char* start_value_ptr = data;
    char* end_value_ptr   = strchr(data, RESPONSE_DELIMITER);
    1a1a:	70 e0       	ldi	r23, 0x00	; 0
    1a1c:	c6 01       	movw	r24, r12
    1a1e:	0e 94 e9 56 	call	0xadd2	; 0xadd2 <strchr>
    1a22:	76 01       	movw	r14, r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:839

    // We did not find the delimiter at all, abort if the index we request
    // is > 0. If it is 0, the command might only consist of one entry and
    // not have a delimiter
    if (end_value_ptr == NULL && index > 0) {
    1a24:	01 e0       	ldi	r16, 0x01	; 1
    1a26:	00 97       	sbiw	r24, 0x00	; 0
    1a28:	21 f4       	brne	.+8      	; 0x1a32 <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0xa8>
    1a2a:	11 23       	and	r17, r17
    1a2c:	81 f0       	breq	.+32     	; 0x1a4e <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0xc4>
    1a2e:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:813
        // Find the first occurrence of the data start character and move
        // pointer to there
        data = strchr(response_copy, start_character);

        if (data == NULL) {
            return false;
    1a30:	32 c0       	rjmp	.+100    	; 0x1a96 <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0x10c>
    1a32:	10 17       	cp	r17, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:845
        return false;
    }

    uint8_t value_index = 1;

    while (end_value_ptr != NULL && value_index <= index) {
    1a34:	90 f0       	brcs	.+36     	; 0x1a5a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0xd0>
    1a36:	7c 01       	movw	r14, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:847
        // Find next occurrence and update accordingly
        start_value_ptr = end_value_ptr + 1;
    1a38:	ff ef       	ldi	r31, 0xFF	; 255
    1a3a:	ef 1a       	sub	r14, r31
    1a3c:	ff 0a       	sbc	r15, r31
    1a3e:	6c e2       	ldi	r22, 0x2C	; 44
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:848
        end_value_ptr   = strchr(start_value_ptr, RESPONSE_DELIMITER);
    1a40:	70 e0       	ldi	r23, 0x00	; 0
    1a42:	c7 01       	movw	r24, r14
    1a44:	0e 94 e9 56 	call	0xadd2	; 0xadd2 <strchr>
    1a48:	0f 5f       	subi	r16, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:849
        value_index++;
    1a4a:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:845
        return false;
    }

    uint8_t value_index = 1;

    while (end_value_ptr != NULL && value_index <= index) {
    1a4c:	91 f7       	brne	.-28     	; 0x1a32 <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0xa8>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:855
    }

    // If we got all the way to the end, set the end_value_ptr to the end of
    // the data ptr
    if (end_value_ptr == NULL) {
        end_value_ptr = data + strlen(data);
    1a4e:	f6 01       	movw	r30, r12
    1a50:	01 90       	ld	r0, Z+
    1a52:	00 20       	and	r0, r0
    1a54:	e9 f7       	brne	.-6      	; 0x1a50 <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0xc6>
    1a56:	cf 01       	movw	r24, r30
    1a58:	01 97       	sbiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:857
    }
    end_value_ptr[0] = 0; // Add null termination
    1a5a:	fc 01       	movw	r30, r24
    1a5c:	10 82       	st	Z, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:861

    // If found, set termination to the carriage return. If not, leave the
    // string be as it is
    char* first_carriage_return = strchr(start_value_ptr, '\r');
    1a5e:	6d e0       	ldi	r22, 0x0D	; 13
    1a60:	70 e0       	ldi	r23, 0x00	; 0
    1a62:	c7 01       	movw	r24, r14
    1a64:	0e 94 e9 56 	call	0xadd2	; 0xadd2 <strchr>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:862
    if (first_carriage_return != NULL) {
    1a68:	00 97       	sbiw	r24, 0x00	; 0
    1a6a:	11 f0       	breq	.+4      	; 0x1a70 <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0xe6>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:863
        *first_carriage_return = 0;
    1a6c:	fc 01       	movw	r30, r24
    1a6e:	10 82       	st	Z, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:866
    }

    size_t value_length = strlen(start_value_ptr);
    1a70:	f7 01       	movw	r30, r14
    1a72:	01 90       	ld	r0, Z+
    1a74:	00 20       	and	r0, r0
    1a76:	e9 f7       	brne	.-6      	; 0x1a72 <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0xe8>
    1a78:	31 97       	sbiw	r30, 0x01	; 1
    1a7a:	ee 19       	sub	r30, r14
    1a7c:	ff 09       	sbc	r31, r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:870
    // We compare inclusive for value length as we want to take the null
    // termination into consideration. So the buffer size has be
    // value_length + 1
    if (value_length >= buffer_size) {
    1a7e:	e6 15       	cp	r30, r6
    1a80:	f7 05       	cpc	r31, r7
    1a82:	20 f0       	brcs	.+8      	; 0x1a8c <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0x102>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:871
        Log.error("Buffer too small for value when extracting value for "
    1a84:	85 ef       	ldi	r24, 0xF5	; 245
    1a86:	93 e4       	ldi	r25, 0x43	; 67
    1a88:	02 dd       	rcall	.-1532   	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    1a8a:	d1 cf       	rjmp	.-94     	; 0x1a2e <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]+0xa4>
    1a8c:	b7 01       	movw	r22, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:876
                  "command response, increase the buffer size");
        return false;
    }

    strcpy(buffer, start_value_ptr);
    1a8e:	c4 01       	movw	r24, r8
    1a90:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    1a94:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:878

    return true;
    1a96:	4d be       	out	0x3d, r4	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:879
}
    1a98:	5e be       	out	0x3e, r5	; 62
    1a9a:	df 91       	pop	r29
    1a9c:	cf 91       	pop	r28
    1a9e:	1f 91       	pop	r17
    1aa0:	0f 91       	pop	r16
    1aa2:	ff 90       	pop	r15
    1aa4:	ef 90       	pop	r14
    1aa6:	df 90       	pop	r13
    1aa8:	cf 90       	pop	r12
    1aaa:	bf 90       	pop	r11
    1aac:	af 90       	pop	r10
    1aae:	9f 90       	pop	r9
    1ab0:	8f 90       	pop	r8
    1ab2:	7f 90       	pop	r7
    1ab4:	6f 90       	pop	r6
    1ab6:	5f 90       	pop	r5
    1ab8:	4f 90       	pop	r4
    1aba:	08 95       	ret

00001abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>:
unregisterCallback():
    1abc:	cf 92       	push	r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:928

    Log.error("Max amount of URC callbacks for SequansController reached");
    return false;
}

void SequansControllerClass::unregisterCallback(const char* urc_identifier) {
    1abe:	df 92       	push	r13
    1ac0:	ef 92       	push	r14
    1ac2:	ff 92       	push	r15
    1ac4:	0f 93       	push	r16
    1ac6:	1f 93       	push	r17
    1ac8:	cf 93       	push	r28
    1aca:	df 93       	push	r29
    1acc:	d8 2e       	mov	r13, r24
    1ace:	c9 2e       	mov	r12, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:929
    const uint8_t urc_identifier_length = strlen(urc_identifier);
    1ad0:	e8 2f       	mov	r30, r24
    1ad2:	f9 2f       	mov	r31, r25
    1ad4:	df 01       	movw	r26, r30
    1ad6:	0d 90       	ld	r0, X+
    1ad8:	00 20       	and	r0, r0
    1ada:	e9 f7       	brne	.-6      	; 0x1ad6 <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]+0x1a>
    1adc:	ad 01       	movw	r20, r26
    1ade:	41 50       	subi	r20, 0x01	; 1
    1ae0:	51 09       	sbc	r21, r1
    1ae2:	4e 1b       	sub	r20, r30
    1ae4:	5f 0b       	sbc	r21, r31
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:932

    // Doing -1 here as we need one byte for null termination
    if (urc_identifier_length > (URC_IDENTIFIER_BUFFER_SIZE - 1)) {
    1ae6:	4c 31       	cpi	r20, 0x1C	; 28
    1ae8:	f0 f0       	brcs	.+60     	; 0x1b26 <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]+0x6a>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:934

        Log.errorf(
    1aea:	1f 92       	push	r1
    1aec:	8b e1       	ldi	r24, 0x1B	; 27
    1aee:	8f 93       	push	r24
    1af0:	5f 93       	push	r21
    1af2:	4f 93       	push	r20
    1af4:	9f 93       	push	r25
    1af6:	df 92       	push	r13
    1af8:	85 e5       	ldi	r24, 0x55	; 85
    1afa:	94 e4       	ldi	r25, 0x44	; 68
    1afc:	9f 93       	push	r25
    1afe:	8f 93       	push	r24
    1b00:	89 e6       	ldi	r24, 0x69	; 105
    1b02:	90 e7       	ldi	r25, 0x70	; 112
    1b04:	9f 93       	push	r25
    1b06:	8f 93       	push	r24
    1b08:	59 dd       	rcall	.-1358   	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    1b0a:	8d b7       	in	r24, 0x3d	; 61
    1b0c:	9e b7       	in	r25, 0x3e	; 62
    1b0e:	0a 96       	adiw	r24, 0x0a	; 10
    1b10:	8d bf       	out	0x3d, r24	; 61
    1b12:	9e bf       	out	0x3e, r25	; 62
    1b14:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:958
            urcs[i].identifier_length = 0;
            urcs[i].callback          = NULL;
            break;
        }
    }
}
    1b16:	cf 91       	pop	r28
    1b18:	1f 91       	pop	r17
    1b1a:	0f 91       	pop	r16
    1b1c:	ff 90       	pop	r15
    1b1e:	ef 90       	pop	r14
    1b20:	df 90       	pop	r13
    1b22:	cf 90       	pop	r12
    1b24:	08 95       	ret
    1b26:	96 e3       	ldi	r25, 0x36	; 54
    1b28:	e9 2e       	mov	r14, r25
    1b2a:	9c e6       	ldi	r25, 0x6C	; 108
    1b2c:	f9 2e       	mov	r15, r25
    1b2e:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:932

void SequansControllerClass::unregisterCallback(const char* urc_identifier) {
    const uint8_t urc_identifier_length = strlen(urc_identifier);

    // Doing -1 here as we need one byte for null termination
    if (urc_identifier_length > (URC_IDENTIFIER_BUFFER_SIZE - 1)) {
    1b30:	00 e0       	ldi	r16, 0x00	; 0
    1b32:	ea 01       	movw	r28, r20
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:945

        return;
    }

    for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
        if (memcmp((const void*)urc_identifier,
    1b34:	dd 27       	eor	r29, r29
    1b36:	ae 01       	movw	r20, r28
    1b38:	b7 01       	movw	r22, r14
    1b3a:	8d 2d       	mov	r24, r13
    1b3c:	9c 2d       	mov	r25, r12
    1b3e:	0e 94 c1 56 	call	0xad82	; 0xad82 <memcmp>
    1b42:	89 2b       	or	r24, r25
    1b44:	61 f4       	brne	.+24     	; 0x1b5e <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]+0xa2>
    1b46:	85 e0       	ldi	r24, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:953

            // No need to fill the look up table identifier table, as we
            // override it if a new registration is issued, but the length
            // is used to check if the slot is active or not, so we set that
            // to 0 and reset the callback pointer for house keeping
            urcs[i].identifier_length = 0;
    1b48:	00 0f       	add	r16, r16
    1b4a:	11 1f       	adc	r17, r17
    1b4c:	8a 95       	dec	r24
    1b4e:	e1 f7       	brne	.-8      	; 0x1b48 <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]+0x8c>
    1b50:	f8 01       	movw	r30, r16
    1b52:	ea 5c       	subi	r30, 0xCA	; 202
    1b54:	f3 49       	sbci	r31, 0x93	; 147
    1b56:	14 8e       	std	Z+28, r1	; 0x1c
    1b58:	16 8e       	std	Z+30, r1	; 0x1e
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:954
            urcs[i].callback          = NULL;
    1b5a:	17 8e       	std	Z+31, r1	; 0x1f
    1b5c:	db cf       	rjmp	.-74     	; 0x1b14 <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]+0x58>
    1b5e:	0f 5f       	subi	r16, 0xFF	; 255
    1b60:	1f 4f       	sbci	r17, 0xFF	; 255
    1b62:	90 e2       	ldi	r25, 0x20	; 32
    1b64:	e9 0e       	add	r14, r25
    1b66:	f1 1c       	adc	r15, r1
    1b68:	0a 30       	cpi	r16, 0x0A	; 10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:944
            URC_IDENTIFIER_BUFFER_SIZE - 1);

        return;
    }

    for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
    1b6a:	11 05       	cpc	r17, r1
    1b6c:	21 f7       	brne	.-56     	; 0x1b36 <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]+0x7a>
    1b6e:	d2 cf       	rjmp	.-92     	; 0x1b14 <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]+0x58>

00001b70 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]>:
registerCallback():
    1b70:	af 92       	push	r10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:881
    strcpy(buffer, start_value_ptr);

    return true;
}

bool SequansControllerClass::registerCallback(const char* urc_identifier,
    1b72:	bf 92       	push	r11
    1b74:	cf 92       	push	r12
    1b76:	df 92       	push	r13
    1b78:	ef 92       	push	r14
    1b7a:	ff 92       	push	r15
    1b7c:	0f 93       	push	r16
    1b7e:	1f 93       	push	r17
    1b80:	cf 93       	push	r28
    1b82:	df 93       	push	r29
    1b84:	f8 2e       	mov	r15, r24
    1b86:	e9 2e       	mov	r14, r25
    1b88:	8b 01       	movw	r16, r22
    1b8a:	d4 2e       	mov	r13, r20
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:885
                                              void (*urc_callback)(char*),
                                              const bool clear_data) {

    const uint8_t urc_identifier_length = strlen(urc_identifier);
    1b8c:	a8 2f       	mov	r26, r24
    1b8e:	b9 2f       	mov	r27, r25
    1b90:	fd 01       	movw	r30, r26
    1b92:	01 90       	ld	r0, Z+
    1b94:	00 20       	and	r0, r0
    1b96:	e9 f7       	brne	.-6      	; 0x1b92 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0x22>
    1b98:	31 97       	sbiw	r30, 0x01	; 1
    1b9a:	ea 1b       	sub	r30, r26
    1b9c:	fb 0b       	sbc	r31, r27
    1b9e:	ce 2e       	mov	r12, r30
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:888

    // Doing -1 here as we need one byte for null termination
    if (urc_identifier_length > (URC_IDENTIFIER_BUFFER_SIZE - 1)) {
    1ba0:	2b e1       	ldi	r18, 0x1B	; 27
    1ba2:	b1 2c       	mov	r11, r1
    1ba4:	a1 2c       	mov	r10, r1
    1ba6:	2e 17       	cp	r18, r30
    1ba8:	50 f5       	brcc	.+84     	; 0x1bfe <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0x8e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:890

        Log.errorf("Attempted to register URC \"%s\" with length greater than "
    1baa:	1f 92       	push	r1
    1bac:	8b e1       	ldi	r24, 0x1B	; 27
    1bae:	8f 93       	push	r24
    1bb0:	ff 27       	eor	r31, r31
    1bb2:	ff 93       	push	r31
    1bb4:	ef 93       	push	r30
    1bb6:	9f 93       	push	r25
    1bb8:	ff 92       	push	r15
    1bba:	8e eb       	ldi	r24, 0xBE	; 190
    1bbc:	94 e4       	ldi	r25, 0x44	; 68
    1bbe:	9f 93       	push	r25
    1bc0:	8f 93       	push	r24
    1bc2:	89 e6       	ldi	r24, 0x69	; 105
    1bc4:	90 e7       	ldi	r25, 0x70	; 112
    1bc6:	9f 93       	push	r25
    1bc8:	8f 93       	push	r24
    1bca:	f8 dc       	rcall	.-1552   	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    1bcc:	8d b7       	in	r24, 0x3d	; 61
    1bce:	9e b7       	in	r25, 0x3e	; 62
    1bd0:	0a 96       	adiw	r24, 0x0a	; 10
    1bd2:	8d bf       	out	0x3d, r24	; 61
    1bd4:	9e bf       	out	0x3e, r25	; 62
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:925
            return true;
        }
    }

    Log.error("Max amount of URC callbacks for SequansController reached");
    return false;
    1bd6:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:926
}
    1bd8:	df 91       	pop	r29
    1bda:	cf 91       	pop	r28
    1bdc:	1f 91       	pop	r17
    1bde:	0f 91       	pop	r16
    1be0:	ff 90       	pop	r15
    1be2:	ef 90       	pop	r14
    1be4:	df 90       	pop	r13
    1be6:	cf 90       	pop	r12
    1be8:	bf 90       	pop	r11
    1bea:	af 90       	pop	r10
    1bec:	08 95       	ret
    1bee:	01 96       	adiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:912
            return true;
        }
    }

    // Look for empty spot
    for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
    1bf0:	8a 30       	cpi	r24, 0x0A	; 10
    1bf2:	91 05       	cpc	r25, r1
    1bf4:	f9 f4       	brne	.+62     	; 0x1c34 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0xc4>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:924

            return true;
        }
    }

    Log.error("Max amount of URC callbacks for SequansController reached");
    1bf6:	84 e2       	ldi	r24, 0x24	; 36
    1bf8:	95 e4       	ldi	r25, 0x45	; 69
    1bfa:	49 dc       	rcall	.-1902   	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    1bfc:	ec cf       	rjmp	.-40     	; 0x1bd6 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0x66>
    1bfe:	e5 01       	movw	r28, r10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:901
        return false;
    }

    // Check if we can override first
    for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
        if (urcs[i].identifier_length == urc_identifier_length &&
    1c00:	85 e0       	ldi	r24, 0x05	; 5
    1c02:	cc 0f       	add	r28, r28
    1c04:	dd 1f       	adc	r29, r29
    1c06:	8a 95       	dec	r24
    1c08:	e1 f7       	brne	.-8      	; 0x1c02 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0x92>
    1c0a:	ca 5c       	subi	r28, 0xCA	; 202
    1c0c:	d3 49       	sbci	r29, 0x93	; 147
    1c0e:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1c10:	c8 12       	cpse	r12, r24
    1c12:	07 c0       	rjmp	.+14     	; 0x1c22 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0xb2>
    1c14:	be 01       	movw	r22, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:903

            strcmp(urc_identifier, (const char*)urcs[i].identifier) == 0) {
    1c16:	8f 2d       	mov	r24, r15
    1c18:	9e 2d       	mov	r25, r14
    1c1a:	0e 94 f4 56 	call	0xade8	; 0xade8 <strcmp>
    1c1e:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:901
        return false;
    }

    // Check if we can override first
    for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
        if (urcs[i].identifier_length == urc_identifier_length &&
    1c20:	41 f1       	breq	.+80     	; 0x1c72 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0x102>
    1c22:	bf ef       	ldi	r27, 0xFF	; 255
    1c24:	ab 1a       	sub	r10, r27
    1c26:	bb 0a       	sbc	r11, r27
    1c28:	2a e0       	ldi	r18, 0x0A	; 10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:900

        return false;
    }

    // Check if we can override first
    for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
    1c2a:	a2 16       	cp	r10, r18
    1c2c:	b1 04       	cpc	r11, r1
    1c2e:	39 f7       	brne	.-50     	; 0x1bfe <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0x8e>
    1c30:	90 e0       	ldi	r25, 0x00	; 0
    1c32:	80 e0       	ldi	r24, 0x00	; 0
    1c34:	ec 01       	movw	r28, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:913
        }
    }

    // Look for empty spot
    for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
        if (urcs[i].identifier_length == 0) {
    1c36:	25 e0       	ldi	r18, 0x05	; 5
    1c38:	cc 0f       	add	r28, r28
    1c3a:	dd 1f       	adc	r29, r29
    1c3c:	2a 95       	dec	r18
    1c3e:	e1 f7       	brne	.-8      	; 0x1c38 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0xc8>
    1c40:	ca 5c       	subi	r28, 0xCA	; 202
    1c42:	d3 49       	sbci	r29, 0x93	; 147
    1c44:	5e 01       	movw	r10, r28
    1c46:	ac e1       	ldi	r26, 0x1C	; 28
    1c48:	aa 0e       	add	r10, r26
    1c4a:	b1 1c       	adc	r11, r1
    1c4c:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1c4e:	21 11       	cpse	r18, r1
    1c50:	ce cf       	rjmp	.-100    	; 0x1bee <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0x7e>
    1c52:	6f 2d       	mov	r22, r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:915

            strcpy((char*)urcs[i].identifier, urc_identifier);
    1c54:	7e 2d       	mov	r23, r14
    1c56:	ce 01       	movw	r24, r28
    1c58:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    1c5c:	af 2d       	mov	r26, r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:916
            urcs[i].identifier_length = strlen(urc_identifier);
    1c5e:	be 2d       	mov	r27, r14
    1c60:	fd 01       	movw	r30, r26
    1c62:	01 90       	ld	r0, Z+
    1c64:	00 20       	and	r0, r0
    1c66:	e9 f7       	brne	.-6      	; 0x1c62 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0xf2>
    1c68:	31 97       	sbiw	r30, 0x01	; 1
    1c6a:	ea 1b       	sub	r30, r26
    1c6c:	fb 0b       	sbc	r31, r27
    1c6e:	d5 01       	movw	r26, r10
    1c70:	ec 93       	st	X, r30
    1c72:	0e 8f       	std	Y+30, r16	; 0x1e
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:904
    // Check if we can override first
    for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
        if (urcs[i].identifier_length == urc_identifier_length &&

            strcmp(urc_identifier, (const char*)urcs[i].identifier) == 0) {
            urcs[i].callback     = urc_callback;
    1c74:	1f 8f       	std	Y+31, r17	; 0x1f
    1c76:	dd 8e       	std	Y+29, r13	; 0x1d
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:905
            urcs[i].should_clear = clear_data;
    1c78:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:907

            return true;
    1c7a:	ae cf       	rjmp	.-164    	; 0x1bd8 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]+0x68>

00001c7c <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]>:
appendDataToTransmitBuffer():
    1c7c:	0f 93       	push	r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:575
    return tx_num_elements < TX_BUFFER_SIZE;
}

bool SequansControllerClass::isRxReady(void) { return rx_num_elements > 0; }

bool SequansControllerClass::appendDataToTransmitBuffer(const uint8_t data) {
    1c7e:	1f 93       	push	r17
    1c80:	cf 93       	push	r28
    1c82:	df 93       	push	r29
    1c84:	cd b7       	in	r28, 0x3d	; 61
    1c86:	de b7       	in	r29, 0x3e	; 62
    1c88:	28 97       	sbiw	r28, 0x08	; 8
    1c8a:	cd bf       	out	0x3d, r28	; 61
    1c8c:	de bf       	out	0x3e, r29	; 62
    1c8e:	08 2f       	mov	r16, r24
isTxReady():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:570

    initialized = false;
}

bool SequansControllerClass::isTxReady(void) {
    return tx_num_elements < TX_BUFFER_SIZE;
    1c90:	80 91 b1 6a 	lds	r24, 0x6AB1	; 0x806ab1 <tx_num_elements>
    1c94:	90 91 b2 6a 	lds	r25, 0x6AB2	; 0x806ab2 <tx_num_elements+0x1>
appendDataToTransmitBuffer():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:580
bool SequansControllerClass::appendDataToTransmitBuffer(const uint8_t data) {

    // If the transmit buffer is full, we enable the data register empty
    // interrupt so that transmitting occurs and push out data before we append
    // the incoming data
    if (!isTxReady()) {
    1c98:	81 15       	cp	r24, r1
    1c9a:	92 40       	sbci	r25, 0x02	; 2
    1c9c:	00 f1       	brcs	.+64     	; 0x1cde <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0x62>
__base_ctor ():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:5
#include "timeout_timer.h"

#include <Arduino.h>

TimeoutTimer::TimeoutTimer(const uint32_t ms) : interval_ms(ms) {
    1c9e:	88 ee       	ldi	r24, 0xE8	; 232
    1ca0:	93 e0       	ldi	r25, 0x03	; 3
    1ca2:	a0 e0       	ldi	r26, 0x00	; 0
    1ca4:	b0 e0       	ldi	r27, 0x00	; 0
    1ca6:	89 83       	std	Y+1, r24	; 0x01
    1ca8:	9a 83       	std	Y+2, r25	; 0x02
    1caa:	ab 83       	std	Y+3, r26	; 0x03
    1cac:	bc 83       	std	Y+4, r27	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:6
    start_ms = millis();
    1cae:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
    1cb2:	6d 83       	std	Y+5, r22	; 0x05
    1cb4:	7e 83       	std	Y+6, r23	; 0x06
    1cb6:	8f 83       	std	Y+7, r24	; 0x07
    1cb8:	98 87       	std	Y+8, r25	; 0x08
isTxReady():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:570

    initialized = false;
}

bool SequansControllerClass::isTxReady(void) {
    return tx_num_elements < TX_BUFFER_SIZE;
    1cba:	80 91 b1 6a 	lds	r24, 0x6AB1	; 0x806ab1 <tx_num_elements>
    1cbe:	90 91 b2 6a 	lds	r25, 0x6AB2	; 0x806ab2 <tx_num_elements+0x1>
appendDataToTransmitBuffer():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:583
    // interrupt so that transmitting occurs and push out data before we append
    // the incoming data
    if (!isTxReady()) {

        TimeoutTimer timeout_timer(1000);
        while (!isTxReady() && !timeout_timer.hasTimedOut()) {
    1cc2:	81 15       	cp	r24, r1
    1cc4:	92 40       	sbci	r25, 0x02	; 2
    1cc6:	30 f0       	brcs	.+12     	; 0x1cd4 <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0x58>
    1cc8:	ce 01       	movw	r24, r28
    1cca:	01 96       	adiw	r24, 0x01	; 1
    1ccc:	c3 d8       	rcall	.-3706   	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    1cce:	18 2f       	mov	r17, r24
    1cd0:	88 23       	and	r24, r24
    1cd2:	71 f1       	breq	.+92     	; 0x1d30 <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0xb4>
    1cd4:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:605
            }
        }

        // Disable data register empty interrupt again before appending to the
        // buffer
        HWSERIALAT.CTRLA &= ~USART_DREIE_bm;
    1cd8:	8f 7d       	andi	r24, 0xDF	; 223
    1cda:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:608
    }

    cli();
    1cde:	f8 94       	cli
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:609
    tx_head_index            = (tx_head_index + 1) & TX_BUFFER_MASK;
    1ce0:	80 91 af 6a 	lds	r24, 0x6AAF	; 0x806aaf <tx_head_index>
    1ce4:	90 91 b0 6a 	lds	r25, 0x6AB0	; 0x806ab0 <tx_head_index+0x1>
    1ce8:	01 96       	adiw	r24, 0x01	; 1
    1cea:	91 70       	andi	r25, 0x01	; 1
    1cec:	80 93 af 6a 	sts	0x6AAF, r24	; 0x806aaf <tx_head_index>
    1cf0:	90 93 b0 6a 	sts	0x6AB0, r25	; 0x806ab0 <tx_head_index+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:610
    tx_buffer[tx_head_index] = data;
    1cf4:	e0 91 af 6a 	lds	r30, 0x6AAF	; 0x806aaf <tx_head_index>
    1cf8:	f0 91 b0 6a 	lds	r31, 0x6AB0	; 0x806ab0 <tx_head_index+0x1>
    1cfc:	e1 55       	subi	r30, 0x51	; 81
    1cfe:	f7 49       	sbci	r31, 0x97	; 151
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:611
    tx_num_elements++;
    1d00:	00 83       	st	Z, r16
    1d02:	80 91 b1 6a 	lds	r24, 0x6AB1	; 0x806ab1 <tx_num_elements>
    1d06:	90 91 b2 6a 	lds	r25, 0x6AB2	; 0x806ab2 <tx_num_elements+0x1>
    1d0a:	01 96       	adiw	r24, 0x01	; 1
    1d0c:	80 93 b1 6a 	sts	0x6AB1, r24	; 0x806ab1 <tx_num_elements>
    1d10:	90 93 b2 6a 	sts	0x6AB2, r25	; 0x806ab2 <tx_num_elements+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:614
    sei();

    return true;
    1d14:	78 94       	sei
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:586

        TimeoutTimer timeout_timer(1000);
        while (!isTxReady() && !timeout_timer.hasTimedOut()) {

            // Wait if the modem can't accept more data
            while (VPORTC.IN & CTS_PIN_bm && !timeout_timer.hasTimedOut()) {
    1d16:	11 e0       	ldi	r17, 0x01	; 1
    1d18:	15 c0       	rjmp	.+42     	; 0x1d44 <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0xc8>
    1d1a:	ce 01       	movw	r24, r28
    1d1c:	01 96       	adiw	r24, 0x01	; 1
    1d1e:	9a d8       	rcall	.-3788   	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    1d20:	81 11       	cpse	r24, r1
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:187
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    1d22:	08 c0       	rjmp	.+16     	; 0x1d34 <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0xb8>
_delay_ms():
    1d24:	8f e6       	ldi	r24, 0x6F	; 111
    1d26:	97 e1       	ldi	r25, 0x17	; 23
    1d28:	01 97       	sbiw	r24, 0x01	; 1
    1d2a:	f1 f7       	brne	.-4      	; 0x1d28 <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0xac>
    1d2c:	00 c0       	rjmp	.+0      	; 0x1d2e <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0xb2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:586
    1d2e:	00 00       	nop
appendDataToTransmitBuffer():
    1d30:	54 99       	sbic	0x0a, 4	; 10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:590
                _delay_ms(1);
            }

            if (!(VPORTC.IN & CTS_PIN_bm) && !timeout_timer.hasTimedOut()) {
    1d32:	f3 cf       	rjmp	.-26     	; 0x1d1a <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0x9e>
    1d34:	54 9b       	sbis	0x0a, 4	; 10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:596
                // Enable data register empty interrupt so that the data gets
                // pushed out. We do this in the loop as the CTS interrupt might
                // disable the interrupt logic, so we wait until that is not the
                // case and then start the transmit logic
                HWSERIALAT.CTRLA |= USART_DREIE_bm;
            } else if (timeout_timer.hasTimedOut()) {
    1d36:	0f c0       	rjmp	.+30     	; 0x1d56 <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0xda>
    1d38:	ce 01       	movw	r24, r28
    1d3a:	01 96       	adiw	r24, 0x01	; 1
    1d3c:	8b d8       	rcall	.-3818   	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    1d3e:	88 23       	and	r24, r24
    1d40:	09 f4       	brne	.+2      	; 0x1d44 <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0xc8>
    1d42:	bb cf       	rjmp	.-138    	; 0x1cba <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0x3e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:615
    tx_buffer[tx_head_index] = data;
    tx_num_elements++;
    sei();

    return true;
}
    1d44:	81 2f       	mov	r24, r17
    1d46:	28 96       	adiw	r28, 0x08	; 8
    1d48:	cd bf       	out	0x3d, r28	; 61
    1d4a:	de bf       	out	0x3e, r29	; 62
    1d4c:	df 91       	pop	r29
    1d4e:	cf 91       	pop	r28
    1d50:	1f 91       	pop	r17
    1d52:	0f 91       	pop	r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:590
            // Wait if the modem can't accept more data
            while (VPORTC.IN & CTS_PIN_bm && !timeout_timer.hasTimedOut()) {
                _delay_ms(1);
            }

            if (!(VPORTC.IN & CTS_PIN_bm) && !timeout_timer.hasTimedOut()) {
    1d54:	08 95       	ret
    1d56:	ce 01       	movw	r24, r28
    1d58:	01 96       	adiw	r24, 0x01	; 1
    1d5a:	7c d8       	rcall	.-3848   	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    1d5c:	81 11       	cpse	r24, r1
    1d5e:	ec cf       	rjmp	.-40     	; 0x1d38 <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0xbc>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:595
                // Enable data register empty interrupt so that the data gets
                // pushed out. We do this in the loop as the CTS interrupt might
                // disable the interrupt logic, so we wait until that is not the
                // case and then start the transmit logic
                HWSERIALAT.CTRLA |= USART_DREIE_bm;
    1d60:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
    1d64:	80 62       	ori	r24, 0x20	; 32
    1d66:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
    1d6a:	a7 cf       	rjmp	.-178    	; 0x1cba <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]+0x3e>

00001d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>:
writeBytes():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:617
    sei();

    return true;
}

void SequansControllerClass::writeBytes(const uint8_t* data,
    1d6c:	df 92       	push	r13
    1d6e:	ef 92       	push	r14
    1d70:	ff 92       	push	r15
    1d72:	0f 93       	push	r16
    1d74:	1f 93       	push	r17
    1d76:	cf 93       	push	r28
    1d78:	df 93       	push	r29
    1d7a:	cd b7       	in	r28, 0x3d	; 61
    1d7c:	de b7       	in	r29, 0x3e	; 62
    1d7e:	28 97       	sbiw	r28, 0x08	; 8
    1d80:	cd bf       	out	0x3d, r28	; 61
    1d82:	de bf       	out	0x3e, r29	; 62
    1d84:	d4 2e       	mov	r13, r20
    1d86:	8c 01       	movw	r16, r24
    1d88:	7c 01       	movw	r14, r24
    1d8a:	e6 0e       	add	r14, r22
    1d8c:	f7 1e       	adc	r15, r23
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:621
                                        const size_t buffer_size,
                                        const bool append_carriage_return) {

    for (size_t i = 0; i < buffer_size; i++) {
    1d8e:	0e 15       	cp	r16, r14
    1d90:	1f 05       	cpc	r17, r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:622
        if (!appendDataToTransmitBuffer(data[i])) {
    1d92:	89 f0       	breq	.+34     	; 0x1db6 <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x4a>
    1d94:	f8 01       	movw	r30, r16
    1d96:	81 91       	ld	r24, Z+
    1d98:	8f 01       	movw	r16, r30
    1d9a:	70 df       	rcall	.-288    	; 0x1c7c <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]>
    1d9c:	81 11       	cpse	r24, r1
    1d9e:	f7 cf       	rjmp	.-18     	; 0x1d8e <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x22>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:645
    // Only enable the data register empty interrupt (so that the data gets
    // pushed out) if the CTS line was logically low before the end of the timer
    if (!(VPORTC.IN & CTS_PIN_bm)) {
        HWSERIALAT.CTRLA |= USART_DREIE_bm;
    }
}
    1da0:	28 96       	adiw	r28, 0x08	; 8
    1da2:	cd bf       	out	0x3d, r28	; 61
    1da4:	de bf       	out	0x3e, r29	; 62
    1da6:	df 91       	pop	r29
    1da8:	cf 91       	pop	r28
    1daa:	1f 91       	pop	r17
    1dac:	0f 91       	pop	r16
    1dae:	ff 90       	pop	r15
    1db0:	ef 90       	pop	r14
    1db2:	df 90       	pop	r13
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:627
        if (!appendDataToTransmitBuffer(data[i])) {
            return;
        }
    }

    if (append_carriage_return) {
    1db4:	08 95       	ret
    1db6:	d1 10       	cpse	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:5
#include "timeout_timer.h"

#include <Arduino.h>

TimeoutTimer::TimeoutTimer(const uint32_t ms) : interval_ms(ms) {
    1db8:	1c c0       	rjmp	.+56     	; 0x1df2 <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x86>
__base_ctor ():
    1dba:	88 ee       	ldi	r24, 0xE8	; 232
    1dbc:	93 e0       	ldi	r25, 0x03	; 3
    1dbe:	a0 e0       	ldi	r26, 0x00	; 0
    1dc0:	b0 e0       	ldi	r27, 0x00	; 0
    1dc2:	89 83       	std	Y+1, r24	; 0x01
    1dc4:	9a 83       	std	Y+2, r25	; 0x02
    1dc6:	ab 83       	std	Y+3, r26	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:6
    start_ms = millis();
    1dc8:	bc 83       	std	Y+4, r27	; 0x04
    1dca:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
    1dce:	6d 83       	std	Y+5, r22	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:636
    }

    const TimeoutTimer timeout_timer(CTS_WAIT_MS);

    // Wait if the modem can't accept more data
    while ((VPORTC.IN & CTS_PIN_bm) && !timeout_timer.hasTimedOut()) {
    1dd0:	7e 83       	std	Y+6, r23	; 0x06
    1dd2:	8f 83       	std	Y+7, r24	; 0x07
    1dd4:	98 87       	std	Y+8, r25	; 0x08
writeBytes():
    1dd6:	54 9b       	sbis	0x0a, 4	; 10
    1dd8:	11 c0       	rjmp	.+34     	; 0x1dfc <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x90>
    1dda:	ce 01       	movw	r24, r28
    1ddc:	01 96       	adiw	r24, 0x01	; 1
    1dde:	3a d8       	rcall	.-3980   	; 0xe54 <TimeoutTimer::hasTimedOut() const>
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:187
    1de0:	81 11       	cpse	r24, r1
    1de2:	0c c0       	rjmp	.+24     	; 0x1dfc <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x90>
_delay_ms():
    1de4:	8f e6       	ldi	r24, 0x6F	; 111
    1de6:	97 e1       	ldi	r25, 0x17	; 23
    1de8:	01 97       	sbiw	r24, 0x01	; 1
    1dea:	f1 f7       	brne	.-4      	; 0x1de8 <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x7c>
    1dec:	00 c0       	rjmp	.+0      	; 0x1dee <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x82>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:628
            return;
        }
    }

    if (append_carriage_return) {
        if (!appendDataToTransmitBuffer((uint8_t)'\r')) {
    1dee:	00 00       	nop
    1df0:	f2 cf       	rjmp	.-28     	; 0x1dd6 <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x6a>
writeBytes():
    1df2:	8d e0       	ldi	r24, 0x0D	; 13
    1df4:	43 df       	rcall	.-378    	; 0x1c7c <SequansControllerClass::appendDataToTransmitBuffer(unsigned char) [clone .constprop.120]>
    1df6:	81 11       	cpse	r24, r1
    1df8:	e0 cf       	rjmp	.-64     	; 0x1dba <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x4e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:642
        _delay_ms(1);
    }

    // Only enable the data register empty interrupt (so that the data gets
    // pushed out) if the CTS line was logically low before the end of the timer
    if (!(VPORTC.IN & CTS_PIN_bm)) {
    1dfa:	d2 cf       	rjmp	.-92     	; 0x1da0 <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x34>
    1dfc:	54 99       	sbic	0x0a, 4	; 10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:643
        HWSERIALAT.CTRLA |= USART_DREIE_bm;
    1dfe:	d0 cf       	rjmp	.-96     	; 0x1da0 <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x34>
    1e00:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
    1e04:	80 62       	ori	r24, 0x20	; 32
    1e06:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:191
        }
    }
}

static void internalDisconnectCallback(char* urc_data) {
    connected_to_broker = false;
    1e0a:	ca cf       	rjmp	.-108    	; 0x1da0 <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]+0x34>

00001e0c <internalDisconnectCallback(char*)>:
internalDisconnectCallback():
    1e0c:	10 92 90 66 	sts	0x6690, r1	; 0x806690 <connected_to_broker>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:193

    SequansController.writeBytes((uint8_t*)MQTT_DISCONNECT,
    1e10:	41 e0       	ldi	r20, 0x01	; 1
    1e12:	67 e1       	ldi	r22, 0x17	; 23
    1e14:	70 e0       	ldi	r23, 0x00	; 0
    1e16:	8e e5       	ldi	r24, 0x5E	; 94
    1e18:	95 e4       	ldi	r25, 0x45	; 69
    1e1a:	a8 df       	rcall	.-176    	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:196
                                 strlen(MQTT_DISCONNECT),
                                 true);
    SequansController.clearReceiveBuffer();
    1e1c:	73 d8       	rcall	.-3866   	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
    1e1e:	e0 91 8e 66 	lds	r30, 0x668E	; 0x80668e <_ZL21disconnected_callback.lto_priv.138>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:198

    if (disconnected_callback != NULL) {
    1e22:	f0 91 8f 66 	lds	r31, 0x668F	; 0x80668f <_ZL21disconnected_callback.lto_priv.138+0x1>
    1e26:	30 97       	sbiw	r30, 0x00	; 0
    1e28:	09 f0       	breq	.+2      	; 0x1e2c <internalDisconnectCallback(char*)+0x20>
    1e2a:	09 94       	ijmp
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:199
        disconnected_callback();
    1e2c:	08 95       	ret

00001e2e <wait_for_urc_callback(char*)>:
wait_for_urc_callback():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:285
/**
 * @brief Callback for the waitForURC() function. This will copy over the URC
 * data to the wait_for_urc_buffer.
 */
static void wait_for_urc_callback(char* urc_data) {
    memcpy(wait_for_urc_buffer, urc_data, wait_for_urc_buffer_size);
    1e2e:	40 91 33 6c 	lds	r20, 0x6C33	; 0x806c33 <wait_for_urc_buffer_size>
    1e32:	50 91 34 6c 	lds	r21, 0x6C34	; 0x806c34 <wait_for_urc_buffer_size+0x1>
    1e36:	bc 01       	movw	r22, r24
    1e38:	83 eb       	ldi	r24, 0xB3	; 179
    1e3a:	9a e6       	ldi	r25, 0x6A	; 106
    1e3c:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:286
    got_wait_for_urc_callback = true;
    1e40:	81 e0       	ldi	r24, 0x01	; 1
    1e42:	80 93 35 6c 	sts	0x6C35, r24	; 0x806c35 <got_wait_for_urc_callback>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:287
}
    1e46:	08 95       	ret

00001e48 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]>:
waitForURC():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:960
            break;
        }
    }
}

bool SequansControllerClass::waitForURC(const char* urc_identifier,
    1e48:	8f 92       	push	r8
    1e4a:	9f 92       	push	r9
    1e4c:	af 92       	push	r10
    1e4e:	bf 92       	push	r11
    1e50:	cf 92       	push	r12
    1e52:	df 92       	push	r13
    1e54:	ef 92       	push	r14
    1e56:	ff 92       	push	r15
    1e58:	0f 93       	push	r16
    1e5a:	1f 93       	push	r17
    1e5c:	cf 93       	push	r28
    1e5e:	df 93       	push	r29
    1e60:	cd b7       	in	r28, 0x3d	; 61
    1e62:	de b7       	in	r29, 0x3e	; 62
    1e64:	28 97       	sbiw	r28, 0x08	; 8
    1e66:	cd bf       	out	0x3d, r28	; 61
    1e68:	de bf       	out	0x3e, r29	; 62
    1e6a:	8c 01       	movw	r16, r24
    1e6c:	5b 01       	movw	r10, r22
    1e6e:	4a 01       	movw	r8, r20
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:964
                                        char* out_buffer,
                                        const uint16_t out_buffer_size,
                                        const uint64_t timeout_ms) {
    got_wait_for_urc_callback = false;
    1e70:	10 92 35 6c 	sts	0x6C35, r1	; 0x806c35 <got_wait_for_urc_callback>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:965
    wait_for_urc_buffer_size  = out_buffer_size;
    1e74:	40 93 33 6c 	sts	0x6C33, r20	; 0x806c33 <wait_for_urc_buffer_size>
    1e78:	50 93 34 6c 	sts	0x6C34, r21	; 0x806c34 <wait_for_urc_buffer_size+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:969

    // We might hit the maximum amount of URC callbacks allowed, so return
    // if that is the case
    if (!registerCallback(urc_identifier, wait_for_urc_callback)) {
    1e7c:	41 e0       	ldi	r20, 0x01	; 1
    1e7e:	67 e1       	ldi	r22, 0x17	; 23
    1e80:	7f e0       	ldi	r23, 0x0F	; 15
    1e82:	76 de       	rcall	.-788    	; 0x1b70 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]>
    1e84:	81 11       	cpse	r24, r1
    1e86:	12 c0       	rjmp	.+36     	; 0x1eac <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]+0x64>
    1e88:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:970
        return false;
    1e8a:	81 2f       	mov	r24, r17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:994

        return true;
    } else {
        return false;
    }
}
    1e8c:	28 96       	adiw	r28, 0x08	; 8
    1e8e:	cd bf       	out	0x3d, r28	; 61
    1e90:	de bf       	out	0x3e, r29	; 62
    1e92:	df 91       	pop	r29
    1e94:	cf 91       	pop	r28
    1e96:	1f 91       	pop	r17
    1e98:	0f 91       	pop	r16
    1e9a:	ff 90       	pop	r15
    1e9c:	ef 90       	pop	r14
    1e9e:	df 90       	pop	r13
    1ea0:	cf 90       	pop	r12
    1ea2:	bf 90       	pop	r11
    1ea4:	af 90       	pop	r10
    1ea6:	9f 90       	pop	r9
    1ea8:	8f 90       	pop	r8
    1eaa:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:973
    // if that is the case
    if (!registerCallback(urc_identifier, wait_for_urc_callback)) {
        return false;
    }

    TimeoutTimer timeout_timer(timeout_ms);
    1eac:	c9 82       	std	Y+1, r12	; 0x01
    1eae:	da 82       	std	Y+2, r13	; 0x02
    1eb0:	eb 82       	std	Y+3, r14	; 0x03
    1eb2:	fc 82       	std	Y+4, r15	; 0x04
__base_ctor ():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:6
    1eb4:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
    1eb8:	6d 83       	std	Y+5, r22	; 0x05
    1eba:	7e 83       	std	Y+6, r23	; 0x06
    1ebc:	8f 83       	std	Y+7, r24	; 0x07
    1ebe:	98 87       	std	Y+8, r25	; 0x08
waitForURC():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:975

    while (!got_wait_for_urc_callback && !timeout_timer.hasTimedOut()) {
    1ec0:	80 91 35 6c 	lds	r24, 0x6C35	; 0x806c35 <got_wait_for_urc_callback>
    1ec4:	81 11       	cpse	r24, r1
    1ec6:	0f c0       	rjmp	.+30     	; 0x1ee6 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]+0x9e>
    1ec8:	ce 01       	movw	r24, r28
    1eca:	01 96       	adiw	r24, 0x01	; 1
    1ecc:	0e 94 2a 07 	call	0xe54	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    1ed0:	81 11       	cpse	r24, r1
    1ed2:	09 c0       	rjmp	.+18     	; 0x1ee6 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]+0x9e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:978
        // We update the CTS here in case the CTS interrupt didn't catch the
        // falling flank
        ctsUpdate();
    1ed4:	0e 94 5d 07 	call	0xeba	; 0xeba <ctsUpdate()>
_delay_ms():
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:187
    1ed8:	8f e6       	ldi	r24, 0x6F	; 111
    1eda:	97 e1       	ldi	r25, 0x17	; 23
    1edc:	01 97       	sbiw	r24, 0x01	; 1
    1ede:	f1 f7       	brne	.-4      	; 0x1edc <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]+0x94>
    1ee0:	00 c0       	rjmp	.+0      	; 0x1ee2 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]+0x9a>
    1ee2:	00 00       	nop
    1ee4:	ed cf       	rjmp	.-38     	; 0x1ec0 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]+0x78>
waitForURC():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:983

        _delay_ms(1);
    }

    unregisterCallback(urc_identifier);
    1ee6:	c8 01       	movw	r24, r16
    1ee8:	e9 dd       	rcall	.-1070   	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
    1eea:	10 91 35 6c 	lds	r17, 0x6C35	; 0x806c35 <got_wait_for_urc_callback>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:985

    if (got_wait_for_urc_callback) {
    1eee:	11 23       	and	r17, r17
    1ef0:	59 f2       	breq	.-106    	; 0x1e88 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]+0x40>
    1ef2:	a1 14       	cp	r10, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:986
        if (out_buffer != NULL) {
    1ef4:	b1 04       	cpc	r11, r1
    1ef6:	49 f2       	breq	.-110    	; 0x1e8a <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]+0x42>
    1ef8:	a4 01       	movw	r20, r8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:987
            memcpy(out_buffer, wait_for_urc_buffer, out_buffer_size);
    1efa:	63 eb       	ldi	r22, 0xB3	; 179
    1efc:	7a e6       	ldi	r23, 0x6A	; 106
    1efe:	c5 01       	movw	r24, r10
    1f00:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
    1f04:	c2 cf       	rjmp	.-124    	; 0x1e8a <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]+0x42>

00001f06 <cJSON_strdup.isra.1.constprop.110>:
cJSON_strdup.isra.1():
    1f06:	ef 92       	push	r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:188
/* strlen of character literals resolved at compile time */
#define static_strlen(string_literal) (sizeof(string_literal) - sizeof(""))

static internal_hooks global_hooks = { internal_malloc, internal_free, internal_realloc };

static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
    1f08:	ff 92       	push	r15
    1f0a:	0f 93       	push	r16
    1f0c:	1f 93       	push	r17
    1f0e:	cf 93       	push	r28
    1f10:	df 93       	push	r29
    1f12:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:195
    size_t length = 0;
    unsigned char *copy = NULL;

    if (string == NULL)
    {
        return NULL;
    1f14:	00 e0       	ldi	r16, 0x00	; 0
    1f16:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:193
static unsigned char* cJSON_strdup(const unsigned char* string, const internal_hooks * const hooks)
{
    size_t length = 0;
    unsigned char *copy = NULL;

    if (string == NULL)
    1f18:	a9 f0       	breq	.+42     	; 0x1f44 <cJSON_strdup.isra.1.constprop.110+0x3e>
    1f1a:	ec 01       	movw	r28, r24
    1f1c:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:198
    {
        return NULL;
    }

    length = strlen((const char*)string) + sizeof("");
    1f1e:	01 90       	ld	r0, Z+
    1f20:	00 20       	and	r0, r0
    1f22:	e9 f7       	brne	.-6      	; 0x1f1e <cJSON_strdup.isra.1.constprop.110+0x18>
    1f24:	7f 01       	movw	r14, r30
    1f26:	e8 1a       	sub	r14, r24
    1f28:	f9 0a       	sbc	r15, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:199
    copy = (unsigned char*)hooks->allocate(length);
    1f2a:	e0 91 02 42 	lds	r30, 0x4202	; 0x804202 <global_hooks>
    1f2e:	f0 91 03 42 	lds	r31, 0x4203	; 0x804203 <global_hooks+0x1>
    1f32:	c7 01       	movw	r24, r14
    1f34:	09 95       	icall
    1f36:	8c 01       	movw	r16, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:200
    if (copy == NULL)
    1f38:	00 97       	sbiw	r24, 0x00	; 0
    1f3a:	21 f0       	breq	.+8      	; 0x1f44 <cJSON_strdup.isra.1.constprop.110+0x3e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:204
    {
        return NULL;
    }
    memcpy(copy, string, length);
    1f3c:	a7 01       	movw	r20, r14
    1f3e:	be 01       	movw	r22, r28
    1f40:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:207

    return copy;
}
    1f44:	c8 01       	movw	r24, r16
    1f46:	df 91       	pop	r29
    1f48:	cf 91       	pop	r28
    1f4a:	1f 91       	pop	r17
    1f4c:	0f 91       	pop	r16
    1f4e:	ff 90       	pop	r15
    1f50:	ef 90       	pop	r14
    1f52:	08 95       	ret

00001f54 <add_item_to_object.constprop.108>:
add_item_to_object():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2007
#if defined(__clang__) || (defined(__GNUC__)  && ((__GNUC__ > 4) || ((__GNUC__ == 4) && (__GNUC_MINOR__ > 5))))
    #pragma GCC diagnostic pop
#endif


static cJSON_bool add_item_to_object(cJSON * const object, const char * const string, cJSON * const item, const internal_hooks * const hooks, const cJSON_bool constant_key)
    1f54:	cf 92       	push	r12
    1f56:	df 92       	push	r13
    1f58:	ef 92       	push	r14
    1f5a:	ff 92       	push	r15
    1f5c:	0f 93       	push	r16
    1f5e:	1f 93       	push	r17
    1f60:	cf 93       	push	r28
    1f62:	df 93       	push	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2012
{
    char *new_key = NULL;
    int new_type = cJSON_Invalid;

    if ((object == NULL) || (string == NULL) || (item == NULL) || (object == item))
    1f64:	00 97       	sbiw	r24, 0x00	; 0
    1f66:	81 f1       	breq	.+96     	; 0x1fc8 <add_item_to_object.constprop.108+0x74>
    1f68:	61 15       	cp	r22, r1
    1f6a:	71 05       	cpc	r23, r1
    1f6c:	69 f1       	breq	.+90     	; 0x1fc8 <add_item_to_object.constprop.108+0x74>
    1f6e:	41 15       	cp	r20, r1
    1f70:	51 05       	cpc	r21, r1
    1f72:	51 f1       	breq	.+84     	; 0x1fc8 <add_item_to_object.constprop.108+0x74>
    1f74:	84 17       	cp	r24, r20
    1f76:	95 07       	cpc	r25, r21
    1f78:	39 f1       	breq	.+78     	; 0x1fc8 <add_item_to_object.constprop.108+0x74>
    1f7a:	ea 01       	movw	r28, r20
    1f7c:	8c 01       	movw	r16, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2024
        new_key = (char*)cast_away_const(string);
        new_type = item->type | cJSON_StringIsConst;
    }
    else
    {
        new_key = (char*)cJSON_strdup((const unsigned char*)string, hooks);
    1f7e:	cb 01       	movw	r24, r22
    1f80:	c2 df       	rcall	.-124    	; 0x1f06 <cJSON_strdup.isra.1.constprop.110>
    1f82:	7c 01       	movw	r14, r24
    1f84:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2025
        if (new_key == NULL)
    1f86:	01 f1       	breq	.+64     	; 0x1fc8 <add_item_to_object.constprop.108+0x74>
    1f88:	8e 81       	ldd	r24, Y+6	; 0x06
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2030
        {
            return false;
        }

        new_type = item->type & ~cJSON_StringIsConst;
    1f8a:	9f 81       	ldd	r25, Y+7	; 0x07
    1f8c:	6c 01       	movw	r12, r24
    1f8e:	e8 94       	clt
    1f90:	d1 f8       	bld	r13, 1
    1f92:	91 fd       	sbrc	r25, 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2033
    }

    if (!(item->type & cJSON_StringIsConst) && (item->string != NULL))
    1f94:	09 c0       	rjmp	.+18     	; 0x1fa8 <add_item_to_object.constprop.108+0x54>
    1f96:	88 89       	ldd	r24, Y+16	; 0x10
    1f98:	99 89       	ldd	r25, Y+17	; 0x11
    1f9a:	00 97       	sbiw	r24, 0x00	; 0
    1f9c:	29 f0       	breq	.+10     	; 0x1fa8 <add_item_to_object.constprop.108+0x54>
    1f9e:	e0 91 04 42 	lds	r30, 0x4204	; 0x804204 <global_hooks+0x2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2035
    {
        hooks->deallocate(item->string);
    1fa2:	f0 91 05 42 	lds	r31, 0x4205	; 0x804205 <global_hooks+0x3>
    1fa6:	09 95       	icall
    1fa8:	e8 8a       	std	Y+16, r14	; 0x10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2038
    }

    item->string = new_key;
    1faa:	f9 8a       	std	Y+17, r15	; 0x11
    1fac:	ce 82       	std	Y+6, r12	; 0x06
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2039
    item->type = new_type;
    1fae:	df 82       	std	Y+7, r13	; 0x07
    1fb0:	be 01       	movw	r22, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2041

    return add_item_to_array(object, item);
    1fb2:	c8 01       	movw	r24, r16
    1fb4:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2042
}
    1fb6:	cf 91       	pop	r28
    1fb8:	1f 91       	pop	r17
    1fba:	0f 91       	pop	r16
    1fbc:	ff 90       	pop	r15
    1fbe:	ef 90       	pop	r14
    1fc0:	df 90       	pop	r13
    1fc2:	cf 90       	pop	r12
    1fc4:	0c 94 20 05 	jmp	0xa40	; 0xa40 <add_item_to_array>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2041
    }

    item->string = new_key;
    item->type = new_type;

    return add_item_to_array(object, item);
    1fc8:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2042
}
    1fca:	80 e0       	ldi	r24, 0x00	; 0
    1fcc:	df 91       	pop	r29
    1fce:	cf 91       	pop	r28
    1fd0:	1f 91       	pop	r17
    1fd2:	0f 91       	pop	r16
    1fd4:	ff 90       	pop	r15
    1fd6:	ef 90       	pop	r14
    1fd8:	df 90       	pop	r13
    1fda:	cf 90       	pop	r12
    1fdc:	08 95       	ret

00001fde <iotcl_strdup>:
iotcl_strdup():
    1fde:	ef 92       	push	r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:26

const char *iotcl_iso_timestamp_now(void) {
    return to_iso_timestamp(NULL);
}

char *iotcl_strdup(const char *str) {
    1fe0:	ff 92       	push	r15
    1fe2:	0f 93       	push	r16
    1fe4:	1f 93       	push	r17
    1fe6:	cf 93       	push	r28
    1fe8:	df 93       	push	r29
    1fea:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:28
    if (!str) {
        return NULL;
    1fec:	00 e0       	ldi	r16, 0x00	; 0
    1fee:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:27
const char *iotcl_iso_timestamp_now(void) {
    return to_iso_timestamp(NULL);
}

char *iotcl_strdup(const char *str) {
    if (!str) {
    1ff0:	91 f0       	breq	.+36     	; 0x2016 <iotcl_strdup+0x38>
    1ff2:	ec 01       	movw	r28, r24
    1ff4:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:30
        return NULL;
    }
    size_t size = strlen(str) + 1;
    1ff6:	01 90       	ld	r0, Z+
    1ff8:	00 20       	and	r0, r0
    1ffa:	e9 f7       	brne	.-6      	; 0x1ff6 <iotcl_strdup+0x18>
    1ffc:	7f 01       	movw	r14, r30
    1ffe:	e8 1a       	sub	r14, r24
    2000:	f9 0a       	sbc	r15, r25
    2002:	c7 01       	movw	r24, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:31
    char *p = (char *) malloc(size);
    2004:	0e 94 b8 54 	call	0xa970	; 0xa970 <malloc>
    2008:	8c 01       	movw	r16, r24
    200a:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:32
    if (p != NULL) {
    200c:	21 f0       	breq	.+8      	; 0x2016 <iotcl_strdup+0x38>
    200e:	a7 01       	movw	r20, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:33
        memcpy(p, str, size);
    2010:	be 01       	movw	r22, r28
    2012:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
    2016:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:36
    }
    return p;
}
    2018:	df 91       	pop	r29
    201a:	cf 91       	pop	r28
    201c:	1f 91       	pop	r17
    201e:	0f 91       	pop	r16
    2020:	ff 90       	pop	r15
    2022:	ef 90       	pop	r14
    2024:	08 95       	ret

00002026 <ensure>:
ensure():
    2026:	ef 92       	push	r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:440
    internal_hooks hooks;
} printbuffer;

/* realloc printbuffer if necessary to have at least "needed" bytes more */
static unsigned char* ensure(printbuffer * const p, size_t needed)
{
    2028:	ff 92       	push	r15
    202a:	0f 93       	push	r16
    202c:	1f 93       	push	r17
    202e:	cf 93       	push	r28
    2030:	df 93       	push	r29
    2032:	ec 01       	movw	r28, r24
    2034:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:444
    unsigned char *newbuffer = NULL;
    size_t newsize = 0;

    if ((p == NULL) || (p->buffer == NULL))
    2036:	89 f1       	breq	.+98     	; 0x209a <ensure+0x74>
    2038:	08 81       	ld	r16, Y
    203a:	19 81       	ldd	r17, Y+1	; 0x01
    203c:	01 15       	cp	r16, r1
    203e:	11 05       	cpc	r17, r1
    2040:	b1 f0       	breq	.+44     	; 0x206e <ensure+0x48>
    2042:	8a 81       	ldd	r24, Y+2	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:449
    {
        return NULL;
    }

    if ((p->length > 0) && (p->offset >= p->length))
    2044:	9b 81       	ldd	r25, Y+3	; 0x03
    2046:	00 97       	sbiw	r24, 0x00	; 0
    2048:	29 f0       	breq	.+10     	; 0x2054 <ensure+0x2e>
    204a:	2c 81       	ldd	r18, Y+4	; 0x04
    204c:	3d 81       	ldd	r19, Y+5	; 0x05
    204e:	28 17       	cp	r18, r24
    2050:	39 07       	cpc	r19, r25
    2052:	18 f5       	brcc	.+70     	; 0x209a <ensure+0x74>
    2054:	77 fd       	sbrc	r23, 7
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:455
    {
        /* make sure that offset is valid */
        return NULL;
    }

    if (needed > INT_MAX)
    2056:	21 c0       	rjmp	.+66     	; 0x209a <ensure+0x74>
    2058:	2c 81       	ldd	r18, Y+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:461
    {
        /* sizes bigger than INT_MAX are currently not supported */
        return NULL;
    }

    needed += p->offset + 1;
    205a:	3d 81       	ldd	r19, Y+5	; 0x05
    205c:	6f 5f       	subi	r22, 0xFF	; 255
    205e:	7f 4f       	sbci	r23, 0xFF	; 255
    2060:	62 0f       	add	r22, r18
    2062:	73 1f       	adc	r23, r19
    2064:	86 17       	cp	r24, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:462
    if (needed <= p->length)
    2066:	97 07       	cpc	r25, r23
    2068:	50 f0       	brcs	.+20     	; 0x207e <ensure+0x58>
    206a:	02 0f       	add	r16, r18
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:464
    {
        return p->buffer + p->offset;
    206c:	13 1f       	adc	r17, r19
    206e:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:522
    }
    p->length = newsize;
    p->buffer = newbuffer;

    return newbuffer + p->offset;
}
    2070:	df 91       	pop	r29
    2072:	cf 91       	pop	r28
    2074:	1f 91       	pop	r17
    2076:	0f 91       	pop	r16
    2078:	ff 90       	pop	r15
    207a:	ef 90       	pop	r14
    207c:	08 95       	ret
    207e:	88 85       	ldd	r24, Y+8	; 0x08
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:467
    if (needed <= p->length)
    {
        return p->buffer + p->offset;
    }

    if (p->noalloc) {
    2080:	99 85       	ldd	r25, Y+9	; 0x09
    2082:	89 2b       	or	r24, r25
    2084:	51 f4       	brne	.+20     	; 0x209a <ensure+0x74>
    2086:	61 15       	cp	r22, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:472
        return NULL;
    }

    /* calculate new buffer size */
    if (needed > (INT_MAX / 2))
    2088:	80 e4       	ldi	r24, 0x40	; 64
    208a:	78 07       	cpc	r23, r24
    208c:	48 f0       	brcs	.+18     	; 0x20a0 <ensure+0x7a>
    208e:	ee 24       	eor	r14, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:477
    {
        /* overflow of int, use INT_MAX if possible */
        if (needed <= INT_MAX)
        {
            newsize = INT_MAX;
    2090:	ea 94       	dec	r14
    2092:	8f e7       	ldi	r24, 0x7F	; 127
    2094:	f8 2e       	mov	r15, r24
    2096:	77 ff       	sbrs	r23, 7
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:475

    /* calculate new buffer size */
    if (needed > (INT_MAX / 2))
    {
        /* overflow of int, use INT_MAX if possible */
        if (needed <= INT_MAX)
    2098:	06 c0       	rjmp	.+12     	; 0x20a6 <ensure+0x80>
    209a:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:446
    unsigned char *newbuffer = NULL;
    size_t newsize = 0;

    if ((p == NULL) || (p->buffer == NULL))
    {
        return NULL;
    209c:	00 e0       	ldi	r16, 0x00	; 0
    209e:	e7 cf       	rjmp	.-50     	; 0x206e <ensure+0x48>
    20a0:	7b 01       	movw	r14, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:486
            return NULL;
        }
    }
    else
    {
        newsize = needed * 2;
    20a2:	ee 0c       	add	r14, r14
    20a4:	ff 1c       	adc	r15, r15
    20a6:	e8 89       	ldd	r30, Y+16	; 0x10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:489
    }

    if (p->hooks.reallocate != NULL)
    20a8:	f9 89       	ldd	r31, Y+17	; 0x11
    20aa:	30 97       	sbiw	r30, 0x00	; 0
    20ac:	81 f0       	breq	.+32     	; 0x20ce <ensure+0xa8>
    20ae:	b7 01       	movw	r22, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:492
    {
        /* reallocate with realloc if available */
        newbuffer = (unsigned char*)p->hooks.reallocate(p->buffer, newsize);
    20b0:	c8 01       	movw	r24, r16
    20b2:	09 95       	icall
    20b4:	8c 01       	movw	r16, r24
    20b6:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:493
        if (newbuffer == NULL)
    20b8:	21 f5       	brne	.+72     	; 0x2102 <ensure+0xdc>
    20ba:	ee 85       	ldd	r30, Y+14	; 0x0e
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:495
        {
            p->hooks.deallocate(p->buffer);
    20bc:	ff 85       	ldd	r31, Y+15	; 0x0f
    20be:	88 81       	ld	r24, Y
    20c0:	99 81       	ldd	r25, Y+1	; 0x01
    20c2:	09 95       	icall
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:508
    {
        /* otherwise reallocate manually */
        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
        if (!newbuffer)
        {
            p->hooks.deallocate(p->buffer);
    20c4:	1a 82       	std	Y+2, r1	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:509
            p->length = 0;
    20c6:	1b 82       	std	Y+3, r1	; 0x03
    20c8:	18 82       	st	Y, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:510
            p->buffer = NULL;
    20ca:	19 82       	std	Y+1, r1	; 0x01
    20cc:	d0 cf       	rjmp	.-96     	; 0x206e <ensure+0x48>
    20ce:	ec 85       	ldd	r30, Y+12	; 0x0c
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:505
        }
    }
    else
    {
        /* otherwise reallocate manually */
        newbuffer = (unsigned char*)p->hooks.allocate(newsize);
    20d0:	fd 85       	ldd	r31, Y+13	; 0x0d
    20d2:	c7 01       	movw	r24, r14
    20d4:	09 95       	icall
    20d6:	8c 01       	movw	r16, r24
    20d8:	88 81       	ld	r24, Y
    20da:	99 81       	ldd	r25, Y+1	; 0x01
    20dc:	01 15       	cp	r16, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:506
        if (!newbuffer)
    20de:	11 05       	cpc	r17, r1
    20e0:	19 f4       	brne	.+6      	; 0x20e8 <ensure+0xc2>
    20e2:	ee 85       	ldd	r30, Y+14	; 0x0e
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:508
        {
            p->hooks.deallocate(p->buffer);
    20e4:	ff 85       	ldd	r31, Y+15	; 0x0f
    20e6:	ed cf       	rjmp	.-38     	; 0x20c2 <ensure+0x9c>
    20e8:	4c 81       	ldd	r20, Y+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:515
            p->buffer = NULL;

            return NULL;
        }
        
        memcpy(newbuffer, p->buffer, p->offset + 1);
    20ea:	5d 81       	ldd	r21, Y+5	; 0x05
    20ec:	4f 5f       	subi	r20, 0xFF	; 255
    20ee:	5f 4f       	sbci	r21, 0xFF	; 255
    20f0:	bc 01       	movw	r22, r24
    20f2:	c8 01       	movw	r24, r16
    20f4:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
    20f8:	ee 85       	ldd	r30, Y+14	; 0x0e
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:516
        p->hooks.deallocate(p->buffer);
    20fa:	ff 85       	ldd	r31, Y+15	; 0x0f
    20fc:	88 81       	ld	r24, Y
    20fe:	99 81       	ldd	r25, Y+1	; 0x01
    2100:	09 95       	icall
    2102:	ea 82       	std	Y+2, r14	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:518
    }
    p->length = newsize;
    2104:	fb 82       	std	Y+3, r15	; 0x03
    2106:	08 83       	st	Y, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:519
    p->buffer = newbuffer;
    2108:	19 83       	std	Y+1, r17	; 0x01
    210a:	8c 81       	ldd	r24, Y+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:521

    return newbuffer + p->offset;
    210c:	9d 81       	ldd	r25, Y+5	; 0x05
    210e:	08 0f       	add	r16, r24
    2110:	19 1f       	adc	r17, r25
    2112:	ad cf       	rjmp	.-166    	; 0x206e <ensure+0x48>

00002114 <append_iotconnect_blank_record(DataHeaderUnion*, unsigned int, unsigned int)>:
append_iotconnect_blank_record():
    2114:	0f 93       	push	r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:88

static char* ecchdr_data_ptr(DataHeaderUnion* h) {
    return ((char*)h) + sizeof(DataHeaderUnion);
}

static DataHeaderUnion* append_iotconnect_blank_record(DataHeaderUnion* h, uint16_t type,  size_t data_size) {
    2116:	1f 93       	push	r17
    2118:	cf 93       	push	r28
    211a:	df 93       	push	r29
    211c:	8c 01       	movw	r16, r24
    211e:	ec 01       	movw	r28, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:90
    uint16_t this_header_offset = (char*) h - data_cache;
    h->header.next =  this_header_offset + sizeof(DataHeaderUnion) + (uint16_t) data_size;
    2120:	c4 0f       	add	r28, r20
    2122:	d5 1f       	adc	r29, r21
    2124:	c2 55       	subi	r28, 0x52	; 82
    2126:	d4 46       	sbci	r29, 0x64	; 100
    2128:	f8 01       	movw	r30, r16
    212a:	c0 83       	st	Z, r28
    212c:	86 2f       	mov	r24, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:91
    h->header.type = type;
    212e:	88 0f       	add	r24, r24
    2130:	6d 2f       	mov	r22, r29
    2132:	61 70       	andi	r22, 0x01	; 1
    2134:	68 2b       	or	r22, r24
    2136:	61 83       	std	Z+1, r22	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:92
    memset(ecchdr_data_ptr(h), 0, data_size);
    2138:	70 e0       	ldi	r23, 0x00	; 0
    213a:	60 e0       	ldi	r22, 0x00	; 0
    213c:	c8 01       	movw	r24, r16
    213e:	02 96       	adiw	r24, 0x02	; 2
    2140:	0e 94 d7 56 	call	0xadae	; 0xadae <memset>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:79
    return (h->header.next - this_header_offset - sizeof(DataHeaderUnion));
}

static DataHeaderUnion* ecchdr_next(DataHeaderUnion* h) {
    if (!h) {
        return (DataHeaderUnion*) data_cache;
    2144:	84 e5       	ldi	r24, 0x54	; 84
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:78
    uint16_t this_header_offset = (char*) h - data_cache;
    return (h->header.next - this_header_offset - sizeof(DataHeaderUnion));
}

static DataHeaderUnion* ecchdr_next(DataHeaderUnion* h) {
    if (!h) {
    2146:	94 e6       	ldi	r25, 0x64	; 100
ecchdr_next():
    2148:	01 2b       	or	r16, r17
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:81
        return (DataHeaderUnion*) data_cache;
    }
    return (DataHeaderUnion*) &data_cache[h->header.next];
    214a:	21 f0       	breq	.+8      	; 0x2154 <append_iotconnect_blank_record(DataHeaderUnion*, unsigned int, unsigned int)+0x40>
    214c:	ce 01       	movw	r24, r28
    214e:	91 70       	andi	r25, 0x01	; 1
    2150:	8c 5a       	subi	r24, 0xAC	; 172
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:94
    uint16_t this_header_offset = (char*) h - data_cache;
    h->header.next =  this_header_offset + sizeof(DataHeaderUnion) + (uint16_t) data_size;
    h->header.type = type;
    memset(ecchdr_data_ptr(h), 0, data_size);
    return ecchdr_next(h);
}
    2152:	9b 49       	sbci	r25, 0x9B	; 155
append_iotconnect_blank_record():
    2154:	df 91       	pop	r29
    2156:	cf 91       	pop	r28
    2158:	1f 91       	pop	r17
    215a:	0f 91       	pop	r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:241
        global_hooks.reallocate = realloc;
    }
}

/* Internal constructor. */
static cJSON *cJSON_New_Item(const internal_hooks * const hooks)
    215c:	08 95       	ret

0000215e <cJSON_New_Item.isra.5>:
cJSON_New_Item.isra.5():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:243
{
    cJSON* node = (cJSON*)hooks->allocate(sizeof(cJSON));
    215e:	fc 01       	movw	r30, r24
    2160:	82 e1       	ldi	r24, 0x12	; 18
    2162:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:244
    if (node)
    2164:	09 95       	icall
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:246
    {
        memset(node, '\0', sizeof(cJSON));
    2166:	00 97       	sbiw	r24, 0x00	; 0
    2168:	29 f0       	breq	.+10     	; 0x2174 <cJSON_New_Item.isra.5+0x16>
    216a:	22 e1       	ldi	r18, 0x12	; 18
    216c:	fc 01       	movw	r30, r24
    216e:	11 92       	st	Z+, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:250
    }

    return node;
}
    2170:	2a 95       	dec	r18
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2171

    cJSON_Delete(object_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
    2172:	e9 f7       	brne	.-6      	; 0x216e <cJSON_New_Item.isra.5+0x10>
    2174:	08 95       	ret

00002176 <cJSON_AddArrayToObject.constprop.82>:
cJSON_AddArrayToObject():
    2176:	0f 93       	push	r16
    2178:	1f 93       	push	r17
    217a:	cf 93       	push	r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2515
    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateArray(void)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    217c:	df 93       	push	r29
    217e:	8c 01       	movw	r16, r24
cJSON_CreateArray():
    2180:	80 91 02 42 	lds	r24, 0x4202	; 0x804202 <global_hooks>
    2184:	90 91 03 42 	lds	r25, 0x4203	; 0x804203 <global_hooks+0x1>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2516
    if(item)
    2188:	ea df       	rcall	.-44     	; 0x215e <cJSON_New_Item.isra.5>
    218a:	ec 01       	movw	r28, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2518
    {
        item->type=cJSON_Array;
    218c:	89 2b       	or	r24, r25
    218e:	21 f0       	breq	.+8      	; 0x2198 <cJSON_AddArrayToObject.constprop.82+0x22>
    2190:	80 e2       	ldi	r24, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2174
}

CJSON_PUBLIC(cJSON*) cJSON_AddArrayToObject(cJSON * const object, const char * const name)
{
    cJSON *array = cJSON_CreateArray();
    if (add_item_to_object(object, name, array, &global_hooks, false))
    2192:	90 e0       	ldi	r25, 0x00	; 0
    2194:	8e 83       	std	Y+6, r24	; 0x06
    2196:	9f 83       	std	Y+7, r25	; 0x07
cJSON_AddArrayToObject():
    2198:	ae 01       	movw	r20, r28
    219a:	65 e8       	ldi	r22, 0x85	; 133
    219c:	76 e4       	ldi	r23, 0x46	; 70
    219e:	c8 01       	movw	r24, r16
    21a0:	d9 de       	rcall	.-590    	; 0x1f54 <add_item_to_object.constprop.108>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2179
    {
        return array;
    }

    cJSON_Delete(array);
    21a2:	89 2b       	or	r24, r25
    21a4:	29 f4       	brne	.+10     	; 0x21b0 <cJSON_AddArrayToObject.constprop.82+0x3a>
    21a6:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2180
    return NULL;
    21a8:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2181
}
    21ac:	d0 e0       	ldi	r29, 0x00	; 0
    21ae:	c0 e0       	ldi	r28, 0x00	; 0
    21b0:	ce 01       	movw	r24, r28
    21b2:	df 91       	pop	r29
    21b4:	cf 91       	pop	r28
    21b6:	1f 91       	pop	r17
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2526
    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateObject(void)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    21b8:	0f 91       	pop	r16
    21ba:	08 95       	ret

000021bc <cJSON_CreateObject>:
cJSON_CreateObject():
    21bc:	80 91 02 42 	lds	r24, 0x4202	; 0x804202 <global_hooks>
    21c0:	90 91 03 42 	lds	r25, 0x4203	; 0x804203 <global_hooks+0x1>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2527
    if (item)
    21c4:	cc df       	rcall	.-104    	; 0x215e <cJSON_New_Item.isra.5>
    21c6:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2529
    {
        item->type = cJSON_Object;
    21c8:	29 f0       	breq	.+10     	; 0x21d4 <cJSON_CreateObject+0x18>
    21ca:	20 e4       	ldi	r18, 0x40	; 64
    21cc:	30 e0       	ldi	r19, 0x00	; 0
    21ce:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2533
    }

    return item;
}
    21d0:	26 83       	std	Z+6, r18	; 0x06
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2160
    cJSON_Delete(raw_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddObjectToObject(cJSON * const object, const char * const name)
{
    21d2:	37 83       	std	Z+7, r19	; 0x07
    21d4:	08 95       	ret

000021d6 <cJSON_AddObjectToObject>:
cJSON_AddObjectToObject():
    21d6:	ef 92       	push	r14
    21d8:	ff 92       	push	r15
    21da:	0f 93       	push	r16
    21dc:	1f 93       	push	r17
    21de:	cf 93       	push	r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2161
    cJSON *object_item = cJSON_CreateObject();
    21e0:	df 93       	push	r29
    21e2:	8c 01       	movw	r16, r24
    21e4:	7b 01       	movw	r14, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2162
    if (add_item_to_object(object, name, object_item, &global_hooks, false))
    21e6:	ea df       	rcall	.-44     	; 0x21bc <cJSON_CreateObject>
    21e8:	ec 01       	movw	r28, r24
    21ea:	ac 01       	movw	r20, r24
    21ec:	b7 01       	movw	r22, r14
    21ee:	c8 01       	movw	r24, r16
    21f0:	b1 de       	rcall	.-670    	; 0x1f54 <add_item_to_object.constprop.108>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2167
    {
        return object_item;
    }

    cJSON_Delete(object_item);
    21f2:	89 2b       	or	r24, r25
    21f4:	29 f4       	brne	.+10     	; 0x2200 <cJSON_AddObjectToObject+0x2a>
    21f6:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2168
    return NULL;
    21f8:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2169
}
    21fc:	d0 e0       	ldi	r29, 0x00	; 0
    21fe:	c0 e0       	ldi	r28, 0x00	; 0
    2200:	ce 01       	movw	r24, r28
    2202:	df 91       	pop	r29
    2204:	cf 91       	pop	r28
    2206:	1f 91       	pop	r17
    2208:	0f 91       	pop	r16
    220a:	ff 90       	pop	r15
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2136
    cJSON_Delete(number_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
{
    220c:	ef 90       	pop	r14
    220e:	08 95       	ret

00002210 <cJSON_AddStringToObject>:
cJSON_AddStringToObject():
    2210:	cf 92       	push	r12
    2212:	df 92       	push	r13
    2214:	ef 92       	push	r14
    2216:	ff 92       	push	r15
    2218:	0f 93       	push	r16
    221a:	1f 93       	push	r17
    221c:	cf 93       	push	r28
    221e:	df 93       	push	r29
    2220:	8c 01       	movw	r16, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2448
    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateString(const char *string)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    2222:	7b 01       	movw	r14, r22
    2224:	6a 01       	movw	r12, r20
cJSON_CreateString():
    2226:	80 91 02 42 	lds	r24, 0x4202	; 0x804202 <global_hooks>
    222a:	90 91 03 42 	lds	r25, 0x4203	; 0x804203 <global_hooks+0x1>
    222e:	97 df       	rcall	.-210    	; 0x215e <cJSON_New_Item.isra.5>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2449
    if(item)
    2230:	ec 01       	movw	r28, r24
    2232:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2451
    {
        item->type = cJSON_String;
    2234:	79 f0       	breq	.+30     	; 0x2254 <cJSON_AddStringToObject+0x44>
    2236:	80 e1       	ldi	r24, 0x10	; 16
    2238:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2452
        item->valuestring = (char*)cJSON_strdup((const unsigned char*)string, &global_hooks);
    223a:	8e 83       	std	Y+6, r24	; 0x06
    223c:	9f 83       	std	Y+7, r25	; 0x07
    223e:	c6 01       	movw	r24, r12
    2240:	62 de       	rcall	.-828    	; 0x1f06 <cJSON_strdup.isra.1.constprop.110>
    2242:	88 87       	std	Y+8, r24	; 0x08
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2453
        if(!item->valuestring)
    2244:	99 87       	std	Y+9, r25	; 0x09
    2246:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2455
        {
            cJSON_Delete(item);
    2248:	29 f4       	brne	.+10     	; 0x2254 <cJSON_AddStringToObject+0x44>
    224a:	ce 01       	movw	r24, r28
    224c:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
cJSON_AddStringToObject():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2456
            return NULL;
    2250:	d0 e0       	ldi	r29, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2138
}

CJSON_PUBLIC(cJSON*) cJSON_AddStringToObject(cJSON * const object, const char * const name, const char * const string)
{
    cJSON *string_item = cJSON_CreateString(string);
    if (add_item_to_object(object, name, string_item, &global_hooks, false))
    2252:	c0 e0       	ldi	r28, 0x00	; 0
    2254:	ae 01       	movw	r20, r28
    2256:	b7 01       	movw	r22, r14
    2258:	c8 01       	movw	r24, r16
    225a:	7c de       	rcall	.-776    	; 0x1f54 <add_item_to_object.constprop.108>
    225c:	89 2b       	or	r24, r25
    225e:	29 f4       	brne	.+10     	; 0x226a <cJSON_AddStringToObject+0x5a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2143
    {
        return string_item;
    }

    cJSON_Delete(string_item);
    2260:	ce 01       	movw	r24, r28
    2262:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2144
    return NULL;
    2266:	d0 e0       	ldi	r29, 0x00	; 0
    2268:	c0 e0       	ldi	r28, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2145
}
    226a:	ce 01       	movw	r24, r28
    226c:	df 91       	pop	r29
    226e:	cf 91       	pop	r28
    2270:	1f 91       	pop	r17
    2272:	0f 91       	pop	r16
    2274:	ff 90       	pop	r15
    2276:	ef 90       	pop	r14
    2278:	df 90       	pop	r13
    227a:	cf 90       	pop	r12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2124
    cJSON_Delete(bool_item);
    return NULL;
}

CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
{
    227c:	08 95       	ret

0000227e <cJSON_AddNumberToObject>:
cJSON_AddNumberToObject():
    227e:	af 92       	push	r10
    2280:	bf 92       	push	r11
    2282:	cf 92       	push	r12
    2284:	df 92       	push	r13
    2286:	ef 92       	push	r14
    2288:	ff 92       	push	r15
    228a:	0f 93       	push	r16
    228c:	1f 93       	push	r17
    228e:	cf 93       	push	r28
    2290:	df 93       	push	r29
    2292:	8c 01       	movw	r16, r24
    2294:	5b 01       	movw	r10, r22
    2296:	69 01       	movw	r12, r18
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2422
    return item;
}

CJSON_PUBLIC(cJSON *) cJSON_CreateNumber(double num)
{
    cJSON *item = cJSON_New_Item(&global_hooks);
    2298:	7a 01       	movw	r14, r20
cJSON_CreateNumber():
    229a:	80 91 02 42 	lds	r24, 0x4202	; 0x804202 <global_hooks>
    229e:	90 91 03 42 	lds	r25, 0x4203	; 0x804203 <global_hooks+0x1>
    22a2:	5d df       	rcall	.-326    	; 0x215e <cJSON_New_Item.isra.5>
    22a4:	ec 01       	movw	r28, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2423
    if(item)
    22a6:	89 2b       	or	r24, r25
    22a8:	b1 f0       	breq	.+44     	; 0x22d6 <cJSON_AddNumberToObject+0x58>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2425
    {
        item->type = cJSON_Number;
    22aa:	88 e0       	ldi	r24, 0x08	; 8
    22ac:	90 e0       	ldi	r25, 0x00	; 0
    22ae:	8e 83       	std	Y+6, r24	; 0x06
    22b0:	9f 83       	std	Y+7, r25	; 0x07
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2426
        item->valuedouble = num;
    22b2:	cc 86       	std	Y+12, r12	; 0x0c
    22b4:	dd 86       	std	Y+13, r13	; 0x0d
    22b6:	ee 86       	std	Y+14, r14	; 0x0e
    22b8:	ff 86       	std	Y+15, r15	; 0x0f
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2429

        /* use saturation in case of overflow */
        if (num >= INT_MAX)
    22ba:	20 e0       	ldi	r18, 0x00	; 0
    22bc:	3e ef       	ldi	r19, 0xFE	; 254
    22be:	4f ef       	ldi	r20, 0xFF	; 255
    22c0:	56 e4       	ldi	r21, 0x46	; 70
    22c2:	c7 01       	movw	r24, r14
    22c4:	b6 01       	movw	r22, r12
    22c6:	0e 94 da 53 	call	0xa7b4	; 0xa7b4 <__gesf2>
    22ca:	87 fd       	sbrc	r24, 7
    22cc:	1b c0       	rjmp	.+54     	; 0x2304 <cJSON_AddNumberToObject+0x86>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2431
        {
            item->valueint = INT_MAX;
    22ce:	8f ef       	ldi	r24, 0xFF	; 255
    22d0:	9f e7       	ldi	r25, 0x7F	; 127
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2435
        }
        else if (num <= (double)INT_MIN)
        {
            item->valueint = INT_MIN;
    22d2:	8a 87       	std	Y+10, r24	; 0x0a
    22d4:	9b 87       	std	Y+11, r25	; 0x0b
cJSON_AddNumberToObject():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2126
}

CJSON_PUBLIC(cJSON*) cJSON_AddNumberToObject(cJSON * const object, const char * const name, const double number)
{
    cJSON *number_item = cJSON_CreateNumber(number);
    if (add_item_to_object(object, name, number_item, &global_hooks, false))
    22d6:	ae 01       	movw	r20, r28
    22d8:	b5 01       	movw	r22, r10
    22da:	c8 01       	movw	r24, r16
    22dc:	3b de       	rcall	.-906    	; 0x1f54 <add_item_to_object.constprop.108>
    22de:	89 2b       	or	r24, r25
    22e0:	29 f4       	brne	.+10     	; 0x22ec <cJSON_AddNumberToObject+0x6e>
    22e2:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2131
    {
        return number_item;
    }

    cJSON_Delete(number_item);
    22e4:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
    22e8:	d0 e0       	ldi	r29, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2132
    return NULL;
    22ea:	c0 e0       	ldi	r28, 0x00	; 0
    22ec:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2133
}
    22ee:	df 91       	pop	r29
    22f0:	cf 91       	pop	r28
    22f2:	1f 91       	pop	r17
    22f4:	0f 91       	pop	r16
    22f6:	ff 90       	pop	r15
    22f8:	ef 90       	pop	r14
    22fa:	df 90       	pop	r13
    22fc:	cf 90       	pop	r12
    22fe:	bf 90       	pop	r11
    2300:	af 90       	pop	r10
    2302:	08 95       	ret
cJSON_CreateNumber():
    2304:	20 e0       	ldi	r18, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2433
        /* use saturation in case of overflow */
        if (num >= INT_MAX)
        {
            item->valueint = INT_MAX;
        }
        else if (num <= (double)INT_MIN)
    2306:	30 e0       	ldi	r19, 0x00	; 0
    2308:	40 e0       	ldi	r20, 0x00	; 0
    230a:	57 ec       	ldi	r21, 0xC7	; 199
    230c:	c7 01       	movw	r24, r14
    230e:	b6 01       	movw	r22, r12
    2310:	0e 94 27 51 	call	0xa24e	; 0xa24e <__cmpsf2>
    2314:	18 16       	cp	r1, r24
    2316:	1c f0       	brlt	.+6      	; 0x231e <cJSON_AddNumberToObject+0xa0>
    2318:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2435
        {
            item->valueint = INT_MIN;
    231a:	90 e8       	ldi	r25, 0x80	; 128
    231c:	da cf       	rjmp	.-76     	; 0x22d2 <cJSON_AddNumberToObject+0x54>
    231e:	c7 01       	movw	r24, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2439
        }
        else
        {
            item->valueint = (int)num;
    2320:	b6 01       	movw	r22, r12
    2322:	0e 94 a9 53 	call	0xa752	; 0xa752 <__fixsfsi>
    2326:	6a 87       	std	Y+10, r22	; 0x0a
    2328:	7b 87       	std	Y+11, r23	; 0x0b
    232a:	d5 cf       	rjmp	.-86     	; 0x22d6 <cJSON_AddNumberToObject+0x58>

0000232c <calib_execute_command>:
calib_execute_command():
    232c:	2f 92       	push	r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:463
 * \param[in]    device  CryptoAuthentication device to send the command to.
 *
 * \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS calib_execute_command(ATCAPacket* packet, ATCADevice device)
{
    232e:	3f 92       	push	r3
    2330:	4f 92       	push	r4
    2332:	5f 92       	push	r5
    2334:	6f 92       	push	r6
    2336:	7f 92       	push	r7
    2338:	8f 92       	push	r8
    233a:	9f 92       	push	r9
    233c:	af 92       	push	r10
    233e:	bf 92       	push	r11
    2340:	cf 92       	push	r12
    2342:	df 92       	push	r13
    2344:	ef 92       	push	r14
    2346:	ff 92       	push	r15
    2348:	0f 93       	push	r16
    234a:	1f 93       	push	r17
    234c:	cf 93       	push	r28
    234e:	df 93       	push	r29
    2350:	cd b7       	in	r28, 0x3d	; 61
    2352:	de b7       	in	r29, 0x3e	; 62
    2354:	a4 97       	sbiw	r28, 0x24	; 36
    2356:	cd bf       	out	0x3d, r28	; 61
    2358:	de bf       	out	0x3e, r29	; 62
    235a:	1c 01       	movw	r2, r24
    235c:	3b 01       	movw	r6, r22
    235e:	cb 01       	movw	r24, r22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:468
    ATCA_STATUS status;
    uint32_t execution_or_wait_time;
    uint32_t max_delay_count;
    uint16_t rxsize;
    uint8_t device_address = atcab_get_device_address(device);
    2360:	0e 94 42 09 	call	0x1284	; 0x1284 <atcab_get_device_address>
    2364:	8e 8b       	std	Y+22, r24	; 0x16
atca_iface_get_retries():
    2366:	61 14       	cp	r6, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:388
}

/** \brief Retrive the number of retries for a configured interface */
int atca_iface_get_retries(ATCAIface ca_iface)
{
    if (ca_iface && ca_iface->mIfaceCFG)
    2368:	71 04       	cpc	r7, r1
    236a:	09 f4       	brne	.+2      	; 0x236e <calib_execute_command+0x42>
    236c:	6b c0       	rjmp	.+214    	; 0x2444 <calib_execute_command+0x118>
    236e:	d3 01       	movw	r26, r6
    2370:	ed 91       	ld	r30, X+
    2372:	fc 91       	ld	r31, X
    2374:	30 97       	sbiw	r30, 0x00	; 0
    2376:	09 f4       	brne	.+2      	; 0x237a <calib_execute_command+0x4e>
    2378:	65 c0       	rjmp	.+202    	; 0x2444 <calib_execute_command+0x118>
    237a:	47 88       	ldd	r4, Z+23	; 0x17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:390
    {
        return ca_iface->mIfaceCFG->rx_retries;
    237c:	50 8c       	ldd	r5, Z+24	; 0x18
hal_check_wake():
    237e:	20 91 12 42 	lds	r18, 0x4212	; 0x804212 <__malloc_margin+0x2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:372
 * \return ATCA_SUCCESS for expected wake, ATCA_STATUS_SELFTEST_ERROR if the
 *         power on self test failed, ATCA_WAKE_FAILED for other failures.
 */
ATCA_STATUS hal_check_wake(const uint8_t* response, int response_size)
{
    const uint8_t expected_response[4] = { 0x04, 0x11, 0x33, 0x43 };
    2382:	30 91 13 42 	lds	r19, 0x4213	; 0x804213 <__malloc_margin+0x3>
    2386:	40 91 14 42 	lds	r20, 0x4214	; 0x804214 <__malloc_margin+0x4>
    238a:	50 91 15 42 	lds	r21, 0x4215	; 0x804215 <__malloc_margin+0x5>
    238e:	2d 8f       	std	Y+29, r18	; 0x1d
    2390:	3e 8f       	std	Y+30, r19	; 0x1e
    2392:	4f 8f       	std	Y+31, r20	; 0x1f
    2394:	58 a3       	std	Y+32, r21	; 0x20
    2396:	80 91 16 42 	lds	r24, 0x4216	; 0x804216 <__malloc_margin+0x6>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:373
    const uint8_t selftest_fail_resp[4] = { 0x04, 0x07, 0xC4, 0x40 };
    239a:	90 91 17 42 	lds	r25, 0x4217	; 0x804217 <__malloc_margin+0x7>
    239e:	a0 91 18 42 	lds	r26, 0x4218	; 0x804218 <__malloc_margin+0x8>
    23a2:	b0 91 19 42 	lds	r27, 0x4219	; 0x804219 <__malloc_margin+0x9>
    23a6:	89 a3       	std	Y+33, r24	; 0x21
    23a8:	9a a3       	std	Y+34, r25	; 0x22
    23aa:	ab a3       	std	Y+35, r26	; 0x23
    23ac:	bc a3       	std	Y+36, r27	; 0x24
calib_execute_command():
    23ae:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:499
    #endif
#endif
        retries = atca_iface_get_retries(&device->mIface);
        do
        {
            if (ATCA_DEVICE_STATE_ACTIVE != device->device_state)
    23b0:	18 96       	adiw	r26, 0x08	; 8
    23b2:	8c 91       	ld	r24, X
    23b4:	18 97       	sbiw	r26, 0x08	; 8
    23b6:	83 30       	cpi	r24, 0x03	; 3
    23b8:	09 f4       	brne	.+2      	; 0x23bc <calib_execute_command+0x90>
    23ba:	50 c0       	rjmp	.+160    	; 0x245c <calib_execute_command+0x130>
calib_wakeup():
    23bc:	61 14       	cp	r6, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:116
ATCA_STATUS calib_wakeup(ATCADevice device)
{
    ATCA_STATUS status = ATCA_BAD_PARAM;
    ATCAIface iface = atGetIFace(device);

    if (iface && iface->mIfaceCFG)
    23be:	71 04       	cpc	r7, r1
    23c0:	09 f4       	brne	.+2      	; 0x23c4 <calib_execute_command+0x98>
    23c2:	4c c0       	rjmp	.+152    	; 0x245c <calib_execute_command+0x130>
    23c4:	0d 91       	ld	r16, X+
    23c6:	1c 91       	ld	r17, X
    23c8:	01 15       	cp	r16, r1
    23ca:	11 05       	cpc	r17, r1
    23cc:	09 f4       	brne	.+2      	; 0x23d0 <calib_execute_command+0xa4>
    23ce:	46 c0       	rjmp	.+140    	; 0x245c <calib_execute_command+0x130>
    23d0:	c3 01       	movw	r24, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:121
    {
#ifdef ATCA_HAL_LEGACY_API
        status = atwake(iface);
#else
        if (atca_iface_is_kit(iface) || atca_iface_is_swi(&device->mIface))
    23d2:	0e 94 de 08 	call	0x11bc	; 0x11bc <atca_iface_is_kit>
    23d6:	81 11       	cpse	r24, r1
    23d8:	05 c0       	rjmp	.+10     	; 0x23e4 <calib_execute_command+0xb8>
    23da:	c3 01       	movw	r24, r6
    23dc:	0e 94 cb 08 	call	0x1196	; 0x1196 <atca_iface_is_swi>
    23e0:	88 23       	and	r24, r24
    23e2:	99 f1       	breq	.+102    	; 0x244a <calib_execute_command+0x11e>
atwake():
    23e4:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:241
    {
        return ATCA_BAD_PARAM;
    }


    if (ca_iface->hal && ca_iface->hal->halcontrol)
    23e6:	12 96       	adiw	r26, 0x02	; 2
    23e8:	ed 91       	ld	r30, X+
    23ea:	fc 91       	ld	r31, X
    23ec:	30 97       	sbiw	r30, 0x00	; 0
    23ee:	b1 f1       	breq	.+108    	; 0x245c <calib_execute_command+0x130>
    23f0:	00 84       	ldd	r0, Z+8	; 0x08
    23f2:	f1 85       	ldd	r31, Z+9	; 0x09
    23f4:	e0 2d       	mov	r30, r0
    23f6:	30 97       	sbiw	r30, 0x00	; 0
    23f8:	89 f1       	breq	.+98     	; 0x245c <calib_execute_command+0x130>
    23fa:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:243
    {
        ATCA_STATUS status = ca_iface->hal->halcontrol(ca_iface, ATCA_HAL_CONTROL_WAKE, NULL, 0);
    23fc:	20 e0       	ldi	r18, 0x00	; 0
    23fe:	50 e0       	ldi	r21, 0x00	; 0
    2400:	40 e0       	ldi	r20, 0x00	; 0
    2402:	60 e0       	ldi	r22, 0x00	; 0
    2404:	c3 01       	movw	r24, r6
    2406:	09 95       	icall
    2408:	8c 01       	movw	r16, r24
    240a:	80 3d       	cpi	r24, 0xD0	; 208
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:245

        if (ATCA_WAKE_FAILED == status)
    240c:	91 05       	cpc	r25, r1
    240e:	b9 f4       	brne	.+46     	; 0x243e <calib_execute_command+0x112>
    2410:	8a ef       	ldi	r24, 0xFA	; 250
    2412:	90 e0       	ldi	r25, 0x00	; 0
_delay_loop_2():
    2414:	e8 e5       	ldi	r30, 0x58	; 88
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay_basic.h:105
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    2416:	f2 e0       	ldi	r31, 0x02	; 2
    2418:	31 97       	sbiw	r30, 0x01	; 1
    241a:	f1 f7       	brne	.-4      	; 0x2418 <calib_execute_command+0xec>
    241c:	01 97       	sbiw	r24, 0x01	; 1
_delay_ms():
    241e:	d1 f7       	brne	.-12     	; 0x2414 <calib_execute_command+0xe8>
atwake():
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:198
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    2420:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:251
        {
            // The device might be performing a POST. Wait for it to complete
            // and try again.
            atca_delay_ms(ATCA_POST_DELAY_MSEC);

            status = ca_iface->hal->halcontrol(ca_iface, ATCA_HAL_CONTROL_WAKE, NULL, 0);
    2422:	12 96       	adiw	r26, 0x02	; 2
    2424:	ed 91       	ld	r30, X+
    2426:	fc 91       	ld	r31, X
    2428:	00 84       	ldd	r0, Z+8	; 0x08
    242a:	f1 85       	ldd	r31, Z+9	; 0x09
    242c:	e0 2d       	mov	r30, r0
    242e:	30 e0       	ldi	r19, 0x00	; 0
    2430:	20 e0       	ldi	r18, 0x00	; 0
    2432:	50 e0       	ldi	r21, 0x00	; 0
    2434:	40 e0       	ldi	r20, 0x00	; 0
    2436:	60 e0       	ldi	r22, 0x00	; 0
    2438:	c3 01       	movw	r24, r6
    243a:	09 95       	icall
calib_wakeup_i2c():
    243c:	8c 01       	movw	r16, r24
calib_execute_command():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:59
            {
                temp = 100000UL;
                status = atcontrol(iface, ATCA_HAL_CHANGE_BAUD, &temp, sizeof(temp));
                if (ATCA_UNIMPLEMENTED == status)
                {
                    status = atcontrol(iface, ATCA_HAL_CONTROL_WAKE, NULL, 0);
    243e:	01 2b       	or	r16, r17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:501
            {
                if (ATCA_SUCCESS == (status = calib_wakeup(device)))
    2440:	49 f0       	breq	.+18     	; 0x2454 <calib_execute_command+0x128>
    2442:	0c c0       	rjmp	.+24     	; 0x245c <calib_execute_command+0x130>
    2444:	51 2c       	mov	r5, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:394
    {
        return ca_iface->mIfaceCFG->rx_retries;
    }
    else
    {
        return 0;
    2446:	41 2c       	mov	r4, r1
    2448:	9a cf       	rjmp	.-204    	; 0x237e <calib_execute_command+0x52>
calib_wakeup():
    244a:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:125
#else
        if (atca_iface_is_kit(iface) || atca_iface_is_swi(&device->mIface))
        {
            status = atwake(iface);
        }
        else if (ATCA_I2C_IFACE == iface->mIfaceCFG->iface_type)
    244c:	80 81       	ld	r24, Z
    244e:	91 81       	ldd	r25, Z+1	; 0x01
    2450:	89 2b       	or	r24, r25
    2452:	b9 f1       	breq	.+110    	; 0x24c2 <calib_execute_command+0x196>
calib_execute_command():
    2454:	83 e0       	ldi	r24, 0x03	; 3
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:503
                {
                    device->device_state = ATCA_DEVICE_STATE_ACTIVE;
    2456:	d3 01       	movw	r26, r6
    2458:	18 96       	adiw	r26, 0x08	; 8
    245a:	8c 93       	st	X, r24
    245c:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:508
                }
            }

            /* Send the command packet to the device */
            if ((ATCA_I2C_IFACE == device->mIface.mIfaceCFG->iface_type) || (ATCA_CUSTOM_IFACE == device->mIface.mIfaceCFG->iface_type))
    245e:	ed 91       	ld	r30, X+
    2460:	fc 91       	ld	r31, X
    2462:	80 81       	ld	r24, Z
    2464:	91 81       	ldd	r25, Z+1	; 0x01
    2466:	00 97       	sbiw	r24, 0x00	; 0
    2468:	21 f0       	breq	.+8      	; 0x2472 <calib_execute_command+0x146>
    246a:	86 30       	cpi	r24, 0x06	; 6
    246c:	91 05       	cpc	r25, r1
    246e:	09 f0       	breq	.+2      	; 0x2472 <calib_execute_command+0x146>
    2470:	74 c1       	rjmp	.+744    	; 0x275a <calib_execute_command+0x42e>
    2472:	83 e0       	ldi	r24, 0x03	; 3
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:510
            {
                packet->_reserved = 0x03;
    2474:	f1 01       	movw	r30, r2
    2476:	80 83       	st	Z, r24
    2478:	f1 01       	movw	r30, r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:522
            else if ((ATCA_SWI_GPIO_IFACE == device->mIface.mIfaceCFG->iface_type) && (atcab_is_ca2_device(device->mIface.mIfaceCFG->devtype)))
            {
                packet->_reserved = 0x03;
            }
    #endif
            if (ATCA_RX_NO_RESPONSE == (status = calib_execute_send(device, device_address, (uint8_t*)packet, packet->txsize + 1)))
    247a:	e1 80       	ldd	r14, Z+1	; 0x01
    247c:	f1 2c       	mov	r15, r1
calib_execute_send():
    247e:	c3 01       	movw	r24, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:336

#ifdef ATCA_HAL_LEGACY_API
    ((void)device_address);
    status = atsend(&device->mIface, 0xFF, (uint8_t*)txdata, (int)txlength - 1);
#else
    if (atca_iface_is_kit(&device->mIface))
    2480:	0e 94 de 08 	call	0x11bc	; 0x11bc <atca_iface_is_kit>
    2484:	88 23       	and	r24, r24
    2486:	09 f4       	brne	.+2      	; 0x248a <calib_execute_command+0x15e>
    2488:	6f c1       	rjmp	.+734    	; 0x2768 <calib_execute_command+0x43c>
    248a:	97 01       	movw	r18, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:338
    {
        status = atsend(&device->mIface, 0xFF, (uint8_t*)&txdata[1], (int)txlength - 1);
    248c:	a1 01       	movw	r20, r2
    248e:	4f 5f       	subi	r20, 0xFF	; 255
    2490:	5f 4f       	sbci	r21, 0xFF	; 255
    2492:	6f ef       	ldi	r22, 0xFF	; 255
    2494:	c3 01       	movw	r24, r6
    2496:	0e 94 1b 09 	call	0x1236	; 0x1236 <atsend>
    249a:	8c 01       	movw	r16, r24
calib_execute_command():
    249c:	07 3e       	cpi	r16, 0xE7	; 231
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:522
            else if ((ATCA_SWI_GPIO_IFACE == device->mIface.mIfaceCFG->iface_type) && (atcab_is_ca2_device(device->mIface.mIfaceCFG->devtype)))
            {
                packet->_reserved = 0x03;
            }
    #endif
            if (ATCA_RX_NO_RESPONSE == (status = calib_execute_send(device, device_address, (uint8_t*)packet, packet->txsize + 1)))
    249e:	11 05       	cpc	r17, r1
    24a0:	09 f0       	breq	.+2      	; 0x24a4 <calib_execute_command+0x178>
    24a2:	82 c1       	rjmp	.+772    	; 0x27a8 <calib_execute_command+0x47c>
    24a4:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:524
            {
                device->device_state = ATCA_DEVICE_STATE_UNKNOWN;
    24a6:	18 96       	adiw	r26, 0x08	; 8
    24a8:	1c 92       	st	X, r1
    24aa:	b1 e0       	ldi	r27, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:536
                }
                retries = 0;
            }

        }
        while (0 < retries--);
    24ac:	4b 1a       	sub	r4, r27
    24ae:	51 08       	sbc	r5, r1
    24b0:	c2 01       	movw	r24, r4
    24b2:	01 96       	adiw	r24, 0x01	; 1
    24b4:	18 16       	cp	r1, r24
    24b6:	19 06       	cpc	r1, r25
    24b8:	0c f4       	brge	.+2      	; 0x24bc <calib_execute_command+0x190>
    24ba:	79 cf       	rjmp	.-270    	; 0x23ae <calib_execute_command+0x82>
    24bc:	07 ee       	ldi	r16, 0xE7	; 231
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:578
            {
                status = ATCA_RX_FAIL;
            }
            else
            {
                status = ATCA_RX_NO_RESPONSE;
    24be:	10 e0       	ldi	r17, 0x00	; 0
    24c0:	bc c1       	rjmp	.+888    	; 0x283a <calib_execute_command+0x50e>
calib_wakeup_i2c():
    24c2:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:40
 */

ATCA_STATUS calib_wakeup_i2c(ATCADevice device)
{
    ATCA_STATUS status = ATCA_BAD_PARAM;
    uint8_t second_byte = 0x01;  // I2C general call should not interpreted as an addr write
    24c4:	8b 8b       	std	Y+19, r24	; 0x13
    24c6:	c3 01       	movw	r24, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:46
    ATCAIface iface = atGetIFace(device);

    if (iface)
    {
        int retries = atca_iface_get_retries(iface);
        uint8_t address = atcab_get_device_address(device);
    24c8:	0e 94 42 09 	call	0x1284	; 0x1284 <atcab_get_device_address>
    24cc:	8c 8f       	std	Y+28, r24	; 0x1c
    24ce:	f8 01       	movw	r30, r16
    24d0:	07 88       	ldd	r0, Z+23	; 0x17
    24d2:	f0 8d       	ldd	r31, Z+24	; 0x18
    24d4:	e0 2d       	mov	r30, r0
    24d6:	ec 8b       	std	Y+20, r30	; 0x14
    24d8:	fd 8b       	std	Y+21, r31	; 0x15
    24da:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:53
        uint32_t wake;
        uint16_t rxlen;

        do
        {
            if (100000UL < ATCA_IFACECFG_VALUE(iface->mIfaceCFG, atcai2c.baud))
    24dc:	ed 91       	ld	r30, X+
    24de:	fc 91       	ld	r31, X
    24e0:	86 81       	ldd	r24, Z+6	; 0x06
    24e2:	97 81       	ldd	r25, Z+7	; 0x07
    24e4:	a0 85       	ldd	r26, Z+8	; 0x08
    24e6:	b1 85       	ldd	r27, Z+9	; 0x09
    24e8:	81 3a       	cpi	r24, 0xA1	; 161
    24ea:	96 48       	sbci	r25, 0x86	; 134
    24ec:	a1 40       	sbci	r26, 0x01	; 1
    24ee:	b1 05       	cpc	r27, r1
    24f0:	f0 f0       	brcs	.+60     	; 0x252e <calib_execute_command+0x202>
    24f2:	20 ea       	ldi	r18, 0xA0	; 160
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:55
            {
                temp = 100000UL;
    24f4:	36 e8       	ldi	r19, 0x86	; 134
    24f6:	41 e0       	ldi	r20, 0x01	; 1
    24f8:	50 e0       	ldi	r21, 0x00	; 0
    24fa:	2d 87       	std	Y+13, r18	; 0x0d
    24fc:	3e 87       	std	Y+14, r19	; 0x0e
    24fe:	4f 87       	std	Y+15, r20	; 0x0f
    2500:	58 8b       	std	Y+16, r21	; 0x10
    2502:	24 e0       	ldi	r18, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:56
                status = atcontrol(iface, ATCA_HAL_CHANGE_BAUD, &temp, sizeof(temp));
    2504:	30 e0       	ldi	r19, 0x00	; 0
    2506:	ae 01       	movw	r20, r28
    2508:	43 5f       	subi	r20, 0xF3	; 243
    250a:	5f 4f       	sbci	r21, 0xFF	; 255
    250c:	66 e0       	ldi	r22, 0x06	; 6
    250e:	c3 01       	movw	r24, r6
    2510:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <atcontrol>
    2514:	8c 01       	movw	r16, r24
    2516:	85 3f       	cpi	r24, 0xF5	; 245
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:57
                if (ATCA_UNIMPLEMENTED == status)
    2518:	91 05       	cpc	r25, r1
    251a:	59 f4       	brne	.+22     	; 0x2532 <calib_execute_command+0x206>
    251c:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:59
                {
                    status = atcontrol(iface, ATCA_HAL_CONTROL_WAKE, NULL, 0);
    251e:	20 e0       	ldi	r18, 0x00	; 0
    2520:	50 e0       	ldi	r21, 0x00	; 0
    2522:	40 e0       	ldi	r20, 0x00	; 0
    2524:	60 e0       	ldi	r22, 0x00	; 0
    2526:	c3 01       	movw	r24, r6
    2528:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <atcontrol>
    252c:	87 cf       	rjmp	.-242    	; 0x243c <calib_execute_command+0x110>
calib_execute_command():
    252e:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:65
                    break;
                }
            }
            else
            {
                status = ATCA_SUCCESS;
    2530:	00 e0       	ldi	r16, 0x00	; 0
calib_wakeup_i2c():
    2532:	21 e0       	ldi	r18, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:81
            {

                (void)atsend(iface, 0x00, &second_byte, sizeof(second_byte));
            }
    #else
            (void)atsend(iface, 0x00, &second_byte, sizeof(second_byte));
    2534:	30 e0       	ldi	r19, 0x00	; 0
    2536:	ae 01       	movw	r20, r28
    2538:	4d 5e       	subi	r20, 0xED	; 237
    253a:	5f 4f       	sbci	r21, 0xFF	; 255
    253c:	60 e0       	ldi	r22, 0x00	; 0
    253e:	c3 01       	movw	r24, r6
    2540:	0e 94 1b 09 	call	0x1236	; 0x1236 <atsend>
atca_iface_get_wake_delay():
    2544:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:401
}

/** \brief Retrive the wake/retry delay for a configured interface/device */
uint16_t atca_iface_get_wake_delay(ATCAIface ca_iface)
{
    if (ca_iface && ca_iface->mIfaceCFG)
    2546:	ed 91       	ld	r30, X+
    2548:	fc 91       	ld	r31, X
calib_execute_command():
    254a:	6c ed       	ldi	r22, 0xDC	; 220
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:407
    {
        return ca_iface->mIfaceCFG->wake_delay;
    }
    else
    {
        return 1500;
    254c:	75 e0       	ldi	r23, 0x05	; 5
atca_iface_get_wake_delay():
    254e:	30 97       	sbiw	r30, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:401
}

/** \brief Retrive the wake/retry delay for a configured interface/device */
uint16_t atca_iface_get_wake_delay(ATCAIface ca_iface)
{
    if (ca_iface && ca_iface->mIfaceCFG)
    2550:	11 f0       	breq	.+4      	; 0x2556 <calib_execute_command+0x22a>
    2552:	65 89       	ldd	r22, Z+21	; 0x15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:403
    {
        return ca_iface->mIfaceCFG->wake_delay;
    2554:	76 89       	ldd	r23, Z+22	; 0x16
calib_wakeup_i2c():
    2556:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:83
    #endif
            atca_delay_us(atca_iface_get_wake_delay(iface));
    2558:	80 e0       	ldi	r24, 0x00	; 0
    255a:	0e 94 2b 51 	call	0xa256	; 0xa256 <__floatunsisf>
    255e:	4b 01       	movw	r8, r22
    2560:	5c 01       	movw	r10, r24
_delay_us():
    2562:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:281
	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
    2564:	30 e0       	ldi	r19, 0x00	; 0
    2566:	40 e0       	ldi	r20, 0x00	; 0
    2568:	51 e4       	ldi	r21, 0x41	; 65
    256a:	0e 94 8c 51 	call	0xa318	; 0xa318 <__mulsf3>
    256e:	6b 01       	movw	r12, r22
    2570:	7c 01       	movw	r14, r24
    2572:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:283
	__tmp2 = ((F_CPU) / 4e6) * __us;
	if (__tmp < 1.0)
    2574:	30 e0       	ldi	r19, 0x00	; 0
    2576:	40 e8       	ldi	r20, 0x80	; 128
    2578:	5f e3       	ldi	r21, 0x3F	; 63
    257a:	0e 94 27 51 	call	0xa24e	; 0xa24e <__cmpsf2>
    257e:	87 fd       	sbrc	r24, 7
    2580:	b1 c0       	rjmp	.+354    	; 0x26e4 <calib_execute_command+0x3b8>
    2582:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:282

#else
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
	__tmp2 = ((F_CPU) / 4e6) * __us;
    2584:	30 e0       	ldi	r19, 0x00	; 0
    2586:	40 ec       	ldi	r20, 0xC0	; 192
    2588:	50 e4       	ldi	r21, 0x40	; 64
    258a:	c5 01       	movw	r24, r10
    258c:	b4 01       	movw	r22, r8
    258e:	0e 94 8c 51 	call	0xa318	; 0xa318 <__mulsf3>
    2592:	68 8f       	std	Y+24, r22	; 0x18
    2594:	79 8f       	std	Y+25, r23	; 0x19
    2596:	8a 8f       	std	Y+26, r24	; 0x1a
    2598:	9b 8f       	std	Y+27, r25	; 0x1b
    259a:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:285
	if (__tmp < 1.0)
		__ticks = 1;
	else if (__tmp2 > 65535)
    259c:	3f ef       	ldi	r19, 0xFF	; 255
    259e:	4f e7       	ldi	r20, 0x7F	; 127
    25a0:	57 e4       	ldi	r21, 0x47	; 71
    25a2:	0e 94 da 53 	call	0xa7b4	; 0xa7b4 <__gesf2>
    25a6:	18 16       	cp	r1, r24
    25a8:	0c f0       	brlt	.+2      	; 0x25ac <calib_execute_command+0x280>
    25aa:	48 c0       	rjmp	.+144    	; 0x263c <calib_execute_command+0x310>
    25ac:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:287
	{
		_delay_ms(__us / 1000.0);
    25ae:	30 e0       	ldi	r19, 0x00	; 0
    25b0:	4a e7       	ldi	r20, 0x7A	; 122
    25b2:	54 e4       	ldi	r21, 0x44	; 68
    25b4:	c5 01       	movw	r24, r10
    25b6:	b4 01       	movw	r22, r8
    25b8:	0e 94 41 53 	call	0xa682	; 0xa682 <__divsf3>
    25bc:	4b 01       	movw	r8, r22
    25be:	5c 01       	movw	r10, r24
_delay_ms():
    25c0:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:191

	__builtin_avr_delay_cycles(__ticks_dc);

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
    25c2:	30 e8       	ldi	r19, 0x80	; 128
    25c4:	4b eb       	ldi	r20, 0xBB	; 187
    25c6:	55 e4       	ldi	r21, 0x45	; 69
    25c8:	0e 94 8c 51 	call	0xa318	; 0xa318 <__mulsf3>
    25cc:	6b 01       	movw	r12, r22
    25ce:	7c 01       	movw	r14, r24
    25d0:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:192
	if (__tmp < 1.0)
    25d2:	30 e0       	ldi	r19, 0x00	; 0
    25d4:	40 e8       	ldi	r20, 0x80	; 128
    25d6:	5f e3       	ldi	r21, 0x3F	; 63
    25d8:	0e 94 27 51 	call	0xa24e	; 0xa24e <__cmpsf2>
    25dc:	87 fd       	sbrc	r24, 7
    25de:	2b c0       	rjmp	.+86     	; 0x2636 <calib_execute_command+0x30a>
    25e0:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:194
		__ticks = 1;
	else if (__tmp > 65535)
    25e2:	3f ef       	ldi	r19, 0xFF	; 255
    25e4:	4f e7       	ldi	r20, 0x7F	; 127
    25e6:	57 e4       	ldi	r21, 0x47	; 71
    25e8:	c7 01       	movw	r24, r14
    25ea:	b6 01       	movw	r22, r12
    25ec:	0e 94 da 53 	call	0xa7b4	; 0xa7b4 <__gesf2>
    25f0:	18 16       	cp	r1, r24
    25f2:	cc f4       	brge	.+50     	; 0x2626 <calib_execute_command+0x2fa>
    25f4:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:197
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    25f6:	30 e0       	ldi	r19, 0x00	; 0
    25f8:	40 e2       	ldi	r20, 0x20	; 32
    25fa:	51 e4       	ldi	r21, 0x41	; 65
    25fc:	c5 01       	movw	r24, r10
    25fe:	b4 01       	movw	r22, r8
    2600:	0e 94 8c 51 	call	0xa318	; 0xa318 <__mulsf3>
    2604:	0e 94 ae 53 	call	0xa75c	; 0xa75c <__fixunssfsi>
    2608:	61 15       	cp	r22, r1
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:198
		while(__ticks)
    260a:	71 05       	cpc	r23, r1
    260c:	29 f4       	brne	.+10     	; 0x2618 <calib_execute_command+0x2ec>
_delay_loop_1():
    260e:	ef 89       	ldd	r30, Y+23	; 0x17
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay_basic.h:83
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    2610:	ea 95       	dec	r30
    2612:	f1 f7       	brne	.-4      	; 0x2610 <calib_execute_command+0x2e4>
    2614:	ef 8b       	std	Y+23, r30	; 0x17
    2616:	26 c0       	rjmp	.+76     	; 0x2664 <calib_execute_command+0x338>
_delay_loop_2():
    2618:	88 e5       	ldi	r24, 0x58	; 88
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay_basic.h:105
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    261a:	92 e0       	ldi	r25, 0x02	; 2
    261c:	01 97       	sbiw	r24, 0x01	; 1
    261e:	f1 f7       	brne	.-4      	; 0x261c <calib_execute_command+0x2f0>
_delay_ms():
    2620:	61 50       	subi	r22, 0x01	; 1
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:202
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    2622:	71 09       	sbc	r23, r1
    2624:	f1 cf       	rjmp	.-30     	; 0x2608 <calib_execute_command+0x2dc>
    2626:	c7 01       	movw	r24, r14
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:207
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    2628:	b6 01       	movw	r22, r12
    262a:	0e 94 ae 53 	call	0xa75c	; 0xa75c <__fixunssfsi>
_delay_loop_2():
    262e:	cb 01       	movw	r24, r22
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay_basic.h:105
    2630:	01 97       	sbiw	r24, 0x01	; 1
    2632:	f1 f7       	brne	.-4      	; 0x2630 <calib_execute_command+0x304>
    2634:	ec cf       	rjmp	.-40     	; 0x260e <calib_execute_command+0x2e2>
calib_execute_command():
    2636:	61 e0       	ldi	r22, 0x01	; 1
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:193

#else
	uint16_t __ticks;
	__tmp = ((F_CPU) / 4e3) * __ms;
	if (__tmp < 1.0)
		__ticks = 1;
    2638:	70 e0       	ldi	r23, 0x00	; 0
    263a:	f9 cf       	rjmp	.-14     	; 0x262e <calib_execute_command+0x302>
_delay_us():
    263c:	20 e0       	ldi	r18, 0x00	; 0
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:289
		__ticks = 1;
	else if (__tmp2 > 65535)
	{
		_delay_ms(__us / 1000.0);
	}
	else if (__tmp > 255)
    263e:	30 e0       	ldi	r19, 0x00	; 0
    2640:	4f e7       	ldi	r20, 0x7F	; 127
    2642:	53 e4       	ldi	r21, 0x43	; 67
    2644:	c7 01       	movw	r24, r14
    2646:	b6 01       	movw	r22, r12
    2648:	0e 94 da 53 	call	0xa7b4	; 0xa7b4 <__gesf2>
    264c:	18 16       	cp	r1, r24
    264e:	0c f0       	brlt	.+2      	; 0x2652 <calib_execute_command+0x326>
    2650:	43 c0       	rjmp	.+134    	; 0x26d8 <calib_execute_command+0x3ac>
    2652:	68 8d       	ldd	r22, Y+24	; 0x18
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:291
	{
		uint16_t __ticks=(uint16_t)__tmp2;
    2654:	79 8d       	ldd	r23, Y+25	; 0x19
    2656:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2658:	9b 8d       	ldd	r25, Y+27	; 0x1b
    265a:	0e 94 ae 53 	call	0xa75c	; 0xa75c <__fixunssfsi>
_delay_loop_2():
    265e:	cb 01       	movw	r24, r22
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay_basic.h:105
    2660:	01 97       	sbiw	r24, 0x01	; 1
    2662:	f1 f7       	brne	.-4      	; 0x2660 <calib_execute_command+0x334>
calib_wakeup_i2c():
    2664:	84 e0       	ldi	r24, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:85

            rxlen = sizeof(wake);
    2666:	90 e0       	ldi	r25, 0x00	; 0
    2668:	89 8b       	std	Y+17, r24	; 0x11
    266a:	9a 8b       	std	Y+18, r25	; 0x12
    266c:	01 15       	cp	r16, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:86
            if (ATCA_SUCCESS == status)
    266e:	11 05       	cpc	r17, r1
    2670:	09 f0       	breq	.+2      	; 0x2674 <calib_execute_command+0x348>
    2672:	4b c0       	rjmp	.+150    	; 0x270a <calib_execute_command+0x3de>
    2674:	9e 01       	movw	r18, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:88
            {
                status = atreceive(iface, address, (uint8_t*)&wake, &rxlen);
    2676:	2f 5e       	subi	r18, 0xEF	; 239
    2678:	3f 4f       	sbci	r19, 0xFF	; 255
    267a:	ae 01       	movw	r20, r28
    267c:	47 5f       	subi	r20, 0xF7	; 247
    267e:	5f 4f       	sbci	r21, 0xFF	; 255
    2680:	6c 8d       	ldd	r22, Y+28	; 0x1c
    2682:	c3 01       	movw	r24, r6
    2684:	0e 94 07 09 	call	0x120e	; 0x120e <atreceive>
    2688:	8c 01       	movw	r16, r24
    268a:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:91
            }

            if ((ATCA_SUCCESS == status) && (100000UL < ATCA_IFACECFG_VALUE(iface->mIfaceCFG, atcai2c.baud)))
    268c:	f1 f5       	brne	.+124    	; 0x270a <calib_execute_command+0x3de>
    268e:	d3 01       	movw	r26, r6
    2690:	ed 91       	ld	r30, X+
    2692:	fc 91       	ld	r31, X
    2694:	86 81       	ldd	r24, Z+6	; 0x06
    2696:	97 81       	ldd	r25, Z+7	; 0x07
    2698:	a0 85       	ldd	r26, Z+8	; 0x08
    269a:	b1 85       	ldd	r27, Z+9	; 0x09
    269c:	81 3a       	cpi	r24, 0xA1	; 161
    269e:	e6 e8       	ldi	r30, 0x86	; 134
    26a0:	9e 07       	cpc	r25, r30
    26a2:	e1 e0       	ldi	r30, 0x01	; 1
    26a4:	ae 07       	cpc	r26, r30
    26a6:	b1 05       	cpc	r27, r1
    26a8:	00 f5       	brcc	.+64     	; 0x26ea <calib_execute_command+0x3be>
    26aa:	89 89       	ldd	r24, Y+17	; 0x11
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:99
                status = atcontrol(iface, ATCA_HAL_CHANGE_BAUD, &temp, sizeof(temp));
            }

            if (ATCA_SUCCESS == status)
            {
                status = hal_check_wake((uint8_t*)&wake, rxlen);
    26ac:	9a 89       	ldd	r25, Y+18	; 0x12
hal_check_wake():
    26ae:	2d 8d       	ldd	r18, Y+29	; 0x1d
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:372
 * \return ATCA_SUCCESS for expected wake, ATCA_STATUS_SELFTEST_ERROR if the
 *         power on self test failed, ATCA_WAKE_FAILED for other failures.
 */
ATCA_STATUS hal_check_wake(const uint8_t* response, int response_size)
{
    const uint8_t expected_response[4] = { 0x04, 0x11, 0x33, 0x43 };
    26b0:	3e 8d       	ldd	r19, Y+30	; 0x1e
    26b2:	4f 8d       	ldd	r20, Y+31	; 0x1f
    26b4:	58 a1       	ldd	r21, Y+32	; 0x20
    26b6:	2d 83       	std	Y+5, r18	; 0x05
    26b8:	3e 83       	std	Y+6, r19	; 0x06
    26ba:	4f 83       	std	Y+7, r20	; 0x07
    26bc:	58 87       	std	Y+8, r21	; 0x08
    26be:	29 a1       	ldd	r18, Y+33	; 0x21
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:373
    const uint8_t selftest_fail_resp[4] = { 0x04, 0x07, 0xC4, 0x40 };
    26c0:	3a a1       	ldd	r19, Y+34	; 0x22
    26c2:	4b a1       	ldd	r20, Y+35	; 0x23
    26c4:	5c a1       	ldd	r21, Y+36	; 0x24
    26c6:	29 83       	std	Y+1, r18	; 0x01
    26c8:	3a 83       	std	Y+2, r19	; 0x02
    26ca:	4b 83       	std	Y+3, r20	; 0x03
    26cc:	5c 83       	std	Y+4, r21	; 0x04
    26ce:	04 97       	sbiw	r24, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:375

    if (response_size != 4)
    26d0:	59 f1       	breq	.+86     	; 0x2728 <calib_execute_command+0x3fc>
calib_execute_command():
    26d2:	00 ed       	ldi	r16, 0xD0	; 208
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:387
    }
    if (memcmp(response, selftest_fail_resp, 4) == 0)
    {
        return ATCA_STATUS_SELFTEST_ERROR;
    }
    return ATCA_WAKE_FAILED;
    26d4:	10 e0       	ldi	r17, 0x00	; 0
    26d6:	19 c0       	rjmp	.+50     	; 0x270a <calib_execute_command+0x3de>
_delay_us():
    26d8:	c7 01       	movw	r24, r14
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:296
		_delay_loop_2(__ticks);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    26da:	b6 01       	movw	r22, r12
    26dc:	0e 94 ae 53 	call	0xa75c	; 0xa75c <__fixunssfsi>
    26e0:	6f 8b       	std	Y+23, r22	; 0x17
    26e2:	95 cf       	rjmp	.-214    	; 0x260e <calib_execute_command+0x2e2>
calib_execute_command():
    26e4:	b1 e0       	ldi	r27, 0x01	; 1
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:284
	uint8_t __ticks;
	double __tmp2 ;
	__tmp = ((F_CPU) / 3e6) * __us;
	__tmp2 = ((F_CPU) / 4e6) * __us;
	if (__tmp < 1.0)
		__ticks = 1;
    26e6:	bf 8b       	std	Y+23, r27	; 0x17
    26e8:	92 cf       	rjmp	.-220    	; 0x260e <calib_execute_command+0x2e2>
calib_wakeup_i2c():
    26ea:	8d 87       	std	Y+13, r24	; 0x0d
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:93
                status = atreceive(iface, address, (uint8_t*)&wake, &rxlen);
            }

            if ((ATCA_SUCCESS == status) && (100000UL < ATCA_IFACECFG_VALUE(iface->mIfaceCFG, atcai2c.baud)))
            {
                temp = ATCA_IFACECFG_VALUE(iface->mIfaceCFG, atcai2c.baud);
    26ec:	9e 87       	std	Y+14, r25	; 0x0e
    26ee:	af 87       	std	Y+15, r26	; 0x0f
    26f0:	b8 8b       	std	Y+16, r27	; 0x10
    26f2:	24 e0       	ldi	r18, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:94
                status = atcontrol(iface, ATCA_HAL_CHANGE_BAUD, &temp, sizeof(temp));
    26f4:	30 e0       	ldi	r19, 0x00	; 0
    26f6:	ae 01       	movw	r20, r28
    26f8:	43 5f       	subi	r20, 0xF3	; 243
    26fa:	5f 4f       	sbci	r21, 0xFF	; 255
    26fc:	66 e0       	ldi	r22, 0x06	; 6
    26fe:	c3 01       	movw	r24, r6
    2700:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <atcontrol>
    2704:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:97
            }

            if (ATCA_SUCCESS == status)
    2706:	89 f2       	breq	.-94     	; 0x26aa <calib_execute_command+0x37e>
    2708:	8c 01       	movw	r16, r24
    270a:	4c 89       	ldd	r20, Y+20	; 0x14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:102
            {
                status = hal_check_wake((uint8_t*)&wake, rxlen);
            }
        }
        while (0 < retries-- && ATCA_SUCCESS != status);
    270c:	5d 89       	ldd	r21, Y+21	; 0x15
    270e:	14 16       	cp	r1, r20
    2710:	15 06       	cpc	r1, r21
    2712:	0c f0       	brlt	.+2      	; 0x2716 <calib_execute_command+0x3ea>
    2714:	94 ce       	rjmp	.-728    	; 0x243e <calib_execute_command+0x112>
    2716:	41 50       	subi	r20, 0x01	; 1
    2718:	51 09       	sbc	r21, r1
    271a:	4c 8b       	std	Y+20, r20	; 0x14
    271c:	5d 8b       	std	Y+21, r21	; 0x15
    271e:	01 15       	cp	r16, r1
    2720:	11 05       	cpc	r17, r1
    2722:	09 f0       	breq	.+2      	; 0x2726 <calib_execute_command+0x3fa>
    2724:	da ce       	rjmp	.-588    	; 0x24da <calib_execute_command+0x1ae>
    2726:	8b ce       	rjmp	.-746    	; 0x243e <calib_execute_command+0x112>
hal_check_wake():
    2728:	44 e0       	ldi	r20, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:379

    if (response_size != 4)
    {
        return ATCA_WAKE_FAILED;
    }
    if (memcmp(response, expected_response, 4) == 0)
    272a:	50 e0       	ldi	r21, 0x00	; 0
    272c:	be 01       	movw	r22, r28
    272e:	6b 5f       	subi	r22, 0xFB	; 251
    2730:	7f 4f       	sbci	r23, 0xFF	; 255
    2732:	ce 01       	movw	r24, r28
    2734:	09 96       	adiw	r24, 0x09	; 9
    2736:	0e 94 c1 56 	call	0xad82	; 0xad82 <memcmp>
    273a:	89 2b       	or	r24, r25
    273c:	31 f3       	breq	.-52     	; 0x270a <calib_execute_command+0x3de>
    273e:	44 e0       	ldi	r20, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:383
    {
        return ATCA_SUCCESS;
    }
    if (memcmp(response, selftest_fail_resp, 4) == 0)
    2740:	50 e0       	ldi	r21, 0x00	; 0
    2742:	be 01       	movw	r22, r28
    2744:	6f 5f       	subi	r22, 0xFF	; 255
    2746:	7f 4f       	sbci	r23, 0xFF	; 255
    2748:	ce 01       	movw	r24, r28
    274a:	09 96       	adiw	r24, 0x09	; 9
    274c:	0e 94 c1 56 	call	0xad82	; 0xad82 <memcmp>
calib_execute_command():
    2750:	07 ed       	ldi	r16, 0xD7	; 215
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:385
    {
        return ATCA_STATUS_SELFTEST_ERROR;
    2752:	10 e0       	ldi	r17, 0x00	; 0
hal_check_wake():
    2754:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:383
    }
    if (memcmp(response, expected_response, 4) == 0)
    {
        return ATCA_SUCCESS;
    }
    if (memcmp(response, selftest_fail_resp, 4) == 0)
    2756:	c9 f2       	breq	.-78     	; 0x270a <calib_execute_command+0x3de>
    2758:	bc cf       	rjmp	.-136    	; 0x26d2 <calib_execute_command+0x3a6>
calib_execute_command():
    275a:	01 97       	sbiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:512
            /* Send the command packet to the device */
            if ((ATCA_I2C_IFACE == device->mIface.mIfaceCFG->iface_type) || (ATCA_CUSTOM_IFACE == device->mIface.mIfaceCFG->iface_type))
            {
                packet->_reserved = 0x03;
            }
            else if (ATCA_SWI_IFACE == device->mIface.mIfaceCFG->iface_type)
    275c:	09 f0       	breq	.+2      	; 0x2760 <calib_execute_command+0x434>
    275e:	8c ce       	rjmp	.-744    	; 0x2478 <calib_execute_command+0x14c>
    2760:	87 e7       	ldi	r24, 0x77	; 119
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:514
            {
                packet->_reserved = CALIB_SWI_FLAG_CMD;
    2762:	d1 01       	movw	r26, r2
    2764:	8c 93       	st	X, r24
    2766:	88 ce       	rjmp	.-752    	; 0x2478 <calib_execute_command+0x14c>
calib_execute_send():
    2768:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:342
    {
        status = atsend(&device->mIface, 0xFF, (uint8_t*)&txdata[1], (int)txlength - 1);
    }
    else
    {
        status = atcontrol(&device->mIface, ATCA_HAL_CONTROL_SELECT, NULL, 0);
    276a:	20 e0       	ldi	r18, 0x00	; 0
    276c:	50 e0       	ldi	r21, 0x00	; 0
    276e:	40 e0       	ldi	r20, 0x00	; 0
    2770:	64 e0       	ldi	r22, 0x04	; 4
    2772:	c3 01       	movw	r24, r6
    2774:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <atcontrol>
    2778:	8c 01       	movw	r16, r24
    277a:	85 3f       	cpi	r24, 0xF5	; 245
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:343
        if (ATCA_UNIMPLEMENTED == status || ATCA_SUCCESS == status)
    277c:	91 05       	cpc	r25, r1
    277e:	11 f0       	breq	.+4      	; 0x2784 <calib_execute_command+0x458>
    2780:	89 2b       	or	r24, r25
    2782:	49 f4       	brne	.+18     	; 0x2796 <calib_execute_command+0x46a>
calib_execute_command():
    2784:	97 01       	movw	r18, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:522
            else if ((ATCA_SWI_GPIO_IFACE == device->mIface.mIfaceCFG->iface_type) && (atcab_is_ca2_device(device->mIface.mIfaceCFG->devtype)))
            {
                packet->_reserved = 0x03;
            }
    #endif
            if (ATCA_RX_NO_RESPONSE == (status = calib_execute_send(device, device_address, (uint8_t*)packet, packet->txsize + 1)))
    2786:	2f 5f       	subi	r18, 0xFF	; 255
    2788:	3f 4f       	sbci	r19, 0xFF	; 255
calib_execute_send():
    278a:	a1 01       	movw	r20, r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:346
    {
        status = atcontrol(&device->mIface, ATCA_HAL_CONTROL_SELECT, NULL, 0);
        if (ATCA_UNIMPLEMENTED == status || ATCA_SUCCESS == status)
        {
            /* Send the command packet to the device */
            status = atsend(&device->mIface, device_address, (uint8_t*)txdata, (int)txlength);
    278c:	6e 89       	ldd	r22, Y+22	; 0x16
    278e:	c3 01       	movw	r24, r6
    2790:	0e 94 1b 09 	call	0x1236	; 0x1236 <atsend>
    2794:	8c 01       	movw	r16, r24
    2796:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:348
        }
        (void)atcontrol(&device->mIface, ATCA_HAL_CONTROL_DESELECT, NULL, 0);
    2798:	20 e0       	ldi	r18, 0x00	; 0
    279a:	50 e0       	ldi	r21, 0x00	; 0
    279c:	40 e0       	ldi	r20, 0x00	; 0
    279e:	65 e0       	ldi	r22, 0x05	; 5
    27a0:	c3 01       	movw	r24, r6
    27a2:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <atcontrol>
    27a6:	7a ce       	rjmp	.-780    	; 0x249c <calib_execute_command+0x170>
calib_execute_command():
    27a8:	f3 01       	movw	r30, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:528
            {
                device->device_state = ATCA_DEVICE_STATE_UNKNOWN;
            }
            else
            {
                if (ATCA_DEVICE_STATE_ACTIVE != device->device_state)
    27aa:	80 85       	ldd	r24, Z+8	; 0x08
    27ac:	83 30       	cpi	r24, 0x03	; 3
    27ae:	11 f0       	breq	.+4      	; 0x27b4 <calib_execute_command+0x488>
    27b0:	83 e0       	ldi	r24, 0x03	; 3
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:530
                {
                    device->device_state = ATCA_DEVICE_STATE_ACTIVE;
    27b2:	80 87       	std	Z+8, r24	; 0x08
    27b4:	01 15       	cp	r16, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:538
            }

        }
        while (0 < retries--);

        if (ATCA_SUCCESS != status)
    27b6:	11 05       	cpc	r17, r1
    27b8:	09 f0       	breq	.+2      	; 0x27bc <calib_execute_command+0x490>
    27ba:	3f c0       	rjmp	.+126    	; 0x283a <calib_execute_command+0x50e>
_delay_loop_2():
    27bc:	80 e7       	ldi	r24, 0x70	; 112
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay_basic.h:105
    27be:	97 e1       	ldi	r25, 0x17	; 23
    27c0:	01 97       	sbiw	r24, 0x01	; 1
    27c2:	f1 f7       	brne	.-4      	; 0x27c0 <calib_execute_command+0x494>
    27c4:	d1 2c       	mov	r13, r1
    27c6:	c1 2c       	mov	r12, r1
calib_execute_command():
    27c8:	71 01       	movw	r14, r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:548
        // Delay for execution time or initial wait before polling
        atca_delay_ms(execution_or_wait_time);

        do
        {
            memset(packet->data, 0, sizeof(packet->data));
    27ca:	f6 e0       	ldi	r31, 0x06	; 6
    27cc:	ef 0e       	add	r14, r31
    27ce:	f1 1c       	adc	r15, r1
    27d0:	80 ec       	ldi	r24, 0xC0	; 192
    27d2:	58 2e       	mov	r5, r24
calib_execute_receive():
    27d4:	aa 24       	eor	r10, r10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:369

#ifdef ATCA_HAL_LEGACY_API
    ((void)device_address);
    status = atreceive(&device->mIface, 0, rxdata, rxlength);
#else
    uint16_t read_length = 1;
    27d6:	a3 94       	inc	r10
    27d8:	b1 2c       	mov	r11, r1
    27da:	41 01       	movw	r8, r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:431
            }

            /* Read given length bytes from device */
            read_length -= 1;

            status = atreceive(&device->mIface, device_address, &rxdata[1], &read_length);
    27dc:	27 e0       	ldi	r18, 0x07	; 7
    27de:	82 0e       	add	r8, r18
    27e0:	91 1c       	adc	r9, r1
    27e2:	28 e8       	ldi	r18, 0x88	; 136
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:389
            }

            /*Send Word address to device...*/
            if (ATCA_SWI_IFACE == device->mIface.mIfaceCFG->iface_type)
            {
                word_address = CALIB_SWI_FLAG_TX;
    27e4:	42 2e       	mov	r4, r18
calib_execute_command():
    27e6:	d7 01       	movw	r26, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:548
        // Delay for execution time or initial wait before polling
        atca_delay_ms(execution_or_wait_time);

        do
        {
            memset(packet->data, 0, sizeof(packet->data));
    27e8:	e5 2d       	mov	r30, r5
    27ea:	1d 92       	st	X+, r1
    27ec:	ea 95       	dec	r30
    27ee:	e9 f7       	brne	.-6      	; 0x27ea <calib_execute_command+0x4be>
    27f0:	20 ec       	ldi	r18, 0xC0	; 192
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:550
            // receive the response
            rxsize = sizeof(packet->data);
    27f2:	30 e0       	ldi	r19, 0x00	; 0
    27f4:	2d 83       	std	Y+5, r18	; 0x05
    27f6:	3e 83       	std	Y+6, r19	; 0x06
calib_execute_receive():
    27f8:	a9 82       	std	Y+1, r10	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:369

#ifdef ATCA_HAL_LEGACY_API
    ((void)device_address);
    status = atreceive(&device->mIface, 0, rxdata, rxlength);
#else
    uint16_t read_length = 1;
    27fa:	ba 82       	std	Y+2, r11	; 0x02
    27fc:	c3 01       	movw	r24, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:372
    uint8_t word_address;

    if (atca_iface_is_kit(&device->mIface))
    27fe:	0e 94 de 08 	call	0x11bc	; 0x11bc <atca_iface_is_kit>
    2802:	88 23       	and	r24, r24
    2804:	09 f4       	brne	.+2      	; 0x2808 <calib_execute_command+0x4dc>
    2806:	65 c0       	rjmp	.+202    	; 0x28d2 <calib_execute_command+0x5a6>
    2808:	9e 01       	movw	r18, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:374
    {
        status = atreceive(&device->mIface, 0, rxdata, rxlength);
    280a:	2b 5f       	subi	r18, 0xFB	; 251
    280c:	3f 4f       	sbci	r19, 0xFF	; 255
    280e:	a7 01       	movw	r20, r14
    2810:	60 e0       	ldi	r22, 0x00	; 0
    2812:	c3 01       	movw	r24, r6
    2814:	0e 94 07 09 	call	0x120e	; 0x120e <atreceive>
    2818:	8c 01       	movw	r16, r24
calib_execute_command():
    281a:	01 15       	cp	r16, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:552
        {
            memset(packet->data, 0, sizeof(packet->data));
            // receive the response
            rxsize = sizeof(packet->data);

            if (ATCA_SUCCESS == (status = calib_execute_receive(device, device_address, packet->data, &rxsize)))
    281c:	11 05       	cpc	r17, r1
    281e:	09 f4       	brne	.+2      	; 0x2822 <calib_execute_command+0x4f6>
    2820:	12 c1       	rjmp	.+548    	; 0x2a46 <calib_execute_command+0x71a>
_delay_loop_2():
    2822:	80 ee       	ldi	r24, 0xE0	; 224
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay_basic.h:105
    2824:	9e e2       	ldi	r25, 0x2E	; 46
    2826:	01 97       	sbiw	r24, 0x01	; 1
    2828:	f1 f7       	brne	.-4      	; 0x2826 <calib_execute_command+0x4fa>
    282a:	ff ef       	ldi	r31, 0xFF	; 255
    282c:	cf 1a       	sub	r12, r31
    282e:	df 0a       	sbc	r13, r31
calib_execute_command():
    2830:	23 ee       	ldi	r18, 0xE3	; 227
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:562
#ifndef ATCA_NO_POLL
            // delay for polling frequency time
            atca_delay_ms(ATCA_POLLING_FREQUENCY_TIME_MSEC);
#endif
        }
        while (max_delay_count-- > 0);
    2832:	c2 16       	cp	r12, r18
    2834:	24 e0       	ldi	r18, 0x04	; 4
    2836:	d2 06       	cpc	r13, r18
    2838:	b1 f6       	brne	.-84     	; 0x27e6 <calib_execute_command+0x4ba>
    283a:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:596
        }
    }
    while (0);

    // Skip Idle for ECC204 device
    if (!atcab_is_ca2_device(device->mIface.mIfaceCFG->devtype))
    283c:	ed 91       	ld	r30, X+
    283e:	fc 91       	ld	r31, X
atcab_is_ca2_device():
    2840:	82 81       	ldd	r24, Z+2	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:264
/** \brief Check whether the device is cryptoauth device
 *  \return True if device is cryptoauth device or False.
 */
bool atcab_is_ca2_device(ATCADeviceType dev_type)
{
    return ((dev_type & 0xF0) == 0x20) ? true : false;
    2842:	93 81       	ldd	r25, Z+3	; 0x03
    2844:	80 7f       	andi	r24, 0xF0	; 240
    2846:	99 27       	eor	r25, r25
calib_execute_command():
    2848:	80 97       	sbiw	r24, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:596
    284a:	61 f1       	breq	.+88     	; 0x28a4 <calib_execute_command+0x578>
calib_idle():
    284c:	c3 01       	movw	r24, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:146
 *  \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS calib_idle(ATCADevice device)
{
    ATCA_STATUS status = ATCA_BAD_PARAM;
    ATCADeviceType device_type = atcab_get_device_type_ext(device);
    284e:	0e 94 51 09 	call	0x12a2	; 0x12a2 <atcab_get_device_type_ext>
    2852:	7c 01       	movw	r14, r24
    2854:	c3 01       	movw	r24, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:151

#ifdef ATCA_HAL_LEGACY_API
    status = atidle(&device->mIface);
#else
    if (atca_iface_is_kit(&device->mIface) || atca_iface_is_swi(&device->mIface))
    2856:	0e 94 de 08 	call	0x11bc	; 0x11bc <atca_iface_is_kit>
    285a:	81 11       	cpse	r24, r1
    285c:	06 c0       	rjmp	.+12     	; 0x286a <calib_execute_command+0x53e>
    285e:	c3 01       	movw	r24, r6
    2860:	0e 94 cb 08 	call	0x1196	; 0x1196 <atca_iface_is_swi>
    2864:	88 23       	and	r24, r24
    2866:	09 f4       	brne	.+2      	; 0x286a <calib_execute_command+0x53e>
    2868:	d7 c0       	rjmp	.+430    	; 0x2a18 <calib_execute_command+0x6ec>
atidle():
    286a:	61 14       	cp	r6, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:271
 * \param[in] ca_iface  Device to interact with.
 * \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS atidle(ATCAIface ca_iface)
{
    if (!ca_iface)
    286c:	71 04       	cpc	r7, r1
    286e:	b1 f0       	breq	.+44     	; 0x289c <calib_execute_command+0x570>
    2870:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:276
    {
        return ATCA_BAD_PARAM;
    }

    if (ca_iface->hal && ca_iface->hal->halcontrol)
    2872:	12 96       	adiw	r26, 0x02	; 2
    2874:	ed 91       	ld	r30, X+
    2876:	fc 91       	ld	r31, X
    2878:	30 97       	sbiw	r30, 0x00	; 0
    287a:	81 f0       	breq	.+32     	; 0x289c <calib_execute_command+0x570>
    287c:	00 84       	ldd	r0, Z+8	; 0x08
    287e:	f1 85       	ldd	r31, Z+9	; 0x09
    2880:	e0 2d       	mov	r30, r0
    2882:	30 97       	sbiw	r30, 0x00	; 0
    2884:	59 f0       	breq	.+22     	; 0x289c <calib_execute_command+0x570>
    2886:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:278
    {
        ATCA_STATUS status = ca_iface->hal->halcontrol(ca_iface, ATCA_HAL_CONTROL_IDLE, NULL, 0);
    2888:	20 e0       	ldi	r18, 0x00	; 0
    288a:	50 e0       	ldi	r21, 0x00	; 0
    288c:	40 e0       	ldi	r20, 0x00	; 0
    288e:	61 e0       	ldi	r22, 0x01	; 1
    2890:	c3 01       	movw	r24, r6
    2892:	09 95       	icall
_delay_loop_2():
    2894:	80 e7       	ldi	r24, 0x70	; 112
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay_basic.h:105
    2896:	97 e1       	ldi	r25, 0x17	; 23
    2898:	01 97       	sbiw	r24, 0x01	; 1
    289a:	f1 f7       	brne	.-4      	; 0x2898 <calib_execute_command+0x56c>
calib_execute_command():
    289c:	82 e0       	ldi	r24, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:599
    {
        (void)calib_idle(device);
        device->device_state = ATCA_DEVICE_STATE_IDLE;
    289e:	d3 01       	movw	r26, r6
    28a0:	18 96       	adiw	r26, 0x08	; 8
    28a2:	8c 93       	st	X, r24
    28a4:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:603
    }

    return status;
}
    28a6:	a4 96       	adiw	r28, 0x24	; 36
    28a8:	cd bf       	out	0x3d, r28	; 61
    28aa:	de bf       	out	0x3e, r29	; 62
    28ac:	df 91       	pop	r29
    28ae:	cf 91       	pop	r28
    28b0:	1f 91       	pop	r17
    28b2:	0f 91       	pop	r16
    28b4:	ff 90       	pop	r15
    28b6:	ef 90       	pop	r14
    28b8:	df 90       	pop	r13
    28ba:	cf 90       	pop	r12
    28bc:	bf 90       	pop	r11
    28be:	af 90       	pop	r10
    28c0:	9f 90       	pop	r9
    28c2:	8f 90       	pop	r8
    28c4:	7f 90       	pop	r7
    28c6:	6f 90       	pop	r6
    28c8:	5f 90       	pop	r5
    28ca:	4f 90       	pop	r4
    28cc:	3f 90       	pop	r3
    28ce:	2f 90       	pop	r2
    28d0:	08 95       	ret
calib_execute_receive():
    28d2:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:380
    }
    else
    {
        do
        {
            status = atcontrol(&device->mIface, ATCA_HAL_CONTROL_SELECT, NULL, 0);
    28d4:	20 e0       	ldi	r18, 0x00	; 0
    28d6:	50 e0       	ldi	r21, 0x00	; 0
    28d8:	40 e0       	ldi	r20, 0x00	; 0
    28da:	64 e0       	ldi	r22, 0x04	; 4
    28dc:	c3 01       	movw	r24, r6
    28de:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <atcontrol>
    28e2:	8c 01       	movw	r16, r24
    28e4:	85 3f       	cpi	r24, 0xF5	; 245
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:381
            if (ATCA_UNIMPLEMENTED != status && ATCA_SUCCESS != status)
    28e6:	91 05       	cpc	r25, r1
    28e8:	11 f0       	breq	.+4      	; 0x28ee <calib_execute_command+0x5c2>
    28ea:	89 2b       	or	r24, r25
    28ec:	c9 f4       	brne	.+50     	; 0x2920 <calib_execute_command+0x5f4>
    28ee:	d3 01       	movw	r26, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:387
            {
                break;
            }

            /*Send Word address to device...*/
            if (ATCA_SWI_IFACE == device->mIface.mIfaceCFG->iface_type)
    28f0:	ed 91       	ld	r30, X+
    28f2:	fc 91       	ld	r31, X
    28f4:	80 81       	ld	r24, Z
    28f6:	91 81       	ldd	r25, Z+1	; 0x01
    28f8:	01 97       	sbiw	r24, 0x01	; 1
    28fa:	d9 f4       	brne	.+54     	; 0x2932 <calib_execute_command+0x606>
    28fc:	49 86       	std	Y+9, r4	; 0x09
atcab_is_ca2_device():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:389
            {
                word_address = CALIB_SWI_FLAG_TX;
    28fe:	82 81       	ldd	r24, Z+2	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:264
    2900:	93 81       	ldd	r25, Z+3	; 0x03
    2902:	80 7f       	andi	r24, 0xF0	; 240
    2904:	99 27       	eor	r25, r25
calib_execute_receive():
    2906:	80 97       	sbiw	r24, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:397
            {
                word_address = 0;
            }

            // Skip word address send for ECC204 device
            if (!atcab_is_ca2_device(device->mIface.mIfaceCFG->devtype))
    2908:	b1 f4       	brne	.+44     	; 0x2936 <calib_execute_command+0x60a>
    290a:	9e 01       	movw	r18, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:406
                    break;
                }
            }

            /* Read length bytes to know number of bytes to read */
            status = atreceive(&device->mIface, device_address, rxdata, &read_length);
    290c:	2f 5f       	subi	r18, 0xFF	; 255
    290e:	3f 4f       	sbci	r19, 0xFF	; 255
    2910:	a7 01       	movw	r20, r14
    2912:	6e 89       	ldd	r22, Y+22	; 0x16
    2914:	c3 01       	movw	r24, r6
    2916:	0e 94 07 09 	call	0x120e	; 0x120e <atreceive>
    291a:	8c 01       	movw	r16, r24
    291c:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:407
            if (ATCA_SUCCESS != status)
    291e:	c1 f0       	breq	.+48     	; 0x2950 <calib_execute_command+0x624>
    2920:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:445

            *rxlength = read_length;
        }
        while (0);

        (void)atcontrol(&device->mIface, ATCA_HAL_CONTROL_DESELECT, NULL, 0);
    2922:	20 e0       	ldi	r18, 0x00	; 0
    2924:	50 e0       	ldi	r21, 0x00	; 0
    2926:	40 e0       	ldi	r20, 0x00	; 0
    2928:	65 e0       	ldi	r22, 0x05	; 5
    292a:	c3 01       	movw	r24, r6
    292c:	0e 94 f3 08 	call	0x11e6	; 0x11e6 <atcontrol>
    2930:	74 cf       	rjmp	.-280    	; 0x281a <calib_execute_command+0x4ee>
    2932:	19 86       	std	Y+9, r1	; 0x09
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:393
            {
                word_address = CALIB_SWI_FLAG_TX;
            }
            else
            {
                word_address = 0;
    2934:	e4 cf       	rjmp	.-56     	; 0x28fe <calib_execute_command+0x5d2>
    2936:	21 e0       	ldi	r18, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:399
            }

            // Skip word address send for ECC204 device
            if (!atcab_is_ca2_device(device->mIface.mIfaceCFG->devtype))
            {
                if (ATCA_SUCCESS != (status = atsend(&device->mIface, device_address, &word_address, sizeof(word_address))))
    2938:	30 e0       	ldi	r19, 0x00	; 0
    293a:	ae 01       	movw	r20, r28
    293c:	47 5f       	subi	r20, 0xF7	; 247
    293e:	5f 4f       	sbci	r21, 0xFF	; 255
    2940:	6e 89       	ldd	r22, Y+22	; 0x16
    2942:	c3 01       	movw	r24, r6
    2944:	0e 94 1b 09 	call	0x1236	; 0x1236 <atsend>
    2948:	8c 01       	movw	r16, r24
    294a:	89 2b       	or	r24, r25
    294c:	49 f7       	brne	.-46     	; 0x2920 <calib_execute_command+0x5f4>
    294e:	dd cf       	rjmp	.-70     	; 0x290a <calib_execute_command+0x5de>
    2950:	f1 01       	movw	r30, r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:414
                ATCA_TRACE(status, "atreceive - failed");
                break;
            }

            /*Calculate bytes to read based on device response*/
            read_length = rxdata[0];
    2952:	86 81       	ldd	r24, Z+6	; 0x06
    2954:	90 e0       	ldi	r25, 0x00	; 0
    2956:	89 83       	std	Y+1, r24	; 0x01
    2958:	9a 83       	std	Y+2, r25	; 0x02
    295a:	2d 81       	ldd	r18, Y+5	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:416

            if (read_length > *rxlength)
    295c:	3e 81       	ldd	r19, Y+6	; 0x06
calib_execute_command():
    295e:	0d ee       	ldi	r16, 0xED	; 237
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:418
            {
                status = ATCA_TRACE(ATCA_SMALL_BUFFER, "rxdata is small buffer");
    2960:	10 e0       	ldi	r17, 0x00	; 0
calib_execute_receive():
    2962:	28 17       	cp	r18, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:416
            }

            /*Calculate bytes to read based on device response*/
            read_length = rxdata[0];

            if (read_length > *rxlength)
    2964:	39 07       	cpc	r19, r25
    2966:	e0 f2       	brcs	.-72     	; 0x2920 <calib_execute_command+0x5f4>
calib_execute_command():
    2968:	06 ee       	ldi	r16, 0xE6	; 230
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:424
                break;
            }

            if (read_length < 4)
            {
                status = ATCA_TRACE(ATCA_RX_FAIL, "packet size is invalid");
    296a:	10 e0       	ldi	r17, 0x00	; 0
calib_execute_receive():
    296c:	84 30       	cpi	r24, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:422
            {
                status = ATCA_TRACE(ATCA_SMALL_BUFFER, "rxdata is small buffer");
                break;
            }

            if (read_length < 4)
    296e:	91 05       	cpc	r25, r1
    2970:	b8 f2       	brcs	.-82     	; 0x2920 <calib_execute_command+0x5f4>
    2972:	01 97       	sbiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:429
                status = ATCA_TRACE(ATCA_RX_FAIL, "packet size is invalid");
                break;
            }

            /* Read given length bytes from device */
            read_length -= 1;
    2974:	89 83       	std	Y+1, r24	; 0x01
    2976:	9a 83       	std	Y+2, r25	; 0x02
    2978:	9e 01       	movw	r18, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:431

            status = atreceive(&device->mIface, device_address, &rxdata[1], &read_length);
    297a:	2f 5f       	subi	r18, 0xFF	; 255
    297c:	3f 4f       	sbci	r19, 0xFF	; 255
    297e:	a4 01       	movw	r20, r8
    2980:	6e 89       	ldd	r22, Y+22	; 0x16
    2982:	c3 01       	movw	r24, r6
    2984:	0e 94 07 09 	call	0x120e	; 0x120e <atreceive>
    2988:	8c 01       	movw	r16, r24
    298a:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:433

            if (ATCA_SUCCESS != status)
    298c:	49 f6       	brne	.-110    	; 0x2920 <calib_execute_command+0x5f4>
    298e:	89 81       	ldd	r24, Y+1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:439
            {
                status = ATCA_TRACE(status, "atreceive - failed");
                break;
            }

            read_length += 1;
    2990:	9a 81       	ldd	r25, Y+2	; 0x02
    2992:	01 96       	adiw	r24, 0x01	; 1
    2994:	89 83       	std	Y+1, r24	; 0x01
    2996:	9a 83       	std	Y+2, r25	; 0x02
    2998:	8d 83       	std	Y+5, r24	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:441

            *rxlength = read_length;
    299a:	9e 83       	std	Y+6, r25	; 0x06
    299c:	c1 cf       	rjmp	.-126    	; 0x2920 <calib_execute_command+0x5f4>
calib_execute_command():
    299e:	06 ee       	ldi	r16, 0xE6	; 230
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:574
        // Check response size
        if (rxsize < 4)
        {
            if (rxsize > 0)
            {
                status = ATCA_RX_FAIL;
    29a0:	10 e0       	ldi	r17, 0x00	; 0
    29a2:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:572
        }

        // Check response size
        if (rxsize < 4)
        {
            if (rxsize > 0)
    29a4:	09 f0       	breq	.+2      	; 0x29a8 <calib_execute_command+0x67c>
    29a6:	49 cf       	rjmp	.-366    	; 0x283a <calib_execute_command+0x50e>
    29a8:	89 cd       	rjmp	.-1262   	; 0x24bc <calib_execute_command+0x190>
isATCAError():
    29aa:	f1 01       	movw	r30, r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:799
 * \return ATCA_SUCCESS on success, otherwise an error code.
 */

ATCA_STATUS isATCAError(uint8_t *data)
{
    if (data[0] == 0x04)        // error packets are always 4 bytes long
    29ac:	86 81       	ldd	r24, Z+6	; 0x06
    29ae:	84 30       	cpi	r24, 0x04	; 4
    29b0:	09 f0       	breq	.+2      	; 0x29b4 <calib_execute_command+0x688>
    29b2:	43 cf       	rjmp	.-378    	; 0x283a <calib_execute_command+0x50e>
    29b4:	87 81       	ldd	r24, Z+7	; 0x07
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:801
    {
        switch (data[1])
    29b6:	87 30       	cpi	r24, 0x07	; 7
    29b8:	49 f1       	breq	.+82     	; 0x2a0c <calib_execute_command+0x6e0>
    29ba:	88 f4       	brcc	.+34     	; 0x29de <calib_execute_command+0x6b2>
    29bc:	81 30       	cpi	r24, 0x01	; 1
    29be:	49 f1       	breq	.+82     	; 0x2a12 <calib_execute_command+0x6e6>
    29c0:	08 f4       	brcc	.+2      	; 0x29c4 <calib_execute_command+0x698>
    29c2:	3b cf       	rjmp	.-394    	; 0x283a <calib_execute_command+0x50e>
calib_execute_command():
    29c4:	02 ed       	ldi	r16, 0xD2	; 210
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:809
            return ATCA_SUCCESS;
        case 0x01: // checkmac or verify failed
            return ATCA_CHECKMAC_VERIFY_FAILED;
            break;
        case 0x03: // command received byte length, opcode or parameter was illegal
            return ATCA_PARSE_ERROR;
    29c6:	10 e0       	ldi	r17, 0x00	; 0
isATCAError():
    29c8:	83 30       	cpi	r24, 0x03	; 3
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:801

ATCA_STATUS isATCAError(uint8_t *data)
{
    if (data[0] == 0x04)        // error packets are always 4 bytes long
    {
        switch (data[1])
    29ca:	09 f4       	brne	.+2      	; 0x29ce <calib_execute_command+0x6a2>
    29cc:	36 cf       	rjmp	.-404    	; 0x283a <calib_execute_command+0x50e>
calib_execute_command():
    29ce:	06 ed       	ldi	r16, 0xD6	; 214
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:812
            break;
        case 0x03: // command received byte length, opcode or parameter was illegal
            return ATCA_PARSE_ERROR;
            break;
        case 0x05: // computation error during ECC processing causing invalid results
            return ATCA_STATUS_ECC;
    29d0:	10 e0       	ldi	r17, 0x00	; 0
isATCAError():
    29d2:	85 30       	cpi	r24, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:801

ATCA_STATUS isATCAError(uint8_t *data)
{
    if (data[0] == 0x04)        // error packets are always 4 bytes long
    {
        switch (data[1])
    29d4:	09 f4       	brne	.+2      	; 0x29d8 <calib_execute_command+0x6ac>
    29d6:	31 cf       	rjmp	.-414    	; 0x283a <calib_execute_command+0x50e>
calib_execute_command():
    29d8:	01 ee       	ldi	r16, 0xE1	; 225
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:829
            break;
        case 0xff: // bad crc found (command not properly received by device) or other comm error
            return ATCA_STATUS_CRC;
            break;
        default:
            return ATCA_GEN_FAIL;
    29da:	10 e0       	ldi	r17, 0x00	; 0
    29dc:	2e cf       	rjmp	.-420    	; 0x283a <calib_execute_command+0x50e>
    29de:	04 ef       	ldi	r16, 0xF4	; 244
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:820
            return ATCA_STATUS_SELFTEST_ERROR;
            break;
        case 0x08: //random number generator health test error
            return ATCA_HEALTH_TEST_ERROR;
        case 0x0f: // chip can't execute the command
            return ATCA_EXECUTION_ERROR;
    29e0:	10 e0       	ldi	r17, 0x00	; 0
isATCAError():
    29e2:	8f 30       	cpi	r24, 0x0F	; 15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:801

ATCA_STATUS isATCAError(uint8_t *data)
{
    if (data[0] == 0x04)        // error packets are always 4 bytes long
    {
        switch (data[1])
    29e4:	09 f4       	brne	.+2      	; 0x29e8 <calib_execute_command+0x6bc>
    29e6:	29 cf       	rjmp	.-430    	; 0x283a <calib_execute_command+0x50e>
    29e8:	30 f4       	brcc	.+12     	; 0x29f6 <calib_execute_command+0x6ca>
calib_execute_command():
    29ea:	0a ef       	ldi	r16, 0xFA	; 250
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:818
            break;
        case 0x07: // chip is in self test failure mode
            return ATCA_STATUS_SELFTEST_ERROR;
            break;
        case 0x08: //random number generator health test error
            return ATCA_HEALTH_TEST_ERROR;
    29ec:	10 e0       	ldi	r17, 0x00	; 0
isATCAError():
    29ee:	88 30       	cpi	r24, 0x08	; 8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:801

ATCA_STATUS isATCAError(uint8_t *data)
{
    if (data[0] == 0x04)        // error packets are always 4 bytes long
    {
        switch (data[1])
    29f0:	09 f4       	brne	.+2      	; 0x29f4 <calib_execute_command+0x6c8>
    29f2:	23 cf       	rjmp	.-442    	; 0x283a <calib_execute_command+0x50e>
    29f4:	f1 cf       	rjmp	.-30     	; 0x29d8 <calib_execute_command+0x6ac>
calib_execute_command():
    29f6:	03 ef       	ldi	r16, 0xF3	; 243
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:823
            return ATCA_HEALTH_TEST_ERROR;
        case 0x0f: // chip can't execute the command
            return ATCA_EXECUTION_ERROR;
            break;
        case 0x11: // chip was successfully woken up
            return ATCA_WAKE_SUCCESS;
    29f8:	10 e0       	ldi	r17, 0x00	; 0
isATCAError():
    29fa:	81 31       	cpi	r24, 0x11	; 17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:801

ATCA_STATUS isATCAError(uint8_t *data)
{
    if (data[0] == 0x04)        // error packets are always 4 bytes long
    {
        switch (data[1])
    29fc:	09 f4       	brne	.+2      	; 0x2a00 <calib_execute_command+0x6d4>
    29fe:	1d cf       	rjmp	.-454    	; 0x283a <calib_execute_command+0x50e>
calib_execute_command():
    2a00:	04 ed       	ldi	r16, 0xD4	; 212
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:826
            break;
        case 0x11: // chip was successfully woken up
            return ATCA_WAKE_SUCCESS;
            break;
        case 0xff: // bad crc found (command not properly received by device) or other comm error
            return ATCA_STATUS_CRC;
    2a02:	10 e0       	ldi	r17, 0x00	; 0
isATCAError():
    2a04:	8f 3f       	cpi	r24, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:801

ATCA_STATUS isATCAError(uint8_t *data)
{
    if (data[0] == 0x04)        // error packets are always 4 bytes long
    {
        switch (data[1])
    2a06:	09 f4       	brne	.+2      	; 0x2a0a <calib_execute_command+0x6de>
    2a08:	18 cf       	rjmp	.-464    	; 0x283a <calib_execute_command+0x50e>
    2a0a:	e6 cf       	rjmp	.-52     	; 0x29d8 <calib_execute_command+0x6ac>
calib_execute_command():
    2a0c:	07 ed       	ldi	r16, 0xD7	; 215
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:815
            break;
        case 0x05: // computation error during ECC processing causing invalid results
            return ATCA_STATUS_ECC;
            break;
        case 0x07: // chip is in self test failure mode
            return ATCA_STATUS_SELFTEST_ERROR;
    2a0e:	10 e0       	ldi	r17, 0x00	; 0
    2a10:	14 cf       	rjmp	.-472    	; 0x283a <calib_execute_command+0x50e>
    2a12:	01 ed       	ldi	r16, 0xD1	; 209
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:806
        switch (data[1])
        {
        case 0x00: //No Error
            return ATCA_SUCCESS;
        case 0x01: // checkmac or verify failed
            return ATCA_CHECKMAC_VERIFY_FAILED;
    2a14:	10 e0       	ldi	r17, 0x00	; 0
    2a16:	11 cf       	rjmp	.-478    	; 0x283a <calib_execute_command+0x50e>
atcab_is_ca2_device():
    2a18:	b0 ef       	ldi	r27, 0xF0	; 240
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:264
    2a1a:	eb 22       	and	r14, r27
    2a1c:	ff 24       	eor	r15, r15
calib_idle():
    2a1e:	e0 e2       	ldi	r30, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:157
    {
        status = atidle(&device->mIface);
    }
    else
    {
        if (!atcab_is_ca2_device(device_type))
    2a20:	ee 16       	cp	r14, r30
    2a22:	f1 04       	cpc	r15, r1
    2a24:	09 f4       	brne	.+2      	; 0x2a28 <calib_execute_command+0x6fc>
    2a26:	3a cf       	rjmp	.-396    	; 0x289c <calib_execute_command+0x570>
    2a28:	82 e0       	ldi	r24, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:159
        {
            uint8_t command = 0x02;
    2a2a:	89 83       	std	Y+1, r24	; 0x01
    2a2c:	c3 01       	movw	r24, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:160
            status = atsend(&device->mIface, atcab_get_device_address(device), &command, 1);
    2a2e:	0e 94 42 09 	call	0x1284	; 0x1284 <atcab_get_device_address>
    2a32:	21 e0       	ldi	r18, 0x01	; 1
    2a34:	30 e0       	ldi	r19, 0x00	; 0
    2a36:	ae 01       	movw	r20, r28
    2a38:	4f 5f       	subi	r20, 0xFF	; 255
    2a3a:	5f 4f       	sbci	r21, 0xFF	; 255
    2a3c:	68 2f       	mov	r22, r24
    2a3e:	c3 01       	movw	r24, r6
    2a40:	0e 94 1b 09 	call	0x1236	; 0x1236 <atsend>
    2a44:	2b cf       	rjmp	.-426    	; 0x289c <calib_execute_command+0x570>
calib_execute_command():
    2a46:	8d 81       	ldd	r24, Y+5	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_execution.c:570
        {
            break;
        }

        // Check response size
        if (rxsize < 4)
    2a48:	9e 81       	ldd	r25, Y+6	; 0x06
    2a4a:	84 30       	cpi	r24, 0x04	; 4
    2a4c:	91 05       	cpc	r25, r1
    2a4e:	08 f4       	brcc	.+2      	; 0x2a52 <calib_execute_command+0x726>
    2a50:	a6 cf       	rjmp	.-180    	; 0x299e <calib_execute_command+0x672>
atCheckCrc():
    2a52:	d1 01       	movw	r26, r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:733
 */

ATCA_STATUS atCheckCrc(const uint8_t *response)
{
    uint8_t crc[ATCA_CRC_SIZE];
    uint8_t count = response[ATCA_COUNT_IDX];
    2a54:	16 96       	adiw	r26, 0x06	; 6
    2a56:	cc 90       	ld	r12, X
    2a58:	ca 94       	dec	r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:735

    count -= ATCA_CRC_SIZE;
    2a5a:	ca 94       	dec	r12
    2a5c:	d1 2c       	mov	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:736
    atCRC(count, response, crc);
    2a5e:	ae 01       	movw	r20, r28
    2a60:	4f 5f       	subi	r20, 0xFF	; 255
    2a62:	5f 4f       	sbci	r21, 0xFF	; 255
    2a64:	b7 01       	movw	r22, r14
    2a66:	c6 01       	movw	r24, r12
    2a68:	0e 94 93 08 	call	0x1126	; 0x1126 <atCRC>
    2a6c:	f7 01       	movw	r30, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:738

    return (crc[0] == response[count] && crc[1] == response[count + 1]) ? ATCA_SUCCESS : ATCA_RX_CRC_ERROR;
    2a6e:	ec 0d       	add	r30, r12
    2a70:	fd 1d       	adc	r31, r13
    2a72:	99 81       	ldd	r25, Y+1	; 0x01
    2a74:	80 81       	ld	r24, Z
    2a76:	98 13       	cpse	r25, r24
    2a78:	05 c0       	rjmp	.+10     	; 0x2a84 <calib_execute_command+0x758>
    2a7a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a7c:	81 81       	ldd	r24, Z+1	; 0x01
    2a7e:	98 17       	cp	r25, r24
    2a80:	09 f4       	brne	.+2      	; 0x2a84 <calib_execute_command+0x758>
    2a82:	93 cf       	rjmp	.-218    	; 0x29aa <calib_execute_command+0x67e>
    2a84:	05 ee       	ldi	r16, 0xE5	; 229
    2a86:	10 e0       	ldi	r17, 0x00	; 0
    2a88:	d8 ce       	rjmp	.-592    	; 0x283a <calib_execute_command+0x50e>

00002a8a <calib_read_bytes_zone>:
calib_read_bytes_zone():
    2a8a:	2f 92       	push	r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:286
 *  \param[in]  length  Number of bytes to read starting from the offset.
 *
 *  \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS calib_read_bytes_zone(ATCADevice device, uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)
{
    2a8c:	3f 92       	push	r3
    2a8e:	4f 92       	push	r4
    2a90:	5f 92       	push	r5
    2a92:	6f 92       	push	r6
    2a94:	7f 92       	push	r7
    2a96:	8f 92       	push	r8
    2a98:	9f 92       	push	r9
    2a9a:	af 92       	push	r10
    2a9c:	bf 92       	push	r11
    2a9e:	cf 92       	push	r12
    2aa0:	df 92       	push	r13
    2aa2:	ef 92       	push	r14
    2aa4:	ff 92       	push	r15
    2aa6:	0f 93       	push	r16
    2aa8:	1f 93       	push	r17
    2aaa:	cf 93       	push	r28
    2aac:	df 93       	push	r29
    2aae:	cd b7       	in	r28, 0x3d	; 61
    2ab0:	de b7       	in	r29, 0x3e	; 62
    2ab2:	c0 5f       	subi	r28, 0xF0	; 240
    2ab4:	d1 09       	sbc	r29, r1
    2ab6:	cd bf       	out	0x3d, r28	; 61
    2ab8:	de bf       	out	0x3e, r29	; 62
    2aba:	e1 14       	cp	r14, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:301
    size_t read_offset = 0;

    ATCA_CHECK_INVALID_MSG((zone != ATCA_ZONE_CONFIG && zone != ATCA_ZONE_OTP && zone != ATCA_ZONE_DATA), ATCA_BAD_PARAM, "Invalid zone received");
    ATCA_CHECK_INVALID_MSG((zone == ATCA_ZONE_DATA && slot > 15), ATCA_BAD_PARAM, "Invalid slot received");

    if (length == 0)
    2abc:	f1 04       	cpc	r15, r1
    2abe:	c9 f4       	brne	.+50     	; 0x2af2 <calib_read_bytes_zone+0x68>
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:303
    {
        return ATCA_SUCCESS;  // Always succeed reading 0 bytes
    2ac2:	80 e0       	ldi	r24, 0x00	; 0
    2ac4:	c0 51       	subi	r28, 0x10	; 16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:377
        }
    }
    while (false);

    return status;
}
    2ac6:	df 4f       	sbci	r29, 0xFF	; 255
    2ac8:	cd bf       	out	0x3d, r28	; 61
    2aca:	de bf       	out	0x3e, r29	; 62
    2acc:	df 91       	pop	r29
    2ace:	cf 91       	pop	r28
    2ad0:	1f 91       	pop	r17
    2ad2:	0f 91       	pop	r16
    2ad4:	ff 90       	pop	r15
    2ad6:	ef 90       	pop	r14
    2ad8:	df 90       	pop	r13
    2ada:	cf 90       	pop	r12
    2adc:	bf 90       	pop	r11
    2ade:	af 90       	pop	r10
    2ae0:	9f 90       	pop	r9
    2ae2:	8f 90       	pop	r8
    2ae4:	7f 90       	pop	r7
    2ae6:	6f 90       	pop	r6
    2ae8:	5f 90       	pop	r5
    2aea:	4f 90       	pop	r4
    2aec:	3f 90       	pop	r3
    2aee:	2f 90       	pop	r2
    2af0:	08 95       	ret
calib_get_zone_size():
    2af2:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:296
 */
ATCA_STATUS calib_get_zone_size(ATCADevice device, uint8_t zone, uint16_t slot, size_t* size)
{
    ATCA_STATUS status = ATCA_SUCCESS;

    if ((device == NULL) || (size == NULL))
    2af4:	19 f4       	brne	.+6      	; 0x2afc <calib_read_bytes_zone+0x72>
calib_read_bytes_zone():
    2af6:	82 ee       	ldi	r24, 0xE2	; 226
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:298
    {
        return ATCA_TRACE(ATCA_BAD_PARAM, "NULL pointer received");
    2af8:	90 e0       	ldi	r25, 0x00	; 0
    2afa:	e4 cf       	rjmp	.-56     	; 0x2ac4 <calib_read_bytes_zone+0x3a>
calib_get_zone_size():
    2afc:	dc 01       	movw	r26, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:301
    }

    if (device->mIface.mIfaceCFG->devtype == ATSHA204A)
    2afe:	ed 91       	ld	r30, X+
    2b00:	fc 91       	ld	r31, X
    2b02:	02 80       	ldd	r0, Z+2	; 0x02
    2b04:	f3 81       	ldd	r31, Z+3	; 0x03
    2b06:	e0 2d       	mov	r30, r0
calib_read_bytes_zone():
    2b08:	b1 2c       	mov	r11, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:288
 *  \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS calib_read_bytes_zone(ATCADevice device, uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)
{
    ATCA_STATUS status = ATCA_GEN_FAIL;
    size_t zone_size = 0;
    2b0a:	a1 2c       	mov	r10, r1
calib_get_zone_size():
    2b0c:	ef 2b       	or	r30, r31
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:301
    2b0e:	a1 f0       	breq	.+40     	; 0x2b38 <calib_read_bytes_zone+0xae>
    2b10:	a0 e4       	ldi	r26, 0x40	; 64
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:358
    else
    {
        switch (zone)
        {
        case ATCA_ZONE_CONFIG: *size = 128; break;
        case ATCA_ZONE_OTP:    *size = 64; break;
    2b12:	aa 2e       	mov	r10, r26
    2b14:	b1 2c       	mov	r11, r1
    2b16:	61 30       	cpi	r22, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:355
        }
    }
#endif
    else
    {
        switch (zone)
    2b18:	79 f0       	breq	.+30     	; 0x2b38 <calib_read_bytes_zone+0xae>
    2b1a:	70 e8       	ldi	r23, 0x80	; 128
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:357
        {
        case ATCA_ZONE_CONFIG: *size = 128; break;
    2b1c:	a7 2e       	mov	r10, r23
    2b1e:	b1 2c       	mov	r11, r1
    2b20:	62 30       	cpi	r22, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:355
        }
    }
#endif
    else
    {
        switch (zone)
    2b22:	51 f4       	brne	.+20     	; 0x2b38 <calib_read_bytes_zone+0xae>
    2b24:	b4 e2       	ldi	r27, 0x24	; 36
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:362
        case ATCA_ZONE_CONFIG: *size = 128; break;
        case ATCA_ZONE_OTP:    *size = 64; break;
        case ATCA_ZONE_DATA:
            if (slot < 8)
            {
                *size = 36;
    2b26:	ab 2e       	mov	r10, r27
    2b28:	b1 2c       	mov	r11, r1
    2b2a:	48 30       	cpi	r20, 0x08	; 8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:360
        switch (zone)
        {
        case ATCA_ZONE_CONFIG: *size = 128; break;
        case ATCA_ZONE_OTP:    *size = 64; break;
        case ATCA_ZONE_DATA:
            if (slot < 8)
    2b2c:	51 05       	cpc	r21, r1
    2b2e:	21 f4       	brne	.+8      	; 0x2b38 <calib_read_bytes_zone+0xae>
    2b30:	f0 ea       	ldi	r31, 0xA0	; 160
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:366
            {
                *size = 36;
            }
            else if (slot == 8)
            {
                *size = 416;
    2b32:	af 2e       	mov	r10, r31
    2b34:	bb 24       	eor	r11, r11
    2b36:	b3 94       	inc	r11
calib_read_bytes_zone():
    2b38:	f7 01       	movw	r30, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:317
            ATCA_TRACE(status, "calib_get_zone_size - failed");
            break;
        }

        // Can't read past the end of a zone
        ATCA_CHECK_INVALID_MSG((offset + length > zone_size), ATCA_BAD_PARAM, "Invalid parameter received");
    2b3a:	e2 0f       	add	r30, r18
    2b3c:	f3 1f       	adc	r31, r19
    2b3e:	ae 16       	cp	r10, r30
    2b40:	bf 06       	cpc	r11, r31
    2b42:	c8 f2       	brcs	.-78     	; 0x2af6 <calib_read_bytes_zone+0x6c>
    2b44:	17 01       	movw	r2, r14
    2b46:	c1 51       	subi	r28, 0x11	; 17
    2b48:	df 4f       	sbci	r29, 0xFF	; 255
    2b4a:	08 83       	st	Y, r16
    2b4c:	19 83       	std	Y+1, r17	; 0x01
    2b4e:	cf 5e       	subi	r28, 0xEF	; 239
    2b50:	d0 40       	sbci	r29, 0x00	; 0
    2b52:	29 01       	movw	r4, r18
    2b54:	c7 51       	subi	r28, 0x17	; 23
    2b56:	df 4f       	sbci	r29, 0xFF	; 255
    2b58:	68 83       	st	Y, r22
    2b5a:	c9 5e       	subi	r28, 0xE9	; 233
    2b5c:	d0 40       	sbci	r29, 0x00	; 0
    2b5e:	c3 51       	subi	r28, 0x13	; 19
    2b60:	df 4f       	sbci	r29, 0xFF	; 255
    2b62:	88 83       	st	Y, r24
    2b64:	99 83       	std	Y+1, r25	; 0x01
    2b66:	cd 5e       	subi	r28, 0xED	; 237
    2b68:	d0 40       	sbci	r29, 0x00	; 0
calib_get_addr():
    2b6a:	9a 01       	movw	r18, r20
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:240
            *addr = ((uint16_t)block) << 3;
            *addr |= offset;
        }
        else     // ATCA_ZONE_DATA
        {
            *addr = slot << 3;
    2b6c:	e3 e0       	ldi	r30, 0x03	; 3
    2b6e:	22 0f       	add	r18, r18
    2b70:	33 1f       	adc	r19, r19
    2b72:	ea 95       	dec	r30
    2b74:	e1 f7       	brne	.-8      	; 0x2b6e <calib_read_bytes_zone+0xe4>
    2b76:	c6 51       	subi	r28, 0x16	; 22
    2b78:	df 4f       	sbci	r29, 0xFF	; 255
    2b7a:	28 83       	st	Y, r18
    2b7c:	39 83       	std	Y+1, r19	; 0x01
    2b7e:	ca 5e       	subi	r28, 0xEA	; 234
    2b80:	d0 40       	sbci	r29, 0x00	; 0
calib_read_bytes_zone():
    2b82:	30 e2       	ldi	r19, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:293
    size_t zone_size = 0;
    uint8_t read_buf[32];
    size_t data_idx = 0;
    size_t cur_block = 0;
    size_t cur_offset = 0;
    uint8_t read_size = ATCA_BLOCK_SIZE;
    2b84:	c8 51       	subi	r28, 0x18	; 24
    2b86:	df 4f       	sbci	r29, 0xFF	; 255
    2b88:	38 83       	st	Y, r19
    2b8a:	c8 5e       	subi	r28, 0xE8	; 232
    2b8c:	d0 40       	sbci	r29, 0x00	; 0
    2b8e:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:292
    ATCA_STATUS status = ATCA_GEN_FAIL;
    size_t zone_size = 0;
    uint8_t read_buf[32];
    size_t data_idx = 0;
    size_t cur_block = 0;
    size_t cur_offset = 0;
    2b90:	00 e0       	ldi	r16, 0x00	; 0
    2b92:	d1 2c       	mov	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:319
        }

        // Can't read past the end of a zone
        ATCA_CHECK_INVALID_MSG((offset + length > zone_size), ATCA_BAD_PARAM, "Invalid parameter received");

        cur_block = offset / ATCA_BLOCK_SIZE;
    2b94:	c1 2c       	mov	r12, r1
    2b96:	f1 2c       	mov	r15, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:290
ATCA_STATUS calib_read_bytes_zone(ATCADevice device, uint8_t zone, uint16_t slot, size_t offset, uint8_t *data, size_t length)
{
    ATCA_STATUS status = ATCA_GEN_FAIL;
    size_t zone_size = 0;
    uint8_t read_buf[32];
    size_t data_idx = 0;
    2b98:	e1 2c       	mov	r14, r1
calib_read_zone():
    2b9a:	46 2f       	mov	r20, r22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:83
        }

        // If there are 32 bytes to read, then OR the bit into the mode
        if (len == ATCA_BLOCK_SIZE)
        {
            zone = zone | ATCA_ZONE_READWRITE_32;
    2b9c:	40 68       	ori	r20, 0x80	; 128
    2b9e:	c4 51       	subi	r28, 0x14	; 20
    2ba0:	df 4f       	sbci	r29, 0xFF	; 255
    2ba2:	48 83       	st	Y, r20
    2ba4:	cc 5e       	subi	r28, 0xEC	; 236
    2ba6:	d0 40       	sbci	r29, 0x00	; 0
calib_read_bytes_zone():
    2ba8:	e2 14       	cp	r14, r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:321
        // Can't read past the end of a zone
        ATCA_CHECK_INVALID_MSG((offset + length > zone_size), ATCA_BAD_PARAM, "Invalid parameter received");

        cur_block = offset / ATCA_BLOCK_SIZE;

        while (data_idx < length)
    2baa:	f3 04       	cpc	r15, r3
    2bac:	08 f0       	brcs	.+2      	; 0x2bb0 <calib_read_bytes_zone+0x126>
    2bae:	88 cf       	rjmp	.-240    	; 0x2ac0 <calib_read_bytes_zone+0x36>
    2bb0:	c8 51       	subi	r28, 0x18	; 24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:323
        {
            if (read_size == ATCA_BLOCK_SIZE && zone_size - cur_block * ATCA_BLOCK_SIZE < ATCA_BLOCK_SIZE)
    2bb2:	df 4f       	sbci	r29, 0xFF	; 255
    2bb4:	58 81       	ld	r21, Y
    2bb6:	c8 5e       	subi	r28, 0xE8	; 232
    2bb8:	d0 40       	sbci	r29, 0x00	; 0
    2bba:	50 32       	cpi	r21, 0x20	; 32
    2bbc:	09 f0       	breq	.+2      	; 0x2bc0 <calib_read_bytes_zone+0x136>
    2bbe:	a4 c0       	rjmp	.+328    	; 0x2d08 <calib_read_bytes_zone+0x27e>
    2bc0:	c6 01       	movw	r24, r12
    2bc2:	75 e0       	ldi	r23, 0x05	; 5
    2bc4:	88 0f       	add	r24, r24
    2bc6:	99 1f       	adc	r25, r25
    2bc8:	7a 95       	dec	r23
    2bca:	e1 f7       	brne	.-8      	; 0x2bc4 <calib_read_bytes_zone+0x13a>
    2bcc:	d5 01       	movw	r26, r10
    2bce:	a8 1b       	sub	r26, r24
    2bd0:	b9 0b       	sbc	r27, r25
    2bd2:	90 97       	sbiw	r26, 0x20	; 32
    2bd4:	10 f0       	brcs	.+4      	; 0x2bda <calib_read_bytes_zone+0x150>
    2bd6:	80 2f       	mov	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:331
                read_size = ATCA_WORD_SIZE;
                cur_offset = ((data_idx + offset) / ATCA_WORD_SIZE) % (ATCA_BLOCK_SIZE / ATCA_WORD_SIZE);
            }

            // Read next chunk of data
            if (ATCA_SUCCESS != (status = calib_read_zone(device, zone, slot, (uint8_t)cur_block, (uint8_t)cur_offset, read_buf, read_size)))
    2bd8:	10 c0       	rjmp	.+32     	; 0x2bfa <calib_read_bytes_zone+0x170>
    2bda:	87 01       	movw	r16, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:327
        {
            if (read_size == ATCA_BLOCK_SIZE && zone_size - cur_block * ATCA_BLOCK_SIZE < ATCA_BLOCK_SIZE)
            {
                // We have less than a block to read and can't read past the end of the zone, switch to word reads
                read_size = ATCA_WORD_SIZE;
                cur_offset = ((data_idx + offset) / ATCA_WORD_SIZE) % (ATCA_BLOCK_SIZE / ATCA_WORD_SIZE);
    2bdc:	04 0d       	add	r16, r4
    2bde:	15 1d       	adc	r17, r5
    2be0:	16 95       	lsr	r17
    2be2:	07 95       	ror	r16
    2be4:	16 95       	lsr	r17
    2be6:	07 95       	ror	r16
    2be8:	07 70       	andi	r16, 0x07	; 7
    2bea:	11 27       	eor	r17, r17
    2bec:	80 2f       	mov	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:331
            }

            // Read next chunk of data
            if (ATCA_SUCCESS != (status = calib_read_zone(device, zone, slot, (uint8_t)cur_block, (uint8_t)cur_offset, read_buf, read_size)))
    2bee:	b4 e0       	ldi	r27, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:326
        while (data_idx < length)
        {
            if (read_size == ATCA_BLOCK_SIZE && zone_size - cur_block * ATCA_BLOCK_SIZE < ATCA_BLOCK_SIZE)
            {
                // We have less than a block to read and can't read past the end of the zone, switch to word reads
                read_size = ATCA_WORD_SIZE;
    2bf0:	c8 51       	subi	r28, 0x18	; 24
    2bf2:	df 4f       	sbci	r29, 0xFF	; 255
    2bf4:	b8 83       	st	Y, r27
    2bf6:	c8 5e       	subi	r28, 0xE8	; 232
    2bf8:	d0 40       	sbci	r29, 0x00	; 0
calib_get_addr():
    2bfa:	87 70       	andi	r24, 0x07	; 7
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:232
    do
    {
        // Initialize the addr to 00
        *addr = 0;
        // Mask the offset
        offset = offset & (uint8_t)0x07;
    2bfc:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:233
        if ((mem_zone == ATCA_ZONE_CONFIG) || (mem_zone == ATCA_ZONE_OTP))
    2bfe:	c7 51       	subi	r28, 0x17	; 23
    2c00:	df 4f       	sbci	r29, 0xFF	; 255
    2c02:	38 81       	ld	r19, Y
    2c04:	c9 5e       	subi	r28, 0xE9	; 233
    2c06:	d0 40       	sbci	r29, 0x00	; 0
    2c08:	32 30       	cpi	r19, 0x02	; 2
    2c0a:	09 f4       	brne	.+2      	; 0x2c0e <calib_read_bytes_zone+0x184>
    2c0c:	86 c0       	rjmp	.+268    	; 0x2d1a <calib_read_bytes_zone+0x290>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:235
        {
            *addr = ((uint16_t)block) << 3;
    2c0e:	96 01       	movw	r18, r12
    2c10:	53 e0       	ldi	r21, 0x03	; 3
    2c12:	22 0f       	add	r18, r18
    2c14:	33 1f       	adc	r19, r19
    2c16:	5a 95       	dec	r21
    2c18:	e1 f7       	brne	.-8      	; 0x2c12 <calib_read_bytes_zone+0x188>
    2c1a:	28 7f       	andi	r18, 0xF8	; 248
    2c1c:	37 70       	andi	r19, 0x07	; 7
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:242
        }
        else     // ATCA_ZONE_DATA
        {
            *addr = slot << 3;
            *addr  |= offset;
            *addr |= ((uint16_t)block) << 8;
    2c1e:	82 2b       	or	r24, r18
    2c20:	93 2b       	or	r25, r19
calib_read_zone():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:81
            ATCA_TRACE(status, "calib_get_addr - failed");
            break;
        }

        // If there are 32 bytes to read, then OR the bit into the mode
        if (len == ATCA_BLOCK_SIZE)
    2c22:	c8 51       	subi	r28, 0x18	; 24
    2c24:	df 4f       	sbci	r29, 0xFF	; 255
    2c26:	58 81       	ld	r21, Y
    2c28:	c8 5e       	subi	r28, 0xE8	; 232
    2c2a:	d0 40       	sbci	r29, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:83
        {
            zone = zone | ATCA_ZONE_READWRITE_32;
    2c2c:	c4 51       	subi	r28, 0x14	; 20
    2c2e:	df 4f       	sbci	r29, 0xFF	; 255
    2c30:	28 81       	ld	r18, Y
    2c32:	cc 5e       	subi	r28, 0xEC	; 236
    2c34:	d0 40       	sbci	r29, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:81
            ATCA_TRACE(status, "calib_get_addr - failed");
            break;
        }

        // If there are 32 bytes to read, then OR the bit into the mode
        if (len == ATCA_BLOCK_SIZE)
    2c36:	50 32       	cpi	r21, 0x20	; 32
    2c38:	29 f0       	breq	.+10     	; 0x2c44 <calib_read_bytes_zone+0x1ba>
    2c3a:	c7 51       	subi	r28, 0x17	; 23
    2c3c:	df 4f       	sbci	r29, 0xFF	; 255
    2c3e:	28 81       	ld	r18, Y
    2c40:	c9 5e       	subi	r28, 0xE9	; 233
    2c42:	d0 40       	sbci	r29, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:87
        {
            zone = zone | ATCA_ZONE_READWRITE_32;
        }

        // build a read command
        packet.param1 = zone;
    2c44:	2c 83       	std	Y+4, r18	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:88
        packet.param2 = addr;
    2c46:	8d 83       	std	Y+5, r24	; 0x05
    2c48:	9e 83       	std	Y+6, r25	; 0x06
atRead():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:380
ATCA_STATUS atRead(ATCADeviceType device_type, ATCAPacket *packet)
{
    ((void)device_type);

    // Set the opcode & parameters
    packet->opcode = ATCA_READ;
    2c4a:	82 e0       	ldi	r24, 0x02	; 2
    2c4c:	8b 83       	std	Y+3, r24	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:381
    packet->txsize = READ_COUNT;
    2c4e:	97 e0       	ldi	r25, 0x07	; 7
    2c50:	9a 83       	std	Y+2, r25	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:382
    atCalcCrc(packet);
    2c52:	ce 01       	movw	r24, r28
    2c54:	01 96       	adiw	r24, 0x01	; 1
    2c56:	0e 94 c0 08 	call	0x1180	; 0x1180 <atCalcCrc>
calib_read_zone():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:96
        {
            ATCA_TRACE(status, "atRead - failed");
            break;
        }

        if ((status = atca_execute_command(&packet, device)) != ATCA_SUCCESS)
    2c5a:	c3 51       	subi	r28, 0x13	; 19
    2c5c:	df 4f       	sbci	r29, 0xFF	; 255
    2c5e:	68 81       	ld	r22, Y
    2c60:	79 81       	ldd	r23, Y+1	; 0x01
    2c62:	cd 5e       	subi	r28, 0xED	; 237
    2c64:	d0 40       	sbci	r29, 0x00	; 0
    2c66:	ce 01       	movw	r24, r28
    2c68:	01 96       	adiw	r24, 0x01	; 1
    2c6a:	60 db       	rcall	.-2368   	; 0x232c <calib_execute_command>
    2c6c:	00 97       	sbiw	r24, 0x00	; 0
    2c6e:	09 f0       	breq	.+2      	; 0x2c72 <calib_read_bytes_zone+0x1e8>
    2c70:	29 cf       	rjmp	.-430    	; 0x2ac4 <calib_read_bytes_zone+0x3a>
    2c72:	c8 51       	subi	r28, 0x18	; 24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:102
        {
            ATCA_TRACE(status, "calib_read_zone - execution failed");
            break;
        }

        memcpy(data, &packet.data[1], len);
    2c74:	df 4f       	sbci	r29, 0xFF	; 255
    2c76:	a8 81       	ld	r26, Y
    2c78:	c8 5e       	subi	r28, 0xE8	; 232
    2c7a:	d0 40       	sbci	r29, 0x00	; 0
    2c7c:	8a 2e       	mov	r8, r26
    2c7e:	91 2c       	mov	r9, r1
    2c80:	a4 01       	movw	r20, r8
    2c82:	be 01       	movw	r22, r28
    2c84:	68 5f       	subi	r22, 0xF8	; 248
    2c86:	7f 4f       	sbci	r23, 0xFF	; 255
    2c88:	ce 01       	movw	r24, r28
    2c8a:	88 53       	subi	r24, 0x38	; 56
    2c8c:	9f 4f       	sbci	r25, 0xFF	; 255
    2c8e:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
calib_read_bytes_zone():
    2c92:	c6 01       	movw	r24, r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:338
                ATCA_TRACE(status, "calib_read_zone - falied");
                break;
            }

            // Calculate where in the read buffer we need data from
            read_offset = cur_block * ATCA_BLOCK_SIZE + cur_offset * ATCA_WORD_SIZE;
    2c94:	23 e0       	ldi	r18, 0x03	; 3
    2c96:	88 0f       	add	r24, r24
    2c98:	99 1f       	adc	r25, r25
    2c9a:	2a 95       	dec	r18
    2c9c:	e1 f7       	brne	.-8      	; 0x2c96 <calib_read_bytes_zone+0x20c>
    2c9e:	80 0f       	add	r24, r16
    2ca0:	91 1f       	adc	r25, r17
    2ca2:	88 0f       	add	r24, r24
    2ca4:	99 1f       	adc	r25, r25
    2ca6:	88 0f       	add	r24, r24
    2ca8:	99 1f       	adc	r25, r25
    2caa:	70 e0       	ldi	r23, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:345
            {
                read_buf_idx = offset - read_offset;  // Read data starts before the requested chunk
            }
            else
            {
                read_buf_idx = 0;                     // Read data is within the requested chunk
    2cac:	60 e0       	ldi	r22, 0x00	; 0
    2cae:	84 15       	cp	r24, r4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:339
                break;
            }

            // Calculate where in the read buffer we need data from
            read_offset = cur_block * ATCA_BLOCK_SIZE + cur_offset * ATCA_WORD_SIZE;
            if (read_offset < offset)
    2cb0:	95 05       	cpc	r25, r5
    2cb2:	18 f4       	brcc	.+6      	; 0x2cba <calib_read_bytes_zone+0x230>
    2cb4:	b2 01       	movw	r22, r4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:341
            {
                read_buf_idx = offset - read_offset;  // Read data starts before the requested chunk
    2cb6:	68 1b       	sub	r22, r24
    2cb8:	79 0b       	sbc	r23, r25
    2cba:	86 1a       	sub	r8, r22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:349
            {
                read_buf_idx = 0;                     // Read data is within the requested chunk

            }
            // Calculate how much data from the read buffer we want to copy
            if (length - data_idx < read_size - read_buf_idx)
    2cbc:	97 0a       	sbc	r9, r23
    2cbe:	31 01       	movw	r6, r2
    2cc0:	6e 18       	sub	r6, r14
    2cc2:	7f 08       	sbc	r7, r15
    2cc4:	86 14       	cp	r8, r6
    2cc6:	97 04       	cpc	r9, r7
    2cc8:	08 f4       	brcc	.+2      	; 0x2ccc <calib_read_bytes_zone+0x242>
    2cca:	34 01       	movw	r6, r8
    2ccc:	28 ec       	ldi	r18, 0xC8	; 200
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:358
            else
            {
                copy_length = read_size - read_buf_idx;
            }

            memcpy(&data[data_idx], &read_buf[read_buf_idx], copy_length);
    2cce:	30 e0       	ldi	r19, 0x00	; 0
    2cd0:	2c 0f       	add	r18, r28
    2cd2:	3d 1f       	adc	r19, r29
    2cd4:	62 0f       	add	r22, r18
    2cd6:	73 1f       	adc	r23, r19
    2cd8:	a3 01       	movw	r20, r6
    2cda:	c1 51       	subi	r28, 0x11	; 17
    2cdc:	df 4f       	sbci	r29, 0xFF	; 255
    2cde:	88 81       	ld	r24, Y
    2ce0:	99 81       	ldd	r25, Y+1	; 0x01
    2ce2:	cf 5e       	subi	r28, 0xEF	; 239
    2ce4:	d0 40       	sbci	r29, 0x00	; 0
    2ce6:	8e 0d       	add	r24, r14
    2ce8:	9f 1d       	adc	r25, r15
    2cea:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
    2cee:	e6 0c       	add	r14, r6
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:359
            data_idx += copy_length;
    2cf0:	f7 1c       	adc	r15, r7
    2cf2:	c8 51       	subi	r28, 0x18	; 24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:360
            if (read_size == ATCA_BLOCK_SIZE)
    2cf4:	df 4f       	sbci	r29, 0xFF	; 255
    2cf6:	38 81       	ld	r19, Y
    2cf8:	c8 5e       	subi	r28, 0xE8	; 232
    2cfa:	d0 40       	sbci	r29, 0x00	; 0
    2cfc:	30 32       	cpi	r19, 0x20	; 32
    2cfe:	c1 f4       	brne	.+48     	; 0x2d30 <calib_read_bytes_zone+0x2a6>
    2d00:	4f ef       	ldi	r20, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:362
            {
                cur_block += 1;
    2d02:	c4 1a       	sub	r12, r20
    2d04:	d4 0a       	sbc	r13, r20
    2d06:	50 cf       	rjmp	.-352    	; 0x2ba8 <calib_read_bytes_zone+0x11e>
calib_read_zone():
    2d08:	c8 51       	subi	r28, 0x18	; 24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:71

    do
    {
        // Check the input parameters
        ATCA_CHECK_INVALID_MSG((!device || !data), ATCA_BAD_PARAM, "NULL pointer received");
        ATCA_CHECK_INVALID_MSG((len != 4 && len != 32), ATCA_BAD_PARAM, "NULL pointer received");
    2d0a:	df 4f       	sbci	r29, 0xFF	; 255
    2d0c:	28 81       	ld	r18, Y
    2d0e:	c8 5e       	subi	r28, 0xE8	; 232
    2d10:	d0 40       	sbci	r29, 0x00	; 0
    2d12:	24 30       	cpi	r18, 0x04	; 4
    2d14:	09 f0       	breq	.+2      	; 0x2d18 <calib_read_bytes_zone+0x28e>
    2d16:	ef ce       	rjmp	.-546    	; 0x2af6 <calib_read_bytes_zone+0x6c>
    2d18:	5e cf       	rjmp	.-324    	; 0x2bd6 <calib_read_bytes_zone+0x14c>
calib_get_addr():
    2d1a:	3c 2d       	mov	r19, r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:242
    2d1c:	22 27       	eor	r18, r18
    2d1e:	c6 51       	subi	r28, 0x16	; 22
    2d20:	df 4f       	sbci	r29, 0xFF	; 255
    2d22:	48 81       	ld	r20, Y
    2d24:	59 81       	ldd	r21, Y+1	; 0x01
    2d26:	ca 5e       	subi	r28, 0xEA	; 234
    2d28:	d0 40       	sbci	r29, 0x00	; 0
    2d2a:	24 2b       	or	r18, r20
    2d2c:	35 2b       	or	r19, r21
    2d2e:	77 cf       	rjmp	.-274    	; 0x2c1e <calib_read_bytes_zone+0x194>
calib_read_bytes_zone():
    2d30:	0f 5f       	subi	r16, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:366
            {
                cur_block += 1;
            }
            else
            {
                cur_offset += 1;
    2d32:	1f 4f       	sbci	r17, 0xFF	; 255
    2d34:	39 cf       	rjmp	.-398    	; 0x2ba8 <calib_read_bytes_zone+0x11e>

00002d36 <atcab_init_ext.constprop.49>:
atcab_init_ext():
    2d36:	ef 92       	push	r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:71
 *  \param[out] device Pointer to the device context pointer
 *  \param[in]  cfg    Logical interface configuration. Some predefined
 *                     configurations can be found in atca_cfgs.h
 *  \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS atcab_init_ext(ATCADevice* device, ATCAIfaceCfg *cfg)
    2d38:	ff 92       	push	r15
    2d3a:	0f 93       	push	r16
    2d3c:	1f 93       	push	r17
    2d3e:	cf 93       	push	r28
    2d40:	df 93       	push	r29
    2d42:	8c 01       	movw	r16, r24
    2d44:	c0 91 8a 66 	lds	r28, 0x668A	; 0x80668a <_gDevice>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:78
    ATCA_STATUS status = ATCA_GEN_FAIL;

    if (device)
    {
        // If a device has already been initialized, release it
        if (*device)
    2d48:	d0 91 8b 66 	lds	r29, 0x668B	; 0x80668b <_gDevice+0x1>
    2d4c:	20 97       	sbiw	r28, 0x00	; 0
    2d4e:	31 f1       	breq	.+76     	; 0x2d9c <atcab_init_ext.constprop.49+0x66>
releaseATCAIface():
    2d50:	e8 81       	ld	r30, Y
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:546
 */
ATCA_STATUS releaseATCAIface(ATCAIface ca_iface)
{
    ATCA_STATUS status = ATCA_BAD_PARAM;

    if (ca_iface && ca_iface->mIfaceCFG)
    2d52:	f9 81       	ldd	r31, Y+1	; 0x01
    2d54:	30 97       	sbiw	r30, 0x00	; 0
    2d56:	c1 f0       	breq	.+48     	; 0x2d88 <atcab_init_ext.constprop.49+0x52>
hal_iface_get_registered():
    2d58:	80 81       	ld	r24, Z
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:199
    if (hal && phy)
    {
        size_t i;
        for (i = 0; i < atca_registered_hal_list_size; i++)
        {
            if (iface_type == atca_registered_hal_list[i].iface_type)
    2d5a:	91 81       	ldd	r25, Z+1	; 0x01
    2d5c:	89 2b       	or	r24, r25
    2d5e:	41 f4       	brne	.+16     	; 0x2d70 <atcab_init_ext.constprop.49+0x3a>
hal_iface_release():
    2d60:	e0 91 0a 40 	lds	r30, 0x400A	; 0x80400a <__DATA_REGION_ORIGIN__+0xa>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:345

    status = hal_iface_get_registered(iface_type, &hal, &phy);

    if (ATCA_SUCCESS == status)
    {
        if (hal && hal->halrelease)
    2d64:	f0 91 0b 40 	lds	r31, 0x400B	; 0x80400b <__DATA_REGION_ORIGIN__+0xb>
    2d68:	30 97       	sbiw	r30, 0x00	; 0
    2d6a:	31 f5       	brne	.+76     	; 0x2db8 <atcab_init_ext.constprop.49+0x82>
releaseATCAIface():
    2d6c:	1e 82       	std	Y+6, r1	; 0x06
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:550
    {
        if (ATCA_SUCCESS == (status = hal_iface_release(ca_iface->mIfaceCFG->iface_type, ca_iface->hal_data)))
        {
            ca_iface->hal_data = NULL;
    2d6e:	1f 82       	std	Y+7, r1	; 0x07
    2d70:	e8 81       	ld	r30, Y
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:552
        }
        if (ATCA_CUSTOM_IFACE == ca_iface->mIfaceCFG->iface_type)
    2d72:	f9 81       	ldd	r31, Y+1	; 0x01
    2d74:	80 81       	ld	r24, Z
    2d76:	91 81       	ldd	r25, Z+1	; 0x01
    2d78:	06 97       	sbiw	r24, 0x06	; 6
    2d7a:	31 f4       	brne	.+12     	; 0x2d88 <atcab_init_ext.constprop.49+0x52>
    2d7c:	8a 81       	ldd	r24, Y+2	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:555
        {
#ifndef ATCA_NO_HEAP
            hal_free(ca_iface->hal);
    2d7e:	9b 81       	ldd	r25, Y+3	; 0x03
    2d80:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    2d84:	1a 82       	std	Y+2, r1	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:557
#endif
            ca_iface->hal = NULL;
    2d86:	1b 82       	std	Y+3, r1	; 0x03
deleteATCADevice():
    2d88:	80 91 8a 66 	lds	r24, 0x668A	; 0x80668a <_gDevice>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_device.c:81
        return;
    }

    releaseATCADevice(*ca_dev);

    hal_free(*ca_dev);
    2d8c:	90 91 8b 66 	lds	r25, 0x668B	; 0x80668b <_gDevice+0x1>
    2d90:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    2d94:	10 92 8a 66 	sts	0x668A, r1	; 0x80668a <_gDevice>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_device.c:82
    *ca_dev = NULL;
    2d98:	10 92 8b 66 	sts	0x668B, r1	; 0x80668b <_gDevice+0x1>
newATCADevice():
    2d9c:	86 e1       	ldi	r24, 0x16	; 22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_device.c:50
    if (cfg == NULL)
    {
        return NULL;
    }

    ca_dev = (ATCADevice)hal_malloc(sizeof(*ca_dev));
    2d9e:	90 e0       	ldi	r25, 0x00	; 0
    2da0:	0e 94 b8 54 	call	0xa970	; 0xa970 <malloc>
    2da4:	ec 01       	movw	r28, r24
    2da6:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_device.c:51
    if (ca_dev == NULL)
    2da8:	69 f4       	brne	.+26     	; 0x2dc4 <atcab_init_ext.constprop.49+0x8e>
atcab_init_ext():
    2daa:	10 92 8a 66 	sts	0x668A, r1	; 0x80668a <_gDevice>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:93
        {
            return status;
        }
        *device = &g_atcab_device;
#else
        if (NULL != (*device = newATCADevice(cfg)))
    2dae:	10 92 8b 66 	sts	0x668B, r1	; 0x80668b <_gDevice+0x1>
    2db2:	81 ee       	ldi	r24, 0xE1	; 225
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:73
 *                     configurations can be found in atca_cfgs.h
 *  \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS atcab_init_ext(ATCADevice* device, ATCAIfaceCfg *cfg)
{
    ATCA_STATUS status = ATCA_GEN_FAIL;
    2db4:	90 e0       	ldi	r25, 0x00	; 0
    2db6:	56 c0       	rjmp	.+172    	; 0x2e64 <atcab_init_ext.constprop.49+0x12e>
hal_iface_release():
    2db8:	8e 81       	ldd	r24, Y+6	; 0x06
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:347
        {
            status = hal->halrelease(hal_data);
    2dba:	9f 81       	ldd	r25, Y+7	; 0x07
    2dbc:	09 95       	icall
releaseATCAIface():
    2dbe:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:548
{
    ATCA_STATUS status = ATCA_BAD_PARAM;

    if (ca_iface && ca_iface->mIfaceCFG)
    {
        if (ATCA_SUCCESS == (status = hal_iface_release(ca_iface->mIfaceCFG->iface_type, ca_iface->hal_data)))
    2dc0:	a9 f2       	breq	.-86     	; 0x2d6c <atcab_init_ext.constprop.49+0x36>
    2dc2:	d6 cf       	rjmp	.-84     	; 0x2d70 <atcab_init_ext.constprop.49+0x3a>
newATCADevice():
    2dc4:	84 e1       	ldi	r24, 0x14	; 20
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_device.c:56
    {
        return NULL;
    }

    memset(ca_dev, 0, sizeof(struct atca_device));
    2dc6:	fe 01       	movw	r30, r28
    2dc8:	32 96       	adiw	r30, 0x02	; 2
    2dca:	df 01       	movw	r26, r30
    2dcc:	1d 92       	st	X+, r1
    2dce:	8a 95       	dec	r24
    2dd0:	e9 f7       	brne	.-6      	; 0x2dcc <atcab_init_ext.constprop.49+0x96>
initATCAIface():
    2dd2:	08 83       	st	Y, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:53
    if (cfg == NULL || ca_iface == NULL)
    {
        return ATCA_BAD_PARAM;
    }

    ca_iface->mIfaceCFG = cfg;
    2dd4:	19 83       	std	Y+1, r17	; 0x01
hal_iface_get_registered():
    2dd6:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:199
    if (hal && phy)
    {
        size_t i;
        for (i = 0; i < atca_registered_hal_list_size; i++)
        {
            if (iface_type == atca_registered_hal_list[i].iface_type)
    2dd8:	80 81       	ld	r24, Z
    2dda:	91 81       	ldd	r25, Z+1	; 0x01
    2ddc:	89 2b       	or	r24, r25
    2dde:	09 f0       	breq	.+2      	; 0x2de2 <atcab_init_ext.constprop.49+0xac>
    2de0:	48 c0       	rjmp	.+144    	; 0x2e72 <atcab_init_ext.constprop.49+0x13c>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:207
            }
        }

        if (i < atca_registered_hal_list_size)
        {
            *hal = atca_registered_hal_list[i].hal;
    2de2:	80 e0       	ldi	r24, 0x00	; 0
    2de4:	90 e4       	ldi	r25, 0x40	; 64
    2de6:	8a 83       	std	Y+2, r24	; 0x02
    2de8:	9b 83       	std	Y+3, r25	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\hal/atca_hal.c:208
            *phy = atca_registered_hal_list[i].phy;
    2dea:	1c 82       	std	Y+4, r1	; 0x04
    2dec:	1d 82       	std	Y+5, r1	; 0x05
atinit():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:120
        }

        /* Initialize the hal itself */
        if (ATCA_SUCCESS == status)
        {
            if (ca_iface->hal->halinit && ca_iface->hal->halpostinit)
    2dee:	e0 91 00 40 	lds	r30, 0x4000	; 0x804000 <__DATA_REGION_ORIGIN__>
    2df2:	f0 91 01 40 	lds	r31, 0x4001	; 0x804001 <__DATA_REGION_ORIGIN__+0x1>
    2df6:	30 97       	sbiw	r30, 0x00	; 0
    2df8:	e1 f1       	breq	.+120    	; 0x2e72 <atcab_init_ext.constprop.49+0x13c>
    2dfa:	80 91 02 40 	lds	r24, 0x4002	; 0x804002 <__DATA_REGION_ORIGIN__+0x2>
    2dfe:	90 91 03 40 	lds	r25, 0x4003	; 0x804003 <__DATA_REGION_ORIGIN__+0x3>
    2e02:	89 2b       	or	r24, r25
    2e04:	b1 f1       	breq	.+108    	; 0x2e72 <atcab_init_ext.constprop.49+0x13c>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:122
            {
                if (ATCA_SUCCESS == (status = ATCA_TRACE(ca_iface->hal->halinit(ca_iface, ca_iface->mIfaceCFG), "halinit")))
    2e06:	b8 01       	movw	r22, r16
    2e08:	ce 01       	movw	r24, r28
    2e0a:	09 95       	icall
    2e0c:	89 2b       	or	r24, r25
    2e0e:	89 f5       	brne	.+98     	; 0x2e72 <atcab_init_ext.constprop.49+0x13c>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:124
                {
                    status = ATCA_TRACE(ca_iface->hal->halpostinit(ca_iface), "halpostinit");
    2e10:	ea 81       	ldd	r30, Y+2	; 0x02
    2e12:	fb 81       	ldd	r31, Y+3	; 0x03
    2e14:	02 80       	ldd	r0, Z+2	; 0x02
    2e16:	f3 81       	ldd	r31, Z+3	; 0x03
    2e18:	e0 2d       	mov	r30, r0
    2e1a:	ce 01       	movw	r24, r28
    2e1c:	09 95       	icall
initATCAIface():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_iface.c:56
    }

    ca_iface->mIfaceCFG = cfg;

    status = ATCA_TRACE(atinit(ca_iface), "atinit");
    if (status != ATCA_SUCCESS)
    2e1e:	00 97       	sbiw	r24, 0x00	; 0
    2e20:	41 f5       	brne	.+80     	; 0x2e72 <atcab_init_ext.constprop.49+0x13c>
atcab_init_ext():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:93
        {
            return status;
        }
        *device = &g_atcab_device;
#else
        if (NULL != (*device = newATCADevice(cfg)))
    2e22:	c0 93 8a 66 	sts	0x668A, r28	; 0x80668a <_gDevice>
    2e26:	d0 93 8b 66 	sts	0x668B, r29	; 0x80668b <_gDevice+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:103

#if defined(ATCA_ATECC608_SUPPORT) || ATCA_CA2_SUPPORT
        if (ATCA_SUCCESS == status)
        {
    #ifdef ATCA_ATECC608_SUPPORT
            if (ATECC608 == cfg->devtype)
    2e2a:	d8 01       	movw	r26, r16
    2e2c:	12 96       	adiw	r26, 0x02	; 2
    2e2e:	2d 91       	ld	r18, X+
    2e30:	3c 91       	ld	r19, X
    2e32:	23 30       	cpi	r18, 0x03	; 3
    2e34:	31 05       	cpc	r19, r1
    2e36:	b1 f4       	brne	.+44     	; 0x2e64 <atcab_init_ext.constprop.49+0x12e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:105
            {
                if ((status = calib_read_bytes_zone(*device, ATCA_ZONE_CONFIG, 0, ATCA_CHIPMODE_OFFSET, &(*device)->clock_divider, 1)) != ATCA_SUCCESS)
    2e38:	8e 01       	movw	r16, r28
    2e3a:	07 5f       	subi	r16, 0xF7	; 247
    2e3c:	1f 4f       	sbci	r17, 0xFF	; 255
    2e3e:	ee 24       	eor	r14, r14
    2e40:	e3 94       	inc	r14
    2e42:	f1 2c       	mov	r15, r1
    2e44:	23 e1       	ldi	r18, 0x13	; 19
    2e46:	30 e0       	ldi	r19, 0x00	; 0
    2e48:	50 e0       	ldi	r21, 0x00	; 0
    2e4a:	40 e0       	ldi	r20, 0x00	; 0
    2e4c:	60 e0       	ldi	r22, 0x00	; 0
    2e4e:	ce 01       	movw	r24, r28
    2e50:	1c de       	rcall	.-968    	; 0x2a8a <calib_read_bytes_zone>
    2e52:	00 97       	sbiw	r24, 0x00	; 0
    2e54:	39 f4       	brne	.+14     	; 0x2e64 <atcab_init_ext.constprop.49+0x12e>
    2e56:	e0 91 8a 66 	lds	r30, 0x668A	; 0x80668a <_gDevice>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:109
                {
                    return status;
                }
                (*device)->clock_divider &= ATCA_CHIPMODE_CLOCK_DIV_MASK;
    2e5a:	f0 91 8b 66 	lds	r31, 0x668B	; 0x80668b <_gDevice+0x1>
    2e5e:	21 85       	ldd	r18, Z+9	; 0x09
    2e60:	28 7f       	andi	r18, 0xF8	; 248
    2e62:	21 87       	std	Z+9, r18	; 0x09
    2e64:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:126
        }
#endif
    }

    return status;
}
    2e66:	cf 91       	pop	r28
    2e68:	1f 91       	pop	r17
    2e6a:	0f 91       	pop	r16
    2e6c:	ff 90       	pop	r15
    2e6e:	ef 90       	pop	r14
    2e70:	08 95       	ret
newATCADevice():
    2e72:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_device.c:61

    status = initATCADevice(cfg, ca_dev);
    if (status != ATCA_SUCCESS)
    {
        hal_free(ca_dev);
    2e74:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    2e78:	98 cf       	rjmp	.-208    	; 0x2daa <atcab_init_ext.constprop.49+0x74>

00002e7a <to_iso_timestamp.constprop.106>:
to_iso_timestamp():
    2e7a:	cf 93       	push	r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:12
#include <string.h>
#include "iotconnect_common.h"

static char timebuf[sizeof "2011-10-08T07:07:01.000Z"];

static const char *to_iso_timestamp(time_t *timestamp) {
    2e7c:	df 93       	push	r29
    2e7e:	00 d0       	rcall	.+0      	; 0x2e80 <to_iso_timestamp.constprop.106+0x6>
    2e80:	00 d0       	rcall	.+0      	; 0x2e82 <to_iso_timestamp.constprop.106+0x8>
    2e82:	cd b7       	in	r28, 0x3d	; 61
    2e84:	de b7       	in	r29, 0x3e	; 62
time():
    2e86:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:72
    return now;
}

//override time() system function
time_t time(time_t *tloc) {
  return(rtc_start + (time_t)(millis()/1000));
    2e8a:	28 ee       	ldi	r18, 0xE8	; 232
    2e8c:	33 e0       	ldi	r19, 0x03	; 3
    2e8e:	40 e0       	ldi	r20, 0x00	; 0
    2e90:	50 e0       	ldi	r21, 0x00	; 0
    2e92:	0e 94 79 52 	call	0xa4f2	; 0xa4f2 <__udivmodsi4>
    2e96:	80 91 92 66 	lds	r24, 0x6692	; 0x806692 <rtc_start>
    2e9a:	90 91 93 66 	lds	r25, 0x6693	; 0x806693 <rtc_start+0x1>
    2e9e:	a0 91 94 66 	lds	r26, 0x6694	; 0x806694 <rtc_start+0x2>
    2ea2:	b0 91 95 66 	lds	r27, 0x6695	; 0x806695 <rtc_start+0x3>
    2ea6:	82 0f       	add	r24, r18
    2ea8:	93 1f       	adc	r25, r19
    2eaa:	a4 1f       	adc	r26, r20
    2eac:	b5 1f       	adc	r27, r21
to_iso_timestamp():
    2eae:	89 83       	std	Y+1, r24	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:13
    time_t ts = timestamp ? *timestamp : time(NULL);
    2eb0:	9a 83       	std	Y+2, r25	; 0x02
    2eb2:	ab 83       	std	Y+3, r26	; 0x03
    2eb4:	bc 83       	std	Y+4, r27	; 0x04
    2eb6:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:14
    strftime(timebuf, (sizeof timebuf), "%Y-%m-%dT%H:%M:%S.000Z", gmtime(&ts));
    2eb8:	01 96       	adiw	r24, 0x01	; 1
    2eba:	0e 94 ed 33 	call	0x67da	; 0x67da <gmtime>
    2ebe:	9c 01       	movw	r18, r24
    2ec0:	46 e7       	ldi	r20, 0x76	; 118
    2ec2:	55 e4       	ldi	r21, 0x45	; 69
    2ec4:	69 e1       	ldi	r22, 0x19	; 25
    2ec6:	70 e0       	ldi	r23, 0x00	; 0
    2ec8:	86 e9       	ldi	r24, 0x96	; 150
    2eca:	96 e6       	ldi	r25, 0x66	; 102
    2ecc:	0e 94 6a 36 	call	0x6cd4	; 0x6cd4 <strftime>
    2ed0:	86 e9       	ldi	r24, 0x96	; 150
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:16
    return timebuf;
}
    2ed2:	96 e6       	ldi	r25, 0x66	; 102
    2ed4:	24 96       	adiw	r28, 0x04	; 4
    2ed6:	cd bf       	out	0x3d, r28	; 61
    2ed8:	de bf       	out	0x3e, r29	; 62
    2eda:	df 91       	pop	r29
    2edc:	cf 91       	pop	r28
    2ede:	08 95       	ret

00002ee0 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]>:
readResponse():
    2ee0:	4f 92       	push	r4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:708

    return response;
}

ResponseResult
SequansControllerClass::readResponse(char* out_buffer,
    2ee2:	5f 92       	push	r5
    2ee4:	6f 92       	push	r6
    2ee6:	7f 92       	push	r7
    2ee8:	af 92       	push	r10
    2eea:	bf 92       	push	r11
    2eec:	cf 92       	push	r12
    2eee:	df 92       	push	r13
    2ef0:	ef 92       	push	r14
    2ef2:	ff 92       	push	r15
    2ef4:	0f 93       	push	r16
    2ef6:	1f 93       	push	r17
    2ef8:	cf 93       	push	r28
    2efa:	df 93       	push	r29
    2efc:	cd b7       	in	r28, 0x3d	; 61
    2efe:	de b7       	in	r29, 0x3e	; 62
    2f00:	a8 97       	sbiw	r28, 0x28	; 40
    2f02:	cd bf       	out	0x3d, r28	; 61
    2f04:	de bf       	out	0x3e, r29	; 62
    2f06:	8c 01       	movw	r16, r24
    2f08:	5b 01       	movw	r10, r22
    2f0a:	19 82       	std	Y+1, r1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:713
                                     const size_t out_buffer_size) {

    // Enough to hold the OK and ERROR termination if the out_buffer is NULL
    // and the result is not needed
    char placeholder_buffer[32] = "";
    2f0c:	1a 82       	std	Y+2, r1	; 0x02
    2f0e:	fe 01       	movw	r30, r28
    2f10:	33 96       	adiw	r30, 0x03	; 3
    2f12:	8e e1       	ldi	r24, 0x1E	; 30
    2f14:	df 01       	movw	r26, r30
    2f16:	1d 92       	st	X+, r1
    2f18:	8a 95       	dec	r24
    2f1a:	e9 f7       	brne	.-6      	; 0x2f16 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x36>
    2f1c:	01 15       	cp	r16, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:718

    char* buffer       = placeholder_buffer;
    size_t buffer_size = sizeof(placeholder_buffer);

    if (out_buffer != NULL && buffer_size != 0) {
    2f1e:	11 05       	cpc	r17, r1
    2f20:	31 f4       	brne	.+12     	; 0x2f2e <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x4e>
    2f22:	90 e2       	ldi	r25, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:716
    // Enough to hold the OK and ERROR termination if the out_buffer is NULL
    // and the result is not needed
    char placeholder_buffer[32] = "";

    char* buffer       = placeholder_buffer;
    size_t buffer_size = sizeof(placeholder_buffer);
    2f24:	a9 2e       	mov	r10, r25
    2f26:	b1 2c       	mov	r11, r1
    2f28:	8e 01       	movw	r16, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:715

    // Enough to hold the OK and ERROR termination if the out_buffer is NULL
    // and the result is not needed
    char placeholder_buffer[32] = "";

    char* buffer       = placeholder_buffer;
    2f2a:	0f 5f       	subi	r16, 0xFF	; 255
    2f2c:	1f 4f       	sbci	r17, 0xFF	; 255
    2f2e:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:724
        buffer      = out_buffer;
        buffer_size = out_buffer_size;
    }

    // Safe guard and place null termination at end of buffer
    buffer[buffer_size - 1] = '\0';
    2f30:	ea 0d       	add	r30, r10
    2f32:	fb 1d       	adc	r31, r11
    2f34:	31 97       	sbiw	r30, 0x01	; 1
    2f36:	10 82       	st	Z, r1
    2f38:	68 01       	movw	r12, r16
    2f3a:	f1 2c       	mov	r15, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:726

    size_t i = 0;
    2f3c:	e1 2c       	mov	r14, r1
__base_ctor ():
    2f3e:	80 ed       	ldi	r24, 0xD0	; 208
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:5
#include "timeout_timer.h"

#include <Arduino.h>

TimeoutTimer::TimeoutTimer(const uint32_t ms) : interval_ms(ms) {
    2f40:	48 2e       	mov	r4, r24
    2f42:	87 e0       	ldi	r24, 0x07	; 7
    2f44:	58 2e       	mov	r5, r24
    2f46:	61 2c       	mov	r6, r1
    2f48:	71 2c       	mov	r7, r1
readResponse():
    2f4a:	ae 14       	cp	r10, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:728

    while (i < buffer_size) {
    2f4c:	bf 04       	cpc	r11, r15
    2f4e:	09 f4       	brne	.+2      	; 0x2f52 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x72>
    2f50:	6b c0       	rjmp	.+214    	; 0x3028 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x148>
__base_ctor ():
    2f52:	49 a2       	std	Y+33, r4	; 0x21
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:5
    2f54:	5a a2       	std	Y+34, r5	; 0x22
    2f56:	6b a2       	std	Y+35, r6	; 0x23
    2f58:	7c a2       	std	Y+36, r7	; 0x24
    2f5a:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:6
    start_ms = millis();
    2f5e:	6d a3       	std	Y+37, r22	; 0x25
    2f60:	7e a3       	std	Y+38, r23	; 0x26
    2f62:	8f a3       	std	Y+39, r24	; 0x27
    2f64:	98 a7       	std	Y+40, r25	; 0x28
isRxReady():
    2f66:	80 91 7a 6d 	lds	r24, 0x6D7A	; 0x806d7a <rx_num_elements>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:573

bool SequansControllerClass::isTxReady(void) {
    return tx_num_elements < TX_BUFFER_SIZE;
}

bool SequansControllerClass::isRxReady(void) { return rx_num_elements > 0; }
    2f6a:	90 91 7b 6d 	lds	r25, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
readResponse():
    2f6e:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:730

    size_t i = 0;

    while (i < buffer_size) {
        TimeoutTimer timeout_timer(READ_TIMEOUT_MS);
        while (!isRxReady() && !timeout_timer.hasTimedOut()) {
    2f70:	79 f4       	brne	.+30     	; 0x2f90 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0xb0>
    2f72:	ce 01       	movw	r24, r28
    2f74:	81 96       	adiw	r24, 0x21	; 33
    2f76:	0e 94 2a 07 	call	0xe54	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    2f7a:	81 11       	cpse	r24, r1
    2f7c:	09 c0       	rjmp	.+18     	; 0x2f90 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0xb0>
    2f7e:	0e 94 5d 07 	call	0xeba	; 0xeba <ctsUpdate()>
_delay_ms():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:733
            // We update the CTS here in case the CTS interrupt didn't catch the
            // falling flank
            ctsUpdate();
    2f82:	ef e6       	ldi	r30, 0x6F	; 111
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:187
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    2f84:	f7 e1       	ldi	r31, 0x17	; 23
    2f86:	31 97       	sbiw	r30, 0x01	; 1
    2f88:	f1 f7       	brne	.-4      	; 0x2f86 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0xa6>
    2f8a:	00 c0       	rjmp	.+0      	; 0x2f8c <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0xac>
    2f8c:	00 00       	nop
    2f8e:	eb cf       	rjmp	.-42     	; 0x2f66 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x86>
isRxReady():
    2f90:	80 91 7a 6d 	lds	r24, 0x6D7A	; 0x806d7a <rx_num_elements>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:573

bool SequansControllerClass::isTxReady(void) {
    return tx_num_elements < TX_BUFFER_SIZE;
}

bool SequansControllerClass::isRxReady(void) { return rx_num_elements > 0; }
    2f94:	90 91 7b 6d 	lds	r25, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
readResponse():
    2f98:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:738
            ctsUpdate();

            _delay_ms(1);
        }

        if (!isRxReady() && timeout_timer.hasTimedOut()) {
    2f9a:	81 f1       	breq	.+96     	; 0x2ffc <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x11c>
    2f9c:	0e 94 91 07 	call	0xf22	; 0xf22 <SequansControllerClass::readByte() [clone .constprop.117]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:742
            return ResponseResult::TIMEOUT;
        }

        buffer[i++] = (char)readByte();
    2fa0:	ff ef       	ldi	r31, 0xFF	; 255
    2fa2:	ef 1a       	sub	r14, r31
    2fa4:	ff 0a       	sbc	r15, r31
    2fa6:	d6 01       	movw	r26, r12
    2fa8:	8d 93       	st	X+, r24
    2faa:	6d 01       	movw	r12, r26
    2fac:	b2 e0       	ldi	r27, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:746

        // We won't check for the buffer having a termination until at least
        // 2 bytes are in it
        if (i < 2) {
    2fae:	eb 16       	cp	r14, r27
    2fb0:	f1 04       	cpc	r15, r1
    2fb2:	58 f2       	brcs	.-106    	; 0x2f4a <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x6a>
    2fb4:	f6 01       	movw	r30, r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:757
        // "\r\n".
        //
        // Since we post increment the i variable, we have to take that into
        // consideration and look for the last 2 elements after the variable
        // is incremented
        if (buffer[i - 2] == CARRIAGE_RETURN && buffer[i - 1] == LINE_FEED) {
    2fb6:	32 97       	sbiw	r30, 0x02	; 2
    2fb8:	90 81       	ld	r25, Z
    2fba:	9d 30       	cpi	r25, 0x0D	; 13
    2fbc:	31 f6       	brne	.-116    	; 0x2f4a <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x6a>
    2fbe:	8a 30       	cpi	r24, 0x0A	; 10
    2fc0:	21 f6       	brne	.-120    	; 0x2f4a <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x6a>
    2fc2:	68 ec       	ldi	r22, 0xC8	; 200
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:759

            char* ok_index = strstr(buffer, OK_TERMINATION);
    2fc4:	72 e4       	ldi	r23, 0x42	; 66
    2fc6:	c8 01       	movw	r24, r16
    2fc8:	0e 94 2a 57 	call	0xae54	; 0xae54 <strstr>
    2fcc:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:760
            if (ok_index != NULL) {
    2fce:	f9 f0       	breq	.+62     	; 0x300e <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x12e>
    2fd0:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:762
                // Terminate and omit the rest from the OK index.
                *ok_index = '\0';
    2fd2:	10 82       	st	Z, r1
    2fd4:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:763
                return ResponseResult::OK;
    2fd6:	90 e0       	ldi	r25, 0x00	; 0
    2fd8:	a8 96       	adiw	r28, 0x28	; 40
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:778
    }

    // Didn't find the end marker within the number of bytes given for the
    // response. Caller should increase the buffer size.
    return ResponseResult::BUFFER_OVERFLOW;
}
    2fda:	cd bf       	out	0x3d, r28	; 61
    2fdc:	de bf       	out	0x3e, r29	; 62
    2fde:	df 91       	pop	r29
    2fe0:	cf 91       	pop	r28
    2fe2:	1f 91       	pop	r17
    2fe4:	0f 91       	pop	r16
    2fe6:	ff 90       	pop	r15
    2fe8:	ef 90       	pop	r14
    2fea:	df 90       	pop	r13
    2fec:	cf 90       	pop	r12
    2fee:	bf 90       	pop	r11
    2ff0:	af 90       	pop	r10
    2ff2:	7f 90       	pop	r7
    2ff4:	6f 90       	pop	r6
    2ff6:	5f 90       	pop	r5
    2ff8:	4f 90       	pop	r4
    2ffa:	08 95       	ret
    2ffc:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:738
            ctsUpdate();

            _delay_ms(1);
        }

        if (!isRxReady() && timeout_timer.hasTimedOut()) {
    2ffe:	81 96       	adiw	r24, 0x21	; 33
    3000:	0e 94 2a 07 	call	0xe54	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    3004:	88 23       	and	r24, r24
    3006:	51 f2       	breq	.-108    	; 0x2f9c <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0xbc>
    3008:	84 e0       	ldi	r24, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:739
            return ResponseResult::TIMEOUT;
    300a:	90 e0       	ldi	r25, 0x00	; 0
    300c:	e5 cf       	rjmp	.-54     	; 0x2fd8 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0xf8>
    300e:	6e eb       	ldi	r22, 0xBE	; 190
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:766
                // Terminate and omit the rest from the OK index.
                *ok_index = '\0';
                return ResponseResult::OK;
            }

            char* error_index = strstr(buffer, ERROR_TERMINATION);
    3010:	72 e4       	ldi	r23, 0x42	; 66
    3012:	c8 01       	movw	r24, r16
    3014:	0e 94 2a 57 	call	0xae54	; 0xae54 <strstr>
    3018:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:767
            if (error_index != NULL) {
    301a:	09 f4       	brne	.+2      	; 0x301e <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x13e>
    301c:	96 cf       	rjmp	.-212    	; 0x2f4a <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0x6a>
    301e:	dc 01       	movw	r26, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:769
                // Terminate and omit the rest from the ERROR index
                *error_index = '\0';
    3020:	1c 92       	st	X, r1
    3022:	82 e0       	ldi	r24, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:770
                return ResponseResult::ERROR;
    3024:	90 e0       	ldi	r25, 0x00	; 0
    3026:	d8 cf       	rjmp	.-80     	; 0x2fd8 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0xf8>
    3028:	83 e0       	ldi	r24, 0x03	; 3
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:777
        }
    }

    // Didn't find the end marker within the number of bytes given for the
    // response. Caller should increase the buffer size.
    return ResponseResult::BUFFER_OVERFLOW;
    302a:	90 e0       	ldi	r25, 0x00	; 0
    302c:	d5 cf       	rjmp	.-86     	; 0x2fd8 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]+0xf8>

0000302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>:
writeCommand():
    302e:	9f 92       	push	r9
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:666

    return rx_buffer[next_tail_index];
}

ResponseResult
SequansControllerClass::writeCommand(const char* command,
    3030:	af 92       	push	r10
    3032:	bf 92       	push	r11
    3034:	cf 92       	push	r12
    3036:	df 92       	push	r13
    3038:	ef 92       	push	r14
    303a:	ff 92       	push	r15
    303c:	0f 93       	push	r16
    303e:	1f 93       	push	r17
    3040:	cf 93       	push	r28
    3042:	df 93       	push	r29
    3044:	cd b7       	in	r28, 0x3d	; 61
    3046:	de b7       	in	r29, 0x3e	; 62
    3048:	62 97       	sbiw	r28, 0x12	; 18
    304a:	cd bf       	out	0x3d, r28	; 61
    304c:	de bf       	out	0x3e, r29	; 62
    304e:	a8 2e       	mov	r10, r24
    3050:	99 2e       	mov	r9, r25
    3052:	7b 01       	movw	r14, r22
    3054:	6a 01       	movw	r12, r20
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:670
                                     char* result_buffer,
                                     const size_t result_buffer_size) {

    clearReceiveBuffer();
    3056:	0e 94 82 07 	call	0xf04	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:671
    Log.debugf("Sending AT command: %s", command);
    305a:	9f 92       	push	r9
    305c:	af 92       	push	r10
    305e:	8d e8       	ldi	r24, 0x8D	; 141
    3060:	95 e4       	ldi	r25, 0x45	; 69
    3062:	9f 93       	push	r25
    3064:	8f 93       	push	r24
    3066:	89 e6       	ldi	r24, 0x69	; 105
    3068:	90 e7       	ldi	r25, 0x70	; 112
    306a:	9f 93       	push	r25
    306c:	8f 93       	push	r24
    306e:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <LogClass::debugf(char const*, ...) [clone .constprop.118]>
    3072:	0f 90       	pop	r0
    3074:	0f 90       	pop	r0
    3076:	0f 90       	pop	r0
    3078:	0f 90       	pop	r0
    307a:	0f 90       	pop	r0
    307c:	0f 90       	pop	r0
    307e:	86 e0       	ldi	r24, 0x06	; 6
    3080:	b8 2e       	mov	r11, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:677
    ResponseResult response;

    uint8_t retry_count = 0;

    do {
        writeBytes((const uint8_t*)command, strlen(command), true);
    3082:	aa 2d       	mov	r26, r10
    3084:	b9 2d       	mov	r27, r9
    3086:	fd 01       	movw	r30, r26
    3088:	01 90       	ld	r0, Z+
    308a:	00 20       	and	r0, r0
    308c:	e9 f7       	brne	.-6      	; 0x3088 <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x5a>
    308e:	31 97       	sbiw	r30, 0x01	; 1
    3090:	bf 01       	movw	r22, r30
    3092:	6a 1b       	sub	r22, r26
    3094:	7b 0b       	sbc	r23, r27
    3096:	41 e0       	ldi	r20, 0x01	; 1
    3098:	8a 2d       	mov	r24, r10
    309a:	99 2d       	mov	r25, r9
    309c:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:678
        response = readResponse(result_buffer, result_buffer_size);
    30a0:	b6 01       	movw	r22, r12
    30a2:	c7 01       	movw	r24, r14
    30a4:	1d df       	rcall	.-454    	; 0x2ee0 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]>
    30a6:	8c 01       	movw	r16, r24
    30a8:	83 30       	cpi	r24, 0x03	; 3
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:680

        if (response == ResponseResult::BUFFER_OVERFLOW &&
    30aa:	91 05       	cpc	r25, r1
    30ac:	e1 f4       	brne	.+56     	; 0x30e6 <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0xb8>
    30ae:	e1 14       	cp	r14, r1
    30b0:	f1 04       	cpc	r15, r1
    30b2:	d9 f0       	breq	.+54     	; 0x30ea <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0xbc>
    30b4:	62 ef       	ldi	r22, 0xF2	; 242
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:683
            result_buffer != NULL) {

            strcpy(result_buffer, "");
    30b6:	71 e6       	ldi	r23, 0x61	; 97
    30b8:	c7 01       	movw	r24, r14
    30ba:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    30be:	84 ea       	ldi	r24, 0xA4	; 164
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:684
            Log.error(
    30c0:	95 e4       	ldi	r25, 0x45	; 69
    30c2:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    30c6:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:705
    if (Log.getLogLevel() == LogLevel::DEBUG) {
        Log.rawf(" -> %s\r\n", response_string);
    }

    return response;
}
    30c8:	62 96       	adiw	r28, 0x12	; 18
    30ca:	cd bf       	out	0x3d, r28	; 61
    30cc:	de bf       	out	0x3e, r29	; 62
    30ce:	df 91       	pop	r29
    30d0:	cf 91       	pop	r28
    30d2:	1f 91       	pop	r17
    30d4:	0f 91       	pop	r16
    30d6:	ff 90       	pop	r15
    30d8:	ef 90       	pop	r14
    30da:	df 90       	pop	r13
    30dc:	cf 90       	pop	r12
    30de:	bf 90       	pop	r11
    30e0:	af 90       	pop	r10
    30e2:	9f 90       	pop	r9
    30e4:	08 95       	ret
    30e6:	01 97       	sbiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:691
                "is too small for the response. Increase response buffer "
                "size.");
            return response;
        }

        if (response != ResponseResult::OK) {
    30e8:	c1 f0       	breq	.+48     	; 0x311a <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0xec>
_delay_ms():
    30ea:	2f ef       	ldi	r18, 0xFF	; 255
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:187
    30ec:	8e e9       	ldi	r24, 0x9E	; 158
    30ee:	94 e2       	ldi	r25, 0x24	; 36
    30f0:	21 50       	subi	r18, 0x01	; 1
    30f2:	80 40       	sbci	r24, 0x00	; 0
    30f4:	90 40       	sbci	r25, 0x00	; 0
    30f6:	e1 f7       	brne	.-8      	; 0x30f0 <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0xc2>
    30f8:	00 c0       	rjmp	.+0      	; 0x30fa <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0xcc>
    30fa:	00 00       	nop
    30fc:	ba 94       	dec	r11
writeCommand():
    30fe:	b1 10       	cpse	r11, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:694
            _delay_ms(COMMAND_RETRY_SLEEP_MS);
        }
    } while (response != ResponseResult::OK &&
    3100:	c0 cf       	rjmp	.-128    	; 0x3082 <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x54>
responseResultToString():
    3102:	02 30       	cpi	r16, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1032

void SequansControllerClass::responseResultToString(
    const ResponseResult response_result,
    char* response_string) {

    switch (response_result) {
    3104:	11 05       	cpc	r17, r1
    3106:	c9 f1       	breq	.+114    	; 0x317a <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x14c>
    3108:	8c f4       	brge	.+34     	; 0x312c <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0xfe>
    310a:	69 e4       	ldi	r22, 0x49	; 73
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1049
        break;
    case ResponseResult::SERIAL_READ_ERROR:
        strcpy(response_string, "SERIAL_READ_ERROR");
        break;
    case ResponseResult::NONE:
        strcpy(response_string, "NONE");
    310c:	76 e4       	ldi	r23, 0x46	; 70
    310e:	01 15       	cp	r16, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1032

void SequansControllerClass::responseResultToString(
    const ResponseResult response_result,
    char* response_string) {

    switch (response_result) {
    3110:	11 05       	cpc	r17, r1
    3112:	a9 f1       	breq	.+106    	; 0x317e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x150>
    3114:	01 30       	cpi	r16, 0x01	; 1
    3116:	11 05       	cpc	r17, r1
    3118:	91 f4       	brne	.+36     	; 0x313e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x110>
    311a:	6c e1       	ldi	r22, 0x1C	; 28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1034
    case ResponseResult::OK:
        strcpy(response_string, "OK");
    311c:	76 e4       	ldi	r23, 0x46	; 70
    311e:	ce 01       	movw	r24, r28
    3120:	01 96       	adiw	r24, 0x01	; 1
    3122:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    3126:	01 e0       	ldi	r16, 0x01	; 1
    3128:	10 e0       	ldi	r17, 0x00	; 0
    312a:	09 c0       	rjmp	.+18     	; 0x313e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x110>
    312c:	04 30       	cpi	r16, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1032

void SequansControllerClass::responseResultToString(
    const ResponseResult response_result,
    char* response_string) {

    switch (response_result) {
    312e:	11 05       	cpc	r17, r1
    3130:	71 f1       	breq	.+92     	; 0x318e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x160>
    3132:	54 f1       	brlt	.+84     	; 0x3188 <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x15a>
    3134:	67 e3       	ldi	r22, 0x37	; 55
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1046
        break;
    case ResponseResult::TIMEOUT:
        strcpy(response_string, "TIMEOUT");
        break;
    case ResponseResult::SERIAL_READ_ERROR:
        strcpy(response_string, "SERIAL_READ_ERROR");
    3136:	76 e4       	ldi	r23, 0x46	; 70
    3138:	05 30       	cpi	r16, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1032

void SequansControllerClass::responseResultToString(
    const ResponseResult response_result,
    char* response_string) {

    switch (response_result) {
    313a:	11 05       	cpc	r17, r1
    313c:	01 f1       	breq	.+64     	; 0x317e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x150>
getLogLevel():
    313e:	89 e6       	ldi	r24, 0x69	; 105
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:44

void LogClass::setLogLevel(const LogLevel log_level) {
    this->log_level = log_level;
}

LogLevel LogClass::getLogLevel(void) { return log_level; }
    3140:	90 e7       	ldi	r25, 0x70	; 112
writeCommand():
    3142:	20 91 6b 70 	lds	r18, 0x706B	; 0x80706b <Log+0x2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:700
             retry_count++ < COMMAND_NUM_RETRIES);

    char response_string[18];
    responseResultToString(response, response_string);

    if (Log.getLogLevel() == LogLevel::DEBUG) {
    3146:	30 91 6c 70 	lds	r19, 0x706C	; 0x80706c <Log+0x3>
    314a:	24 30       	cpi	r18, 0x04	; 4
    314c:	31 05       	cpc	r19, r1
    314e:	09 f0       	breq	.+2      	; 0x3152 <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x124>
    3150:	ba cf       	rjmp	.-140    	; 0x30c6 <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x98>
    3152:	9e 01       	movw	r18, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:701
        Log.rawf(" -> %s\r\n", response_string);
    3154:	2f 5f       	subi	r18, 0xFF	; 255
    3156:	3f 4f       	sbci	r19, 0xFF	; 255
    3158:	3f 93       	push	r19
    315a:	2f 93       	push	r18
    315c:	2e e4       	ldi	r18, 0x4E	; 78
    315e:	36 e4       	ldi	r19, 0x46	; 70
    3160:	3f 93       	push	r19
    3162:	2f 93       	push	r18
    3164:	9f 93       	push	r25
    3166:	8f 93       	push	r24
    3168:	0e 94 ba 0a 	call	0x1574	; 0x1574 <LogClass::rawf(char const*, ...) [clone .constprop.102]>
    316c:	0f 90       	pop	r0
    316e:	0f 90       	pop	r0
    3170:	0f 90       	pop	r0
    3172:	0f 90       	pop	r0
    3174:	0f 90       	pop	r0
    3176:	0f 90       	pop	r0
    3178:	a6 cf       	rjmp	.-180    	; 0x30c6 <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x98>
responseResultToString():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1037
    switch (response_result) {
    case ResponseResult::OK:
        strcpy(response_string, "OK");
        break;
    case ResponseResult::ERROR:
        strcpy(response_string, "ERROR");
    317a:	67 ea       	ldi	r22, 0xA7	; 167
    317c:	73 e4       	ldi	r23, 0x43	; 67
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1049
        break;
    case ResponseResult::SERIAL_READ_ERROR:
        strcpy(response_string, "SERIAL_READ_ERROR");
        break;
    case ResponseResult::NONE:
        strcpy(response_string, "NONE");
    317e:	ce 01       	movw	r24, r28
    3180:	01 96       	adiw	r24, 0x01	; 1
    3182:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    3186:	db cf       	rjmp	.-74     	; 0x313e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x110>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1040
        break;
    case ResponseResult::ERROR:
        strcpy(response_string, "ERROR");
        break;
    case ResponseResult::BUFFER_OVERFLOW:
        strcpy(response_string, "BUFFER_OVERFLOW");
    3188:	6f e1       	ldi	r22, 0x1F	; 31
    318a:	76 e4       	ldi	r23, 0x46	; 70
    318c:	f8 cf       	rjmp	.-16     	; 0x317e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x150>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1043
        break;
    case ResponseResult::TIMEOUT:
        strcpy(response_string, "TIMEOUT");
    318e:	6f e2       	ldi	r22, 0x2F	; 47
    3190:	76 e4       	ldi	r23, 0x46	; 70
    3192:	f5 cf       	rjmp	.-22     	; 0x317e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]+0x150>

00003194 <SecurityProfileClass::profileExists(unsigned char) [clone .constprop.69]>:
profileExists():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:13

#define SECURITY_PROFILE_PREFIX_LENGTH 11

SecurityProfileClass SecurityProfile = SecurityProfileClass::instance();

bool SecurityProfileClass::profileExists(const uint8_t id) {
    3194:	cf 92       	push	r12
    3196:	df 92       	push	r13
    3198:	ef 92       	push	r14
    319a:	ff 92       	push	r15
    319c:	0f 93       	push	r16
    319e:	1f 93       	push	r17
    31a0:	cf 93       	push	r28
    31a2:	df 93       	push	r29
    31a4:	cd b7       	in	r28, 0x3d	; 61
    31a6:	de b7       	in	r29, 0x3e	; 62
    31a8:	c2 50       	subi	r28, 0x02	; 2
    31aa:	d1 40       	sbci	r29, 0x01	; 1
    31ac:	cd bf       	out	0x3d, r28	; 61
    31ae:	de bf       	out	0x3e, r29	; 62
    31b0:	e8 2e       	mov	r14, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:15

    char response[256]    = "";
    31b2:	19 82       	std	Y+1, r1	; 0x01
    31b4:	1a 82       	std	Y+2, r1	; 0x02
    31b6:	fe 01       	movw	r30, r28
    31b8:	33 96       	adiw	r30, 0x03	; 3
    31ba:	8e ef       	ldi	r24, 0xFE	; 254
    31bc:	df 01       	movw	r26, r30
    31be:	1d 92       	st	X+, r1
    31c0:	8a 95       	dec	r24
    31c2:	e9 f7       	brne	.-6      	; 0x31be <SecurityProfileClass::profileExists(unsigned char) [clone .constprop.69]+0x2a>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:19
    ResponseResult result = SequansController.writeCommand(
        QUERY_SECURITY_PROFILE,
        response,
        sizeof(response));
    31c4:	40 e0       	ldi	r20, 0x00	; 0
    31c6:	51 e0       	ldi	r21, 0x01	; 1
    31c8:	be 01       	movw	r22, r28
    31ca:	6f 5f       	subi	r22, 0xFF	; 255
    31cc:	7f 4f       	sbci	r23, 0xFF	; 255
    31ce:	87 e5       	ldi	r24, 0x57	; 87
    31d0:	96 e4       	ldi	r25, 0x46	; 70
    31d2:	2d df       	rcall	.-422    	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    31d4:	01 97       	sbiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:21

    if (result != ResponseResult::OK) {
    31d6:	31 f0       	breq	.+12     	; 0x31e4 <SecurityProfileClass::profileExists(unsigned char) [clone .constprop.69]+0x50>
    31d8:	83 e6       	ldi	r24, 0x63	; 99
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:22
        Log.error("Failed to query security profile");
    31da:	96 e4       	ldi	r25, 0x46	; 70
    31dc:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    31e0:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:44
        }

        ptr = strtok(NULL, "\r\n");
    }

    return false;
    31e2:	26 c0       	rjmp	.+76     	; 0x3230 <SecurityProfileClass::profileExists(unsigned char) [clone .constprop.69]+0x9c>
    31e4:	65 e1       	ldi	r22, 0x15	; 21
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:27
        Log.error("Failed to query security profile");
        return false;
    }

    // Split by line feed and carriage return to retrieve each entry
    char* ptr = strtok(response, "\r\n");
    31e6:	77 e5       	ldi	r23, 0x57	; 87
    31e8:	ce 01       	movw	r24, r28
    31ea:	01 96       	adiw	r24, 0x01	; 1
    31ec:	0e 94 5c 50 	call	0xa0b8	; 0xa0b8 <strtok>
    31f0:	8e 01       	movw	r16, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:35

        // Skip the prefix of '+SQNSPCFG: '
        ptr += SECURITY_PROFILE_PREFIX_LENGTH;

        int security_profile_id;
        sscanf(ptr, "%d", &security_profile_id);
    31f2:	0f 5f       	subi	r16, 0xFF	; 255
    31f4:	1e 4f       	sbci	r17, 0xFE	; 254
    31f6:	24 e8       	ldi	r18, 0x84	; 132
    31f8:	c2 2e       	mov	r12, r18
    31fa:	26 e4       	ldi	r18, 0x46	; 70
    31fc:	d2 2e       	mov	r13, r18
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:37

        if (security_profile_id == id) {
    31fe:	f1 2c       	mov	r15, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:29
    }

    // Split by line feed and carriage return to retrieve each entry
    char* ptr = strtok(response, "\r\n");

    while (ptr != NULL) {
    3200:	00 97       	sbiw	r24, 0x00	; 0
    3202:	71 f3       	breq	.-36     	; 0x31e0 <SecurityProfileClass::profileExists(unsigned char) [clone .constprop.69]+0x4c>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:35

        // Skip the prefix of '+SQNSPCFG: '
        ptr += SECURITY_PROFILE_PREFIX_LENGTH;

        int security_profile_id;
        sscanf(ptr, "%d", &security_profile_id);
    3204:	1f 93       	push	r17
    3206:	0f 93       	push	r16
    3208:	df 92       	push	r13
    320a:	cf 92       	push	r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:32
    char* ptr = strtok(response, "\r\n");

    while (ptr != NULL) {

        // Skip the prefix of '+SQNSPCFG: '
        ptr += SECURITY_PROFILE_PREFIX_LENGTH;
    320c:	0b 96       	adiw	r24, 0x0b	; 11
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:35

        int security_profile_id;
        sscanf(ptr, "%d", &security_profile_id);
    320e:	9f 93       	push	r25
    3210:	8f 93       	push	r24
    3212:	0e 94 e4 57 	call	0xafc8	; 0xafc8 <sscanf>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:37

        if (security_profile_id == id) {
    3216:	0f 90       	pop	r0
    3218:	0f 90       	pop	r0
    321a:	0f 90       	pop	r0
    321c:	0f 90       	pop	r0
    321e:	0f 90       	pop	r0
    3220:	0f 90       	pop	r0
    3222:	f8 01       	movw	r30, r16
    3224:	80 81       	ld	r24, Z
    3226:	91 81       	ldd	r25, Z+1	; 0x01
    3228:	e8 16       	cp	r14, r24
    322a:	f9 06       	cpc	r15, r25
    322c:	71 f4       	brne	.+28     	; 0x324a <SecurityProfileClass::profileExists(unsigned char) [clone .constprop.69]+0xb6>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:38
            return true;
    322e:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:45

        ptr = strtok(NULL, "\r\n");
    }

    return false;
    3230:	ce 5f       	subi	r28, 0xFE	; 254
    3232:	de 4f       	sbci	r29, 0xFE	; 254
    3234:	cd bf       	out	0x3d, r28	; 61
    3236:	de bf       	out	0x3e, r29	; 62
    3238:	df 91       	pop	r29
    323a:	cf 91       	pop	r28
    323c:	1f 91       	pop	r17
    323e:	0f 91       	pop	r16
    3240:	ff 90       	pop	r15
    3242:	ef 90       	pop	r14
    3244:	df 90       	pop	r13
    3246:	cf 90       	pop	r12
    3248:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/security_profile.cpp:41

        if (security_profile_id == id) {
            return true;
        }

        ptr = strtok(NULL, "\r\n");
    324a:	65 e1       	ldi	r22, 0x15	; 21
    324c:	77 e5       	ldi	r23, 0x57	; 87
    324e:	90 e0       	ldi	r25, 0x00	; 0
    3250:	80 e0       	ldi	r24, 0x00	; 0
    3252:	0e 94 5c 50 	call	0xa0b8	; 0xa0b8 <strtok>
    3256:	d4 cf       	rjmp	.-88     	; 0x3200 <SecurityProfileClass::profileExists(unsigned char) [clone .constprop.69]+0x6c>

00003258 <HttpClientClass::configure(char const*, unsigned int, bool) [clone .constprop.68]>:
configure():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:308
    LedCtrl.off(Led::CON, true);

    return http_response;
}

bool HttpClientClass::configure(const char* host,
    3258:	ff 92       	push	r15
    325a:	0f 93       	push	r16
    325c:	1f 93       	push	r17
    325e:	cf 93       	push	r28
    3260:	df 93       	push	r29
    3262:	cd b7       	in	r28, 0x3d	; 61
    3264:	de b7       	in	r29, 0x3e	; 62
    3266:	c9 5a       	subi	r28, 0xA9	; 169
    3268:	d1 09       	sbc	r29, r1
    326a:	cd bf       	out	0x3d, r28	; 61
    326c:	de bf       	out	0x3e, r29	; 62
    326e:	08 2f       	mov	r16, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:313
                                const uint16_t port,
                                const bool enable_tls) {

    if (enable_tls) {
        if (!SecurityProfile.profileExists(HTTPS_SECURITY_PROFILE_NUMBER)) {
    3270:	f9 2e       	mov	r15, r25
    3272:	83 e0       	ldi	r24, 0x03	; 3
    3274:	8f df       	rcall	.-226    	; 0x3194 <SecurityProfileClass::profileExists(unsigned char) [clone .constprop.69]>
    3276:	18 2f       	mov	r17, r24
    3278:	81 11       	cpse	r24, r1
    327a:	0f c0       	rjmp	.+30     	; 0x329a <HttpClientClass::configure(char const*, unsigned int, bool) [clone .constprop.68]+0x42>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:314
            Log.error("Security profile not set up for HTTPS. Run the "
    327c:	87 e8       	ldi	r24, 0x87	; 135
    327e:	96 e4       	ldi	r25, 0x46	; 70
    3280:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:324
    }

    char command[HTTP_CONFIGURE_SIZE] = "";
    sprintf(command, HTTP_CONFIGURE, host, port, enable_tls ? 1 : 0);
    return SequansController.writeCommand(command) == ResponseResult::OK;
}
    3284:	81 2f       	mov	r24, r17
    3286:	c7 55       	subi	r28, 0x57	; 87
    3288:	df 4f       	sbci	r29, 0xFF	; 255
    328a:	cd bf       	out	0x3d, r28	; 61
    328c:	de bf       	out	0x3e, r29	; 62
    328e:	df 91       	pop	r29
    3290:	cf 91       	pop	r28
    3292:	1f 91       	pop	r17
    3294:	0f 91       	pop	r16
    3296:	ff 90       	pop	r15
    3298:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:321

            return false;
        }
    }

    char command[HTTP_CONFIGURE_SIZE] = "";
    329a:	19 82       	std	Y+1, r1	; 0x01
    329c:	1a 82       	std	Y+2, r1	; 0x02
    329e:	fe 01       	movw	r30, r28
    32a0:	33 96       	adiw	r30, 0x03	; 3
    32a2:	87 ea       	ldi	r24, 0xA7	; 167
    32a4:	df 01       	movw	r26, r30
    32a6:	1d 92       	st	X+, r1
    32a8:	8a 95       	dec	r24
    32aa:	e9 f7       	brne	.-6      	; 0x32a6 <HttpClientClass::configure(char const*, unsigned int, bool) [clone .constprop.68]+0x4e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:322
    sprintf(command, HTTP_CONFIGURE, host, port, enable_tls ? 1 : 0);
    32ac:	1f 92       	push	r1
    32ae:	81 e0       	ldi	r24, 0x01	; 1
    32b0:	8f 93       	push	r24
    32b2:	8f 93       	push	r24
    32b4:	8b eb       	ldi	r24, 0xBB	; 187
    32b6:	8f 93       	push	r24
    32b8:	ff 92       	push	r15
    32ba:	0f 93       	push	r16
    32bc:	89 ee       	ldi	r24, 0xE9	; 233
    32be:	96 e4       	ldi	r25, 0x46	; 70
    32c0:	9f 93       	push	r25
    32c2:	8f 93       	push	r24
    32c4:	8e 01       	movw	r16, r28
    32c6:	0f 5f       	subi	r16, 0xFF	; 255
    32c8:	1f 4f       	sbci	r17, 0xFF	; 255
    32ca:	1f 93       	push	r17
    32cc:	0f 93       	push	r16
    32ce:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:323
    return SequansController.writeCommand(command) == ResponseResult::OK;
    32d2:	50 e0       	ldi	r21, 0x00	; 0
    32d4:	40 e0       	ldi	r20, 0x00	; 0
    32d6:	70 e0       	ldi	r23, 0x00	; 0
    32d8:	60 e0       	ldi	r22, 0x00	; 0
    32da:	c8 01       	movw	r24, r16
    32dc:	a8 de       	rcall	.-688    	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    32de:	11 e0       	ldi	r17, 0x01	; 1
    32e0:	cd bf       	out	0x3d, r28	; 61
    32e2:	de bf       	out	0x3e, r29	; 62
    32e4:	01 97       	sbiw	r24, 0x01	; 1
    32e6:	71 f2       	breq	.-100    	; 0x3284 <HttpClientClass::configure(char const*, unsigned int, bool) [clone .constprop.68]+0x2c>
    32e8:	10 e0       	ldi	r17, 0x00	; 0
    32ea:	cc cf       	rjmp	.-104    	; 0x3284 <HttpClientClass::configure(char const*, unsigned int, bool) [clone .constprop.68]+0x2c>

000032ec <print_string_ptr>:
print_string_ptr():
    32ec:	4f 92       	push	r4
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:899
    return false;
}

/* Render the cstring provided to an escaped version that can be printed. */
static cJSON_bool print_string_ptr(const unsigned char * const input, printbuffer * const output_buffer)
{
    32ee:	5f 92       	push	r5
    32f0:	6f 92       	push	r6
    32f2:	7f 92       	push	r7
    32f4:	8f 92       	push	r8
    32f6:	9f 92       	push	r9
    32f8:	af 92       	push	r10
    32fa:	bf 92       	push	r11
    32fc:	cf 92       	push	r12
    32fe:	df 92       	push	r13
    3300:	ef 92       	push	r14
    3302:	ff 92       	push	r15
    3304:	0f 93       	push	r16
    3306:	1f 93       	push	r17
    3308:	cf 93       	push	r28
    330a:	df 93       	push	r29
    330c:	61 15       	cp	r22, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:907
    unsigned char *output_pointer = NULL;
    size_t output_length = 0;
    /* numbers of additional characters needed for escaping */
    size_t escape_characters = 0;

    if (output_buffer == NULL)
    330e:	71 05       	cpc	r23, r1
    3310:	99 f4       	brne	.+38     	; 0x3338 <print_string_ptr+0x4c>
    3312:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:909
    {
        return false;
    3314:	80 e0       	ldi	r24, 0x00	; 0
    3316:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1017
    }
    output[output_length + 1] = '\"';
    output[output_length + 2] = '\0';

    return true;
}
    3318:	cf 91       	pop	r28
    331a:	1f 91       	pop	r17
    331c:	0f 91       	pop	r16
    331e:	ff 90       	pop	r15
    3320:	ef 90       	pop	r14
    3322:	df 90       	pop	r13
    3324:	cf 90       	pop	r12
    3326:	bf 90       	pop	r11
    3328:	af 90       	pop	r10
    332a:	9f 90       	pop	r9
    332c:	8f 90       	pop	r8
    332e:	7f 90       	pop	r7
    3330:	6f 90       	pop	r6
    3332:	5f 90       	pop	r5
    3334:	4f 90       	pop	r4
    3336:	08 95       	ret
    3338:	9b 01       	movw	r18, r22
    333a:	7c 01       	movw	r14, r24
    333c:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:913
    {
        return false;
    }

    /* empty string */
    if (input == NULL)
    333e:	09 f4       	brne	.+2      	; 0x3342 <print_string_ptr+0x56>
    3340:	a4 c0       	rjmp	.+328    	; 0x348a <print_string_ptr+0x19e>
    3342:	5c 01       	movw	r10, r24
    3344:	8c 01       	movw	r16, r24
    3346:	91 2c       	mov	r9, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:905
    const unsigned char *input_pointer = NULL;
    unsigned char *output = NULL;
    unsigned char *output_pointer = NULL;
    size_t output_length = 0;
    /* numbers of additional characters needed for escaping */
    size_t escape_characters = 0;
    3348:	81 2c       	mov	r8, r1
    334a:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:926

        return true;
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
    334c:	91 91       	ld	r25, Z+
    334e:	91 11       	cpse	r25, r1
    3350:	2c c0       	rjmp	.+88     	; 0x33aa <print_string_ptr+0xbe>
    3352:	0e 19       	sub	r16, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:949
                    escape_characters += 5;
                }
                break;
        }
    }
    output_length = (size_t)(input_pointer - input) + escape_characters;
    3354:	1f 09       	sbc	r17, r15
    3356:	08 0d       	add	r16, r8
    3358:	19 1d       	adc	r17, r9
    335a:	b8 01       	movw	r22, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:951

    output = ensure(output_buffer, output_length + sizeof("\"\""));
    335c:	6d 5f       	subi	r22, 0xFD	; 253
    335e:	7f 4f       	sbci	r23, 0xFF	; 255
    3360:	c9 01       	movw	r24, r18
    3362:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3366:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:952
    if (output == NULL)
    3368:	a1 f2       	breq	.-88     	; 0x3312 <print_string_ptr+0x26>
    336a:	ec 01       	movw	r28, r24
    336c:	21 96       	adiw	r28, 0x01	; 1
    336e:	68 01       	movw	r12, r16
    3370:	ef ef       	ldi	r30, 0xFF	; 255
    3372:	ce 1a       	sub	r12, r30
    3374:	de 0a       	sbc	r13, r30
    3376:	c8 0e       	add	r12, r24
    3378:	d9 1e       	adc	r13, r25
    337a:	38 01       	movw	r6, r16
    337c:	f2 e0       	ldi	r31, 0x02	; 2
    337e:	6f 0e       	add	r6, r31
    3380:	71 1c       	adc	r7, r1
    3382:	68 0e       	add	r6, r24
    3384:	79 1e       	adc	r7, r25
    3386:	89 28       	or	r8, r9
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:958
    {
        return false;
    }

    /* no characters have to be escaped */
    if (escape_characters == 0)
    3388:	39 f5       	brne	.+78     	; 0x33d8 <print_string_ptr+0xec>
    338a:	62 e2       	ldi	r22, 0x22	; 34
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:960
    {
        output[0] = '\"';
    338c:	b6 2e       	mov	r11, r22
    338e:	fc 01       	movw	r30, r24
    3390:	b0 82       	st	Z, r11
    3392:	a8 01       	movw	r20, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:961
        memcpy(output + 1, input, output_length);
    3394:	b7 01       	movw	r22, r14
    3396:	ce 01       	movw	r24, r28
    3398:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
    339c:	f6 01       	movw	r30, r12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:962
        output[output_length + 1] = '\"';
    339e:	b0 82       	st	Z, r11
    33a0:	f3 01       	movw	r30, r6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1014
                    break;
            }
        }
    }
    output[output_length + 1] = '\"';
    output[output_length + 2] = '\0';
    33a2:	10 82       	st	Z, r1
    33a4:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:922
        {
            return false;
        }
        strcpy((char*)output, "\"\"");

        return true;
    33a6:	90 e0       	ldi	r25, 0x00	; 0
    33a8:	b6 cf       	rjmp	.-148    	; 0x3316 <print_string_ptr+0x2a>
    33aa:	9e 30       	cpi	r25, 0x0E	; 14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:928
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
    {
        switch (*input_pointer)
    33ac:	58 f4       	brcc	.+22     	; 0x33c4 <print_string_ptr+0xd8>
    33ae:	9c 30       	cpi	r25, 0x0C	; 12
    33b0:	20 f4       	brcc	.+8      	; 0x33ba <print_string_ptr+0xce>
    33b2:	88 ef       	ldi	r24, 0xF8	; 248
    33b4:	89 0f       	add	r24, r25
    33b6:	83 30       	cpi	r24, 0x03	; 3
    33b8:	48 f4       	brcc	.+18     	; 0x33cc <print_string_ptr+0xe0>
    33ba:	8f ef       	ldi	r24, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:938
            case '\f':
            case '\n':
            case '\r':
            case '\t':
                /* one character escape sequence */
                escape_characters++;
    33bc:	88 1a       	sub	r8, r24
    33be:	98 0a       	sbc	r9, r24
    33c0:	8f 01       	movw	r16, r30
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:905
    const unsigned char *input_pointer = NULL;
    unsigned char *output = NULL;
    unsigned char *output_pointer = NULL;
    size_t output_length = 0;
    /* numbers of additional characters needed for escaping */
    size_t escape_characters = 0;
    33c2:	c3 cf       	rjmp	.-122    	; 0x334a <print_string_ptr+0x5e>
    33c4:	92 32       	cpi	r25, 0x22	; 34
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:928
    }

    /* set "flag" to 1 if something needs to be escaped */
    for (input_pointer = input; *input_pointer; input_pointer++)
    {
        switch (*input_pointer)
    33c6:	c9 f3       	breq	.-14     	; 0x33ba <print_string_ptr+0xce>
    33c8:	9c 35       	cpi	r25, 0x5C	; 92
    33ca:	b9 f3       	breq	.-18     	; 0x33ba <print_string_ptr+0xce>
    33cc:	90 32       	cpi	r25, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:941
            case '\t':
                /* one character escape sequence */
                escape_characters++;
                break;
            default:
                if (*input_pointer < 32)
    33ce:	c0 f7       	brcc	.-16     	; 0x33c0 <print_string_ptr+0xd4>
    33d0:	85 e0       	ldi	r24, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:944
                {
                    /* UTF-16 escape sequence uXXXX */
                    escape_characters += 5;
    33d2:	88 0e       	add	r8, r24
    33d4:	91 1c       	adc	r9, r1
    33d6:	f4 cf       	rjmp	.-24     	; 0x33c0 <print_string_ptr+0xd4>
    33d8:	22 e2       	ldi	r18, 0x22	; 34
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:968
        output[output_length + 2] = '\0';

        return true;
    }

    output[0] = '\"';
    33da:	fc 01       	movw	r30, r24
    33dc:	20 83       	st	Z, r18
    33de:	8c e5       	ldi	r24, 0x5C	; 92
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:981
            *output_pointer = *input_pointer;
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
    33e0:	f8 2e       	mov	r15, r24
    33e2:	96 e6       	ldi	r25, 0x66	; 102
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:994
                    break;
                case '\b':
                    *output_pointer = 'b';
                    break;
                case '\f':
                    *output_pointer = 'f';
    33e4:	e9 2e       	mov	r14, r25
    33e6:	03 e1       	ldi	r16, 0x13	; 19
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1007
                case '\t':
                    *output_pointer = 't';
                    break;
                default:
                    /* escape and print as unicode codepoint */
                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
    33e8:	17 e4       	ldi	r17, 0x47	; 71
    33ea:	22 e7       	ldi	r18, 0x72	; 114
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1000
                    break;
                case '\n':
                    *output_pointer = 'n';
                    break;
                case '\r':
                    *output_pointer = 'r';
    33ec:	92 2e       	mov	r9, r18
    33ee:	34 e7       	ldi	r19, 0x74	; 116
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1003
                    break;
                case '\t':
                    *output_pointer = 't';
    33f0:	83 2e       	mov	r8, r19
    33f2:	4e e6       	ldi	r20, 0x6E	; 110
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:997
                    break;
                case '\f':
                    *output_pointer = 'f';
                    break;
                case '\n':
                    *output_pointer = 'n';
    33f4:	54 2e       	mov	r5, r20
    33f6:	52 e6       	ldi	r21, 0x62	; 98
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:991
                    break;
                case '\"':
                    *output_pointer = '\"';
                    break;
                case '\b':
                    *output_pointer = 'b';
    33f8:	45 2e       	mov	r4, r21
    33fa:	f5 01       	movw	r30, r10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:971
    }

    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
    33fc:	81 91       	ld	r24, Z+
    33fe:	5f 01       	movw	r10, r30
    3400:	81 11       	cpse	r24, r1
    3402:	04 c0       	rjmp	.+8      	; 0x340c <print_string_ptr+0x120>
    3404:	82 e2       	ldi	r24, 0x22	; 34
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1013
                    output_pointer += 4;
                    break;
            }
        }
    }
    output[output_length + 1] = '\"';
    3406:	f6 01       	movw	r30, r12
    3408:	80 83       	st	Z, r24
    340a:	ca cf       	rjmp	.-108    	; 0x33a0 <print_string_ptr+0xb4>
    340c:	80 32       	cpi	r24, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:973
    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
    {
        if ((*input_pointer > 31) && (*input_pointer != '\"') && (*input_pointer != '\\'))
    340e:	48 f0       	brcs	.+18     	; 0x3422 <print_string_ptr+0x136>
    3410:	82 32       	cpi	r24, 0x22	; 34
    3412:	39 f0       	breq	.+14     	; 0x3422 <print_string_ptr+0x136>
    3414:	8c 35       	cpi	r24, 0x5C	; 92
    3416:	29 f0       	breq	.+10     	; 0x3422 <print_string_ptr+0x136>
    3418:	88 83       	st	Y, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:976
        {
            /* normal character, copy */
            *output_pointer = *input_pointer;
    341a:	9e 01       	movw	r18, r28
    341c:	e9 01       	movw	r28, r18
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:971
    }

    output[0] = '\"';
    output_pointer = output + 1;
    /* copy the string */
    for (input_pointer = input; *input_pointer != '\0'; (void)input_pointer++, output_pointer++)
    341e:	21 96       	adiw	r28, 0x01	; 1
    3420:	ec cf       	rjmp	.-40     	; 0x33fa <print_string_ptr+0x10e>
    3422:	9e 01       	movw	r18, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:981
            *output_pointer = *input_pointer;
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
    3424:	2f 5f       	subi	r18, 0xFF	; 255
    3426:	3f 4f       	sbci	r19, 0xFF	; 255
    3428:	f8 82       	st	Y, r15
    342a:	f5 01       	movw	r30, r10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:982
            switch (*input_pointer)
    342c:	31 97       	sbiw	r30, 0x01	; 1
    342e:	80 81       	ld	r24, Z
    3430:	8c 30       	cpi	r24, 0x0C	; 12
    3432:	99 f0       	breq	.+38     	; 0x345a <print_string_ptr+0x16e>
    3434:	40 f4       	brcc	.+16     	; 0x3446 <print_string_ptr+0x15a>
    3436:	89 30       	cpi	r24, 0x09	; 9
    3438:	a1 f0       	breq	.+40     	; 0x3462 <print_string_ptr+0x176>
    343a:	8a 30       	cpi	r24, 0x0A	; 10
    343c:	81 f0       	breq	.+32     	; 0x345e <print_string_ptr+0x172>
    343e:	88 30       	cpi	r24, 0x08	; 8
    3440:	91 f4       	brne	.+36     	; 0x3466 <print_string_ptr+0x17a>
    3442:	49 82       	std	Y+1, r4	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:991
                    break;
                case '\"':
                    *output_pointer = '\"';
                    break;
                case '\b':
                    *output_pointer = 'b';
    3444:	eb cf       	rjmp	.-42     	; 0x341c <print_string_ptr+0x130>
    3446:	82 32       	cpi	r24, 0x22	; 34
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:982
        }
        else
        {
            /* character needs to be escaped */
            *output_pointer++ = '\\';
            switch (*input_pointer)
    3448:	31 f0       	breq	.+12     	; 0x3456 <print_string_ptr+0x16a>
    344a:	8c 35       	cpi	r24, 0x5C	; 92
    344c:	21 f0       	breq	.+8      	; 0x3456 <print_string_ptr+0x16a>
    344e:	8d 30       	cpi	r24, 0x0D	; 13
    3450:	51 f4       	brne	.+20     	; 0x3466 <print_string_ptr+0x17a>
    3452:	99 82       	std	Y+1, r9	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1000
                    break;
                case '\n':
                    *output_pointer = 'n';
                    break;
                case '\r':
                    *output_pointer = 'r';
    3454:	e3 cf       	rjmp	.-58     	; 0x341c <print_string_ptr+0x130>
    3456:	89 83       	std	Y+1, r24	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:988
            {
                case '\\':
                    *output_pointer = '\\';
                    break;
                case '\"':
                    *output_pointer = '\"';
    3458:	e1 cf       	rjmp	.-62     	; 0x341c <print_string_ptr+0x130>
    345a:	e9 82       	std	Y+1, r14	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:994
                    break;
                case '\b':
                    *output_pointer = 'b';
                    break;
                case '\f':
                    *output_pointer = 'f';
    345c:	df cf       	rjmp	.-66     	; 0x341c <print_string_ptr+0x130>
    345e:	59 82       	std	Y+1, r5	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:997
                    break;
                case '\n':
                    *output_pointer = 'n';
    3460:	dd cf       	rjmp	.-70     	; 0x341c <print_string_ptr+0x130>
    3462:	89 82       	std	Y+1, r8	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1003
                    break;
                case '\r':
                    *output_pointer = 'r';
                    break;
                case '\t':
                    *output_pointer = 't';
    3464:	db cf       	rjmp	.-74     	; 0x341c <print_string_ptr+0x130>
    3466:	1f 92       	push	r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1007
                    break;
                default:
                    /* escape and print as unicode codepoint */
                    sprintf((char*)output_pointer, "u%04x", *input_pointer);
    3468:	8f 93       	push	r24
    346a:	1f 93       	push	r17
    346c:	0f 93       	push	r16
    346e:	3f 93       	push	r19
    3470:	2f 93       	push	r18
    3472:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    3476:	9e 01       	movw	r18, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1008
                    output_pointer += 4;
    3478:	2b 5f       	subi	r18, 0xFB	; 251
    347a:	3f 4f       	sbci	r19, 0xFF	; 255
    347c:	0f 90       	pop	r0
    347e:	0f 90       	pop	r0
    3480:	0f 90       	pop	r0
    3482:	0f 90       	pop	r0
    3484:	0f 90       	pop	r0
    3486:	0f 90       	pop	r0
    3488:	c9 cf       	rjmp	.-110    	; 0x341c <print_string_ptr+0x130>
    348a:	63 e0       	ldi	r22, 0x03	; 3
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:915
    }

    /* empty string */
    if (input == NULL)
    {
        output = ensure(output_buffer, sizeof("\"\""));
    348c:	70 e0       	ldi	r23, 0x00	; 0
    348e:	c9 01       	movw	r24, r18
    3490:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3494:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:916
        if (output == NULL)
    3496:	09 f4       	brne	.+2      	; 0x349a <print_string_ptr+0x1ae>
    3498:	3c cf       	rjmp	.-392    	; 0x3312 <print_string_ptr+0x26>
    349a:	69 e1       	ldi	r22, 0x19	; 25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:920
        {
            return false;
        }
        strcpy((char*)output, "\"\"");
    349c:	77 e4       	ldi	r23, 0x47	; 71
    349e:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    34a2:	80 cf       	rjmp	.-256    	; 0x33a4 <print_string_ptr+0xb8>

000034a4 <print_value.part.6>:
print_value.part.6():
    34a4:	2f 92       	push	r2
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1363

    return false;
}

/* Render a value to text. */
static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
    34a6:	3f 92       	push	r3
    34a8:	4f 92       	push	r4
    34aa:	5f 92       	push	r5
    34ac:	6f 92       	push	r6
    34ae:	7f 92       	push	r7
    34b0:	8f 92       	push	r8
    34b2:	9f 92       	push	r9
    34b4:	af 92       	push	r10
    34b6:	bf 92       	push	r11
    34b8:	cf 92       	push	r12
    34ba:	df 92       	push	r13
    34bc:	ef 92       	push	r14
    34be:	ff 92       	push	r15
    34c0:	0f 93       	push	r16
    34c2:	1f 93       	push	r17
    34c4:	cf 93       	push	r28
    34c6:	df 93       	push	r29
    34c8:	cd b7       	in	r28, 0x3d	; 61
    34ca:	de b7       	in	r29, 0x3e	; 62
    34cc:	a4 97       	sbiw	r28, 0x24	; 36
    34ce:	cd bf       	out	0x3d, r28	; 61
    34d0:	de bf       	out	0x3e, r29	; 62
    34d2:	7c 01       	movw	r14, r24
    34d4:	8b 01       	movw	r16, r22
    34d6:	dc 01       	movw	r26, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1372
    if ((item == NULL) || (output_buffer == NULL))
    {
        return false;
    }

    switch ((item->type) & 0xFF)
    34d8:	16 96       	adiw	r26, 0x06	; 6
    34da:	8d 91       	ld	r24, X+
    34dc:	9c 91       	ld	r25, X
    34de:	17 97       	sbiw	r26, 0x07	; 7
    34e0:	99 27       	eor	r25, r25
    34e2:	88 30       	cpi	r24, 0x08	; 8
    34e4:	91 05       	cpc	r25, r1
    34e6:	09 f4       	brne	.+2      	; 0x34ea <print_value.part.6+0x46>
    34e8:	58 c0       	rjmp	.+176    	; 0x359a <print_value.part.6+0xf6>
    34ea:	9c f4       	brge	.+38     	; 0x3512 <print_value.part.6+0x6e>
    34ec:	82 30       	cpi	r24, 0x02	; 2
    34ee:	91 05       	cpc	r25, r1
    34f0:	09 f4       	brne	.+2      	; 0x34f4 <print_value.part.6+0x50>
    34f2:	49 c0       	rjmp	.+146    	; 0x3586 <print_value.part.6+0xe2>
    34f4:	84 30       	cpi	r24, 0x04	; 4
    34f6:	91 05       	cpc	r25, r1
    34f8:	c1 f1       	breq	.+112    	; 0x356a <print_value.part.6+0xc6>
    34fa:	01 97       	sbiw	r24, 0x01	; 1
    34fc:	91 f4       	brne	.+36     	; 0x3522 <print_value.part.6+0x7e>
    34fe:	66 e0       	ldi	r22, 0x06	; 6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1384
            }
            strcpy((char*)output, "null");
            return true;

        case cJSON_False:
            output = ensure(output_buffer, 6);
    3500:	70 e0       	ldi	r23, 0x00	; 0
    3502:	c8 01       	movw	r24, r16
    3504:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3508:	61 e2       	ldi	r22, 0x21	; 33
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1389
            if (output == NULL)
            {
                return false;
            }
            strcpy((char*)output, "false");
    350a:	77 e4       	ldi	r23, 0x47	; 71
    350c:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1385
            strcpy((char*)output, "null");
            return true;

        case cJSON_False:
            output = ensure(output_buffer, 6);
            if (output == NULL)
    350e:	b1 f5       	brne	.+108    	; 0x357c <print_value.part.6+0xd8>
    3510:	08 c0       	rjmp	.+16     	; 0x3522 <print_value.part.6+0x7e>
    3512:	80 32       	cpi	r24, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1372
    if ((item == NULL) || (output_buffer == NULL))
    {
        return false;
    }

    switch ((item->type) & 0xFF)
    3514:	91 05       	cpc	r25, r1
    3516:	09 f4       	brne	.+2      	; 0x351a <print_value.part.6+0x76>
    3518:	26 c1       	rjmp	.+588    	; 0x3766 <print_value.part.6+0x2c2>
    351a:	34 f4       	brge	.+12     	; 0x3528 <print_value.part.6+0x84>
    351c:	40 97       	sbiw	r24, 0x10	; 16
    351e:	09 f4       	brne	.+2      	; 0x3522 <print_value.part.6+0x7e>
    3520:	08 c1       	rjmp	.+528    	; 0x3732 <print_value.part.6+0x28e>
    3522:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1432

        case cJSON_Object:
            return print_object(item, output_buffer);

        default:
            return false;
    3524:	80 e0       	ldi	r24, 0x00	; 0
    3526:	09 c1       	rjmp	.+530    	; 0x373a <print_value.part.6+0x296>
    3528:	80 34       	cpi	r24, 0x40	; 64
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1372
    if ((item == NULL) || (output_buffer == NULL))
    {
        return false;
    }

    switch ((item->type) & 0xFF)
    352a:	91 05       	cpc	r25, r1
    352c:	09 f4       	brne	.+2      	; 0x3530 <print_value.part.6+0x8c>
    352e:	9a c1       	rjmp	.+820    	; 0x3864 <print_value.part.6+0x3c0>
    3530:	80 38       	cpi	r24, 0x80	; 128
    3532:	91 05       	cpc	r25, r1
    3534:	b1 f7       	brne	.-20     	; 0x3522 <print_value.part.6+0x7e>
    3536:	f7 01       	movw	r30, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1407
            return print_number(item, output_buffer);

        case cJSON_Raw:
        {
            size_t raw_length = 0;
            if (item->valuestring == NULL)
    3538:	a0 85       	ldd	r26, Z+8	; 0x08
    353a:	b1 85       	ldd	r27, Z+9	; 0x09
    353c:	10 97       	sbiw	r26, 0x00	; 0
    353e:	89 f3       	breq	.-30     	; 0x3522 <print_value.part.6+0x7e>
    3540:	fd 01       	movw	r30, r26
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1412
            {
                return false;
            }

            raw_length = strlen(item->valuestring) + sizeof("");
    3542:	01 90       	ld	r0, Z+
    3544:	00 20       	and	r0, r0
    3546:	e9 f7       	brne	.-6      	; 0x3542 <print_value.part.6+0x9e>
    3548:	6f 01       	movw	r12, r30
    354a:	ca 1a       	sub	r12, r26
    354c:	db 0a       	sbc	r13, r27
    354e:	b6 01       	movw	r22, r12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1413
            output = ensure(output_buffer, raw_length);
    3550:	c8 01       	movw	r24, r16
    3552:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3556:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1414
            if (output == NULL)
    3558:	21 f3       	breq	.-56     	; 0x3522 <print_value.part.6+0x7e>
    355a:	d7 01       	movw	r26, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1418
            {
                return false;
            }
            memcpy(output, item->valuestring, raw_length);
    355c:	18 96       	adiw	r26, 0x08	; 8
    355e:	6d 91       	ld	r22, X+
    3560:	7c 91       	ld	r23, X
    3562:	a6 01       	movw	r20, r12
    3564:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
    3568:	0b c0       	rjmp	.+22     	; 0x3580 <print_value.part.6+0xdc>
    356a:	65 e0       	ldi	r22, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1375
    }

    switch ((item->type) & 0xFF)
    {
        case cJSON_NULL:
            output = ensure(output_buffer, 5);
    356c:	70 e0       	ldi	r23, 0x00	; 0
    356e:	c8 01       	movw	r24, r16
    3570:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3574:	6c e1       	ldi	r22, 0x1C	; 28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1380
            if (output == NULL)
            {
                return false;
            }
            strcpy((char*)output, "null");
    3576:	77 e4       	ldi	r23, 0x47	; 71
    3578:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1376

    switch ((item->type) & 0xFF)
    {
        case cJSON_NULL:
            output = ensure(output_buffer, 5);
            if (output == NULL)
    357a:	99 f2       	breq	.-90     	; 0x3522 <print_value.part.6+0x7e>
    357c:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1398
            output = ensure(output_buffer, 5);
            if (output == NULL)
            {
                return false;
            }
            strcpy((char*)output, "true");
    3580:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1820
    }
    *output_pointer++ = '}';
    *output_pointer = '\0';
    output_buffer->depth--;

    return true;
    3582:	90 e0       	ldi	r25, 0x00	; 0
    3584:	da c0       	rjmp	.+436    	; 0x373a <print_value.part.6+0x296>
    3586:	65 e0       	ldi	r22, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1393
            }
            strcpy((char*)output, "false");
            return true;

        case cJSON_True:
            output = ensure(output_buffer, 5);
    3588:	70 e0       	ldi	r23, 0x00	; 0
    358a:	c8 01       	movw	r24, r16
    358c:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3590:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1394
            if (output == NULL)
    3592:	39 f2       	breq	.-114    	; 0x3522 <print_value.part.6+0x7e>
    3594:	67 e2       	ldi	r22, 0x27	; 39
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1398
            {
                return false;
            }
            strcpy((char*)output, "true");
    3596:	77 e4       	ldi	r23, 0x47	; 71
    3598:	f1 cf       	rjmp	.-30     	; 0x357c <print_value.part.6+0xd8>
print_number():
    359a:	f7 01       	movw	r30, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:548

/* Render the number nicely from the given item into a string. */
static cJSON_bool print_number(const cJSON * const item, printbuffer * const output_buffer)
{
    unsigned char *output_pointer = NULL;
    double d = item->valuedouble;
    359c:	44 84       	ldd	r4, Z+12	; 0x0c
    359e:	55 84       	ldd	r5, Z+13	; 0x0d
    35a0:	66 84       	ldd	r6, Z+14	; 0x0e
    35a2:	77 84       	ldd	r7, Z+15	; 0x0f
    35a4:	9e 01       	movw	r18, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:551
    int length = 0;
    size_t i = 0;
    unsigned char number_buffer[26] = {0}; /* temporary buffer to print the number into */
    35a6:	2f 5f       	subi	r18, 0xFF	; 255
    35a8:	3f 4f       	sbci	r19, 0xFF	; 255
    35aa:	2f 8f       	std	Y+31, r18	; 0x1f
    35ac:	38 a3       	std	Y+32, r19	; 0x20
    35ae:	8a e1       	ldi	r24, 0x1A	; 26
    35b0:	d9 01       	movw	r26, r18
    35b2:	1d 92       	st	X+, r1
    35b4:	8a 95       	dec	r24
    35b6:	e9 f7       	brne	.-6      	; 0x35b2 <print_value.part.6+0x10e>
    35b8:	1b 8e       	std	Y+27, r1	; 0x1b
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:553
    unsigned char decimal_point = get_decimal_point();
    double test = 0.0;
    35ba:	1c 8e       	std	Y+28, r1	; 0x1c
    35bc:	1d 8e       	std	Y+29, r1	; 0x1d
    35be:	1e 8e       	std	Y+30, r1	; 0x1e
    35c0:	67 2b       	or	r22, r23
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:555

    if (output_buffer == NULL)
    35c2:	09 f4       	brne	.+2      	; 0x35c6 <print_value.part.6+0x122>
    35c4:	ae cf       	rjmp	.-164    	; 0x3522 <print_value.part.6+0x7e>
    35c6:	a3 01       	movw	r20, r6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:561
    {
        return false;
    }

    /* This checks for NaN and Infinity */
    if (isnan(d) || isinf(d))
    35c8:	92 01       	movw	r18, r4
    35ca:	c3 01       	movw	r24, r6
    35cc:	b2 01       	movw	r22, r4
    35ce:	0e 94 27 51 	call	0xa24e	; 0xa24e <__cmpsf2>
    35d2:	81 11       	cpse	r24, r1
    35d4:	0c c0       	rjmp	.+24     	; 0x35ee <print_value.part.6+0x14a>
    35d6:	a3 01       	movw	r20, r6
    35d8:	92 01       	movw	r18, r4
    35da:	c3 01       	movw	r24, r6
    35dc:	b2 01       	movw	r22, r4
    35de:	0e 94 dc 52 	call	0xa5b8	; 0xa5b8 <__subsf3>
    35e2:	9b 01       	movw	r18, r22
    35e4:	ac 01       	movw	r20, r24
    35e6:	0e 94 27 51 	call	0xa24e	; 0xa24e <__cmpsf2>
    35ea:	88 23       	and	r24, r24
    35ec:	79 f1       	breq	.+94     	; 0x364c <print_value.part.6+0x1a8>
    35ee:	6c e1       	ldi	r22, 0x1C	; 28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:563
    {
        length = sprintf((char*)number_buffer, "null");
    35f0:	77 e4       	ldi	r23, 0x47	; 71
    35f2:	ce 01       	movw	r24, r28
    35f4:	01 96       	adiw	r24, 0x01	; 1
    35f6:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
print_value.part.6():
    35fa:	94 e0       	ldi	r25, 0x04	; 4
    35fc:	29 2e       	mov	r2, r25
    35fe:	31 2c       	mov	r3, r1
print_number():
    3600:	fa e1       	ldi	r31, 0x1A	; 26
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:579
            length = sprintf((char*)number_buffer, "%1.17g", d);
        }
    }

    /* sprintf failed or buffer overrun occurred */
    if ((length < 0) || (length > (int)(sizeof(number_buffer) - 1)))
    3602:	2f 16       	cp	r2, r31
    3604:	31 04       	cpc	r3, r1
    3606:	08 f0       	brcs	.+2      	; 0x360a <print_value.part.6+0x166>
    3608:	8c cf       	rjmp	.-232    	; 0x3522 <print_value.part.6+0x7e>
    360a:	b1 01       	movw	r22, r2
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:585
    {
        return false;
    }

    /* reserve appropriate space in the output */
    output_pointer = ensure(output_buffer, (size_t)length + sizeof(""));
    360c:	6f 5f       	subi	r22, 0xFF	; 255
    360e:	7f 4f       	sbci	r23, 0xFF	; 255
    3610:	c8 01       	movw	r24, r16
    3612:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3616:	fc 01       	movw	r30, r24
    3618:	de 01       	movw	r26, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:586
    if (output_pointer == NULL)
    361a:	11 96       	adiw	r26, 0x01	; 1
    361c:	00 97       	sbiw	r24, 0x00	; 0
    361e:	09 f4       	brne	.+2      	; 0x3622 <print_value.part.6+0x17e>
    3620:	80 cf       	rjmp	.-256    	; 0x3522 <print_value.part.6+0x7e>
    3622:	9d 01       	movw	r18, r26
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:593
        return false;
    }

    /* copy the printed number to the output and replace locale
     * dependent decimal point with '.' */
    for (i = 0; i < ((size_t)length); i++)
    3624:	4f 8d       	ldd	r20, Y+31	; 0x1f
    3626:	58 a1       	ldd	r21, Y+32	; 0x20
    3628:	24 1b       	sub	r18, r20
    362a:	35 0b       	sbc	r19, r21
    362c:	22 15       	cp	r18, r2
    362e:	33 05       	cpc	r19, r3
    3630:	08 f4       	brcc	.+2      	; 0x3634 <print_value.part.6+0x190>
    3632:	7b c0       	rjmp	.+246    	; 0x372a <print_value.part.6+0x286>
    3634:	82 0d       	add	r24, r2
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:603
            continue;
        }

        output_pointer[i] = number_buffer[i];
    }
    output_pointer[i] = '\0';
    3636:	93 1d       	adc	r25, r3
    3638:	dc 01       	movw	r26, r24
    363a:	1c 92       	st	X, r1
    363c:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:605

    output_buffer->offset += (size_t)length;
    363e:	84 81       	ldd	r24, Z+4	; 0x04
    3640:	95 81       	ldd	r25, Z+5	; 0x05
    3642:	28 0e       	add	r2, r24
    3644:	39 1e       	adc	r3, r25
    3646:	24 82       	std	Z+4, r2	; 0x04
    3648:	35 82       	std	Z+5, r3	; 0x05
    364a:	9a cf       	rjmp	.-204    	; 0x3580 <print_value.part.6+0xdc>
    364c:	7f 92       	push	r7
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:568
        length = sprintf((char*)number_buffer, "null");
    }
    else
    {
        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
        length = sprintf((char*)number_buffer, "%1.15g", d);
    364e:	6f 92       	push	r6
    3650:	5f 92       	push	r5
    3652:	4f 92       	push	r4
    3654:	8c e2       	ldi	r24, 0x2C	; 44
    3656:	97 e4       	ldi	r25, 0x47	; 71
    3658:	9f 93       	push	r25
    365a:	8f 93       	push	r24
    365c:	e1 e0       	ldi	r30, 0x01	; 1
    365e:	f0 e0       	ldi	r31, 0x00	; 0
    3660:	ec 0f       	add	r30, r28
    3662:	fd 1f       	adc	r31, r29
    3664:	ff 93       	push	r31
    3666:	ef 93       	push	r30
    3668:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    366c:	1c 01       	movw	r2, r24
    366e:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:571

        /* Check whether the original double can be recovered */
        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d))
    3670:	4b 96       	adiw	r24, 0x1b	; 27
    3672:	9f 93       	push	r25
    3674:	8f 93       	push	r24
    3676:	83 e3       	ldi	r24, 0x33	; 51
    3678:	97 e4       	ldi	r25, 0x47	; 71
    367a:	9f 93       	push	r25
    367c:	8f 93       	push	r24
    367e:	21 e0       	ldi	r18, 0x01	; 1
    3680:	30 e0       	ldi	r19, 0x00	; 0
    3682:	2c 0f       	add	r18, r28
    3684:	3d 1f       	adc	r19, r29
    3686:	3f 93       	push	r19
    3688:	2f 93       	push	r18
    368a:	0e 94 e4 57 	call	0xafc8	; 0xafc8 <sscanf>
    368e:	cd bf       	out	0x3d, r28	; 61
    3690:	de bf       	out	0x3e, r29	; 62
    3692:	01 97       	sbiw	r24, 0x01	; 1
    3694:	b1 f5       	brne	.+108    	; 0x3702 <print_value.part.6+0x25e>
    3696:	8b 8c       	ldd	r8, Y+27	; 0x1b
    3698:	9c 8c       	ldd	r9, Y+28	; 0x1c
    369a:	ad 8c       	ldd	r10, Y+29	; 0x1d
    369c:	be 8c       	ldd	r11, Y+30	; 0x1e
compare_double():
    369e:	d5 01       	movw	r26, r10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:540
}

/* securely comparison of floating-point variables */
static cJSON_bool compare_double(double a, double b)
{
    double maxVal = fabs(a) > fabs(b) ? fabs(a) : fabs(b);
    36a0:	c4 01       	movw	r24, r8
    36a2:	bf 77       	andi	r27, 0x7F	; 127
    36a4:	89 a3       	std	Y+33, r24	; 0x21
    36a6:	9a a3       	std	Y+34, r25	; 0x22
    36a8:	ab a3       	std	Y+35, r26	; 0x23
    36aa:	bc a3       	std	Y+36, r27	; 0x24
    36ac:	73 01       	movw	r14, r6
    36ae:	62 01       	movw	r12, r4
    36b0:	e8 94       	clt
    36b2:	f7 f8       	bld	r15, 7
    36b4:	a7 01       	movw	r20, r14
    36b6:	96 01       	movw	r18, r12
    36b8:	bc 01       	movw	r22, r24
    36ba:	cd 01       	movw	r24, r26
    36bc:	0e 94 da 53 	call	0xa7b4	; 0xa7b4 <__gesf2>
    36c0:	18 16       	cp	r1, r24
    36c2:	24 f4       	brge	.+8      	; 0x36cc <print_value.part.6+0x228>
print_value.part.6():
    36c4:	c9 a0       	ldd	r12, Y+33	; 0x21
    36c6:	da a0       	ldd	r13, Y+34	; 0x22
    36c8:	eb a0       	ldd	r14, Y+35	; 0x23
    36ca:	fc a0       	ldd	r15, Y+36	; 0x24
compare_double():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:541
    return (fabs(a - b) <= maxVal * DBL_EPSILON);
    36cc:	a3 01       	movw	r20, r6
    36ce:	92 01       	movw	r18, r4
    36d0:	c5 01       	movw	r24, r10
    36d2:	b4 01       	movw	r22, r8
    36d4:	0e 94 dc 52 	call	0xa5b8	; 0xa5b8 <__subsf3>
    36d8:	4b 01       	movw	r8, r22
    36da:	5c 01       	movw	r10, r24
    36dc:	e8 94       	clt
    36de:	b7 f8       	bld	r11, 7
    36e0:	20 e0       	ldi	r18, 0x00	; 0
    36e2:	30 e0       	ldi	r19, 0x00	; 0
    36e4:	40 e0       	ldi	r20, 0x00	; 0
    36e6:	54 e3       	ldi	r21, 0x34	; 52
    36e8:	c7 01       	movw	r24, r14
    36ea:	b6 01       	movw	r22, r12
    36ec:	0e 94 8c 51 	call	0xa318	; 0xa318 <__mulsf3>
    36f0:	9b 01       	movw	r18, r22
    36f2:	ac 01       	movw	r20, r24
print_number():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:571
    {
        /* Try 15 decimal places of precision to avoid nonsignificant nonzero digits */
        length = sprintf((char*)number_buffer, "%1.15g", d);

        /* Check whether the original double can be recovered */
        if ((sscanf((char*)number_buffer, "%lg", &test) != 1) || !compare_double((double)test, d))
    36f4:	c5 01       	movw	r24, r10
    36f6:	b4 01       	movw	r22, r8
    36f8:	0e 94 27 51 	call	0xa24e	; 0xa24e <__cmpsf2>
    36fc:	18 16       	cp	r1, r24
    36fe:	0c f0       	brlt	.+2      	; 0x3702 <print_value.part.6+0x25e>
    3700:	7f cf       	rjmp	.-258    	; 0x3600 <print_value.part.6+0x15c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:574
        {
            /* If not, print with 17 decimal places of precision */
            length = sprintf((char*)number_buffer, "%1.17g", d);
    3702:	7f 92       	push	r7
    3704:	6f 92       	push	r6
    3706:	5f 92       	push	r5
    3708:	4f 92       	push	r4
    370a:	87 e3       	ldi	r24, 0x37	; 55
    370c:	97 e4       	ldi	r25, 0x47	; 71
    370e:	9f 93       	push	r25
    3710:	8f 93       	push	r24
    3712:	a1 e0       	ldi	r26, 0x01	; 1
    3714:	b0 e0       	ldi	r27, 0x00	; 0
    3716:	ac 0f       	add	r26, r28
    3718:	bd 1f       	adc	r27, r29
    371a:	bf 93       	push	r27
    371c:	af 93       	push	r26
    371e:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    3722:	1c 01       	movw	r2, r24
    3724:	cd bf       	out	0x3d, r28	; 61
    3726:	de bf       	out	0x3e, r29	; 62
    3728:	6b cf       	rjmp	.-298    	; 0x3600 <print_value.part.6+0x15c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:595

    /* copy the printed number to the output and replace locale
     * dependent decimal point with '.' */
    for (i = 0; i < ((size_t)length); i++)
    {
        if (number_buffer[i] == decimal_point)
    372a:	2d 91       	ld	r18, X+
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:597
        {
            output_pointer[i] = '.';
    372c:	20 83       	st	Z, r18
    372e:	31 96       	adiw	r30, 0x01	; 1
    3730:	78 cf       	rjmp	.-272    	; 0x3622 <print_value.part.6+0x17e>
print_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1022
}

/* Invoke print_string_ptr (which is useful) on an item. */
static cJSON_bool print_string(const cJSON * const item, printbuffer * const p)
{
    return print_string_ptr((unsigned char*)item->valuestring, p);
    3732:	f7 01       	movw	r30, r14
    3734:	80 85       	ldd	r24, Z+8	; 0x08
    3736:	91 85       	ldd	r25, Z+9	; 0x09
    3738:	d9 dd       	rcall	.-1102   	; 0x32ec <print_string_ptr>
print_value.part.6():
    373a:	a4 96       	adiw	r28, 0x24	; 36
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1434
            return print_object(item, output_buffer);

        default:
            return false;
    }
}
    373c:	cd bf       	out	0x3d, r28	; 61
    373e:	de bf       	out	0x3e, r29	; 62
    3740:	df 91       	pop	r29
    3742:	cf 91       	pop	r28
    3744:	1f 91       	pop	r17
    3746:	0f 91       	pop	r16
    3748:	ff 90       	pop	r15
    374a:	ef 90       	pop	r14
    374c:	df 90       	pop	r13
    374e:	cf 90       	pop	r12
    3750:	bf 90       	pop	r11
    3752:	af 90       	pop	r10
    3754:	9f 90       	pop	r9
    3756:	8f 90       	pop	r8
    3758:	7f 90       	pop	r7
    375a:	6f 90       	pop	r6
    375c:	5f 90       	pop	r5
    375e:	4f 90       	pop	r4
    3760:	3f 90       	pop	r3
    3762:	2f 90       	pop	r2
    3764:	08 95       	ret
print_array.isra.7():
    3766:	67 2b       	or	r22, r23
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1541
{
    unsigned char *output_pointer = NULL;
    size_t length = 0;
    cJSON *current_element = item->child;

    if (output_buffer == NULL)
    3768:	09 f4       	brne	.+2      	; 0x376c <print_value.part.6+0x2c8>
    376a:	db ce       	rjmp	.-586    	; 0x3522 <print_value.part.6+0x7e>
    376c:	14 96       	adiw	r26, 0x04	; 4
    376e:	ed 90       	ld	r14, X+
    3770:	fc 90       	ld	r15, X
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1548
        return false;
    }

    /* Compose the output array. */
    /* opening square bracket */
    output_pointer = ensure(output_buffer, 1);
    3772:	61 e0       	ldi	r22, 0x01	; 1
    3774:	70 e0       	ldi	r23, 0x00	; 0
    3776:	c8 01       	movw	r24, r16
    3778:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1549
    if (output_pointer == NULL)
    377c:	00 97       	sbiw	r24, 0x00	; 0
    377e:	09 f4       	brne	.+2      	; 0x3782 <print_value.part.6+0x2de>
    3780:	d0 ce       	rjmp	.-608    	; 0x3522 <print_value.part.6+0x7e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1554
    {
        return false;
    }

    *output_pointer = '[';
    3782:	2b e5       	ldi	r18, 0x5B	; 91
    3784:	fc 01       	movw	r30, r24
    3786:	20 83       	st	Z, r18
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1555
    output_buffer->offset++;
    3788:	d8 01       	movw	r26, r16
    378a:	14 96       	adiw	r26, 0x04	; 4
    378c:	8d 91       	ld	r24, X+
    378e:	9c 91       	ld	r25, X
    3790:	15 97       	sbiw	r26, 0x05	; 5
    3792:	01 96       	adiw	r24, 0x01	; 1
    3794:	14 96       	adiw	r26, 0x04	; 4
    3796:	8d 93       	st	X+, r24
    3798:	9c 93       	st	X, r25
    379a:	15 97       	sbiw	r26, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1556
    output_buffer->depth++;
    379c:	16 96       	adiw	r26, 0x06	; 6
    379e:	8d 91       	ld	r24, X+
    37a0:	9c 91       	ld	r25, X
    37a2:	17 97       	sbiw	r26, 0x07	; 7
    37a4:	01 96       	adiw	r24, 0x01	; 1
    37a6:	16 96       	adiw	r26, 0x06	; 6
    37a8:	8d 93       	st	X+, r24
    37aa:	9c 93       	st	X, r25
    37ac:	17 97       	sbiw	r26, 0x07	; 7
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1573
            output_pointer = ensure(output_buffer, length + 1);
            if (output_pointer == NULL)
            {
                return false;
            }
            *output_pointer++ = ',';
    37ae:	bc e2       	ldi	r27, 0x2C	; 44
    37b0:	bb 2e       	mov	r11, r27
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1576
            if(output_buffer->format)
            {
                *output_pointer++ = ' ';
    37b2:	80 e2       	ldi	r24, 0x20	; 32
    37b4:	a8 2e       	mov	r10, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1558

    *output_pointer = '[';
    output_buffer->offset++;
    output_buffer->depth++;

    while (current_element != NULL)
    37b6:	e1 14       	cp	r14, r1
    37b8:	f1 04       	cpc	r15, r1
    37ba:	b9 f4       	brne	.+46     	; 0x37ea <print_value.part.6+0x346>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1584
            output_buffer->offset += length;
        }
        current_element = current_element->next;
    }

    output_pointer = ensure(output_buffer, 2);
    37bc:	62 e0       	ldi	r22, 0x02	; 2
    37be:	70 e0       	ldi	r23, 0x00	; 0
    37c0:	c8 01       	movw	r24, r16
    37c2:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1589
    if (output_pointer == NULL)
    {
        return false;
    }
    *output_pointer++ = ']';
    37c6:	2d e5       	ldi	r18, 0x5D	; 93
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1585
        }
        current_element = current_element->next;
    }

    output_pointer = ensure(output_buffer, 2);
    if (output_pointer == NULL)
    37c8:	00 97       	sbiw	r24, 0x00	; 0
    37ca:	09 f4       	brne	.+2      	; 0x37ce <print_value.part.6+0x32a>
    37cc:	aa ce       	rjmp	.-684    	; 0x3522 <print_value.part.6+0x7e>
print_object.isra.8():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1816
        for (i = 0; i < (output_buffer->depth - 1); i++)
        {
            *output_pointer++ = '\t';
        }
    }
    *output_pointer++ = '}';
    37ce:	fc 01       	movw	r30, r24
    37d0:	20 83       	st	Z, r18
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1817
    *output_pointer = '\0';
    37d2:	11 82       	std	Z+1, r1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1818
    output_buffer->depth--;
    37d4:	d8 01       	movw	r26, r16
    37d6:	16 96       	adiw	r26, 0x06	; 6
    37d8:	8d 91       	ld	r24, X+
    37da:	9c 91       	ld	r25, X
    37dc:	17 97       	sbiw	r26, 0x07	; 7
    37de:	01 97       	sbiw	r24, 0x01	; 1
    37e0:	16 96       	adiw	r26, 0x06	; 6
    37e2:	8d 93       	st	X+, r24
    37e4:	9c 93       	st	X, r25
    37e6:	17 97       	sbiw	r26, 0x07	; 7
    37e8:	cb ce       	rjmp	.-618    	; 0x3580 <print_value.part.6+0xdc>
print_value():
    37ea:	b8 01       	movw	r22, r16
    37ec:	c7 01       	movw	r24, r14
    37ee:	5a de       	rcall	.-844    	; 0x34a4 <print_value.part.6>
print_array.isra.7():
    37f0:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1560
    output_buffer->offset++;
    output_buffer->depth++;

    while (current_element != NULL)
    {
        if (!print_value(current_element, output_buffer))
    37f2:	09 f4       	brne	.+2      	; 0x37f6 <print_value.part.6+0x352>
    37f4:	96 ce       	rjmp	.-724    	; 0x3522 <print_value.part.6+0x7e>
    37f6:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1564
        {
            return false;
        }
        update_offset(output_buffer);
    37f8:	0e 94 a3 09 	call	0x1346	; 0x1346 <update_offset>
    37fc:	f7 01       	movw	r30, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1565
        if (current_element->next)
    37fe:	80 81       	ld	r24, Z
    3800:	91 81       	ldd	r25, Z+1	; 0x01
    3802:	89 2b       	or	r24, r25
    3804:	59 f1       	breq	.+86     	; 0x385c <print_value.part.6+0x3b8>
    3806:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1567
        {
            length = (size_t) (output_buffer->format ? 2 : 1);
    3808:	1a 96       	adiw	r26, 0x0a	; 10
    380a:	8d 91       	ld	r24, X+
    380c:	9c 91       	ld	r25, X
print_value.part.6():
    380e:	a2 e0       	ldi	r26, 0x02	; 2
    3810:	ca 2e       	mov	r12, r26
    3812:	d1 2c       	mov	r13, r1
print_array.isra.7():
    3814:	89 2b       	or	r24, r25
    3816:	19 f4       	brne	.+6      	; 0x381e <print_value.part.6+0x37a>
print_value.part.6():
    3818:	cc 24       	eor	r12, r12
    381a:	c3 94       	inc	r12
    381c:	d1 2c       	mov	r13, r1
print_array.isra.7():
    381e:	b6 01       	movw	r22, r12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1568
            output_pointer = ensure(output_buffer, length + 1);
    3820:	6f 5f       	subi	r22, 0xFF	; 255
    3822:	7f 4f       	sbci	r23, 0xFF	; 255
    3824:	c8 01       	movw	r24, r16
    3826:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    382a:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1569
            if (output_pointer == NULL)
    382c:	09 f4       	brne	.+2      	; 0x3830 <print_value.part.6+0x38c>
    382e:	79 ce       	rjmp	.-782    	; 0x3522 <print_value.part.6+0x7e>
    3830:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1573
            {
                return false;
            }
            *output_pointer++ = ',';
    3832:	b0 82       	st	Z, r11
    3834:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1574
            if(output_buffer->format)
    3836:	1a 96       	adiw	r26, 0x0a	; 10
    3838:	2d 91       	ld	r18, X+
    383a:	3c 91       	ld	r19, X
    383c:	31 96       	adiw	r30, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1573
            output_pointer = ensure(output_buffer, length + 1);
            if (output_pointer == NULL)
            {
                return false;
            }
            *output_pointer++ = ',';
    383e:	23 2b       	or	r18, r19
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1574
            if(output_buffer->format)
    3840:	29 f0       	breq	.+10     	; 0x384c <print_value.part.6+0x3a8>
    3842:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1576
            {
                *output_pointer++ = ' ';
    3844:	32 96       	adiw	r30, 0x02	; 2
    3846:	dc 01       	movw	r26, r24
    3848:	11 96       	adiw	r26, 0x01	; 1
    384a:	ac 92       	st	X, r10
    384c:	10 82       	st	Z, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1578
            }
            *output_pointer = '\0';
    384e:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1579
            output_buffer->offset += length;
    3850:	84 81       	ldd	r24, Z+4	; 0x04
    3852:	95 81       	ldd	r25, Z+5	; 0x05
    3854:	8c 0d       	add	r24, r12
    3856:	9d 1d       	adc	r25, r13
    3858:	84 83       	std	Z+4, r24	; 0x04
    385a:	95 83       	std	Z+5, r25	; 0x05
    385c:	d7 01       	movw	r26, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1581
        }
        current_element = current_element->next;
    385e:	ed 90       	ld	r14, X+
    3860:	fc 90       	ld	r15, X
    3862:	a9 cf       	rjmp	.-174    	; 0x37b6 <print_value.part.6+0x312>
print_object.isra.8():
    3864:	61 15       	cp	r22, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1716
{
    unsigned char *output_pointer = NULL;
    size_t length = 0;
    cJSON *current_item = item->child;

    if (output_buffer == NULL)
    3866:	71 05       	cpc	r23, r1
    3868:	09 f4       	brne	.+2      	; 0x386c <print_value.part.6+0x3c8>
    386a:	5b ce       	rjmp	.-842    	; 0x3522 <print_value.part.6+0x7e>
    386c:	fb 01       	movw	r30, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1722
    {
        return false;
    }

    /* Compose the output: */
    length = (size_t) (output_buffer->format ? 2 : 1); /* fmt: {\n */
    386e:	82 85       	ldd	r24, Z+10	; 0x0a
    3870:	93 85       	ldd	r25, Z+11	; 0x0b
print_value.part.6():
    3872:	e2 e0       	ldi	r30, 0x02	; 2
    3874:	ce 2e       	mov	r12, r30
    3876:	d1 2c       	mov	r13, r1
print_object.isra.8():
    3878:	89 2b       	or	r24, r25
    387a:	19 f4       	brne	.+6      	; 0x3882 <print_value.part.6+0x3de>
print_value.part.6():
    387c:	cc 24       	eor	r12, r12
    387e:	c3 94       	inc	r12
    3880:	d1 2c       	mov	r13, r1
    3882:	d7 01       	movw	r26, r14
    3884:	14 96       	adiw	r26, 0x04	; 4
    3886:	ed 90       	ld	r14, X+
    3888:	fc 90       	ld	r15, X
print_object.isra.8():
    388a:	b6 01       	movw	r22, r12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1723
    output_pointer = ensure(output_buffer, length + 1);
    388c:	6f 5f       	subi	r22, 0xFF	; 255
    388e:	7f 4f       	sbci	r23, 0xFF	; 255
    3890:	c8 01       	movw	r24, r16
    3892:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3896:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1724
    if (output_pointer == NULL)
    3898:	09 f4       	brne	.+2      	; 0x389c <print_value.part.6+0x3f8>
    389a:	43 ce       	rjmp	.-890    	; 0x3522 <print_value.part.6+0x7e>
    389c:	2b e7       	ldi	r18, 0x7B	; 123
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1729
    {
        return false;
    }

    *output_pointer++ = '{';
    389e:	fc 01       	movw	r30, r24
    38a0:	20 83       	st	Z, r18
    38a2:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1730
    output_buffer->depth++;
    38a4:	16 96       	adiw	r26, 0x06	; 6
    38a6:	2d 91       	ld	r18, X+
    38a8:	3c 91       	ld	r19, X
    38aa:	17 97       	sbiw	r26, 0x07	; 7
    38ac:	2f 5f       	subi	r18, 0xFF	; 255
    38ae:	3f 4f       	sbci	r19, 0xFF	; 255
    38b0:	16 96       	adiw	r26, 0x06	; 6
    38b2:	2d 93       	st	X+, r18
    38b4:	3c 93       	st	X, r19
    38b6:	17 97       	sbiw	r26, 0x07	; 7
    38b8:	1a 96       	adiw	r26, 0x0a	; 10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1731
    if (output_buffer->format)
    38ba:	2d 91       	ld	r18, X+
    38bc:	3c 91       	ld	r19, X
    38be:	23 2b       	or	r18, r19
    38c0:	11 f0       	breq	.+4      	; 0x38c6 <print_value.part.6+0x422>
    38c2:	2a e0       	ldi	r18, 0x0A	; 10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1733
    {
        *output_pointer++ = '\n';
    38c4:	21 83       	std	Z+1, r18	; 0x01
    38c6:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1735
    }
    output_buffer->offset += length;
    38c8:	84 81       	ldd	r24, Z+4	; 0x04
    38ca:	95 81       	ldd	r25, Z+5	; 0x05
    38cc:	8c 0d       	add	r24, r12
    38ce:	9d 1d       	adc	r25, r13
    38d0:	84 83       	std	Z+4, r24	; 0x04
    38d2:	95 83       	std	Z+5, r25	; 0x05
    38d4:	39 e0       	ldi	r19, 0x09	; 9
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1749
            {
                return false;
            }
            for (i = 0; i < output_buffer->depth; i++)
            {
                *output_pointer++ = '\t';
    38d6:	b3 2e       	mov	r11, r19
    38d8:	4a e3       	ldi	r20, 0x3A	; 58
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1767
        output_pointer = ensure(output_buffer, length);
        if (output_pointer == NULL)
        {
            return false;
        }
        *output_pointer++ = ':';
    38da:	a4 2e       	mov	r10, r20
    38dc:	5c e2       	ldi	r21, 0x2C	; 44
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1790
        {
            return false;
        }
        if (current_item->next)
        {
            *output_pointer++ = ',';
    38de:	95 2e       	mov	r9, r21
    38e0:	6a e0       	ldi	r22, 0x0A	; 10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1795
        }

        if (output_buffer->format)
        {
            *output_pointer++ = '\n';
    38e2:	86 2e       	mov	r8, r22
    38e4:	f8 01       	movw	r30, r16
    38e6:	82 85       	ldd	r24, Z+10	; 0x0a
    38e8:	93 85       	ldd	r25, Z+11	; 0x0b
    38ea:	e1 14       	cp	r14, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1737
    {
        *output_pointer++ = '\n';
    }
    output_buffer->offset += length;

    while (current_item)
    38ec:	f1 04       	cpc	r15, r1
    38ee:	41 f5       	brne	.+80     	; 0x3940 <print_value.part.6+0x49c>
print_value.part.6():
    38f0:	62 e0       	ldi	r22, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1803
        output_buffer->offset += length;

        current_item = current_item->next;
    }

    output_pointer = ensure(output_buffer, output_buffer->format ? (output_buffer->depth + 1) : 2);
    38f2:	70 e0       	ldi	r23, 0x00	; 0
print_object.isra.8():
    38f4:	89 2b       	or	r24, r25
    38f6:	21 f0       	breq	.+8      	; 0x3900 <print_value.part.6+0x45c>
    38f8:	66 81       	ldd	r22, Z+6	; 0x06
    38fa:	77 81       	ldd	r23, Z+7	; 0x07
    38fc:	6f 5f       	subi	r22, 0xFF	; 255
    38fe:	7f 4f       	sbci	r23, 0xFF	; 255
    3900:	c8 01       	movw	r24, r16
    3902:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3906:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1804
    if (output_pointer == NULL)
    3908:	09 f4       	brne	.+2      	; 0x390c <print_value.part.6+0x468>
    390a:	0b ce       	rjmp	.-1002   	; 0x3522 <print_value.part.6+0x7e>
    390c:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1808
    {
        return false;
    }
    if (output_buffer->format)
    390e:	1a 96       	adiw	r26, 0x0a	; 10
    3910:	2d 91       	ld	r18, X+
    3912:	3c 91       	ld	r19, X
    3914:	23 2b       	or	r18, r19
    3916:	91 f0       	breq	.+36     	; 0x393c <print_value.part.6+0x498>
    3918:	bc 01       	movw	r22, r24
    391a:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1813
    {
        size_t i;
        for (i = 0; i < (output_buffer->depth - 1); i++)
        {
            *output_pointer++ = '\t';
    391c:	89 e0       	ldi	r24, 0x09	; 9
    391e:	f8 2e       	mov	r15, r24
    3920:	cf 01       	movw	r24, r30
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1811
        return false;
    }
    if (output_buffer->format)
    {
        size_t i;
        for (i = 0; i < (output_buffer->depth - 1); i++)
    3922:	d8 01       	movw	r26, r16
    3924:	16 96       	adiw	r26, 0x06	; 6
    3926:	2d 91       	ld	r18, X+
    3928:	3c 91       	ld	r19, X
    392a:	21 50       	subi	r18, 0x01	; 1
    392c:	31 09       	sbc	r19, r1
    392e:	af 01       	movw	r20, r30
    3930:	46 1b       	sub	r20, r22
    3932:	57 0b       	sbc	r21, r23
    3934:	42 17       	cp	r20, r18
    3936:	53 07       	cpc	r21, r19
    3938:	08 f4       	brcc	.+2      	; 0x393c <print_value.part.6+0x498>
    393a:	99 c0       	rjmp	.+306    	; 0x3a6e <print_value.part.6+0x5ca>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1816
        {
            *output_pointer++ = '\t';
        }
    }
    *output_pointer++ = '}';
    393c:	2d e7       	ldi	r18, 0x7D	; 125
    393e:	47 cf       	rjmp	.-370    	; 0x37ce <print_value.part.6+0x32a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1739
    }
    output_buffer->offset += length;

    while (current_item)
    {
        if (output_buffer->format)
    3940:	89 2b       	or	r24, r25
    3942:	09 f1       	breq	.+66     	; 0x3986 <print_value.part.6+0x4e2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1742
        {
            size_t i;
            output_pointer = ensure(output_buffer, output_buffer->depth);
    3944:	d8 01       	movw	r26, r16
    3946:	16 96       	adiw	r26, 0x06	; 6
    3948:	6d 91       	ld	r22, X+
    394a:	7c 91       	ld	r23, X
    394c:	c8 01       	movw	r24, r16
    394e:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1743
            if (output_pointer == NULL)
    3952:	00 97       	sbiw	r24, 0x00	; 0
    3954:	09 f4       	brne	.+2      	; 0x3958 <print_value.part.6+0x4b4>
    3956:	e5 cd       	rjmp	.-1078   	; 0x3522 <print_value.part.6+0x7e>
    3958:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1747
            {
                return false;
            }
            for (i = 0; i < output_buffer->depth; i++)
    395a:	d8 01       	movw	r26, r16
    395c:	16 96       	adiw	r26, 0x06	; 6
    395e:	2d 91       	ld	r18, X+
    3960:	3c 91       	ld	r19, X
    3962:	17 97       	sbiw	r26, 0x07	; 7
    3964:	af 01       	movw	r20, r30
    3966:	48 1b       	sub	r20, r24
    3968:	59 0b       	sbc	r21, r25
    396a:	42 17       	cp	r20, r18
    396c:	53 07       	cpc	r21, r19
    396e:	08 f4       	brcc	.+2      	; 0x3972 <print_value.part.6+0x4ce>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1751
            {
                *output_pointer++ = '\t';
            }
            output_buffer->offset += output_buffer->depth;
    3970:	7c c0       	rjmp	.+248    	; 0x3a6a <print_value.part.6+0x5c6>
    3972:	14 96       	adiw	r26, 0x04	; 4
    3974:	8d 91       	ld	r24, X+
    3976:	9c 91       	ld	r25, X
    3978:	15 97       	sbiw	r26, 0x05	; 5
    397a:	82 0f       	add	r24, r18
    397c:	93 1f       	adc	r25, r19
    397e:	14 96       	adiw	r26, 0x04	; 4
    3980:	8d 93       	st	X+, r24
    3982:	9c 93       	st	X, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1755
        }

        /* print key */
        if (!print_string_ptr((unsigned char*)current_item->string, output_buffer))
    3984:	15 97       	sbiw	r26, 0x05	; 5
    3986:	b8 01       	movw	r22, r16
    3988:	f7 01       	movw	r30, r14
    398a:	80 89       	ldd	r24, Z+16	; 0x10
    398c:	91 89       	ldd	r25, Z+17	; 0x11
    398e:	ae dc       	rcall	.-1700   	; 0x32ec <print_string_ptr>
    3990:	89 2b       	or	r24, r25
    3992:	09 f4       	brne	.+2      	; 0x3996 <print_value.part.6+0x4f2>
    3994:	c6 cd       	rjmp	.-1140   	; 0x3522 <print_value.part.6+0x7e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1759
        {
            return false;
        }
        update_offset(output_buffer);
    3996:	c8 01       	movw	r24, r16
    3998:	0e 94 a3 09 	call	0x1346	; 0x1346 <update_offset>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1761

        length = (size_t) (output_buffer->format ? 2 : 1);
    399c:	d8 01       	movw	r26, r16
    399e:	1a 96       	adiw	r26, 0x0a	; 10
    39a0:	8d 91       	ld	r24, X+
    39a2:	9c 91       	ld	r25, X
print_value.part.6():
    39a4:	22 e0       	ldi	r18, 0x02	; 2
    39a6:	c2 2e       	mov	r12, r18
    39a8:	d1 2c       	mov	r13, r1
print_object.isra.8():
    39aa:	89 2b       	or	r24, r25
    39ac:	19 f4       	brne	.+6      	; 0x39b4 <print_value.part.6+0x510>
print_value.part.6():
    39ae:	cc 24       	eor	r12, r12
    39b0:	c3 94       	inc	r12
    39b2:	d1 2c       	mov	r13, r1
print_object.isra.8():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1762
        output_pointer = ensure(output_buffer, length);
    39b4:	b6 01       	movw	r22, r12
    39b6:	c8 01       	movw	r24, r16
    39b8:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1763
        if (output_pointer == NULL)
    39bc:	00 97       	sbiw	r24, 0x00	; 0
    39be:	09 f4       	brne	.+2      	; 0x39c2 <print_value.part.6+0x51e>
    39c0:	b0 cd       	rjmp	.-1184   	; 0x3522 <print_value.part.6+0x7e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1767
        {
            return false;
        }
        *output_pointer++ = ':';
    39c2:	fc 01       	movw	r30, r24
    39c4:	a0 82       	st	Z, r10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1768
        if (output_buffer->format)
    39c6:	d8 01       	movw	r26, r16
    39c8:	1a 96       	adiw	r26, 0x0a	; 10
    39ca:	2d 91       	ld	r18, X+
    39cc:	3c 91       	ld	r19, X
    39ce:	23 2b       	or	r18, r19
    39d0:	09 f0       	breq	.+2      	; 0x39d4 <print_value.part.6+0x530>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1770
        {
            *output_pointer++ = '\t';
    39d2:	b1 82       	std	Z+1, r11	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1772
        }
        output_buffer->offset += length;
    39d4:	f8 01       	movw	r30, r16
    39d6:	64 81       	ldd	r22, Z+4	; 0x04
    39d8:	75 81       	ldd	r23, Z+5	; 0x05
    39da:	6c 0d       	add	r22, r12
    39dc:	7d 1d       	adc	r23, r13
    39de:	64 83       	std	Z+4, r22	; 0x04
    39e0:	75 83       	std	Z+5, r23	; 0x05
print_value():
    39e2:	b8 01       	movw	r22, r16
    39e4:	c7 01       	movw	r24, r14
    39e6:	5e dd       	rcall	.-1348   	; 0x34a4 <print_value.part.6>
print_object.isra.8():
    39e8:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1775

        /* print value */
        if (!print_value(current_item, output_buffer))
    39ea:	09 f4       	brne	.+2      	; 0x39ee <print_value.part.6+0x54a>
    39ec:	9a cd       	rjmp	.-1228   	; 0x3522 <print_value.part.6+0x7e>
    39ee:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1779
        {
            return false;
        }
        update_offset(output_buffer);
    39f0:	0e 94 a3 09 	call	0x1346	; 0x1346 <update_offset>
    39f4:	21 e0       	ldi	r18, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1782

        /* print comma if not last */
        length = ((size_t)(output_buffer->format ? 1 : 0) + (size_t)(current_item->next ? 1 : 0));
    39f6:	30 e0       	ldi	r19, 0x00	; 0
    39f8:	d8 01       	movw	r26, r16
    39fa:	1a 96       	adiw	r26, 0x0a	; 10
    39fc:	8d 91       	ld	r24, X+
    39fe:	9c 91       	ld	r25, X
    3a00:	89 2b       	or	r24, r25
    3a02:	11 f4       	brne	.+4      	; 0x3a08 <print_value.part.6+0x564>
    3a04:	30 e0       	ldi	r19, 0x00	; 0
    3a06:	20 e0       	ldi	r18, 0x00	; 0
    3a08:	81 e0       	ldi	r24, 0x01	; 1
    3a0a:	90 e0       	ldi	r25, 0x00	; 0
    3a0c:	f7 01       	movw	r30, r14
    3a0e:	40 81       	ld	r20, Z
    3a10:	51 81       	ldd	r21, Z+1	; 0x01
    3a12:	45 2b       	or	r20, r21
    3a14:	11 f4       	brne	.+4      	; 0x3a1a <print_value.part.6+0x576>
    3a16:	90 e0       	ldi	r25, 0x00	; 0
    3a18:	80 e0       	ldi	r24, 0x00	; 0
    3a1a:	69 01       	movw	r12, r18
    3a1c:	c8 0e       	add	r12, r24
    3a1e:	d9 1e       	adc	r13, r25
    3a20:	b6 01       	movw	r22, r12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1783
        output_pointer = ensure(output_buffer, length + 1);
    3a22:	6f 5f       	subi	r22, 0xFF	; 255
    3a24:	7f 4f       	sbci	r23, 0xFF	; 255
    3a26:	c8 01       	movw	r24, r16
    3a28:	0e 94 13 10 	call	0x2026	; 0x2026 <ensure>
    3a2c:	fc 01       	movw	r30, r24
    3a2e:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1784
        if (output_pointer == NULL)
    3a30:	09 f4       	brne	.+2      	; 0x3a34 <print_value.part.6+0x590>
    3a32:	77 cd       	rjmp	.-1298   	; 0x3522 <print_value.part.6+0x7e>
    3a34:	d7 01       	movw	r26, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1788
        {
            return false;
        }
        if (current_item->next)
    3a36:	8d 91       	ld	r24, X+
    3a38:	9c 91       	ld	r25, X
    3a3a:	89 2b       	or	r24, r25
    3a3c:	11 f0       	breq	.+4      	; 0x3a42 <print_value.part.6+0x59e>
    3a3e:	90 82       	st	Z, r9
print_value.part.6():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1790
        {
            *output_pointer++ = ',';
    3a40:	31 96       	adiw	r30, 0x01	; 1
print_object.isra.8():
    3a42:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1793
        }

        if (output_buffer->format)
    3a44:	1a 96       	adiw	r26, 0x0a	; 10
    3a46:	8d 91       	ld	r24, X+
    3a48:	9c 91       	ld	r25, X
    3a4a:	89 2b       	or	r24, r25
    3a4c:	11 f0       	breq	.+4      	; 0x3a52 <print_value.part.6+0x5ae>
    3a4e:	80 82       	st	Z, r8
print_value.part.6():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1795
        {
            *output_pointer++ = '\n';
    3a50:	31 96       	adiw	r30, 0x01	; 1
print_object.isra.8():
    3a52:	10 82       	st	Z, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1797
        }
        *output_pointer = '\0';
    3a54:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1798
        output_buffer->offset += length;
    3a56:	84 81       	ldd	r24, Z+4	; 0x04
    3a58:	95 81       	ldd	r25, Z+5	; 0x05
    3a5a:	c8 0e       	add	r12, r24
    3a5c:	d9 1e       	adc	r13, r25
    3a5e:	c4 82       	std	Z+4, r12	; 0x04
    3a60:	d5 82       	std	Z+5, r13	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1800

        current_item = current_item->next;
    3a62:	d7 01       	movw	r26, r14
    3a64:	ed 90       	ld	r14, X+
    3a66:	fc 90       	ld	r15, X
    3a68:	3d cf       	rjmp	.-390    	; 0x38e4 <print_value.part.6+0x440>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1749
            {
                return false;
            }
            for (i = 0; i < output_buffer->depth; i++)
            {
                *output_pointer++ = '\t';
    3a6a:	b1 92       	st	Z+, r11
    3a6c:	76 cf       	rjmp	.-276    	; 0x395a <print_value.part.6+0x4b6>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1813
    if (output_buffer->format)
    {
        size_t i;
        for (i = 0; i < (output_buffer->depth - 1); i++)
        {
            *output_pointer++ = '\t';
    3a6e:	f1 92       	st	Z+, r15
    3a70:	57 cf       	rjmp	.-338    	; 0x3920 <print_value.part.6+0x47c>

00003a72 <print.constprop.111>:
print():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1183
    return cJSON_ParseWithLengthOpts(value, buffer_length, 0, 0);
}

#define cjson_min(a, b) (((a) < (b)) ? (a) : (b))

static unsigned char *print(const cJSON * const item, cJSON_bool format, const internal_hooks * const hooks)
    3a72:	cf 92       	push	r12
    3a74:	df 92       	push	r13
    3a76:	ef 92       	push	r14
    3a78:	ff 92       	push	r15
    3a7a:	0f 93       	push	r16
    3a7c:	1f 93       	push	r17
    3a7e:	cf 93       	push	r28
    3a80:	df 93       	push	r29
    3a82:	cd b7       	in	r28, 0x3d	; 61
    3a84:	de b7       	in	r29, 0x3e	; 62
    3a86:	62 97       	sbiw	r28, 0x12	; 18
    3a88:	cd bf       	out	0x3d, r28	; 61
    3a8a:	de bf       	out	0x3e, r29	; 62
    3a8c:	7c 01       	movw	r14, r24
    3a8e:	6b 01       	movw	r12, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1189
{
    static const size_t default_buffer_size = 256;
    printbuffer buffer[1];
    unsigned char *printed = NULL;

    memset(buffer, 0, sizeof(buffer));
    3a90:	8e 01       	movw	r16, r28
    3a92:	0f 5f       	subi	r16, 0xFF	; 255
    3a94:	1f 4f       	sbci	r17, 0xFF	; 255
    3a96:	82 e1       	ldi	r24, 0x12	; 18
    3a98:	f8 01       	movw	r30, r16
    3a9a:	11 92       	st	Z+, r1
    3a9c:	8a 95       	dec	r24
    3a9e:	e9 f7       	brne	.-6      	; 0x3a9a <print.constprop.111+0x28>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1192

    /* create buffer */
    buffer->buffer = (unsigned char*) hooks->allocate(default_buffer_size);
    3aa0:	e0 91 02 42 	lds	r30, 0x4202	; 0x804202 <global_hooks>
    3aa4:	f0 91 03 42 	lds	r31, 0x4203	; 0x804203 <global_hooks+0x1>
    3aa8:	80 e0       	ldi	r24, 0x00	; 0
    3aaa:	91 e0       	ldi	r25, 0x01	; 1
    3aac:	09 95       	icall
    3aae:	89 83       	std	Y+1, r24	; 0x01
    3ab0:	9a 83       	std	Y+2, r25	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1193
    buffer->length = default_buffer_size;
    3ab2:	20 e0       	ldi	r18, 0x00	; 0
    3ab4:	31 e0       	ldi	r19, 0x01	; 1
    3ab6:	2b 83       	std	Y+3, r18	; 0x03
    3ab8:	3c 83       	std	Y+4, r19	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1194
    buffer->format = format;
    3aba:	cb 86       	std	Y+11, r12	; 0x0b
    3abc:	dc 86       	std	Y+12, r13	; 0x0c
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1195
    buffer->hooks = *hooks;
    3abe:	26 e0       	ldi	r18, 0x06	; 6
    3ac0:	e2 e0       	ldi	r30, 0x02	; 2
    3ac2:	f2 e4       	ldi	r31, 0x42	; 66
    3ac4:	de 01       	movw	r26, r28
    3ac6:	1d 96       	adiw	r26, 0x0d	; 13
    3ac8:	01 90       	ld	r0, Z+
    3aca:	0d 92       	st	X+, r0
    3acc:	2a 95       	dec	r18
    3ace:	e1 f7       	brne	.-8      	; 0x3ac8 <print.constprop.111+0x56>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1196
    if (buffer->buffer == NULL)
    3ad0:	89 2b       	or	r24, r25
    3ad2:	e1 f0       	breq	.+56     	; 0x3b0c <print.constprop.111+0x9a>
print_value():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1367
/* Render a value to text. */
static cJSON_bool print_value(const cJSON * const item, printbuffer * const output_buffer)
{
    unsigned char *output = NULL;

    if ((item == NULL) || (output_buffer == NULL))
    3ad4:	e1 14       	cp	r14, r1
    3ad6:	f1 04       	cpc	r15, r1
    3ad8:	c9 f0       	breq	.+50     	; 0x3b0c <print.constprop.111+0x9a>
    3ada:	b8 01       	movw	r22, r16
    3adc:	c7 01       	movw	r24, r14
    3ade:	e2 dc       	rcall	.-1596   	; 0x34a4 <print_value.part.6>
print():
    3ae0:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1202
    {
        goto fail;
    }

    /* print the value */
    if (!print_value(item, buffer))
    3ae2:	a1 f0       	breq	.+40     	; 0x3b0c <print.constprop.111+0x9a>
    3ae4:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1206
    {
        goto fail;
    }
    update_offset(buffer);
    3ae6:	0e 94 a3 09 	call	0x1346	; 0x1346 <update_offset>
    3aea:	e0 91 06 42 	lds	r30, 0x4206	; 0x804206 <global_hooks+0x4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1209

    /* check if reallocate is available */
    if (hooks->reallocate != NULL)
    3aee:	f0 91 07 42 	lds	r31, 0x4207	; 0x804207 <global_hooks+0x5>
    3af2:	8d 81       	ldd	r24, Y+5	; 0x05
    3af4:	9e 81       	ldd	r25, Y+6	; 0x06
    3af6:	30 97       	sbiw	r30, 0x00	; 0
    3af8:	b9 f0       	breq	.+46     	; 0x3b28 <print.constprop.111+0xb6>
    3afa:	bc 01       	movw	r22, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1211
    {
        printed = (unsigned char*) hooks->reallocate(buffer->buffer, buffer->offset + 1);
    3afc:	6f 5f       	subi	r22, 0xFF	; 255
    3afe:	7f 4f       	sbci	r23, 0xFF	; 255
    3b00:	89 81       	ldd	r24, Y+1	; 0x01
    3b02:	9a 81       	ldd	r25, Y+2	; 0x02
    3b04:	09 95       	icall
    3b06:	8c 01       	movw	r16, r24
    3b08:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1212
        if (printed == NULL) {
    3b0a:	91 f5       	brne	.+100    	; 0x3b70 <print.constprop.111+0xfe>
    3b0c:	09 81       	ldd	r16, Y+1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1234
    }

    return printed;

fail:
    if (buffer->buffer != NULL)
    3b0e:	1a 81       	ldd	r17, Y+2	; 0x02
    3b10:	01 15       	cp	r16, r1
    3b12:	11 05       	cpc	r17, r1
    3b14:	69 f1       	breq	.+90     	; 0x3b70 <print.constprop.111+0xfe>
    3b16:	e0 91 04 42 	lds	r30, 0x4204	; 0x804204 <global_hooks+0x2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1236
    {
        hooks->deallocate(buffer->buffer);
    3b1a:	f0 91 05 42 	lds	r31, 0x4205	; 0x804205 <global_hooks+0x3>
    3b1e:	c8 01       	movw	r24, r16
    3b20:	09 95       	icall
    3b22:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1244
    if (printed != NULL)
    {
        hooks->deallocate(printed);
    }

    return NULL;
    3b24:	00 e0       	ldi	r16, 0x00	; 0
    3b26:	24 c0       	rjmp	.+72     	; 0x3b70 <print.constprop.111+0xfe>
    3b28:	e0 91 02 42 	lds	r30, 0x4202	; 0x804202 <global_hooks>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1219
        }
        buffer->buffer = NULL;
    }
    else /* otherwise copy the JSON over to a new buffer */
    {
        printed = (unsigned char*) hooks->allocate(buffer->offset + 1);
    3b2c:	f0 91 03 42 	lds	r31, 0x4203	; 0x804203 <global_hooks+0x1>
    3b30:	01 96       	adiw	r24, 0x01	; 1
    3b32:	09 95       	icall
    3b34:	8c 01       	movw	r16, r24
    3b36:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1220
        if (printed == NULL)
    3b38:	49 f3       	breq	.-46     	; 0x3b0c <print.constprop.111+0x9a>
    3b3a:	4d 81       	ldd	r20, Y+5	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1224
        {
            goto fail;
        }
        memcpy(printed, buffer->buffer, cjson_min(buffer->length, buffer->offset + 1));
    3b3c:	5e 81       	ldd	r21, Y+6	; 0x06
    3b3e:	8b 81       	ldd	r24, Y+3	; 0x03
    3b40:	9c 81       	ldd	r25, Y+4	; 0x04
    3b42:	4f 5f       	subi	r20, 0xFF	; 255
    3b44:	5f 4f       	sbci	r21, 0xFF	; 255
    3b46:	84 17       	cp	r24, r20
    3b48:	95 07       	cpc	r25, r21
    3b4a:	08 f4       	brcc	.+2      	; 0x3b4e <print.constprop.111+0xdc>
    3b4c:	ac 01       	movw	r20, r24
    3b4e:	69 81       	ldd	r22, Y+1	; 0x01
    3b50:	7a 81       	ldd	r23, Y+2	; 0x02
    3b52:	c8 01       	movw	r24, r16
    3b54:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
    3b58:	ed 81       	ldd	r30, Y+5	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1225
        printed[buffer->offset] = '\0'; /* just to be sure */
    3b5a:	fe 81       	ldd	r31, Y+6	; 0x06
    3b5c:	e0 0f       	add	r30, r16
    3b5e:	f1 1f       	adc	r31, r17
    3b60:	10 82       	st	Z, r1
    3b62:	e0 91 04 42 	lds	r30, 0x4204	; 0x804204 <global_hooks+0x2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1228

        /* free the buffer */
        hooks->deallocate(buffer->buffer);
    3b66:	f0 91 05 42 	lds	r31, 0x4205	; 0x804205 <global_hooks+0x3>
    3b6a:	89 81       	ldd	r24, Y+1	; 0x01
    3b6c:	9a 81       	ldd	r25, Y+2	; 0x02
    3b6e:	09 95       	icall
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1245
    {
        hooks->deallocate(printed);
    }

    return NULL;
}
    3b70:	c8 01       	movw	r24, r16
    3b72:	62 96       	adiw	r28, 0x12	; 18
    3b74:	cd bf       	out	0x3d, r28	; 61
    3b76:	de bf       	out	0x3e, r29	; 62
    3b78:	df 91       	pop	r29
    3b7a:	cf 91       	pop	r28
    3b7c:	1f 91       	pop	r17
    3b7e:	0f 91       	pop	r16
    3b80:	ff 90       	pop	r15
    3b82:	ef 90       	pop	r14
    3b84:	df 90       	pop	r13
    3b86:	cf 90       	pop	r12
    3b88:	08 95       	ret

00003b8a <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]>:
subscribe():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:669
                   strlen(message),
                   quality_of_service,
                   timeout_ms);
}

bool MqttClientClass::subscribe(const char* topic,
    3b8a:	cf 92       	push	r12
    3b8c:	df 92       	push	r13
    3b8e:	ef 92       	push	r14
    3b90:	ff 92       	push	r15
    3b92:	0f 93       	push	r16
    3b94:	1f 93       	push	r17
    3b96:	cf 93       	push	r28
    3b98:	df 93       	push	r29
    3b9a:	cd b7       	in	r28, 0x3d	; 61
    3b9c:	de b7       	in	r29, 0x3e	; 62
    3b9e:	c4 54       	subi	r28, 0x44	; 68
    3ba0:	d1 40       	sbci	r29, 0x01	; 1
    3ba2:	cd bf       	out	0x3d, r28	; 61
    3ba4:	de bf       	out	0x3e, r29	; 62
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:570
    if (disconnected != NULL) {
        disconnected_callback = disconnected;
    }
}

bool MqttClientClass::isConnected(void) { return connected_to_broker; }
    3ba6:	10 91 90 66 	lds	r17, 0x6690	; 0x806690 <connected_to_broker>
subscribe():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:672
}

bool MqttClientClass::subscribe(const char* topic,
                                const MqttQoS quality_of_service) {

    if (!isConnected()) {
    3baa:	11 11       	cpse	r17, r1
    3bac:	05 c0       	rjmp	.+10     	; 0x3bb8 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0x2e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:673
        Log.error(
    3bae:	8e e3       	ldi	r24, 0x3E	; 62
    3bb0:	97 e4       	ldi	r25, 0x47	; 71
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:706
            MQTT_PUB_SUB_URC_STATUS_CODE_INDEX,
            status_code_buffer,
            sizeof(status_code_buffer),
            (char)NULL)) {

        Log.error("Failed to retrieve status code from subscribe notification");
    3bb2:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    3bb6:	55 c0       	rjmp	.+170    	; 0x3c62 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0xd8>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:678
        Log.error(
            "Attempted MQTT Subscribe without being connected to a broker");
        return false;
    }

    char command[MQTT_SUBSCRIBE_LENGTH] = "";
    3bb8:	8e 01       	movw	r16, r28
    3bba:	0b 55       	subi	r16, 0x5B	; 91
    3bbc:	1f 4f       	sbci	r17, 0xFF	; 255
    3bbe:	f8 01       	movw	r30, r16
    3bc0:	11 92       	st	Z+, r1
    3bc2:	11 92       	st	Z+, r1
    3bc4:	2b e9       	ldi	r18, 0x9B	; 155
    3bc6:	df 01       	movw	r26, r30
    3bc8:	1d 92       	st	X+, r1
    3bca:	2a 95       	dec	r18
    3bcc:	e9 f7       	brne	.-6      	; 0x3bc8 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0x3e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:679
    sprintf(command, MQTT_SUSBCRIBE, topic, quality_of_service);
    3bce:	1f 92       	push	r1
    3bd0:	1f 92       	push	r1
    3bd2:	9f 93       	push	r25
    3bd4:	8f 93       	push	r24
    3bd6:	8b e7       	ldi	r24, 0x7B	; 123
    3bd8:	97 e4       	ldi	r25, 0x47	; 71
    3bda:	9f 93       	push	r25
    3bdc:	8f 93       	push	r24
    3bde:	1f 93       	push	r17
    3be0:	0f 93       	push	r16
    3be2:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:681

    if (SequansController.writeCommand(command) != ResponseResult::OK) {
    3be6:	50 e0       	ldi	r21, 0x00	; 0
    3be8:	40 e0       	ldi	r20, 0x00	; 0
    3bea:	70 e0       	ldi	r23, 0x00	; 0
    3bec:	60 e0       	ldi	r22, 0x00	; 0
    3bee:	c8 01       	movw	r24, r16
    3bf0:	1e da       	rcall	.-3012   	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    3bf2:	cd bf       	out	0x3d, r28	; 61
    3bf4:	de bf       	out	0x3e, r29	; 62
    3bf6:	01 97       	sbiw	r24, 0x01	; 1
    3bf8:	31 f0       	breq	.+12     	; 0x3c06 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0x7c>
    3bfa:	8a e9       	ldi	r24, 0x9A	; 154
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:682
        Log.error("Failed to send subscribe command");
    3bfc:	97 e4       	ldi	r25, 0x47	; 71
    3bfe:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    3c02:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:721
    }

    if (subscribe_status_code != 0) {
        Log.errorf("Error happened while subscribing: %s\r\n",
                   status_code_table[subscribe_status_code]);
        return false;
    3c04:	2e c0       	rjmp	.+92     	; 0x3c62 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0xd8>
    3c06:	19 82       	std	Y+1, r1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:686
    if (SequansController.writeCommand(command) != ResponseResult::OK) {
        Log.error("Failed to send subscribe command");
        return false;
    }

    char urc[MQTT_SUBSCRIBE_URC_LENGTH] = "";
    3c08:	1a 82       	std	Y+2, r1	; 0x02
    3c0a:	fe 01       	movw	r30, r28
    3c0c:	33 96       	adiw	r30, 0x03	; 3
    3c0e:	82 ea       	ldi	r24, 0xA2	; 162
    3c10:	df 01       	movw	r26, r30
    3c12:	1d 92       	st	X+, r1
    3c14:	8a 95       	dec	r24
    3c16:	e9 f7       	brne	.-6      	; 0x3c12 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0x88>
    3c18:	ce 5b       	subi	r28, 0xBE	; 190
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:690

    // At most we can have two character ("-1"). We add an extra for null
    // termination
    char status_code_buffer[3] = "";
    3c1a:	de 4f       	sbci	r29, 0xFE	; 254
    3c1c:	18 82       	st	Y, r1
    3c1e:	19 82       	std	Y+1, r1	; 0x01
    3c20:	c2 54       	subi	r28, 0x42	; 66
    3c22:	d1 40       	sbci	r29, 0x01	; 1
    3c24:	cc 5b       	subi	r28, 0xBC	; 188
    3c26:	de 4f       	sbci	r29, 0xFE	; 254
    3c28:	18 82       	st	Y, r1
    3c2a:	c4 54       	subi	r28, 0x44	; 68
    3c2c:	d1 40       	sbci	r29, 0x01	; 1
    3c2e:	80 e2       	ldi	r24, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:692

    if (!SequansController.waitForURC(MQTT_ON_SUBSCRIBE_URC,
    3c30:	c8 2e       	mov	r12, r24
    3c32:	9e e4       	ldi	r25, 0x4E	; 78
    3c34:	d9 2e       	mov	r13, r25
    3c36:	e1 2c       	mov	r14, r1
    3c38:	f1 2c       	mov	r15, r1
    3c3a:	00 e0       	ldi	r16, 0x00	; 0
    3c3c:	10 e0       	ldi	r17, 0x00	; 0
    3c3e:	20 e0       	ldi	r18, 0x00	; 0
    3c40:	30 e0       	ldi	r19, 0x00	; 0
    3c42:	44 ea       	ldi	r20, 0xA4	; 164
    3c44:	50 e0       	ldi	r21, 0x00	; 0
    3c46:	be 01       	movw	r22, r28
    3c48:	6f 5f       	subi	r22, 0xFF	; 255
    3c4a:	7f 4f       	sbci	r23, 0xFF	; 255
    3c4c:	8b eb       	ldi	r24, 0xBB	; 187
    3c4e:	97 e4       	ldi	r25, 0x47	; 71
    3c50:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]>
    3c54:	18 2f       	mov	r17, r24
    3c56:	81 11       	cpse	r24, r1
    3c58:	12 c0       	rjmp	.+36     	; 0x3c7e <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0xf4>
    3c5a:	8f ec       	ldi	r24, 0xCF	; 207
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:695
                                      urc,
                                      sizeof(urc))) {
        Log.warn("Timed out waiting for subscribe confirmation\r\n");
    3c5c:	97 e4       	ldi	r25, 0x47	; 71
    3c5e:	0e 94 9c 0a 	call	0x1538	; 0x1538 <LogClass::warn(char const*) [clone .constprop.124]>
    3c62:	81 2f       	mov	r24, r17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:725
                   status_code_table[subscribe_status_code]);
        return false;
    }

    return true;
}
    3c64:	cc 5b       	subi	r28, 0xBC	; 188
    3c66:	de 4f       	sbci	r29, 0xFE	; 254
    3c68:	cd bf       	out	0x3d, r28	; 61
    3c6a:	de bf       	out	0x3e, r29	; 62
    3c6c:	df 91       	pop	r29
    3c6e:	cf 91       	pop	r28
    3c70:	1f 91       	pop	r17
    3c72:	0f 91       	pop	r16
    3c74:	ff 90       	pop	r15
    3c76:	ef 90       	pop	r14
    3c78:	df 90       	pop	r13
    3c7a:	cf 90       	pop	r12
    3c7c:	08 95       	ret
    3c7e:	00 e0       	ldi	r16, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:699
                                      sizeof(urc))) {
        Log.warn("Timed out waiting for subscribe confirmation\r\n");
        return false;
    }

    if (!SequansController.extractValueFromCommandResponse(
    3c80:	23 e0       	ldi	r18, 0x03	; 3
    3c82:	30 e0       	ldi	r19, 0x00	; 0
    3c84:	ae 01       	movw	r20, r28
    3c86:	4e 5b       	subi	r20, 0xBE	; 190
    3c88:	5e 4f       	sbci	r21, 0xFE	; 254
    3c8a:	62 e0       	ldi	r22, 0x02	; 2
    3c8c:	ce 01       	movw	r24, r28
    3c8e:	01 96       	adiw	r24, 0x01	; 1
    3c90:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    3c94:	18 2f       	mov	r17, r24
    3c96:	81 11       	cpse	r24, r1
    3c98:	03 c0       	rjmp	.+6      	; 0x3ca0 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0x116>
    3c9a:	8e ef       	ldi	r24, 0xFE	; 254
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:706
            MQTT_PUB_SUB_URC_STATUS_CODE_INDEX,
            status_code_buffer,
            sizeof(status_code_buffer),
            (char)NULL)) {

        Log.error("Failed to retrieve status code from subscribe notification");
    3c9c:	97 e4       	ldi	r25, 0x47	; 71
    3c9e:	89 cf       	rjmp	.-238    	; 0x3bb2 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0x28>
    3ca0:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:710
        return false;
    }

    int8_t subscribe_status_code = atoi(status_code_buffer);
    3ca2:	8e 5b       	subi	r24, 0xBE	; 190
    3ca4:	9e 4f       	sbci	r25, 0xFE	; 254
    3ca6:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
    3caa:	8f 3f       	cpi	r24, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:714

    // One of the status codes is -1, so in order to not overflow the status
    // code table, we swap the place with the last one
    if (subscribe_status_code == STATUS_CODE_PENDING) {
    3cac:	d9 f0       	breq	.+54     	; 0x3ce4 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0x15a>
    3cae:	88 23       	and	r24, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:718
        subscribe_status_code = NUM_STATUS_CODES - 1;
    }

    if (subscribe_status_code != 0) {
    3cb0:	c1 f2       	breq	.-80     	; 0x3c62 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0xd8>
    3cb2:	b8 e1       	ldi	r27, 0x18	; 24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:719
        Log.errorf("Error happened while subscribing: %s\r\n",
    3cb4:	8b 02       	muls	r24, r27
    3cb6:	c0 01       	movw	r24, r0
    3cb8:	11 24       	eor	r1, r1
    3cba:	87 5d       	subi	r24, 0xD7	; 215
    3cbc:	9f 4b       	sbci	r25, 0xBF	; 191
    3cbe:	9f 93       	push	r25
    3cc0:	8f 93       	push	r24
    3cc2:	89 e3       	ldi	r24, 0x39	; 57
    3cc4:	98 e4       	ldi	r25, 0x48	; 72
    3cc6:	9f 93       	push	r25
    3cc8:	8f 93       	push	r24
    3cca:	89 e6       	ldi	r24, 0x69	; 105
    3ccc:	90 e7       	ldi	r25, 0x70	; 112
    3cce:	9f 93       	push	r25
    3cd0:	8f 93       	push	r24
    3cd2:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    3cd6:	0f 90       	pop	r0
    3cd8:	0f 90       	pop	r0
    3cda:	0f 90       	pop	r0
    3cdc:	0f 90       	pop	r0
    3cde:	0f 90       	pop	r0
    3ce0:	0f 90       	pop	r0
    3ce2:	8f cf       	rjmp	.-226    	; 0x3c02 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0x78>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:715
    int8_t subscribe_status_code = atoi(status_code_buffer);

    // One of the status codes is -1, so in order to not overflow the status
    // code table, we swap the place with the last one
    if (subscribe_status_code == STATUS_CODE_PENDING) {
        subscribe_status_code = NUM_STATUS_CODES - 1;
    3ce4:	81 e1       	ldi	r24, 0x11	; 17
    3ce6:	e5 cf       	rjmp	.-54     	; 0x3cb2 <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]+0x128>

00003ce8 <cJSON_GetObjectItemCaseSensitive>:
cJSON_GetObjectItemCaseSensitive():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1914
{
    return get_object_item(object, string, false);
}

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
{
    3ce8:	0f 93       	push	r16
    3cea:	1f 93       	push	r17
    3cec:	cf 93       	push	r28
    3cee:	df 93       	push	r29
get_object_item():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1880

static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    3cf0:	00 97       	sbiw	r24, 0x00	; 0
    3cf2:	d1 f0       	breq	.+52     	; 0x3d28 <cJSON_GetObjectItemCaseSensitive+0x40>
    3cf4:	8b 01       	movw	r16, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1885
    {
        return NULL;
    }

    current_element = object->child;
    3cf6:	fc 01       	movw	r30, r24
    3cf8:	c4 81       	ldd	r28, Z+4	; 0x04
    3cfa:	d5 81       	ldd	r29, Z+5	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1888
    if (case_sensitive)
    {
        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
    3cfc:	20 97       	sbiw	r28, 0x00	; 0
    3cfe:	51 f0       	breq	.+20     	; 0x3d14 <cJSON_GetObjectItemCaseSensitive+0x2c>
    3d00:	68 89       	ldd	r22, Y+16	; 0x10
    3d02:	79 89       	ldd	r23, Y+17	; 0x11
    3d04:	61 15       	cp	r22, r1
    3d06:	71 05       	cpc	r23, r1
    3d08:	79 f0       	breq	.+30     	; 0x3d28 <cJSON_GetObjectItemCaseSensitive+0x40>
    3d0a:	c8 01       	movw	r24, r16
    3d0c:	0e 94 f4 56 	call	0xade8	; 0xade8 <strcmp>
    3d10:	89 2b       	or	r24, r25
    3d12:	31 f4       	brne	.+12     	; 0x3d20 <cJSON_GetObjectItemCaseSensitive+0x38>
cJSON_GetObjectItemCaseSensitive():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1916
}

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItemCaseSensitive(const cJSON * const object, const char * const string)
{
    return get_object_item(object, string, true);
}
    3d14:	ce 01       	movw	r24, r28
    3d16:	df 91       	pop	r29
    3d18:	cf 91       	pop	r28
    3d1a:	1f 91       	pop	r17
    3d1c:	0f 91       	pop	r16
    3d1e:	08 95       	ret
get_object_item():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1890
    current_element = object->child;
    if (case_sensitive)
    {
        while ((current_element != NULL) && (current_element->string != NULL) && (strcmp(name, current_element->string) != 0))
        {
            current_element = current_element->next;
    3d20:	09 90       	ld	r0, Y+
    3d22:	d8 81       	ld	r29, Y
    3d24:	c0 2d       	mov	r28, r0
    3d26:	ea cf       	rjmp	.-44     	; 0x3cfc <cJSON_GetObjectItemCaseSensitive+0x14>
cJSON_GetObjectItemCaseSensitive():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1882
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    3d28:	d0 e0       	ldi	r29, 0x00	; 0
    3d2a:	c0 e0       	ldi	r28, 0x00	; 0
    3d2c:	f3 cf       	rjmp	.-26     	; 0x3d14 <cJSON_GetObjectItemCaseSensitive+0x2c>

00003d2e <iotcl_create_ack_string_and_destroy_event>:
iotcl_create_ack_string_and_destroy_event():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:278

char *iotcl_create_ack_string_and_destroy_event(
        IotclEventData data,
        bool success,
        const char *message
) {
    3d2e:	7f 92       	push	r7
    3d30:	8f 92       	push	r8
    3d32:	9f 92       	push	r9
    3d34:	af 92       	push	r10
    3d36:	bf 92       	push	r11
    3d38:	cf 92       	push	r12
    3d3a:	df 92       	push	r13
    3d3c:	ef 92       	push	r14
    3d3e:	ff 92       	push	r15
    3d40:	0f 93       	push	r16
    3d42:	1f 93       	push	r17
    3d44:	cf 93       	push	r28
    3d46:	df 93       	push	r29
    3d48:	7c 01       	movw	r14, r24
    3d4a:	76 2e       	mov	r7, r22
    3d4c:	5a 01       	movw	r10, r20
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:279
    if (!data) return NULL;
    3d4e:	10 e0       	ldi	r17, 0x00	; 0
    3d50:	00 e0       	ldi	r16, 0x00	; 0
    3d52:	00 97       	sbiw	r24, 0x00	; 0
    3d54:	d1 f0       	breq	.+52     	; 0x3d8a <iotcl_create_ack_string_and_destroy_event+0x5c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:281
    // already checked that ack ID is valid in the messages
    char *ack_id = cJSON_GetObjectItemCaseSensitive(data->data, "ackId")->valuestring;
    3d56:	60 e6       	ldi	r22, 0x60	; 96
    3d58:	78 e4       	ldi	r23, 0x48	; 72
    3d5a:	fc 01       	movw	r30, r24
    3d5c:	80 81       	ld	r24, Z
    3d5e:	91 81       	ldd	r25, Z+1	; 0x01
    3d60:	c3 df       	rcall	.-122    	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
    3d62:	fc 01       	movw	r30, r24
    3d64:	80 84       	ldd	r8, Z+8	; 0x08
    3d66:	91 84       	ldd	r9, Z+9	; 0x09
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:282
    char *ret = create_ack(success, message, data->type, ack_id);
    3d68:	f7 01       	movw	r30, r14
    3d6a:	c4 80       	ldd	r12, Z+4	; 0x04
    3d6c:	d5 80       	ldd	r13, Z+5	; 0x05
iotcl_get_config():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:44
    return true;
}


IotclConfig *iotcl_get_config(void) {
    if (!config_is_valid) {
    3d6e:	80 91 3d 64 	lds	r24, 0x643D	; 0x80643d <config_is_valid>
    3d72:	81 11       	cpse	r24, r1
    3d74:	19 c0       	rjmp	.+50     	; 0x3da8 <iotcl_create_ack_string_and_destroy_event+0x7a>
iotcl_create_ack_string_and_destroy_event():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:224
    char *result = NULL;

    IotclConfig *config = iotcl_get_config();

    if (!config) {
        return NULL;
    3d76:	10 e0       	ldi	r17, 0x00	; 0
    3d78:	00 e0       	ldi	r16, 0x00	; 0
iotcl_destroy_event():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:297
    char *ret = create_ack(success, message, DEVICE_OTA, ota_ack_id);
    return ret;
}

void iotcl_destroy_event(IotclEventData data) {
    cJSON_Delete(data->root);
    3d7a:	f7 01       	movw	r30, r14
    3d7c:	82 81       	ldd	r24, Z+2	; 0x02
    3d7e:	93 81       	ldd	r25, Z+3	; 0x03
    3d80:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:298
    free(data);
    3d84:	c7 01       	movw	r24, r14
    3d86:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
iotcl_create_ack_string_and_destroy_event():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:285
    // already checked that ack ID is valid in the messages
    char *ack_id = cJSON_GetObjectItemCaseSensitive(data->data, "ackId")->valuestring;
    char *ret = create_ack(success, message, data->type, ack_id);
    iotcl_destroy_event(data);
    return ret;
}
    3d8a:	c8 01       	movw	r24, r16
    3d8c:	df 91       	pop	r29
    3d8e:	cf 91       	pop	r28
    3d90:	1f 91       	pop	r17
    3d92:	0f 91       	pop	r16
    3d94:	ff 90       	pop	r15
    3d96:	ef 90       	pop	r14
    3d98:	df 90       	pop	r13
    3d9a:	cf 90       	pop	r12
    3d9c:	bf 90       	pop	r11
    3d9e:	af 90       	pop	r10
    3da0:	9f 90       	pop	r9
    3da2:	8f 90       	pop	r8
    3da4:	7f 90       	pop	r7
    3da6:	08 95       	ret
create_ack():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:227

    if (!config) {
        return NULL;
    }

    cJSON *ack_json = cJSON_CreateObject();
    3da8:	0e 94 de 10 	call	0x21bc	; 0x21bc <cJSON_CreateObject>
    3dac:	ec 01       	movw	r28, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:229

    if (ack_json == NULL) {
    3dae:	89 2b       	or	r24, r25
    3db0:	11 f3       	breq	.-60     	; 0x3d76 <iotcl_create_ack_string_and_destroy_event+0x48>
iotcl_create_ack_string_and_destroy_event():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:234
        return NULL;
    }

    // message type 5 in response is the command response. Type 11 is OTA response.
    if (!cJSON_AddNumberToObject(ack_json, "mt", message_type == DEVICE_COMMAND ? 5 : 11)) goto cleanup;
    3db2:	20 e0       	ldi	r18, 0x00	; 0
    3db4:	30 e0       	ldi	r19, 0x00	; 0
    3db6:	40 e3       	ldi	r20, 0x30	; 48
    3db8:	51 e4       	ldi	r21, 0x41	; 65
create_ack():
    3dba:	f1 e0       	ldi	r31, 0x01	; 1
    3dbc:	cf 16       	cp	r12, r31
    3dbe:	d1 04       	cpc	r13, r1
    3dc0:	21 f4       	brne	.+8      	; 0x3dca <iotcl_create_ack_string_and_destroy_event+0x9c>
iotcl_create_ack_string_and_destroy_event():
    3dc2:	20 e0       	ldi	r18, 0x00	; 0
    3dc4:	30 e0       	ldi	r19, 0x00	; 0
    3dc6:	40 ea       	ldi	r20, 0xA0	; 160
    3dc8:	50 e4       	ldi	r21, 0x40	; 64
create_ack():
    3dca:	66 e6       	ldi	r22, 0x66	; 102
    3dcc:	78 e4       	ldi	r23, 0x48	; 72
    3dce:	ce 01       	movw	r24, r28
    3dd0:	0e 94 3f 11 	call	0x227e	; 0x227e <cJSON_AddNumberToObject>
    3dd4:	89 2b       	or	r24, r25
    3dd6:	31 f4       	brne	.+12     	; 0x3de4 <iotcl_create_ack_string_and_destroy_event+0xb6>
iotcl_create_ack_string_and_destroy_event():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:219
        bool success,
        const char *message,
        IotConnectEventType message_type,
        const char *ack_id) {

    char *result = NULL;
    3dd8:	10 e0       	ldi	r17, 0x00	; 0
    3dda:	00 e0       	ldi	r16, 0x00	; 0
create_ack():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:270

    result = cJSON_PrintUnformatted(ack_json);

    // fall through
    cleanup:
    cJSON_Delete(ack_json);
    3ddc:	ce 01       	movw	r24, r28
    3dde:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
    3de2:	cb cf       	rjmp	.-106    	; 0x3d7a <iotcl_create_ack_string_and_destroy_event+0x4c>
iotcl_iso_timestamp_now():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:23
const char *iotcl_to_iso_timestamp(time_t timestamp) {
    return to_iso_timestamp(&timestamp);
}

const char *iotcl_iso_timestamp_now(void) {
    return to_iso_timestamp(NULL);
    3de4:	4a d8       	rcall	.-3948   	; 0x2e7a <to_iso_timestamp.constprop.106>
create_ack():
    3de6:	ac 01       	movw	r20, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:235
        return NULL;
    }

    // message type 5 in response is the command response. Type 11 is OTA response.
    if (!cJSON_AddNumberToObject(ack_json, "mt", message_type == DEVICE_COMMAND ? 5 : 11)) goto cleanup;
    if (!cJSON_AddStringToObject(ack_json, "t", iotcl_iso_timestamp_now())) goto cleanup;
    3de8:	60 ef       	ldi	r22, 0xF0	; 240
    3dea:	7a e5       	ldi	r23, 0x5A	; 90
    3dec:	ce 01       	movw	r24, r28
    3dee:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    3df2:	89 2b       	or	r24, r25
    3df4:	89 f3       	breq	.-30     	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
    3df6:	40 91 2d 64 	lds	r20, 0x642D	; 0x80642d <config>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:237

    if (!cJSON_AddStringToObject(ack_json, "uniqueId", config->device.duid)) goto cleanup;
    3dfa:	50 91 2e 64 	lds	r21, 0x642E	; 0x80642e <config+0x1>
    3dfe:	69 e6       	ldi	r22, 0x69	; 105
    3e00:	78 e4       	ldi	r23, 0x48	; 72
    3e02:	ce 01       	movw	r24, r28
    3e04:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    3e08:	89 2b       	or	r24, r25
    3e0a:	31 f3       	breq	.-52     	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
    3e0c:	40 91 2f 64 	lds	r20, 0x642F	; 0x80642f <config+0x2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:238
    if (!cJSON_AddStringToObject(ack_json, "cpId", config->device.cpid)) goto cleanup;
    3e10:	50 91 30 64 	lds	r21, 0x6430	; 0x806430 <config+0x3>
    3e14:	62 e7       	ldi	r22, 0x72	; 114
    3e16:	78 e4       	ldi	r23, 0x48	; 72
    3e18:	ce 01       	movw	r24, r28
    3e1a:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    3e1e:	89 2b       	or	r24, r25
    3e20:	d9 f2       	breq	.-74     	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
    3e22:	0e 94 de 10 	call	0x21bc	; 0x21bc <cJSON_CreateObject>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:241

    {
        cJSON *sdk_info = cJSON_CreateObject();
    3e26:	8c 01       	movw	r16, r24
    3e28:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:242
        if (NULL == sdk_info) {
    3e2a:	09 f4       	brne	.+2      	; 0x3e2e <iotcl_create_ack_string_and_destroy_event+0x100>
    3e2c:	a4 cf       	rjmp	.-184    	; 0x3d76 <iotcl_create_ack_string_and_destroy_event+0x48>
cJSON_AddItemToObject():
    3e2e:	ac 01       	movw	r20, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2046
    return add_item_to_array(object, item);
}

CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToObject(cJSON *object, const char *string, cJSON *item)
{
    return add_item_to_object(object, string, item, &global_hooks, false);
    3e30:	67 e7       	ldi	r22, 0x77	; 119
    3e32:	78 e4       	ldi	r23, 0x48	; 72
    3e34:	ce 01       	movw	r24, r28
    3e36:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <add_item_to_object.constprop.108>
create_ack():
    3e3a:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:245
            return NULL;
        }
        if (!cJSON_AddItemToObject(ack_json, "sdk", sdk_info)) {
    3e3c:	21 f4       	brne	.+8      	; 0x3e46 <iotcl_create_ack_string_and_destroy_event+0x118>
    3e3e:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:258

    {
        cJSON *ack_data = cJSON_CreateObject();
        if (NULL == ack_data) goto cleanup;
        if (!cJSON_AddItemToObject(ack_json, "d", ack_data)) {
            cJSON_Delete(ack_data);
    3e40:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
    3e44:	c9 cf       	rjmp	.-110    	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
    3e46:	4b e7       	ldi	r20, 0x7B	; 123
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:249
        }
        if (!cJSON_AddItemToObject(ack_json, "sdk", sdk_info)) {
            cJSON_Delete(sdk_info);
            goto cleanup;
        }
        if (!cJSON_AddStringToObject(sdk_info, "l", CONFIG_IOTCONNECT_SDK_NAME)) goto cleanup;
    3e48:	58 e4       	ldi	r21, 0x48	; 72
    3e4a:	6f e1       	ldi	r22, 0x1F	; 31
    3e4c:	77 e4       	ldi	r23, 0x47	; 71
    3e4e:	c8 01       	movw	r24, r16
    3e50:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    3e54:	89 2b       	or	r24, r25
    3e56:	09 f4       	brne	.+2      	; 0x3e5a <iotcl_create_ack_string_and_destroy_event+0x12c>
    3e58:	bf cf       	rjmp	.-130    	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
    3e5a:	4f e7       	ldi	r20, 0x7F	; 127
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:250
        if (!cJSON_AddStringToObject(sdk_info, "v", CONFIG_IOTCONNECT_SDK_VERSION)) goto cleanup;
    3e5c:	58 e4       	ldi	r21, 0x48	; 72
    3e5e:	63 e8       	ldi	r22, 0x83	; 131
    3e60:	78 e4       	ldi	r23, 0x48	; 72
    3e62:	c8 01       	movw	r24, r16
    3e64:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    3e68:	89 2b       	or	r24, r25
    3e6a:	09 f4       	brne	.+2      	; 0x3e6e <iotcl_create_ack_string_and_destroy_event+0x140>
    3e6c:	b5 cf       	rjmp	.-150    	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
    3e6e:	40 91 31 64 	lds	r20, 0x6431	; 0x806431 <config+0x4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:251
        if (!cJSON_AddStringToObject(sdk_info, "e", config->device.env)) goto cleanup;
    3e72:	50 91 32 64 	lds	r21, 0x6432	; 0x806432 <config+0x5>
    3e76:	6a ee       	ldi	r22, 0xEA	; 234
    3e78:	7a e5       	ldi	r23, 0x5A	; 90
    3e7a:	c8 01       	movw	r24, r16
    3e7c:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    3e80:	89 2b       	or	r24, r25
    3e82:	09 f4       	brne	.+2      	; 0x3e86 <iotcl_create_ack_string_and_destroy_event+0x158>
    3e84:	a9 cf       	rjmp	.-174    	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
    3e86:	0e 94 de 10 	call	0x21bc	; 0x21bc <cJSON_CreateObject>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:255
    }

    {
        cJSON *ack_data = cJSON_CreateObject();
    3e8a:	8c 01       	movw	r16, r24
    3e8c:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:256
        if (NULL == ack_data) goto cleanup;
    3e8e:	09 f4       	brne	.+2      	; 0x3e92 <iotcl_create_ack_string_and_destroy_event+0x164>
    3e90:	a3 cf       	rjmp	.-186    	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
cJSON_AddItemToObject():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2046
    3e92:	ac 01       	movw	r20, r24
    3e94:	65 e8       	ldi	r22, 0x85	; 133
    3e96:	76 e4       	ldi	r23, 0x46	; 70
    3e98:	ce 01       	movw	r24, r28
    3e9a:	0e 94 aa 0f 	call	0x1f54	; 0x1f54 <add_item_to_object.constprop.108>
create_ack():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:257
        if (!cJSON_AddItemToObject(ack_json, "d", ack_data)) {
    3e9e:	89 2b       	or	r24, r25
    3ea0:	71 f2       	breq	.-100    	; 0x3e3e <iotcl_create_ack_string_and_destroy_event+0x110>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:261
            cJSON_Delete(ack_data);
            goto cleanup;
        }
        if (!cJSON_AddStringToObject(ack_data, "ackId", ack_id)) goto cleanup;
    3ea2:	a4 01       	movw	r20, r8
    3ea4:	60 e6       	ldi	r22, 0x60	; 96
    3ea6:	78 e4       	ldi	r23, 0x48	; 72
    3ea8:	c8 01       	movw	r24, r16
    3eaa:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    3eae:	89 2b       	or	r24, r25
    3eb0:	09 f4       	brne	.+2      	; 0x3eb4 <iotcl_create_ack_string_and_destroy_event+0x186>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:262
        if (!cJSON_AddStringToObject(ack_data, "msg", message ? message : "")) goto cleanup;
    3eb2:	92 cf       	rjmp	.-220    	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
    3eb4:	a1 14       	cp	r10, r1
    3eb6:	b1 04       	cpc	r11, r1
    3eb8:	21 f4       	brne	.+8      	; 0x3ec2 <iotcl_create_ack_string_and_destroy_event+0x194>
iotcl_create_ack_string_and_destroy_event():
    3eba:	82 ef       	ldi	r24, 0xF2	; 242
    3ebc:	a8 2e       	mov	r10, r24
    3ebe:	81 e6       	ldi	r24, 0x61	; 97
    3ec0:	b8 2e       	mov	r11, r24
create_ack():
    3ec2:	a5 01       	movw	r20, r10
    3ec4:	65 e8       	ldi	r22, 0x85	; 133
    3ec6:	78 e4       	ldi	r23, 0x48	; 72
    3ec8:	c8 01       	movw	r24, r16
    3eca:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    3ece:	89 2b       	or	r24, r25
    3ed0:	09 f4       	brne	.+2      	; 0x3ed4 <iotcl_create_ack_string_and_destroy_event+0x1a6>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:41
4 Firmware command Failed with some reason
7 Firmware command executed successfully
*/
static int to_ack_status(bool success, IotConnectEventType type) {
    int status = 4; // default is "failure"
    if (success == true) {
    3ed2:	82 cf       	rjmp	.-252    	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
to_ack_status():
    3ed4:	77 20       	and	r7, r7
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:44
        switch (type) {
            case DEVICE_COMMAND:
                status = 6;
    3ed6:	61 f0       	breq	.+24     	; 0x3ef0 <iotcl_create_ack_string_and_destroy_event+0x1c2>
iotcl_create_ack_string_and_destroy_event():
    3ed8:	66 e0       	ldi	r22, 0x06	; 6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:42
7 Firmware command executed successfully
*/
static int to_ack_status(bool success, IotConnectEventType type) {
    int status = 4; // default is "failure"
    if (success == true) {
        switch (type) {
    3eda:	70 e0       	ldi	r23, 0x00	; 0
to_ack_status():
    3edc:	81 e0       	ldi	r24, 0x01	; 1
    3ede:	c8 16       	cp	r12, r24
    3ee0:	d1 04       	cpc	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:47
            case DEVICE_COMMAND:
                status = 6;
                break;
            case DEVICE_OTA:
                status = 7;
    3ee2:	41 f0       	breq	.+16     	; 0x3ef4 <iotcl_create_ack_string_and_destroy_event+0x1c6>
iotcl_create_ack_string_and_destroy_event():
    3ee4:	67 e0       	ldi	r22, 0x07	; 7
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:42
7 Firmware command executed successfully
*/
static int to_ack_status(bool success, IotConnectEventType type) {
    int status = 4; // default is "failure"
    if (success == true) {
        switch (type) {
    3ee6:	70 e0       	ldi	r23, 0x00	; 0
to_ack_status():
    3ee8:	e2 e0       	ldi	r30, 0x02	; 2
    3eea:	ce 16       	cp	r12, r30
    3eec:	d1 04       	cpc	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:40
Table 16 [Possible values for st]
4 Firmware command Failed with some reason
7 Firmware command executed successfully
*/
static int to_ack_status(bool success, IotConnectEventType type) {
    int status = 4; // default is "failure"
    3eee:	11 f0       	breq	.+4      	; 0x3ef4 <iotcl_create_ack_string_and_destroy_event+0x1c6>
iotcl_create_ack_string_and_destroy_event():
    3ef0:	64 e0       	ldi	r22, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:263
            cJSON_Delete(ack_data);
            goto cleanup;
        }
        if (!cJSON_AddStringToObject(ack_data, "ackId", ack_id)) goto cleanup;
        if (!cJSON_AddStringToObject(ack_data, "msg", message ? message : "")) goto cleanup;
        if (!cJSON_AddNumberToObject(ack_data, "st", to_ack_status(success, message_type))) goto cleanup;
    3ef2:	70 e0       	ldi	r23, 0x00	; 0
create_ack():
    3ef4:	07 2e       	mov	r0, r23
    3ef6:	00 0c       	add	r0, r0
    3ef8:	88 0b       	sbc	r24, r24
    3efa:	99 0b       	sbc	r25, r25
    3efc:	0e 94 2d 51 	call	0xa25a	; 0xa25a <__floatsisf>
    3f00:	9b 01       	movw	r18, r22
    3f02:	ac 01       	movw	r20, r24
    3f04:	69 e8       	ldi	r22, 0x89	; 137
    3f06:	78 e4       	ldi	r23, 0x48	; 72
    3f08:	c8 01       	movw	r24, r16
    3f0a:	0e 94 3f 11 	call	0x227e	; 0x227e <cJSON_AddNumberToObject>
    3f0e:	89 2b       	or	r24, r25
    3f10:	09 f4       	brne	.+2      	; 0x3f14 <iotcl_create_ack_string_and_destroy_event+0x1e6>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1255
    return (char*)print(item, true, &global_hooks);
}

CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
{
    return (char*)print(item, false, &global_hooks);
    3f12:	62 cf       	rjmp	.-316    	; 0x3dd8 <iotcl_create_ack_string_and_destroy_event+0xaa>
cJSON_PrintUnformatted():
    3f14:	70 e0       	ldi	r23, 0x00	; 0
    3f16:	60 e0       	ldi	r22, 0x00	; 0
    3f18:	ce 01       	movw	r24, r28
    3f1a:	ab dd       	rcall	.-1194   	; 0x3a72 <print.constprop.111>
    3f1c:	8c 01       	movw	r16, r24
    3f1e:	5e cf       	rjmp	.-324    	; 0x3ddc <iotcl_create_ack_string_and_destroy_event+0xae>

00003f20 <iotcl_clone_command>:
iotcl_clone_command():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:154

    cJSON_Delete(root);
    return status;
}

char *iotcl_clone_command(IotclEventData data) {
    3f20:	cf 93       	push	r28
    3f22:	df 93       	push	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:155
    cJSON *command = cJSON_GetObjectItemCaseSensitive(data->data, "command");
    3f24:	63 eb       	ldi	r22, 0xB3	; 179
    3f26:	77 e4       	ldi	r23, 0x47	; 71
    3f28:	fc 01       	movw	r30, r24
    3f2a:	80 81       	ld	r24, Z
    3f2c:	91 81       	ldd	r25, Z+1	; 0x01
    3f2e:	dc de       	rcall	.-584    	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
    3f30:	ec 01       	movw	r28, r24
    3f32:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:156
    if (NULL == command || !is_valid_string(command)) {
    3f34:	51 f0       	breq	.+20     	; 0x3f4a <iotcl_clone_command+0x2a>
    3f36:	0e 94 0d 05 	call	0xa1a	; 0xa1a <is_valid_string>
    3f3a:	88 23       	and	r24, r24
    3f3c:	31 f0       	breq	.+12     	; 0x3f4a <iotcl_clone_command+0x2a>
    3f3e:	88 85       	ldd	r24, Y+8	; 0x08
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:160
        return NULL;
    }

    return iotcl_strdup(command->valuestring);
    3f40:	99 85       	ldd	r25, Y+9	; 0x09
    3f42:	df 91       	pop	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:161
}
    3f44:	cf 91       	pop	r28
    3f46:	0c 94 ef 0f 	jmp	0x1fde	; 0x1fde <iotcl_strdup>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:160
    cJSON *command = cJSON_GetObjectItemCaseSensitive(data->data, "command");
    if (NULL == command || !is_valid_string(command)) {
        return NULL;
    }

    return iotcl_strdup(command->valuestring);
    3f4a:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:161
}
    3f4c:	80 e0       	ldi	r24, 0x00	; 0
    3f4e:	df 91       	pop	r29
    3f50:	cf 91       	pop	r28
    3f52:	08 95       	ret

00003f54 <MqttClientClass::begin(char const*, char const*, unsigned int, bool, unsigned int, bool, char const*, char const*) [clone .constprop.45]>:
begin():
    3f54:	2f 92       	push	r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:390
                       true,
                       "",
                       "");
}

bool MqttClientClass::begin(const char* client_id,
    3f56:	3f 92       	push	r3
    3f58:	4f 92       	push	r4
    3f5a:	5f 92       	push	r5
    3f5c:	6f 92       	push	r6
    3f5e:	7f 92       	push	r7
    3f60:	8f 92       	push	r8
    3f62:	9f 92       	push	r9
    3f64:	af 92       	push	r10
    3f66:	bf 92       	push	r11
    3f68:	cf 92       	push	r12
    3f6a:	df 92       	push	r13
    3f6c:	ef 92       	push	r14
    3f6e:	ff 92       	push	r15
    3f70:	0f 93       	push	r16
    3f72:	1f 93       	push	r17
    3f74:	cf 93       	push	r28
    3f76:	df 93       	push	r29
    3f78:	cd b7       	in	r28, 0x3d	; 61
    3f7a:	de b7       	in	r29, 0x3e	; 62
    3f7c:	c1 56       	subi	r28, 0x61	; 97
    3f7e:	d4 40       	sbci	r29, 0x04	; 4
    3f80:	cd bf       	out	0x3d, r28	; 61
    3f82:	de bf       	out	0x3e, r29	; 62
    3f84:	d8 2e       	mov	r13, r24
    3f86:	b9 2e       	mov	r11, r25
    3f88:	c6 2e       	mov	r12, r22
    3f8a:	77 2e       	mov	r7, r23
    3f8c:	a4 2e       	mov	r10, r20
    3f8e:	95 2e       	mov	r9, r21
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:534

        SequansController.stopCriticalSection();
    }

    return true;
}
    3f90:	2d b6       	in	r2, 0x3d	; 61
    3f92:	3e b6       	in	r3, 0x3e	; 62
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:357

void LteClass::onDisconnect(void (*disconnect_callback)(void)) {
    disconnected_callback = disconnect_callback;
}

bool LteClass::isConnected(void) { return is_connected; }
    3f94:	f0 90 8d 66 	lds	r15, 0x668D	; 0x80668d <is_connected>
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:399
                            const size_t keep_alive,
                            const bool use_ecc,
                            const char* username,
                            const char* password) {

    if (!Lte.isConnected()) {
    3f98:	ff 20       	and	r15, r15
    3f9a:	09 f4       	brne	.+2      	; 0x3f9e <MqttClientClass::begin(char const*, char const*, unsigned int, bool, unsigned int, bool, char const*, char const*) [clone .constprop.45]+0x4a>
    3f9c:	33 c2       	rjmp	.+1126   	; 0x4404 <__DATA_REGION_LENGTH__+0x404>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:404
        return false;
    }

    // Disconnect to terminate existing configuration
    SequansController.writeBytes((uint8_t*)MQTT_DISCONNECT,
    3f9e:	41 e0       	ldi	r20, 0x01	; 1
    3fa0:	67 e1       	ldi	r22, 0x17	; 23
    3fa2:	70 e0       	ldi	r23, 0x00	; 0
    3fa4:	8e e5       	ldi	r24, 0x5E	; 94
    3fa6:	95 e4       	ldi	r25, 0x45	; 69
    3fa8:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:415
    // If there aren't, this will return an error from the modem, but that is
    // fine as it just means that there aren't any connections active.
    //
    // We do this with writeBytes instead of writeCommand to not issue the
    // retries of the command if it fails.
    SequansController.readResponse();
    3fac:	70 e0       	ldi	r23, 0x00	; 0
    3fae:	60 e0       	ldi	r22, 0x00	; 0
    3fb0:	90 e0       	ldi	r25, 0x00	; 0
    3fb2:	80 e0       	ldi	r24, 0x00	; 0
    3fb4:	0e 94 70 17 	call	0x2ee0	; 0x2ee0 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:417

    SequansController.clearReceiveBuffer();
    3fb8:	0e 94 82 07 	call	0xf04	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:421

    // -- Configuration --

    const size_t client_id_length = strlen(client_id);
    3fbc:	ad 2d       	mov	r26, r13
    3fbe:	bb 2d       	mov	r27, r11
    3fc0:	fd 01       	movw	r30, r26
    3fc2:	01 90       	ld	r0, Z+
    3fc4:	00 20       	and	r0, r0
    3fc6:	e9 f7       	brne	.-6      	; 0x3fc2 <MqttClientClass::begin(char const*, char const*, unsigned int, bool, unsigned int, bool, char const*, char const*) [clone .constprop.45]+0x6e>
    3fc8:	31 97       	sbiw	r30, 0x01	; 1
    3fca:	cf 01       	movw	r24, r30
    3fcc:	8a 1b       	sub	r24, r26
    3fce:	9b 0b       	sbc	r25, r27
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:422
    const size_t username_length  = strlen(username);
    3fd0:	aa 2d       	mov	r26, r10
    3fd2:	b9 2d       	mov	r27, r9
    3fd4:	fd 01       	movw	r30, r26
    3fd6:	01 90       	ld	r0, Z+
    3fd8:	00 20       	and	r0, r0
    3fda:	e9 f7       	brne	.-6      	; 0x3fd6 <MqttClientClass::begin(char const*, char const*, unsigned int, bool, unsigned int, bool, char const*, char const*) [clone .constprop.45]+0x82>
    3fdc:	31 97       	sbiw	r30, 0x01	; 1
    3fde:	ea 1b       	sub	r30, r26
    3fe0:	fb 0b       	sbc	r31, r27
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:478
                "Failed to configure MQTT. The TLS setup might be incorrect. "
                "If you're using a custom broker with TLS, run the provision "
                "example sketch in order to provision for a custom MQTT broker "
                "with TLS.");
            return false;
        }
    3fe2:	ed b6       	in	r14, 0x3d	; 61
    3fe4:	fe b6       	in	r15, 0x3e	; 62
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:429

    // The sequans modem fails if we specify 0 as TLS, so we just have to have
    // two commands for this
    if (use_tls) {

        char command[MQTT_CONFIGURE_TLS_LENGTH + client_id_length +
    3fe6:	8e 0f       	add	r24, r30
    3fe8:	9f 1f       	adc	r25, r31
    3fea:	9c 01       	movw	r18, r24
    3fec:	24 5e       	subi	r18, 0xE4	; 228
    3fee:	3f 4f       	sbci	r19, 0xFF	; 255
    3ff0:	4d b7       	in	r20, 0x3d	; 61
    3ff2:	5e b7       	in	r21, 0x3e	; 62
    3ff4:	42 1b       	sub	r20, r18
    3ff6:	53 0b       	sbc	r21, r19
    3ff8:	4d bf       	out	0x3d, r20	; 61
    3ffa:	5e bf       	out	0x3e, r21	; 62
    3ffc:	0d b7       	in	r16, 0x3d	; 61
    3ffe:	1e b7       	in	r17, 0x3e	; 62
    4000:	0f 5f       	subi	r16, 0xFF	; 255
    4002:	1f 4f       	sbci	r17, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:430
                     username_length + password_length] = "";
    4004:	ad b7       	in	r26, 0x3d	; 61
    4006:	be b7       	in	r27, 0x3e	; 62
    4008:	11 96       	adiw	r26, 0x01	; 1
    400a:	1c 92       	st	X, r1
    400c:	f8 01       	movw	r30, r16
    400e:	31 96       	adiw	r30, 0x01	; 1
    4010:	4a 96       	adiw	r24, 0x1a	; 26
    4012:	97 fd       	sbrc	r25, 7
    4014:	03 c0       	rjmp	.+6      	; 0x401c <__DATA_REGION_LENGTH__+0x1c>
    4016:	11 92       	st	Z+, r1
    4018:	01 97       	sbiw	r24, 0x01	; 1
    401a:	fb cf       	rjmp	.-10     	; 0x4012 <__DATA_REGION_LENGTH__+0x12>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:434

        if (use_ecc) {

            if (!SecurityProfile.profileExists(
    401c:	81 e0       	ldi	r24, 0x01	; 1
    401e:	ba d8       	rcall	.-3724   	; 0x3194 <SecurityProfileClass::profileExists(unsigned char) [clone .constprop.69]>
    4020:	81 11       	cpse	r24, r1
    4022:	08 c0       	rjmp	.+16     	; 0x4034 <__DATA_REGION_LENGTH__+0x34>
    4024:	8c e8       	ldi	r24, 0x8C	; 140
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:436
                    MQTT_TLS_ECC_SECURITY_PROFILE_ID)) {
                Log.error("Security profile not set up for MQTT TLS with ECC. "
    4026:	98 e4       	ldi	r25, 0x48	; 72
    4028:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:472
                    password,
                    MQTT_TLS_SECURITY_PROFILE_ID);
        }

        if (SequansController.writeCommand(command) != ResponseResult::OK) {
            Log.error(
    402c:	ed be       	out	0x3d, r14	; 61
    402e:	fe be       	out	0x3e, r15	; 62
    4030:	f1 2c       	mov	r15, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:513
        char urc[URC_DATA_BUFFER_SIZE] = "";
        if (!SequansController.waitForURC(HCESIGN_URC, urc, sizeof(urc))) {
            Log.error("Timed out whilst waiting for TLS signing. Please verify "
                      "your certificate setup (run the provision Arduino "
                      "sketch to set this up for a new broker).\r\n");
            return false;
    4032:	e8 c1       	rjmp	.+976    	; 0x4404 <__DATA_REGION_LENGTH__+0x404>
    4034:	80 91 7e 70 	lds	r24, 0x707E	; 0x80707e <ECC608>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/ecc608.cpp:35
};

ECC608Class ECC608 = ECC608Class::instance();

ATCA_STATUS ECC608Class::begin() {
    if (initialized) {
    4038:	81 11       	cpse	r24, r1
    403a:	0c c0       	rjmp	.+24     	; 0x4054 <__DATA_REGION_LENGTH__+0x54>
    403c:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/ecc608.cpp:38
        return ATCA_SUCCESS;
    } else {
        initialized = true;
    403e:	80 93 7e 70 	sts	0x707E, r24	; 0x80707e <ECC608>
atcab_init():
    4042:	89 ed       	ldi	r24, 0xD9	; 217
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:135
 *                  configurations can be found in atca_cfgs.h
 *  \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS atcab_init(ATCAIfaceCfg* cfg)
{
    return atcab_init_ext(&_gDevice, cfg);
    4044:	91 e4       	ldi	r25, 0x41	; 65
    4046:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <atcab_init_ext.constprop.49>
begin():
    404a:	88 23       	and	r24, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:444
                          "tool to set this up for AWS.");
                return false;
            }

            uint8_t status = ECC608.begin();
            if (status != ATCA_SUCCESS) {
    404c:	19 f0       	breq	.+6      	; 0x4054 <__DATA_REGION_LENGTH__+0x54>
    404e:	82 e4       	ldi	r24, 0x42	; 66
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:445
                Log.error("Could not initialize ECC hardware");
    4050:	99 e4       	ldi	r25, 0x49	; 73
    4052:	ea cf       	rjmp	.-44     	; 0x4028 <__DATA_REGION_LENGTH__+0x28>
    4054:	1f 92       	push	r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:449
                return false;
            }

            sprintf(command,
    4056:	81 e0       	ldi	r24, 0x01	; 1
    4058:	8f 93       	push	r24
    405a:	82 ef       	ldi	r24, 0xF2	; 242
    405c:	91 e6       	ldi	r25, 0x61	; 97
    405e:	9f 93       	push	r25
    4060:	8f 93       	push	r24
    4062:	9f 92       	push	r9
    4064:	af 92       	push	r10
    4066:	bf 92       	push	r11
    4068:	df 92       	push	r13
    406a:	84 e6       	ldi	r24, 0x64	; 100
    406c:	99 e4       	ldi	r25, 0x49	; 73
    406e:	9f 93       	push	r25
    4070:	8f 93       	push	r24
    4072:	1f 93       	push	r17
    4074:	0f 93       	push	r16
    4076:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    407a:	50 e0       	ldi	r21, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:471
                    username,
                    password,
                    MQTT_TLS_SECURITY_PROFILE_ID);
        }

        if (SequansController.writeCommand(command) != ResponseResult::OK) {
    407c:	40 e0       	ldi	r20, 0x00	; 0
    407e:	70 e0       	ldi	r23, 0x00	; 0
    4080:	60 e0       	ldi	r22, 0x00	; 0
    4082:	c8 01       	movw	r24, r16
    4084:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    4088:	ed b7       	in	r30, 0x3d	; 61
    408a:	fe b7       	in	r31, 0x3e	; 62
    408c:	3c 96       	adiw	r30, 0x0c	; 12
    408e:	ed bf       	out	0x3d, r30	; 61
    4090:	fe bf       	out	0x3e, r31	; 62
    4092:	01 97       	sbiw	r24, 0x01	; 1
    4094:	19 f0       	breq	.+6      	; 0x409c <__DATA_REGION_LENGTH__+0x9c>
    4096:	87 e8       	ldi	r24, 0x87	; 135
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:472
            Log.error(
    4098:	99 e4       	ldi	r25, 0x49	; 73
    409a:	c6 cf       	rjmp	.-116    	; 0x4028 <__DATA_REGION_LENGTH__+0x28>
    409c:	ed be       	out	0x3d, r14	; 61
    409e:	fe be       	out	0x3e, r15	; 62
    40a0:	41 e0       	ldi	r20, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:490
            Log.error("Failed to configure MQTT");
            return false;
        }
    }

    SequansController.registerCallback(MQTT_ON_CONNECT_URC,
    40a2:	6d e6       	ldi	r22, 0x6D	; 109
    40a4:	77 e2       	ldi	r23, 0x27	; 39
    40a6:	87 e4       	ldi	r24, 0x47	; 71
    40a8:	9a e4       	ldi	r25, 0x4A	; 74
    40aa:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]>
    40ae:	41 e0       	ldi	r20, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:492
                                       internalConnectedCallback);
    SequansController.registerCallback(MQTT_ON_DISCONNECT_URC,
    40b0:	66 e0       	ldi	r22, 0x06	; 6
    40b2:	7f e0       	ldi	r23, 0x0F	; 15
    40b4:	89 e5       	ldi	r24, 0x59	; 89
    40b6:	9a e4       	ldi	r25, 0x4A	; 74
    40b8:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]>
    40bc:	8e 01       	movw	r16, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:497
                                       internalDisconnectCallback);

    // -- Request connection --
    size_t keep_alive_length = floor(log10(keep_alive)) + 1;
    char command[MQTT_CONNECT_LENGTH_PRE_KEEP_ALIVE + keep_alive_length] = "";
    40be:	07 5b       	subi	r16, 0xB7	; 183
    40c0:	1c 4f       	sbci	r17, 0xFC	; 252
    40c2:	d8 01       	movw	r26, r16
    40c4:	1d 92       	st	X+, r1
    40c6:	4d 01       	movw	r8, r26
    40c8:	5e 01       	movw	r10, r28
    40ca:	b7 e1       	ldi	r27, 0x17	; 23
    40cc:	ab 1a       	sub	r10, r27
    40ce:	bc ef       	ldi	r27, 0xFC	; 252
    40d0:	bb 0a       	sbc	r11, r27
    40d2:	f4 01       	movw	r30, r8
    40d4:	11 92       	st	Z+, r1
    40d6:	4f 01       	movw	r8, r30
    40d8:	ea 15       	cp	r30, r10
    40da:	fb 05       	cpc	r31, r11
    40dc:	d1 f7       	brne	.-12     	; 0x40d2 <__DATA_REGION_LENGTH__+0xd2>
    40de:	1f 92       	push	r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:499

    sprintf(command, MQTT_CONNECT, host, port, keep_alive);
    40e0:	8c e3       	ldi	r24, 0x3C	; 60
    40e2:	8f 93       	push	r24
    40e4:	82 e2       	ldi	r24, 0x22	; 34
    40e6:	8f 93       	push	r24
    40e8:	83 eb       	ldi	r24, 0xB3	; 179
    40ea:	8f 93       	push	r24
    40ec:	7f 92       	push	r7
    40ee:	cf 92       	push	r12
    40f0:	8e e6       	ldi	r24, 0x6E	; 110
    40f2:	9a e4       	ldi	r25, 0x4A	; 74
    40f4:	9f 93       	push	r25
    40f6:	8f 93       	push	r24
    40f8:	1f 93       	push	r17
    40fa:	0f 93       	push	r16
    40fc:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    4100:	50 e0       	ldi	r21, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:501

    if (SequansController.writeCommand(command) != ResponseResult::OK) {
    4102:	40 e0       	ldi	r20, 0x00	; 0
    4104:	70 e0       	ldi	r23, 0x00	; 0
    4106:	60 e0       	ldi	r22, 0x00	; 0
    4108:	c8 01       	movw	r24, r16
    410a:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    410e:	2d b7       	in	r18, 0x3d	; 61
    4110:	3e b7       	in	r19, 0x3e	; 62
    4112:	26 5f       	subi	r18, 0xF6	; 246
    4114:	3f 4f       	sbci	r19, 0xFF	; 255
    4116:	2d bf       	out	0x3d, r18	; 61
    4118:	3e bf       	out	0x3e, r19	; 62
    411a:	01 97       	sbiw	r24, 0x01	; 1
    411c:	29 f0       	breq	.+10     	; 0x4128 <__DATA_REGION_LENGTH__+0x128>
    411e:	8e e8       	ldi	r24, 0x8E	; 142
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:502
        Log.error("Failed to request connection to MQTT broker\r\n");
    4120:	9a e4       	ldi	r25, 0x4A	; 74
    4122:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:522

        SequansController.startCriticalSection();
        bool success = generateSigningCommand(urc, signing_request_buffer);

        if (success != true) {
            Log.error("Unable to handle signature request\r\n");
    4126:	84 cf       	rjmp	.-248    	; 0x4030 <__DATA_REGION_LENGTH__+0x30>
    4128:	19 82       	std	Y+1, r1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:508
        return false;
    }

    if (use_tls && use_ecc) {

        char urc[URC_DATA_BUFFER_SIZE] = "";
    412a:	1a 82       	std	Y+2, r1	; 0x02
    412c:	fe 01       	movw	r30, r28
    412e:	33 96       	adiw	r30, 0x03	; 3
    4130:	8e e7       	ldi	r24, 0x7E	; 126
    4132:	91 e0       	ldi	r25, 0x01	; 1
    4134:	df 01       	movw	r26, r30
    4136:	9c 01       	movw	r18, r24
    4138:	1d 92       	st	X+, r1
    413a:	21 50       	subi	r18, 0x01	; 1
    413c:	30 40       	sbci	r19, 0x00	; 0
    413e:	e1 f7       	brne	.-8      	; 0x4138 <__DATA_REGION_LENGTH__+0x138>
    4140:	50 e2       	ldi	r21, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:509
        if (!SequansController.waitForURC(HCESIGN_URC, urc, sizeof(urc))) {
    4142:	c5 2e       	mov	r12, r21
    4144:	6e e4       	ldi	r22, 0x4E	; 78
    4146:	d6 2e       	mov	r13, r22
    4148:	e1 2c       	mov	r14, r1
    414a:	f1 2c       	mov	r15, r1
    414c:	00 e0       	ldi	r16, 0x00	; 0
    414e:	10 e0       	ldi	r17, 0x00	; 0
    4150:	20 e0       	ldi	r18, 0x00	; 0
    4152:	30 e0       	ldi	r19, 0x00	; 0
    4154:	40 e8       	ldi	r20, 0x80	; 128
    4156:	51 e0       	ldi	r21, 0x01	; 1
    4158:	be 01       	movw	r22, r28
    415a:	6f 5f       	subi	r22, 0xFF	; 255
    415c:	7f 4f       	sbci	r23, 0xFF	; 255
    415e:	8c eb       	ldi	r24, 0xBC	; 188
    4160:	9a e4       	ldi	r25, 0x4A	; 74
    4162:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]>
    4166:	81 11       	cpse	r24, r1
    4168:	03 c0       	rjmp	.+6      	; 0x4170 <__DATA_REGION_LENGTH__+0x170>
    416a:	87 ec       	ldi	r24, 0xC7	; 199
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:510
            Log.error("Timed out whilst waiting for TLS signing. Please verify "
    416c:	9a e4       	ldi	r25, 0x4A	; 74
    416e:	d9 cf       	rjmp	.-78     	; 0x4122 <__DATA_REGION_LENGTH__+0x122>
    4170:	6e 01       	movw	r12, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:516
                      "your certificate setup (run the provision Arduino "
                      "sketch to set this up for a new broker).\r\n");
            return false;
        }

        char signing_request_buffer[MQTT_SIGNING_BUFFER + 1] = "";
    4172:	3f e7       	ldi	r19, 0x7F	; 127
    4174:	c3 1a       	sub	r12, r19
    4176:	3e ef       	ldi	r19, 0xFE	; 254
    4178:	d3 0a       	sbc	r13, r19
    417a:	f6 01       	movw	r30, r12
    417c:	11 92       	st	Z+, r1
    417e:	11 92       	st	Z+, r1
    4180:	8f ef       	ldi	r24, 0xFF	; 255
    4182:	df 01       	movw	r26, r30
    4184:	1d 92       	st	X+, r1
    4186:	8a 95       	dec	r24
    4188:	e9 f7       	brne	.-6      	; 0x4184 <__DATA_REGION_LENGTH__+0x184>
startCriticalSection():
    418a:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1076

    return true;
}

void SequansControllerClass::startCriticalSection(void) {
    critical_section_enabled = true;
    418c:	80 93 89 66 	sts	0x6689, r24	; 0x806689 <critical_section_enabled>
    4190:	80 e8       	ldi	r24, 0x80	; 128
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1077
    RTS_PORT.OUTSET          = RTS_PIN_bm;
    4192:	80 93 45 04 	sts	0x0445, r24	; 0x800445 <__TEXT_REGION_LENGTH__+0x7e0445>
generateSigningCommand():
    4196:	00 e0       	ldi	r16, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:277
    bool got_ctx_id = SequansController.extractValueFromCommandResponse(
        data,
        0,
        ctx_id_buffer,
        HCESIGN_CTX_ID_LENGTH + 1,
        (char)NULL);
    4198:	26 e0       	ldi	r18, 0x06	; 6
    419a:	30 e0       	ldi	r19, 0x00	; 0
    419c:	ae 01       	movw	r20, r28
    419e:	45 5a       	subi	r20, 0xA5	; 165
    41a0:	5b 4f       	sbci	r21, 0xFB	; 251
    41a2:	60 e0       	ldi	r22, 0x00	; 0
    41a4:	ce 01       	movw	r24, r28
    41a6:	01 96       	adiw	r24, 0x01	; 1
    41a8:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    41ac:	81 11       	cpse	r24, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:279

    if (!got_ctx_id) {
    41ae:	07 c0       	rjmp	.+14     	; 0x41be <__DATA_REGION_LENGTH__+0x1be>
    41b0:	8c e5       	ldi	r24, 0x5C	; 92
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:280
        Log.error("No context ID!");
    41b2:	9b e4       	ldi	r25, 0x4B	; 75
    41b4:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:296
        digest,
        HCESIGN_DIGEST_LENGTH + 1,
        (char)NULL);

    if (!got_digest) {
        Log.error("No digest for signing request!");
    41b8:	81 ed       	ldi	r24, 0xD1	; 209
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:522

        SequansController.startCriticalSection();
        bool success = generateSigningCommand(urc, signing_request_buffer);

        if (success != true) {
            Log.error("Unable to handle signature request\r\n");
    41ba:	9b e4       	ldi	r25, 0x4B	; 75
    41bc:	b2 cf       	rjmp	.-156    	; 0x4122 <__DATA_REGION_LENGTH__+0x122>
generateSigningCommand():
    41be:	00 e0       	ldi	r16, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:293
    bool got_digest = SequansController.extractValueFromCommandResponse(
        data,
        3,
        digest,
        HCESIGN_DIGEST_LENGTH + 1,
        (char)NULL);
    41c0:	21 e4       	ldi	r18, 0x41	; 65
    41c2:	30 e0       	ldi	r19, 0x00	; 0
    41c4:	a4 01       	movw	r20, r8
    41c6:	63 e0       	ldi	r22, 0x03	; 3
    41c8:	ce 01       	movw	r24, r28
    41ca:	01 96       	adiw	r24, 0x01	; 1
    41cc:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    41d0:	f8 2e       	mov	r15, r24
    41d2:	81 11       	cpse	r24, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:295

    if (!got_digest) {
    41d4:	03 c0       	rjmp	.+6      	; 0x41dc <__DATA_REGION_LENGTH__+0x1dc>
    41d6:	8b e6       	ldi	r24, 0x6B	; 107
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:296
        Log.error("No digest for signing request!");
    41d8:	9b e4       	ldi	r25, 0x4B	; 75
    41da:	ec cf       	rjmp	.-40     	; 0x41b4 <__DATA_REGION_LENGTH__+0x1b4>
    41dc:	8e 01       	movw	r16, r28
    41de:	06 5d       	subi	r16, 0xD6	; 214
    41e0:	1b 4f       	sbci	r17, 0xFB	; 251
begin():
    41e2:	35 01       	movw	r6, r10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:302
        return false;
    }

    // Convert digest to 32 bytes
    uint8_t message_to_sign[HCESIGN_DIGEST_LENGTH / 2];
    char* position = digest;
    41e4:	e0 2e       	mov	r14, r16
    41e6:	cf 59       	subi	r28, 0x9F	; 159
    41e8:	db 4f       	sbci	r29, 0xFB	; 251
    41ea:	18 83       	st	Y, r17
    41ec:	c1 56       	subi	r28, 0x61	; 97
    41ee:	d4 40       	sbci	r29, 0x04	; 4
generateSigningCommand():
    41f0:	4a e8       	ldi	r20, 0x8A	; 138
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:306

    // Convert hex representation in string to numerical hex values
    for (uint8_t i = 0; i < sizeof(message_to_sign); i++) {
        sscanf(position, "%2hhx", &message_to_sign[i]);
    41f2:	84 2e       	mov	r8, r20
    41f4:	4b e4       	ldi	r20, 0x4B	; 75
    41f6:	94 2e       	mov	r9, r20
    41f8:	2e 01       	movw	r4, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:305
    // Convert digest to 32 bytes
    uint8_t message_to_sign[HCESIGN_DIGEST_LENGTH / 2];
    char* position = digest;

    // Convert hex representation in string to numerical hex values
    for (uint8_t i = 0; i < sizeof(message_to_sign); i++) {
    41fa:	b7 ed       	ldi	r27, 0xD7	; 215
    41fc:	4b 1a       	sub	r4, r27
    41fe:	bb ef       	ldi	r27, 0xFB	; 251
    4200:	5b 0a       	sbc	r5, r27
    4202:	1f 93       	push	r17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:306
        sscanf(position, "%2hhx", &message_to_sign[i]);
    4204:	0f 93       	push	r16
    4206:	9f 92       	push	r9
    4208:	8f 92       	push	r8
    420a:	7f 92       	push	r7
    420c:	6f 92       	push	r6
    420e:	0e 94 e4 57 	call	0xafc8	; 0xafc8 <sscanf>
    4212:	e2 e0       	ldi	r30, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:307
        position += 2;
    4214:	6e 0e       	add	r6, r30
    4216:	71 1c       	adc	r7, r1
    4218:	0f 5f       	subi	r16, 0xFF	; 255
    421a:	1f 4f       	sbci	r17, 0xFF	; 255
    421c:	0f 90       	pop	r0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:305
    // Convert digest to 32 bytes
    uint8_t message_to_sign[HCESIGN_DIGEST_LENGTH / 2];
    char* position = digest;

    // Convert hex representation in string to numerical hex values
    for (uint8_t i = 0; i < sizeof(message_to_sign); i++) {
    421e:	0f 90       	pop	r0
    4220:	0f 90       	pop	r0
    4222:	0f 90       	pop	r0
    4224:	0f 90       	pop	r0
    4226:	0f 90       	pop	r0
    4228:	64 14       	cp	r6, r4
    422a:	75 04       	cpc	r7, r5
    422c:	51 f7       	brne	.-44     	; 0x4202 <__DATA_REGION_LENGTH__+0x202>
    422e:	80 90 8a 66 	lds	r8, 0x668A	; 0x80668a <_gDevice>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:311
        sscanf(position, "%2hhx", &message_to_sign[i]);
        position += 2;
    }

    // Sign digest with ECC's primary private key
    ATCA_STATUS result = atcab_sign(0, message_to_sign, (uint8_t*)digest);
    4232:	90 90 8b 66 	lds	r9, 0x668B	; 0x80668b <_gDevice+0x1>
calib_sign_ext():
    4236:	c4 01       	movw	r24, r8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:159
#endif

#if CALIB_SIGN_EN || CALIB_SIGN_CA2_EN
ATCA_STATUS calib_sign_ext(ATCADevice device, uint16_t key_id, const uint8_t *msg, uint8_t *signature)
{
    ATCADeviceType devtype = atcab_get_device_type_ext(device);
    4238:	0e 94 51 09 	call	0x12a2	; 0x12a2 <atcab_get_device_type_ext>
    423c:	01 97       	sbiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:162
    ATCA_STATUS status = ATCA_BAD_PARAM;

    switch(devtype)
    423e:	03 97       	sbiw	r24, 0x03	; 3
    4240:	08 f0       	brcs	.+2      	; 0x4244 <__DATA_REGION_LENGTH__+0x244>
    4242:	fa c0       	rjmp	.+500    	; 0x4438 <__DATA_REGION_LENGTH__+0x438>
calib_sign():
    4244:	d4 01       	movw	r26, r8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:130
            break;
        }
#endif
#ifdef ATCA_ATECC608_SUPPORT
        // Load message into device
        if (ATECC608 == device->mIface.mIfaceCFG->devtype)
    4246:	ed 91       	ld	r30, X+
    4248:	fc 91       	ld	r31, X
    424a:	82 81       	ldd	r24, Z+2	; 0x02
    424c:	93 81       	ldd	r25, Z+3	; 0x03
    424e:	03 97       	sbiw	r24, 0x03	; 3
    4250:	e1 f4       	brne	.+56     	; 0x428a <__DATA_REGION_LENGTH__+0x28a>
begin():
    4252:	30 e2       	ldi	r19, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:134
        {
            // Use the Message Digest Buffer for the ATECC608
            nonce_target = NONCE_MODE_TARGET_MSGDIGBUF;
            sign_source = SIGN_MODE_SOURCE_MSGDIGBUF;
    4254:	73 2e       	mov	r7, r19
    4256:	80 e4       	ldi	r24, 0x40	; 64
calib_nonce_load():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:133
#ifdef ATCA_ATECC608_SUPPORT
        // Load message into device
        if (ATECC608 == device->mIface.mIfaceCFG->devtype)
        {
            // Use the Message Digest Buffer for the ATECC608
            nonce_target = NONCE_MODE_TARGET_MSGDIGBUF;
    4258:	83 60       	ori	r24, 0x03	; 3
calib_nonce_base():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_nonce.c:156
 *
 *  \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS calib_nonce_load(ATCADevice device, uint8_t target, const uint8_t *num_in, uint16_t num_in_size)
{
    uint8_t mode = NONCE_MODE_PASSTHROUGH | (NONCE_MODE_TARGET_MASK & target);
    425a:	81 14       	cp	r8, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_nonce.c:68
    ATCA_STATUS status = ATCA_GEN_FAIL;
    uint8_t nonce_mode = mode & NONCE_MODE_MASK;

    do
    {
        if (device == NULL)
    425c:	91 04       	cpc	r9, r1
    425e:	c1 f4       	brne	.+48     	; 0x4290 <__DATA_REGION_LENGTH__+0x290>
begin():
    4260:	82 ee       	ldi	r24, 0xE2	; 226
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_nonce.c:70
        {
            status = ATCA_TRACE(ATCA_BAD_PARAM, "NULL pointer received");
    4262:	90 e0       	ldi	r25, 0x00	; 0
generateSigningCommand():
    4264:	9f 93       	push	r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:314

    if (result != ATCA_SUCCESS) {
        Log.errorf("ECC signing failed, status code: %x\r\n", result);
    4266:	8f 93       	push	r24
    4268:	80 e9       	ldi	r24, 0x90	; 144
    426a:	9b e4       	ldi	r25, 0x4B	; 75
    426c:	9f 93       	push	r25
    426e:	8f 93       	push	r24
    4270:	89 e6       	ldi	r24, 0x69	; 105
    4272:	90 e7       	ldi	r25, 0x70	; 112
    4274:	9f 93       	push	r25
    4276:	8f 93       	push	r24
    4278:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    427c:	0f 90       	pop	r0
    427e:	0f 90       	pop	r0
    4280:	0f 90       	pop	r0
    4282:	0f 90       	pop	r0
    4284:	0f 90       	pop	r0
    4286:	0f 90       	pop	r0
    4288:	97 cf       	rjmp	.-210    	; 0x41b8 <__DATA_REGION_LENGTH__+0x1b8>
begin():
    428a:	71 2c       	mov	r7, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:116
 */
ATCA_STATUS calib_sign(ATCADevice device, uint16_t key_id, const uint8_t *msg, uint8_t *signature)
{
    ATCA_STATUS status = ATCA_GEN_FAIL;
    uint8_t nonce_target = NONCE_MODE_TARGET_TEMPKEY;
    uint8_t sign_source = SIGN_MODE_SOURCE_TEMPKEY;
    428c:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:115
 * \return ATCA_SUCCESS on success, otherwise an error code.
 */
ATCA_STATUS calib_sign(ATCADevice device, uint16_t key_id, const uint8_t *msg, uint8_t *signature)
{
    ATCA_STATUS status = ATCA_GEN_FAIL;
    uint8_t nonce_target = NONCE_MODE_TARGET_TEMPKEY;
    428e:	e4 cf       	rjmp	.-56     	; 0x4258 <__DATA_REGION_LENGTH__+0x258>
calib_nonce_base():
    4290:	8e 01       	movw	r16, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_nonce.c:75
            break;
        }

        // build a nonce command
        packet.param1 = mode;
    4292:	0e 57       	subi	r16, 0x7E	; 126
    4294:	1d 4f       	sbci	r17, 0xFD	; 253
    4296:	f8 01       	movw	r30, r16
    4298:	83 83       	std	Z+3, r24	; 0x03
    429a:	14 82       	std	Z+4, r1	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_nonce.c:76
        packet.param2 = param2;
    429c:	15 82       	std	Z+5, r1	; 0x05
    429e:	80 e2       	ldi	r24, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_nonce.c:92
            {
                memcpy(packet.data, num_in, 64);
            }
            else
            {
                memcpy(packet.data, num_in, 32);
    42a0:	ee 2d       	mov	r30, r14
    42a2:	cf 59       	subi	r28, 0x9F	; 159
    42a4:	db 4f       	sbci	r29, 0xFB	; 251
    42a6:	f8 81       	ld	r31, Y
    42a8:	c1 56       	subi	r28, 0x61	; 97
    42aa:	d4 40       	sbci	r29, 0x04	; 4
    42ac:	d8 01       	movw	r26, r16
    42ae:	16 96       	adiw	r26, 0x06	; 6
    42b0:	01 90       	ld	r0, Z+
    42b2:	0d 92       	st	X+, r0
    42b4:	8a 95       	dec	r24
    42b6:	e1 f7       	brne	.-8      	; 0x42b0 <__DATA_REGION_LENGTH__+0x2b0>
atNonce():
    42b8:	86 e1       	ldi	r24, 0x16	; 22
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:287

    // Set the opcode & parameters
    // variable packet size
    uint8_t calc_mode = packet->param1 & NONCE_MODE_MASK;

    packet->opcode = ATCA_NONCE;
    42ba:	d8 01       	movw	r26, r16
    42bc:	12 96       	adiw	r26, 0x02	; 2
    42be:	8c 93       	st	X, r24
    42c0:	12 97       	sbiw	r26, 0x02	; 2
    42c2:	27 e2       	ldi	r18, 0x27	; 39
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:305
            packet->txsize = NONCE_COUNT_LONG_64;
        }
        else
        {
            // 32 byte NumIn
            packet->txsize = NONCE_COUNT_LONG;
    42c4:	e2 2e       	mov	r14, r18
    42c6:	11 96       	adiw	r26, 0x01	; 1
    42c8:	ec 92       	st	X, r14
    42ca:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:312
    }
    else
    {
        return ATCA_TRACE(ATCA_BAD_PARAM, "atNonce - failed; Invalid mode received");
    }
    atCalcCrc(packet);
    42cc:	0e 94 c0 08 	call	0x1180	; 0x1180 <atCalcCrc>
calib_nonce_base():
    42d0:	b4 01       	movw	r22, r8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_nonce.c:106
        {
            ATCA_TRACE(status, "atNonce - failed");
            break;
        }

        if ((status = atca_execute_command(&packet, device)) != ATCA_SUCCESS)
    42d2:	c8 01       	movw	r24, r16
    42d4:	0e 94 96 11 	call	0x232c	; 0x232c <calib_execute_command>
    42d8:	00 97       	sbiw	r24, 0x00	; 0
    42da:	21 f6       	brne	.-120    	; 0x4264 <__DATA_REGION_LENGTH__+0x264>
calib_sign():
    42dc:	87 2d       	mov	r24, r7
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:144
            ATCA_TRACE(status, "calib_nonce_load - failed");
            break;
        }

        // Sign the message
        if ((status = calib_sign_base(device, SIGN_MODE_EXTERNAL | sign_source, key_id, signature)) != ATCA_SUCCESS)
    42de:	80 68       	ori	r24, 0x80	; 128
calib_sign_base():
    42e0:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:64
    }

    do
    {
        // Build sign command
        packet.param1 = mode;
    42e2:	83 83       	std	Z+3, r24	; 0x03
    42e4:	14 82       	std	Z+4, r1	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:65
        packet.param2 = key_id;
    42e6:	15 82       	std	Z+5, r1	; 0x05
    42e8:	c4 01       	movw	r24, r8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:66
        if ((status = atSign(atcab_get_device_type_ext(device), &packet)) != ATCA_SUCCESS)
    42ea:	0e 94 51 09 	call	0x12a2	; 0x12a2 <atcab_get_device_type_ext>
atSign():
    42ee:	21 e4       	ldi	r18, 0x41	; 65
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:477
 * \return ATCA_SUCCESS
 */
ATCA_STATUS atSign(ATCADeviceType device_type, ATCAPacket *packet)
{
    // Set the opcode & parameters
    packet->opcode = ATCA_SIGN;
    42f0:	d8 01       	movw	r26, r16
    42f2:	12 96       	adiw	r26, 0x02	; 2
    42f4:	2c 93       	st	X, r18
    42f6:	12 97       	sbiw	r26, 0x02	; 2
    42f8:	80 97       	sbiw	r24, 0x20	; 32
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:479
    packet->txsize = SIGN_COUNT;
    if ((ECC204 == device_type) || (TA010 == device_type))
    42fa:	02 97       	sbiw	r24, 0x02	; 2
    42fc:	a8 f0       	brcs	.+42     	; 0x4328 <__DATA_REGION_LENGTH__+0x328>
    42fe:	87 e0       	ldi	r24, 0x07	; 7
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:478
 */
ATCA_STATUS atSign(ATCADeviceType device_type, ATCAPacket *packet)
{
    // Set the opcode & parameters
    packet->opcode = ATCA_SIGN;
    packet->txsize = SIGN_COUNT;
    4300:	11 96       	adiw	r26, 0x01	; 1
    4302:	8c 93       	st	X, r24
    4304:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:483
    if ((ECC204 == device_type) || (TA010 == device_type))
    {
        packet->txsize += ATCA_SHA_DIGEST_SIZE;
    }
    atCalcCrc(packet);
    4306:	0e 94 c0 08 	call	0x1180	; 0x1180 <atCalcCrc>
calib_sign_base():
    430a:	b4 01       	movw	r22, r8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:72
        {
            ATCA_TRACE(status, "atSign - failed");
            break;
        }

        if ((status = atca_execute_command(&packet, device)) != ATCA_SUCCESS)
    430c:	c8 01       	movw	r24, r16
    430e:	0e 94 96 11 	call	0x232c	; 0x232c <calib_execute_command>
    4312:	00 97       	sbiw	r24, 0x00	; 0
    4314:	09 f0       	breq	.+2      	; 0x4318 <__DATA_REGION_LENGTH__+0x318>
    4316:	a6 cf       	rjmp	.-180    	; 0x4264 <__DATA_REGION_LENGTH__+0x264>
    4318:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:80
            break;
        }

        if (signature != NULL)
        {
            if (packet.data[ATCA_COUNT_IDX] == (ATCA_SIG_SIZE + ATCA_PACKET_OVERHEAD))
    431a:	16 96       	adiw	r26, 0x06	; 6
    431c:	8c 91       	ld	r24, X
    431e:	83 34       	cpi	r24, 0x43	; 67
    4320:	31 f0       	breq	.+12     	; 0x432e <__DATA_REGION_LENGTH__+0x32e>
begin():
    4322:	86 ee       	ldi	r24, 0xE6	; 230
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:86
            {
                memcpy(signature, &packet.data[ATCA_RSP_DATA_IDX], ATCA_SIG_SIZE);
            }
            else
            {
                status = ATCA_RX_FAIL;
    4324:	90 e0       	ldi	r25, 0x00	; 0
    4326:	9e cf       	rjmp	.-196    	; 0x4264 <__DATA_REGION_LENGTH__+0x264>
atSign():
    4328:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_command.c:481
    // Set the opcode & parameters
    packet->opcode = ATCA_SIGN;
    packet->txsize = SIGN_COUNT;
    if ((ECC204 == device_type) || (TA010 == device_type))
    {
        packet->txsize += ATCA_SHA_DIGEST_SIZE;
    432a:	e1 82       	std	Z+1, r14	; 0x01
    432c:	eb cf       	rjmp	.-42     	; 0x4304 <__DATA_REGION_LENGTH__+0x304>
calib_sign_base():
    432e:	80 e4       	ldi	r24, 0x40	; 64
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:82

        if (signature != NULL)
        {
            if (packet.data[ATCA_COUNT_IDX] == (ATCA_SIG_SIZE + ATCA_PACKET_OVERHEAD))
            {
                memcpy(signature, &packet.data[ATCA_RSP_DATA_IDX], ATCA_SIG_SIZE);
    4330:	f8 01       	movw	r30, r16
    4332:	37 96       	adiw	r30, 0x07	; 7
    4334:	d5 01       	movw	r26, r10
    4336:	01 90       	ld	r0, Z+
    4338:	0d 92       	st	X+, r0
    433a:	8a 95       	dec	r24
    433c:	e1 f7       	brne	.-8      	; 0x4336 <__DATA_REGION_LENGTH__+0x336>
generateSigningCommand():
    433e:	81 e1       	ldi	r24, 0x11	; 17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:320
        return false;
    }

    // Now we need to convert the byte array into a hex string in
    // compact form
    const char hex_conversion[] = "0123456789abcdef";
    4340:	e6 ef       	ldi	r30, 0xF6	; 246
    4342:	fb e4       	ldi	r31, 0x4B	; 75
    4344:	de 01       	movw	r26, r28
    4346:	a6 5b       	subi	r26, 0xB6	; 182
    4348:	bb 4f       	sbci	r27, 0xFB	; 251
    434a:	01 90       	ld	r0, Z+
    434c:	0d 92       	st	X+, r0
    434e:	8a 95       	dec	r24
    4350:	e1 f7       	brne	.-8      	; 0x434a <__DATA_REGION_LENGTH__+0x34a>
    4352:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:323

    // +1 for NULL termination
    char signature[HCESIGN_DIGEST_LENGTH * 2 + 1] = "";
    4354:	11 92       	st	Z+, r1
    4356:	11 92       	st	Z+, r1
    4358:	8f e7       	ldi	r24, 0x7F	; 127
    435a:	df 01       	movw	r26, r30
    435c:	1d 92       	st	X+, r1
    435e:	8a 95       	dec	r24
    4360:	e9 f7       	brne	.-6      	; 0x435c <__DATA_REGION_LENGTH__+0x35c>
    4362:	d8 01       	movw	r26, r16
    4364:	f5 01       	movw	r30, r10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:327

    // Prepare signature by converting to a hex string
    for (uint8_t i = 0; i < sizeof(digest) - 1; i++) {
        signature[i * 2]     = hex_conversion[(digest[i] >> 4) & 0x0F];
    4366:	81 91       	ld	r24, Z+
    4368:	5f 01       	movw	r10, r30
    436a:	e8 2f       	mov	r30, r24
    436c:	08 2e       	mov	r0, r24
    436e:	00 0c       	add	r0, r0
    4370:	ff 0b       	sbc	r31, r31
    4372:	94 e0       	ldi	r25, 0x04	; 4
    4374:	f5 95       	asr	r31
    4376:	e7 95       	ror	r30
    4378:	9a 95       	dec	r25
    437a:	e1 f7       	brne	.-8      	; 0x4374 <__DATA_REGION_LENGTH__+0x374>
    437c:	ef 70       	andi	r30, 0x0F	; 15
    437e:	ff 27       	eor	r31, r31
    4380:	2a e4       	ldi	r18, 0x4A	; 74
    4382:	34 e0       	ldi	r19, 0x04	; 4
    4384:	2c 0f       	add	r18, r28
    4386:	3d 1f       	adc	r19, r29
    4388:	e2 0f       	add	r30, r18
    438a:	f3 1f       	adc	r31, r19
    438c:	90 81       	ld	r25, Z
    438e:	9c 93       	st	X, r25
    4390:	e8 2f       	mov	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:328
        signature[i * 2 + 1] = hex_conversion[digest[i] & 0x0F];
    4392:	ef 70       	andi	r30, 0x0F	; 15
    4394:	a9 01       	movw	r20, r18
    4396:	4e 0f       	add	r20, r30
    4398:	51 1d       	adc	r21, r1
    439a:	fa 01       	movw	r30, r20
    439c:	80 81       	ld	r24, Z
    439e:	11 96       	adiw	r26, 0x01	; 1
    43a0:	8c 93       	st	X, r24
    43a2:	11 97       	sbiw	r26, 0x01	; 1
    43a4:	12 96       	adiw	r26, 0x02	; 2
    43a6:	4a 14       	cp	r4, r10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:326

    // +1 for NULL termination
    char signature[HCESIGN_DIGEST_LENGTH * 2 + 1] = "";

    // Prepare signature by converting to a hex string
    for (uint8_t i = 0; i < sizeof(digest) - 1; i++) {
    43a8:	5b 04       	cpc	r5, r11
    43aa:	e1 f6       	brne	.-72     	; 0x4364 <__DATA_REGION_LENGTH__+0x364>
    43ac:	ce 5f       	subi	r28, 0xFE	; 254
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:332
        signature[i * 2]     = hex_conversion[(digest[i] >> 4) & 0x0F];
        signature[i * 2 + 1] = hex_conversion[digest[i] & 0x0F];
    }

    // NULL terminate
    signature[HCESIGN_DIGEST_LENGTH * 2] = 0;
    43ae:	dc 4f       	sbci	r29, 0xFC	; 252
    43b0:	18 82       	st	Y, r1
    43b2:	c2 50       	subi	r28, 0x02	; 2
    43b4:	d3 40       	sbci	r29, 0x03	; 3
    43b6:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:333
    sprintf(command_buffer, HCESIGN, atoi(ctx_id_buffer), signature);
    43b8:	85 5a       	subi	r24, 0xA5	; 165
    43ba:	9b 4f       	sbci	r25, 0xFB	; 251
    43bc:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
    43c0:	1f 93       	push	r17
    43c2:	0f 93       	push	r16
    43c4:	9f 93       	push	r25
    43c6:	8f 93       	push	r24
    43c8:	86 eb       	ldi	r24, 0xB6	; 182
    43ca:	9b e4       	ldi	r25, 0x4B	; 75
    43cc:	9f 93       	push	r25
    43ce:	8f 93       	push	r24
    43d0:	df 92       	push	r13
    43d2:	cf 92       	push	r12
    43d4:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
begin():
    43d8:	f6 01       	movw	r30, r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:526
        if (success != true) {
            Log.error("Unable to handle signature request\r\n");
            return false;
        }

        SequansController.writeBytes((uint8_t*)signing_request_buffer,
    43da:	01 90       	ld	r0, Z+
    43dc:	00 20       	and	r0, r0
    43de:	e9 f7       	brne	.-6      	; 0x43da <__DATA_REGION_LENGTH__+0x3da>
    43e0:	31 97       	sbiw	r30, 0x01	; 1
    43e2:	bf 01       	movw	r22, r30
    43e4:	6c 19       	sub	r22, r12
    43e6:	7d 09       	sbc	r23, r13
    43e8:	41 e0       	ldi	r20, 0x01	; 1
    43ea:	c6 01       	movw	r24, r12
    43ec:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
stopCriticalSection():
    43f0:	10 92 89 66 	sts	0x6689, r1	; 0x806689 <critical_section_enabled>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1081
}

void SequansControllerClass::stopCriticalSection(void) {
    critical_section_enabled = false;
    43f4:	80 e8       	ldi	r24, 0x80	; 128
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:1082
    RTS_PORT.OUTCLR          = RTS_PIN_bm;
    43f6:	80 93 46 04 	sts	0x0446, r24	; 0x800446 <__TEXT_REGION_LENGTH__+0x7e0446>
begin():
    43fa:	8d b7       	in	r24, 0x3d	; 61
    43fc:	9e b7       	in	r25, 0x3e	; 62
    43fe:	08 96       	adiw	r24, 0x08	; 8
    4400:	8d bf       	out	0x3d, r24	; 61
    4402:	9e bf       	out	0x3e, r25	; 62
    4404:	8f 2d       	mov	r24, r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:534

        SequansController.stopCriticalSection();
    }

    return true;
}
    4406:	2d be       	out	0x3d, r2	; 61
    4408:	3e be       	out	0x3e, r3	; 62
    440a:	cf 59       	subi	r28, 0x9F	; 159
    440c:	db 4f       	sbci	r29, 0xFB	; 251
    440e:	cd bf       	out	0x3d, r28	; 61
    4410:	de bf       	out	0x3e, r29	; 62
    4412:	df 91       	pop	r29
    4414:	cf 91       	pop	r28
    4416:	1f 91       	pop	r17
    4418:	0f 91       	pop	r16
    441a:	ff 90       	pop	r15
    441c:	ef 90       	pop	r14
    441e:	df 90       	pop	r13
    4420:	cf 90       	pop	r12
    4422:	bf 90       	pop	r11
    4424:	af 90       	pop	r10
    4426:	9f 90       	pop	r9
    4428:	8f 90       	pop	r8
    442a:	7f 90       	pop	r7
    442c:	6f 90       	pop	r6
    442e:	5f 90       	pop	r5
    4430:	4f 90       	pop	r4
    4432:	3f 90       	pop	r3
    4434:	2f 90       	pop	r2
    4436:	08 95       	ret
    4438:	85 ef       	ldi	r24, 0xF5	; 245
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_sign.c:182
        case TA010:
            status = calib_ca2_sign(device, key_id, msg, signature);
            break;
#endif
        default:
            status = ATCA_UNIMPLEMENTED;
    443a:	90 e0       	ldi	r25, 0x00	; 0
    443c:	13 cf       	rjmp	.-474    	; 0x4264 <__DATA_REGION_LENGTH__+0x264>

0000443e <_pinconfigure(unsigned char, unsigned int)>:
__pinconfigure():
    443e:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:34
  checkCore(1);
}
#endif
void __pinconfigure(const uint8_t digital_pin, uint16_t pin_config) {

  uint8_t bit_mask = digitalPinToBitMask(digital_pin);
    4440:	fc 01       	movw	r30, r24
    4442:	ed 5b       	subi	r30, 0xBD	; 189
    4444:	fd 4b       	sbci	r31, 0xBD	; 189
    4446:	30 81       	ld	r19, Z
    4448:	3f 3f       	cpi	r19, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:35
  if(bit_mask == NOT_A_PIN || !pin_config) { // Return if digital pin is invalid or the other parameters or out to zero
    444a:	61 f1       	breq	.+88     	; 0x44a4 <_pinconfigure(unsigned char, unsigned int)+0x66>
    444c:	fc 01       	movw	r30, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:38
    return;
  }
  uint8_t bit_pos  = digitalPinToBitPosition(digital_pin);
    444e:	eb 56       	subi	r30, 0x6B	; 107
    4450:	fd 4b       	sbci	r31, 0xBD	; 189
    4452:	20 81       	ld	r18, Z
    4454:	84 59       	subi	r24, 0x94	; 148
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:39
  volatile uint8_t *portbase = (volatile uint8_t*) digitalPinToPortStruct(digital_pin);
    4456:	9d 4b       	sbci	r25, 0xBD	; 189
    4458:	dc 01       	movw	r26, r24
    445a:	ec 91       	ld	r30, X
    445c:	b0 e2       	ldi	r27, 0x20	; 32
    445e:	eb 9f       	mul	r30, r27
    4460:	f0 01       	movw	r30, r0
    4462:	11 24       	eor	r1, r1
    4464:	fc 5f       	subi	r31, 0xFC	; 252
    4466:	a6 2f       	mov	r26, r22
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:42

  // Write to selected pin direction register
  uint8_t setting = pin_config & 0x03; // Mask out direction bits (DIR, DIRSET, DIRCLR, DIRTGL)
    4468:	a3 70       	andi	r26, 0x03	; 3
    446a:	21 f0       	breq	.+8      	; 0x4474 <_pinconfigure(unsigned char, unsigned int)+0x36>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:43
  if(setting)
    446c:	ae 0f       	add	r26, r30
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:44
    *(portbase + setting) = bit_mask;
    446e:	bf 2f       	mov	r27, r31
    4470:	b1 1d       	adc	r27, r1
    4472:	3c 93       	st	X, r19
    4474:	3f b7       	in	r19, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:64
   * For this we need to disable interrupts
   * (for efficiency) we only read the register once
   * modify that value, then write it back at the end.
   */

  uint8_t oldSREG = SREG;             // Store SREG
    4476:	f8 94       	cli
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:65
  cli();
    4478:	84 e0       	ldi	r24, 0x04	; 4
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:66
  pin_config >>= 2;
    447a:	76 95       	lsr	r23
    447c:	67 95       	ror	r22
    447e:	8a 95       	dec	r24
    4480:	e1 f7       	brne	.-8      	; 0x447a <_pinconfigure(unsigned char, unsigned int)+0x3c>
    4482:	82 2f       	mov	r24, r18
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:67
  uint8_t pinncfg = *(portbase + 0x10 + bit_pos);
    4484:	90 e0       	ldi	r25, 0x00	; 0
    4486:	40 96       	adiw	r24, 0x10	; 16
    4488:	e8 0f       	add	r30, r24
    448a:	f9 1f       	adc	r31, r25
    448c:	80 81       	ld	r24, Z
    448e:	63 ff       	sbrs	r22, 3
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:69
  // Input sense configuration (ISC)
  if (pin_config & 0x08) {
    4490:	04 c0       	rjmp	.+8      	; 0x449a <_pinconfigure(unsigned char, unsigned int)+0x5c>
    4492:	88 7f       	andi	r24, 0xF8	; 248
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:70
    pinncfg = (pinncfg & 0xF8) | (pin_config & PORT_ISC_gm);
    4494:	96 2f       	mov	r25, r22
    4496:	97 70       	andi	r25, 0x07	; 7
    4498:	89 2b       	or	r24, r25
    449a:	60 73       	andi	r22, 0x30	; 48
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:73
  }
  // Pullup resistor
  uint8_t temp = pin_config & 0x30;
    449c:	09 f0       	breq	.+2      	; 0x44a0 <_pinconfigure(unsigned char, unsigned int)+0x62>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:74
  if(temp) {                          // Toggle of pullup? I guess...
    449e:	88 60       	ori	r24, 0x08	; 8
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:80
    if(temp == 0x30) {
      pinncfg ^= PORT_PULLUPEN_bm;    // Toggle pullup
    } else if(temp == 0x20) {
      pinncfg &= ~(PORT_PULLUPEN_bm); // Clear pullup
    } else {
      pinncfg |= PORT_PULLUPEN_bm;    // Set pullup
    44a0:	80 83       	st	Z, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:116
      pinncfg &= ~(PORT_INVEN_bm);    // Clear INVEN
    else
      pinncfg |= PORT_INVEN_bm;       // Set INVEN
  }
  // Write to PINnCTRL register
  *(portbase + 0x10 + bit_pos) = pinncfg;
    44a2:	3f bf       	out	0x3f, r19	; 63
_pinconfigure():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:119

  // Restore SREG
  SREG = oldSREG;
    44a4:	08 95       	ret

000044a6 <digitalWrite>:
digitalWrite():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:151
        }
      }
    }
  #endif
  __pinconfigure(pin, pin_config);
}
    44a6:	0f 93       	push	r16
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:209
  default:
    break;
  }
}

void digitalWrite(uint8_t pin, uint8_t val) {
    44a8:	1f 93       	push	r17
    44aa:	cf 93       	push	r28
    44ac:	df 93       	push	r29
    44ae:	89 32       	cpi	r24, 0x29	; 41
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:212
  check_valid_digital_pin(pin);
  /* Get bit mask for pin */
  uint8_t bit_mask = digitalPinToBitMask(pin);
    44b0:	08 f0       	brcs	.+2      	; 0x44b4 <digitalWrite+0xe>
    44b2:	c4 c0       	rjmp	.+392    	; 0x463c <digitalWrite+0x196>
check_valid_digital_pin():
    44b4:	90 e0       	ldi	r25, 0x00	; 0
digitalWrite():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/Arduino.h:712
  #if !defined(NUM_TOTAL_PINS)
    #define NUM_TOTAL_PINS                (NUM_DIGITAL_PINS) /* Used the same way as NUM_DIGITAL_PINS. so it doesn't mean what it's named  - I didn't make the convention*/
  #endif

inline __attribute__((always_inline)) void check_valid_digital_pin(pin_size_t pin) {
  if (__builtin_constant_p(pin)) {
    44b6:	dc 01       	movw	r26, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:212
    44b8:	ad 5b       	subi	r26, 0xBD	; 189
    44ba:	bd 4b       	sbci	r27, 0xBD	; 189
    44bc:	2c 91       	ld	r18, X
    44be:	2f 3f       	cpi	r18, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:213
  if (bit_mask == NOT_A_PIN) {
    44c0:	09 f4       	brne	.+2      	; 0x44c4 <digitalWrite+0x1e>
    44c2:	bc c0       	rjmp	.+376    	; 0x463c <digitalWrite+0x196>
    44c4:	8c 01       	movw	r16, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:218
    return;
  }

  /* Get port */
  PORT_t *port = digitalPinToPortStruct(pin);
    44c6:	04 59       	subi	r16, 0x94	; 148
    44c8:	1d 4b       	sbci	r17, 0xBD	; 189
    44ca:	e8 01       	movw	r28, r16
    44cc:	e8 81       	ld	r30, Y
    44ce:	d0 e2       	ldi	r29, 0x20	; 32
    44d0:	ed 9f       	mul	r30, r29
    44d2:	f0 01       	movw	r30, r0
    44d4:	11 24       	eor	r1, r1
    44d6:	fc 5f       	subi	r31, 0xFC	; 252
    44d8:	61 11       	cpse	r22, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:226
  the behavior of digitalWrite() on classic AVR devices, where
  you could digitalWrite() a pin while it's an input, to ensure
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    44da:	33 c0       	rjmp	.+102    	; 0x4542 <digitalWrite+0x9c>
    44dc:	26 83       	std	Z+6, r18	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:227
    port->OUTCLR = bit_mask;
    44de:	30 81       	ld	r19, Z
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:251
  } else {
    port->OUTSET = bit_mask;
  }

  /* Input direction */
  if (!(port->DIR & bit_mask)) {
    44e0:	23 23       	and	r18, r19
    44e2:	ac 01       	movw	r20, r24
    44e4:	4b 56       	subi	r20, 0x6B	; 107
    44e6:	5d 4b       	sbci	r21, 0xBD	; 189
    44e8:	21 11       	cpse	r18, r1
    44ea:	11 c0       	rjmp	.+34     	; 0x450e <digitalWrite+0x68>
    44ec:	ea 01       	movw	r28, r20
    44ee:	28 81       	ld	r18, Y
    44f0:	30 97       	sbiw	r30, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:261

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
    44f2:	81 f1       	breq	.+96     	; 0x4554 <digitalWrite+0xae>
    44f4:	28 30       	cpi	r18, 0x08	; 8
    44f6:	70 f5       	brcc	.+92     	; 0x4554 <digitalWrite+0xae>
    44f8:	70 96       	adiw	r30, 0x10	; 16
    44fa:	e2 0f       	add	r30, r18
    44fc:	f1 1d       	adc	r31, r1
    44fe:	3f b7       	in	r19, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:264

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    4500:	f8 94       	cli
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:265
    cli();
    4502:	20 81       	ld	r18, Z
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:269

    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    4504:	61 11       	cpse	r22, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:267

    /* Save system status and disable interrupts */
    uint8_t status = SREG;
    cli();

    if (val == LOW) {
    4506:	29 c0       	rjmp	.+82     	; 0x455a <digitalWrite+0xb4>
    4508:	27 7f       	andi	r18, 0xF7	; 247
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:269
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    450a:	20 83       	st	Z, r18
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:272
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
    450c:	3f bf       	out	0x3f, r19	; 63
digitalPinToTimerNow():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:276
    }

    /* Restore system status */
    SREG = status;
    450e:	fa 01       	movw	r30, r20
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:771
  badCall("Resuming core control of type D timer not supported.");
}


uint8_t digitalPinToTimerNow(uint8_t p) {
  uint8_t bit_pos = digitalPinToBitPosition(p);
    4510:	30 81       	ld	r19, Z
    4512:	3f 3f       	cpi	r19, 0xFF	; 255
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:772
  if (bit_pos == NOT_A_PIN) return NOT_ON_TIMER;     /* Use bit position to check for invalid pins */
    4514:	09 f4       	brne	.+2      	; 0x4518 <digitalWrite+0x72>
    4516:	92 c0       	rjmp	.+292    	; 0x463c <digitalWrite+0x196>
    4518:	e8 01       	movw	r28, r16
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:773
  uint8_t port = digitalPinToPort(p);                /* If bit_pos is valid, port will be too      */
    451a:	28 81       	ld	r18, Y
    451c:	36 30       	cpi	r19, 0x06	; 6
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:774
  if ( bit_pos < 6) {                                /* SPLIT MODE TCA output is on pins 0-5       */
    451e:	90 f5       	brcc	.+100    	; 0x4584 <digitalWrite+0xde>
    4520:	30 91 e6 05 	lds	r19, 0x05E6	; 0x8005e6 <__TEXT_REGION_LENGTH__+0x7e05e6>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:776
  #if defined(TCA1)
    uint8_t tcamux = PORTMUX.TCAROUTEA;
    4524:	43 2f       	mov	r20, r19
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:778
    if ( __PeripheralControl & TIMERA0) {              /* make sure user hasn't taken over TCA0      */
      if (((tcamux & PORTMUX_TCA0_gm) == port)) {    /* TCA0 mux is EASY - same as the port number */
    4526:	47 70       	andi	r20, 0x07	; 7
    4528:	24 13       	cpse	r18, r20
    452a:	19 c0       	rjmp	.+50     	; 0x455e <digitalWrite+0xb8>
turnOffPWM():
    452c:	ec 91       	ld	r30, X
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    452e:	e5 30       	cpi	r30, 0x05	; 5
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:128
  switch (timer) {

  /* TCA0 */
  case TIMERA0:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; // there's a blank bit in the middle
    4530:	08 f0       	brcs	.+2      	; 0x4534 <digitalWrite+0x8e>
    4532:	ee 0f       	add	r30, r30
    4534:	80 91 01 0a 	lds	r24, 0x0A01	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7e0a01>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:130
    /* Disable corresponding channel */
    TCA0.SPLIT.CTRLB &= ~bit_mask;
    4538:	e0 95       	com	r30
    453a:	e8 23       	and	r30, r24
    453c:	e0 93 01 0a 	sts	0x0A01, r30	; 0x800a01 <__TEXT_REGION_LENGTH__+0x7e0a01>
    4540:	7d c0       	rjmp	.+250    	; 0x463c <digitalWrite+0x196>
digitalWrite():
    4542:	64 30       	cpi	r22, 0x04	; 4
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:228
  that the value of the port was set correctly when it was
  changed to an output. Code in the wild relies on this behavior. */

  if (val == LOW) { /* If LOW */
    port->OUTCLR = bit_mask;
  } else if (val == CHANGE) { /* If TOGGLE
    4544:	29 f4       	brne	.+10     	; 0x4550 <digitalWrite+0xaa>
    4546:	34 81       	ldd	r19, Z+4	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:235
     * we need to know if it's been set high or low
     * otherwise the pullup state could get out of
     * sync with the output bit. Annoying! But we should
     * have to read it before writing OUTTGL, since that can
     * have a 1 clock delay. So read first + invert */
    val = !(port->OUT & bit_mask);
    4548:	27 83       	std	Z+7, r18	; 0x07
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:236
    port->OUTTGL = bit_mask;
    454a:	64 81       	ldd	r22, Z+4	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:241
    // Now, for the pullup setting part below
    // we need to know if it's been set high or low
    // otherwise the pullup state could get out of
    // sync with the output bit. Annoying!
    val = port->OUT & bit_mask;
    454c:	62 23       	and	r22, r18
    454e:	c7 cf       	rjmp	.-114    	; 0x44de <digitalWrite+0x38>
    4550:	25 83       	std	Z+5, r18	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:247
    // val will now be 0 (LOW) if the toggling made it LOW
    // or bit_mask if not. And further down, we only need to
    // know if it's
  /* If HIGH OR  > TOGGLE  */
  } else {
    port->OUTSET = bit_mask;
    4552:	c5 cf       	rjmp	.-118    	; 0x44de <digitalWrite+0x38>
    4554:	f0 e0       	ldi	r31, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:261

    /* Get bit position for getting pin ctrl reg */
    uint8_t bit_pos = digitalPinToBitPosition(pin);

    /* Calculate where pin control register is */
    volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(port, bit_pos);
    4556:	e0 e0       	ldi	r30, 0x00	; 0
    4558:	d2 cf       	rjmp	.-92     	; 0x44fe <digitalWrite+0x58>
    455a:	28 60       	ori	r18, 0x08	; 8
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:272
    if (val == LOW) {
      /* Disable pullup */
      *pin_ctrl_reg &= ~PORT_PULLUPEN_bm;
    } else {
      /* Enable pull-up */
      *pin_ctrl_reg |= PORT_PULLUPEN_bm;
    455c:	d6 cf       	rjmp	.-84     	; 0x450a <digitalWrite+0x64>
digitalPinToTimerNow():
    455e:	38 71       	andi	r19, 0x18	; 24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:782
        return TIMERA0;
      }
    }
    tcamux &= 0x18;
    4560:	69 f4       	brne	.+26     	; 0x457c <digitalWrite+0xd6>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:784
    if (__PeripheralControl & TIMERA1) {               /* make sure user hasn't taken over TCA0      */
      if ((tcamux == 0 && port == PB ) || (tcamux == 0x18 && port == PG)) { /* supports only 6-ch  */
    4562:	21 30       	cpi	r18, 0x01	; 1
    4564:	79 f4       	brne	.+30     	; 0x4584 <digitalWrite+0xde>
turnOffPWM():
    4566:	ec 91       	ld	r30, X
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    4568:	e5 30       	cpi	r30, 0x05	; 5
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:135
    TCA0.SPLIT.CTRLB &= ~bit_mask;
    break;
  #ifdef TCA1
  case TIMERA1:
    /* Bit position will give output channel */
    if (bit_mask > 0x04)  bit_mask <<= 1; // there's a blank bit in the middle
    456a:	08 f0       	brcs	.+2      	; 0x456e <digitalWrite+0xc8>
    456c:	ee 0f       	add	r30, r30
    456e:	80 91 41 0a 	lds	r24, 0x0A41	; 0x800a41 <__TEXT_REGION_LENGTH__+0x7e0a41>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:137
    /* Disable corresponding channel */
    TCA1.SPLIT.CTRLB &= ~bit_mask;
    4572:	e0 95       	com	r30
    4574:	e8 23       	and	r30, r24
    4576:	e0 93 41 0a 	sts	0x0A41, r30	; 0x800a41 <__TEXT_REGION_LENGTH__+0x7e0a41>
    457a:	60 c0       	rjmp	.+192    	; 0x463c <digitalWrite+0x196>
digitalPinToTimerNow():
    457c:	38 31       	cpi	r19, 0x18	; 24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:784
    457e:	11 f4       	brne	.+4      	; 0x4584 <digitalWrite+0xde>
    4580:	26 30       	cpi	r18, 0x06	; 6
    4582:	89 f3       	breq	.-30     	; 0x4566 <digitalWrite+0xc0>
    4584:	86 5e       	subi	r24, 0xE6	; 230
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:796
        return TIMERA0;
      }
    }
  #endif
  }
  uint8_t timer = digitalPinToTimer(p);
    4586:	9d 4b       	sbci	r25, 0xBD	; 189
    4588:	fc 01       	movw	r30, r24
    458a:	80 81       	ld	r24, Z
    458c:	86 ff       	sbrs	r24, 6
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:799

  if ( __PeripheralControl & TIMERD0) {
    if (timer & TIMERD0) {
    458e:	3d c0       	rjmp	.+122    	; 0x460a <digitalWrite+0x164>
    4590:	90 91 e8 05 	lds	r25, 0x05E8	; 0x8005e8 <__TEXT_REGION_LENGTH__+0x7e05e8>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:800
      byte tcdmux = (PORTMUX.TCDROUTEA & PORTMUX_TCD0_gm);
    4594:	97 70       	andi	r25, 0x07	; 7
    4596:	48 2f       	mov	r20, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:799
  #endif
  }
  uint8_t timer = digitalPinToTimer(p);

  if ( __PeripheralControl & TIMERD0) {
    if (timer & TIMERD0) {
    4598:	50 e0       	ldi	r21, 0x00	; 0
    459a:	4f 7b       	andi	r20, 0xBF	; 191
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:801
      byte tcdmux = (PORTMUX.TCDROUTEA & PORTMUX_TCD0_gm);
      if (tcdmux == (timer & ~TIMERD0)) {
    459c:	94 17       	cp	r25, r20
    459e:	15 06       	cpc	r1, r21
    45a0:	a1 f5       	brne	.+104    	; 0x460a <digitalWrite+0x164>
turnOffPWM():
    45a2:	ec 91       	ld	r30, X
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    45a4:	80 91 92 0b 	lds	r24, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:171
        // on the DA series, it could be any of them
        #if !defined(ERRATA_TCD_PORTMUX) || ERRATA_TCD_PORTMUX == 0
          //                                Px4-Px7
          uint8_t fcset = TCD0.FAULTCTRL & (bit_mask > 0x0F ? bit_mask : bit_mask << 4 ); // hopefully that gets rendereed as swap, not 4 leftshifts
        #else
          uint8_t fcset = TCD0.FAULTCTRL & bit_mask;
    45a8:	8e 23       	and	r24, r30
    45aa:	09 f4       	brne	.+2      	; 0x45ae <digitalWrite+0x108>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:174
        #endif
      #endif
      if (fcset) {
    45ac:	47 c0       	rjmp	.+142    	; 0x463c <digitalWrite+0x196>
    45ae:	c0 e2       	ldi	r28, 0x20	; 32
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:179
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
    45b0:	2c 9f       	mul	r18, r28
    45b2:	90 01       	movw	r18, r0
    45b4:	11 24       	eor	r1, r1
    45b6:	3c 5f       	subi	r19, 0xFC	; 252
    45b8:	e8 30       	cpi	r30, 0x08	; 8
    45ba:	08 f0       	brcs	.+2      	; 0x45be <digitalWrite+0x118>
    45bc:	55 c0       	rjmp	.+170    	; 0x4668 <digitalWrite+0x1c2>
    45be:	20 5f       	subi	r18, 0xF0	; 240
    45c0:	3f 4f       	sbci	r19, 0xFF	; 255
    45c2:	e2 0f       	add	r30, r18
    45c4:	f3 2f       	mov	r31, r19
    45c6:	f1 1d       	adc	r31, r1
    45c8:	4f b7       	in	r20, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:188
        // it was currently set to output PWM, so it's very hard to imagine triggering it with just innocent calls to digitalWrite
        // in a constructor - we do not promise core functions will behave if users are reconfiguring peripherals in arbitrary ways.
        // Starting pwm manually (analogWrite won't start it until init starts the timers) in a constructor and then digitalWriting the same pin,
        // when the pin uses TCD0 for PWM is not expected to to produce correct behavior. If you modify the configuration except as described in
        // REF_TCD.md, you must takeOverTCD0() and assume full responsibility for all TCD configuration.
        uint8_t oldSREG = SREG;
    45ca:	f8 94       	cli
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:189
        cli();
    45cc:	90 91 80 0b 	lds	r25, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:190
        TCD0.CTRLA &= ~TCD_ENABLE_bm; // stop the timer
    45d0:	9e 7f       	andi	r25, 0xFE	; 254
    45d2:	90 93 80 0b 	sts	0x0B80, r25	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
    45d6:	90 91 8e 0b 	lds	r25, 0x0B8E	; 0x800b8e <__TEXT_REGION_LENGTH__+0x7e0b8e>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:192
        // Experimentally found ENRDY must be set set to configure FAULTCTRL
        while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
    45da:	90 ff       	sbrs	r25, 0
    45dc:	fc cf       	rjmp	.-8      	; 0x45d6 <digitalWrite+0x130>
    45de:	20 91 92 0b 	lds	r18, 0x0B92	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:193
        _PROTECTED_WRITE(TCD0.FAULTCTRL,TCD0.FAULTCTRL & ~fcset);
    45e2:	90 e0       	ldi	r25, 0x00	; 0
    45e4:	80 95       	com	r24
    45e6:	90 95       	com	r25
    45e8:	30 e0       	ldi	r19, 0x00	; 0
    45ea:	82 23       	and	r24, r18
    45ec:	93 23       	and	r25, r19
    45ee:	28 ed       	ldi	r18, 0xD8	; 216
    45f0:	24 bf       	out	0x34, r18	; 52
    45f2:	80 93 92 0b 	sts	0x0B92, r24	; 0x800b92 <__TEXT_REGION_LENGTH__+0x7e0b92>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:195
        // while(!(TCD0.STATUS & 0x01));    // wait until it can be re-enabled
        TCD0.CTRLA |= TCD_ENABLE_bm;  // re-enable it
    45f6:	80 91 80 0b 	lds	r24, 0x0B80	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
    45fa:	81 60       	ori	r24, 0x01	; 1
    45fc:	80 93 80 0b 	sts	0x0B80, r24	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:197
        #if defined(NO_GLITCH_TIMERD0)
          *pin_ctrl_reg &= ~(PORT_INVEN_bm);
    4600:	80 81       	ld	r24, Z
    4602:	8f 77       	andi	r24, 0x7F	; 127
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:199
        #endif
        SREG = oldSREG;
    4604:	80 83       	st	Z, r24
    4606:	4f bf       	out	0x3f, r20	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:806
        return TIMERD0;
      }
    }
  }
  if (timer & TIMERB0) { /* Finally check TCBn, if we made it here w/out returning */
    4608:	19 c0       	rjmp	.+50     	; 0x463c <digitalWrite+0x196>
digitalPinToTimerNow():
    460a:	85 ff       	sbrs	r24, 5
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:808
    TCB_t* timer_B;
    timer_B = ((TCB_t *)&TCB0 + (timer - TIMERB0)); /* get timer struct */
    460c:	15 c0       	rjmp	.+42     	; 0x4638 <digitalWrite+0x192>
    460e:	30 e1       	ldi	r19, 0x10	; 16
    4610:	83 9f       	mul	r24, r19
    4612:	f0 01       	movw	r30, r0
    4614:	11 24       	eor	r1, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:809
    if (((timer_B->CTRLB) &  TCB_CNTMODE_gm) != TCB_CNTMODE_PWM8_gc )
    4616:	f7 5f       	subi	r31, 0xF7	; 247
    4618:	91 81       	ldd	r25, Z+1	; 0x01
    461a:	97 70       	andi	r25, 0x07	; 7
    461c:	97 30       	cpi	r25, 0x07	; 7
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:119
  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;

  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
    461e:	71 f4       	brne	.+28     	; 0x463c <digitalWrite+0x196>
turnOffPWM():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:123
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
    4620:	ec 91       	ld	r30, X
    4622:	85 32       	cpi	r24, 0x25	; 37
    4624:	80 f4       	brcc	.+32     	; 0x4646 <digitalWrite+0x1a0>
    4626:	80 32       	cpi	r24, 0x20	; 32
    4628:	b0 f4       	brcc	.+44     	; 0x4656 <digitalWrite+0x1b0>
    462a:	88 30       	cpi	r24, 0x08	; 8
    462c:	09 f4       	brne	.+2      	; 0x4630 <digitalWrite+0x18a>
    462e:	9c cf       	rjmp	.-200    	; 0x4568 <digitalWrite+0xc2>
    4630:	80 31       	cpi	r24, 0x10	; 16
    4632:	09 f4       	brne	.+2      	; 0x4636 <digitalWrite+0x190>
    4634:	7c cf       	rjmp	.-264    	; 0x452e <digitalWrite+0x88>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:116
{
  /* Actually turn off compare channel, not the timer */

  /* Get pin's timer */
  uint8_t timer = digitalPinToTimerNow(pin);
  if(timer == NOT_ON_TIMER) return;
    4636:	02 c0       	rjmp	.+4      	; 0x463c <digitalWrite+0x196>
    4638:	81 11       	cpse	r24, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:289
   * analogWritten() 255, then digitallyWritten() to HIGH, which
   * would turn it off for the time between turnOffPWM() and
   * PORT->OUTCLR)
   * Since there's no penalty, why make a glitch we don't have to? */
  turnOffPWM(pin);
}
    463a:	f2 cf       	rjmp	.-28     	; 0x4620 <digitalWrite+0x17a>
digitalWrite():
    463c:	df 91       	pop	r29
    463e:	cf 91       	pop	r28
    4640:	1f 91       	pop	r17
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:123
  // uint8_t bit_pos = digitalPinToBitPosition(pin);
  uint8_t bit_mask = digitalPinToBitMask(pin);
  // we know is valid because we were told it was a timer above.
  TCB_t *timerB;

  switch (timer) {
    4642:	0f 91       	pop	r16
    4644:	08 95       	ret
turnOffPWM():
    4646:	80 34       	cpi	r24, 0x40	; 64
    4648:	09 f4       	brne	.+2      	; 0x464c <digitalWrite+0x1a6>
    464a:	ac cf       	rjmp	.-168    	; 0x45a4 <digitalWrite+0xfe>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:155
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);

    break;
  #if defined(DAC0)
  case DACOUT:
    DAC0.CTRLA = 0x00;
    464c:	80 38       	cpi	r24, 0x80	; 128
    464e:	b1 f7       	brne	.-20     	; 0x463c <digitalWrite+0x196>
    4650:	10 92 a0 06 	sts	0x06A0, r1	; 0x8006a0 <__TEXT_REGION_LENGTH__+0x7e06a0>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:147
  case TIMERB1:
  case TIMERB2:
  case TIMERB3:
  case TIMERB4:

    timerB = (TCB_t *) &TCB0 + (timer - TIMERB0);
    4654:	f3 cf       	rjmp	.-26     	; 0x463c <digitalWrite+0x196>
    4656:	90 e1       	ldi	r25, 0x10	; 16
    4658:	89 9f       	mul	r24, r25
    465a:	f0 01       	movw	r30, r0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:150

     // Disable TCB compare channel
    timerB->CTRLB &= ~(TCB_CCMPEN_bm);
    465c:	11 24       	eor	r1, r1
    465e:	f7 5f       	subi	r31, 0xF7	; 247
    4660:	81 81       	ldd	r24, Z+1	; 0x01
    4662:	8f 7e       	andi	r24, 0xEF	; 239
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:179
      if (fcset) {
        // don't do any of this unless the pin is currently set to output PWM - spamming digital I/O on a pin that could output PWM shouldn't
        // cause TCD0 to lose a couple of clocks of timing each time.
        #if defined (NO_GLITCH_TIMERD0)
          // Arrgh, almost didn't need bit position!
          volatile uint8_t *pin_ctrl_reg = getPINnCTRLregister(digitalPinToPortStruct(pin), digitalPinToBitMask(pin));
    4664:	81 83       	std	Z+1, r24	; 0x01
    4666:	ea cf       	rjmp	.-44     	; 0x463c <digitalWrite+0x196>
digitalWrite():
    4668:	f0 e0       	ldi	r31, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/led_ctrl.cpp:86

void LedCtrlClass::off(Led led, bool is_from_system_event) {
    if (is_from_system_event && manual_control_enabled)
        return;

    digitalWrite(getLedPin(led), 1);
    466a:	e0 e0       	ldi	r30, 0x00	; 0
    466c:	ad cf       	rjmp	.-166    	; 0x45c8 <digitalWrite+0x122>

0000466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>:
off():
    466e:	0e 94 47 0b 	call	0x168e	; 0x168e <LedCtrlClass::getLedPin(Led) [clone .constprop.132]>
    4672:	61 e0       	ldi	r22, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:538

bool MqttClientClass::end(void) {

    LedCtrl.off(Led::CON, true);
    4674:	18 cf       	rjmp	.-464    	; 0x44a6 <digitalWrite>

00004676 <MqttClientClass::end() [clone .constprop.97]>:
end():
    4676:	61 e0       	ldi	r22, 0x01	; 1
    4678:	81 e0       	ldi	r24, 0x01	; 1
    467a:	90 e0       	ldi	r25, 0x00	; 0
    467c:	f8 df       	rcall	.-16     	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:540

    SequansController.unregisterCallback(MQTT_ON_MESSAGE_URC);
    467e:	87 e0       	ldi	r24, 0x07	; 7
    4680:	9c e4       	ldi	r25, 0x4C	; 76
    4682:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:541
    SequansController.unregisterCallback(MQTT_ON_CONNECT_URC);
    4686:	87 e4       	ldi	r24, 0x47	; 71
    4688:	9a e4       	ldi	r25, 0x4A	; 74
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:542
    SequansController.unregisterCallback(MQTT_ON_DISCONNECT_URC);
    468a:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
    468e:	89 e5       	ldi	r24, 0x59	; 89
    4690:	9a e4       	ldi	r25, 0x4A	; 74
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:570
    if (disconnected != NULL) {
        disconnected_callback = disconnected;
    }
}

bool MqttClientClass::isConnected(void) { return connected_to_broker; }
    4692:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:544

    SequansController.unregisterCallback(MQTT_ON_MESSAGE_URC);
    SequansController.unregisterCallback(MQTT_ON_CONNECT_URC);
    SequansController.unregisterCallback(MQTT_ON_DISCONNECT_URC);

    if (isConnected()) {
    4696:	80 91 90 66 	lds	r24, 0x6690	; 0x806690 <connected_to_broker>
end():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:546

        SequansController.writeCommand(MQTT_DISCONNECT);
    469a:	88 23       	and	r24, r24
    469c:	61 f0       	breq	.+24     	; 0x46b6 <MqttClientClass::end() [clone .constprop.97]+0x40>
    469e:	50 e0       	ldi	r21, 0x00	; 0
    46a0:	40 e0       	ldi	r20, 0x00	; 0
    46a2:	70 e0       	ldi	r23, 0x00	; 0
    46a4:	60 e0       	ldi	r22, 0x00	; 0
    46a6:	8e e5       	ldi	r24, 0x5E	; 94
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:547
        SequansController.clearReceiveBuffer();
    46a8:	95 e4       	ldi	r25, 0x45	; 69
    46aa:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:549

        connected_to_broker = false;
    46ae:	0e 94 82 07 	call	0xf04	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:552
    }

    if (disconnected_callback != NULL) {
    46b2:	10 92 90 66 	sts	0x6690, r1	; 0x806690 <connected_to_broker>
    46b6:	e0 91 8e 66 	lds	r30, 0x668E	; 0x80668e <_ZL21disconnected_callback.lto_priv.138>
    46ba:	f0 91 8f 66 	lds	r31, 0x668F	; 0x80668f <_ZL21disconnected_callback.lto_priv.138+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:557
        disconnected_callback();
    }

    return true;
}
    46be:	30 97       	sbiw	r30, 0x00	; 0
    46c0:	09 f0       	breq	.+2      	; 0x46c4 <MqttClientClass::end() [clone .constprop.97]+0x4e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:22

static bool disconnect_received = false;
static IotConnectMqttClientConfig* c = NULL;

void iotc_mqtt_client_disconnect(void) {
    Log.info("Closing the MQTT connection");
    46c2:	09 95       	icall
    46c4:	81 e0       	ldi	r24, 0x01	; 1
    46c6:	08 95       	ret

000046c8 <iotconnect_sdk_disconnect()>:
iotc_mqtt_client_disconnect():
    46c8:	89 e1       	ldi	r24, 0x19	; 25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:23
    MqttClient.end();
    46ca:	9c e4       	ldi	r25, 0x4C	; 76
    46cc:	0e 94 29 0a 	call	0x1452	; 0x1452 <LogClass::info(char const*) [clone .constprop.93]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:187
    }
}

void iotconnect_sdk_disconnect(void) {
    iotc_mqtt_client_disconnect();
    Log.info("Disconnected.");
    46d0:	d2 df       	rcall	.-92     	; 0x4676 <MqttClientClass::end() [clone .constprop.97]>
iotconnect_sdk_disconnect():
    46d2:	85 e3       	ldi	r24, 0x35	; 53
    46d4:	9c e4       	ldi	r25, 0x4C	; 76
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:203

IotclConfig *iotconnect_sdk_get_lib_config(void) {
    return iotcl_get_config();
}

static void on_message_intercept(IotclEventData data, IotConnectEventType type) {
    46d6:	0c 94 29 0a 	jmp	0x1452	; 0x1452 <LogClass::info(char const*) [clone .constprop.93]>

000046da <on_message_intercept(IotclEventDataTag*, IotConnectEventType)>:
on_message_intercept():
    46da:	0f 93       	push	r16
    46dc:	1f 93       	push	r17
    46de:	cf 93       	push	r28
    46e0:	df 93       	push	r29
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:204
    switch (type) {
    46e2:	8c 01       	movw	r16, r24
    46e4:	eb 01       	movw	r28, r22
    46e6:	62 31       	cpi	r22, 0x12	; 18
    46e8:	71 05       	cpc	r23, r1
    46ea:	81 f0       	breq	.+32     	; 0x470c <on_message_intercept(IotclEventDataTag*, IotConnectEventType)+0x32>
    46ec:	69 39       	cpi	r22, 0x99	; 153
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:216
            iotconnect_sdk_disconnect();
        default:
            break; // not handling nay other messages
    }

    if (NULL != config.msg_cb) {
    46ee:	71 05       	cpc	r23, r1
    46f0:	91 f0       	breq	.+36     	; 0x4716 <on_message_intercept(IotclEventDataTag*, IotConnectEventType)+0x3c>
    46f2:	e0 91 fe 65 	lds	r30, 0x65FE	; 0x8065fe <config+0xa>
    46f6:	f0 91 ff 65 	lds	r31, 0x65FF	; 0x8065ff <config+0xb>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:217
        config.msg_cb(data, type);
    46fa:	30 97       	sbiw	r30, 0x00	; 0
    46fc:	91 f0       	breq	.+36     	; 0x4722 <on_message_intercept(IotclEventDataTag*, IotConnectEventType)+0x48>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:219
    }
}
    46fe:	be 01       	movw	r22, r28
    4700:	c8 01       	movw	r24, r16
    4702:	df 91       	pop	r29
    4704:	cf 91       	pop	r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:217
        default:
            break; // not handling nay other messages
    }

    if (NULL != config.msg_cb) {
        config.msg_cb(data, type);
    4706:	1f 91       	pop	r17
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:206
}

static void on_message_intercept(IotclEventData data, IotConnectEventType type) {
    switch (type) {
        case ON_FORCE_SYNC:
            Log.info("Got ON_FORCE_SYNC. Disconnecting.");
    4708:	0f 91       	pop	r16
    470a:	09 94       	ijmp
    470c:	83 e4       	ldi	r24, 0x43	; 67
    470e:	9c e4       	ldi	r25, 0x4C	; 76
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:207
            iotconnect_sdk_disconnect(); // client will get notification that we disconnected and will reinit
    4710:	0e 94 29 0a 	call	0x1452	; 0x1452 <LogClass::info(char const*) [clone .constprop.93]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:210

        case ON_CLOSE:
            Log.info("Got a disconnect request. Closing the mqtt connection. Device restart is required.");
    4714:	d9 df       	rcall	.-78     	; 0x46c8 <iotconnect_sdk_disconnect()>
    4716:	85 e6       	ldi	r24, 0x65	; 101
    4718:	9c e4       	ldi	r25, 0x4C	; 76
    471a:	0e 94 29 0a 	call	0x1452	; 0x1452 <LogClass::info(char const*) [clone .constprop.93]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:211
            iotconnect_sdk_disconnect();
    471e:	d4 df       	rcall	.-88     	; 0x46c8 <iotconnect_sdk_disconnect()>
    4720:	e8 cf       	rjmp	.-48     	; 0x46f2 <on_message_intercept(IotclEventDataTag*, IotConnectEventType)+0x18>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:219
    }

    if (NULL != config.msg_cb) {
        config.msg_cb(data, type);
    }
}
    4722:	df 91       	pop	r29
    4724:	cf 91       	pop	r28
    4726:	1f 91       	pop	r17
    4728:	0f 91       	pop	r16
    472a:	08 95       	ret

0000472c <LedCtrlClass::on(Led, bool) [clone .constprop.114]>:
on():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/led_ctrl.cpp:79

void LedCtrlClass::on(Led led, bool is_from_system_event) {
    if (is_from_system_event && manual_control_enabled)
        return;

    digitalWrite(getLedPin(led), 0);
    472c:	0e 94 47 0b 	call	0x168e	; 0x168e <LedCtrlClass::getLedPin(Led) [clone .constprop.132]>
    4730:	60 e0       	ldi	r22, 0x00	; 0
    4732:	b9 ce       	rjmp	.-654    	; 0x44a6 <digitalWrite>

00004734 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]>:
iotconnect_https_request():
    4734:	2f 92       	push	r2
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:12
#include <string.h>
#include "http_client.h"
#include "log.h"
#include "iotc_http_request.h"

int iotconnect_https_request(
    4736:	3f 92       	push	r3
    4738:	4f 92       	push	r4
    473a:	5f 92       	push	r5
    473c:	6f 92       	push	r6
    473e:	7f 92       	push	r7
    4740:	8f 92       	push	r8
    4742:	9f 92       	push	r9
    4744:	af 92       	push	r10
    4746:	bf 92       	push	r11
    4748:	cf 92       	push	r12
    474a:	df 92       	push	r13
    474c:	ef 92       	push	r14
    474e:	ff 92       	push	r15
    4750:	0f 93       	push	r16
    4752:	1f 93       	push	r17
    4754:	cf 93       	push	r28
    4756:	df 93       	push	r29
    4758:	cd b7       	in	r28, 0x3d	; 61
    475a:	de b7       	in	r29, 0x3e	; 62
    475c:	c4 57       	subi	r28, 0x74	; 116
    475e:	d1 09       	sbc	r29, r1
    4760:	cd bf       	out	0x3d, r28	; 61
    4762:	de bf       	out	0x3e, r29	; 62
    4764:	e1 96       	adiw	r28, 0x31	; 49
    4766:	8e af       	std	Y+62, r24	; 0x3e
    4768:	9f af       	std	Y+63, r25	; 0x3f
    476a:	e1 97       	sbiw	r28, 0x31	; 49
    476c:	3b 01       	movw	r6, r22
    476e:	b4 2e       	mov	r11, r20
    4770:	a5 2e       	mov	r10, r21
    4772:	69 01       	movw	r12, r18
    4774:	2d b7       	in	r18, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:64
        return -1;
    }
    response->data = (char *) malloc(body_length + 1);
    strcpy(response->data, body.c_str());
    return 0;
}
    4776:	3e b7       	in	r19, 0x3e	; 62
    4778:	e5 96       	adiw	r28, 0x35	; 53
    477a:	2e af       	std	Y+62, r18	; 0x3e
    477c:	3f af       	std	Y+63, r19	; 0x3f
    477e:	e5 97       	sbiw	r28, 0x35	; 53
    4780:	dc 01       	movw	r26, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:18
        IotConnectHttpResponse *response,
        const char *host,
        const char *path,
        const char *send_str
) {
    response->data = NULL;
    4782:	1d 92       	st	X+, r1
    4784:	1c 92       	st	X, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:19
    if (!HttpClient.configure(host, 443, true)) {
    4786:	cb 01       	movw	r24, r22
    4788:	0e 94 2c 19 	call	0x3258	; 0x3258 <HttpClientClass::configure(char const*, unsigned int, bool) [clone .constprop.68]>
    478c:	81 11       	cpse	r24, r1
    478e:	24 c0       	rjmp	.+72     	; 0x47d8 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0xa4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:20
        Log.error("Failed to configure https client");
    4790:	88 eb       	ldi	r24, 0xB8	; 184
    4792:	9c e4       	ldi	r25, 0x4C	; 76
    4794:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:41
        );
    }

    if (0 == http_rsp.status_code) {
        Log.errorf("Unable to get response from the server for URL https://%s%s\r\n", host, path);
        return -1;
    4798:	0f ef       	ldi	r16, 0xFF	; 255
    479a:	1f ef       	ldi	r17, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:64
        return -1;
    }
    response->data = (char *) malloc(body_length + 1);
    strcpy(response->data, body.c_str());
    return 0;
}
    479c:	c8 01       	movw	r24, r16
    479e:	e5 96       	adiw	r28, 0x35	; 53
    47a0:	ee ad       	ldd	r30, Y+62	; 0x3e
    47a2:	ff ad       	ldd	r31, Y+63	; 0x3f
    47a4:	e5 97       	sbiw	r28, 0x35	; 53
    47a6:	ed bf       	out	0x3d, r30	; 61
    47a8:	fe bf       	out	0x3e, r31	; 62
    47aa:	cc 58       	subi	r28, 0x8C	; 140
    47ac:	df 4f       	sbci	r29, 0xFF	; 255
    47ae:	cd bf       	out	0x3d, r28	; 61
    47b0:	de bf       	out	0x3e, r29	; 62
    47b2:	df 91       	pop	r29
    47b4:	cf 91       	pop	r28
    47b6:	1f 91       	pop	r17
    47b8:	0f 91       	pop	r16
    47ba:	ff 90       	pop	r15
    47bc:	ef 90       	pop	r14
    47be:	df 90       	pop	r13
    47c0:	cf 90       	pop	r12
    47c2:	bf 90       	pop	r11
    47c4:	af 90       	pop	r10
    47c6:	9f 90       	pop	r9
    47c8:	8f 90       	pop	r8
    47ca:	7f 90       	pop	r7
    47cc:	6f 90       	pop	r6
    47ce:	5f 90       	pop	r5
    47d0:	4f 90       	pop	r4
    47d2:	3f 90       	pop	r3
    47d4:	2f 90       	pop	r2
    47d6:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:25
        Log.error("Failed to configure https client");
        return -1;
    }

    HttpResponse http_rsp;
    if (!send_str || 0 == strlen(send_str)) {
    47d8:	c1 14       	cp	r12, r1
    47da:	d1 04       	cpc	r13, r1
    47dc:	21 f0       	breq	.+8      	; 0x47e6 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0xb2>
    47de:	f6 01       	movw	r30, r12
    47e0:	80 81       	ld	r24, Z
    47e2:	81 11       	cpse	r24, r1
    47e4:	33 c1       	rjmp	.+614    	; 0x4a4c <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x318>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:26
        Log.debugf("get: %s %s\r\n", host, path);
    47e6:	af 92       	push	r10
    47e8:	bf 92       	push	r11
    47ea:	7f 92       	push	r7
    47ec:	6f 92       	push	r6
    47ee:	89 ed       	ldi	r24, 0xD9	; 217
    47f0:	9c e4       	ldi	r25, 0x4C	; 76
    47f2:	9f 93       	push	r25
    47f4:	8f 93       	push	r24
    47f6:	09 e6       	ldi	r16, 0x69	; 105
    47f8:	10 e7       	ldi	r17, 0x70	; 112
    47fa:	1f 93       	push	r17
    47fc:	0f 93       	push	r16
    47fe:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <LogClass::debugf(char const*, ...) [clone .constprop.118]>
get():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:428
                                  const char* header,
                                  const uint32_t timeout_ms) {
    return queryData(endpoint,
                     HTTP_GET_METHOD,
                     (uint8_t*)header,
                     strlen(header),
    4802:	90 e0       	ldi	r25, 0x00	; 0
    4804:	80 e0       	ldi	r24, 0x00	; 0
    4806:	0e 94 04 57 	call	0xae08	; 0xae08 <strlen>
    480a:	7c 01       	movw	r14, r24
queryData():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:305
    }

    LedCtrl.off(Led::DATA, true);
    LedCtrl.off(Led::CON, true);

    return http_response;
    480c:	2d b7       	in	r18, 0x3d	; 61
    480e:	3e b7       	in	r19, 0x3e	; 62
    4810:	28 5f       	subi	r18, 0xF8	; 248
    4812:	3f 4f       	sbci	r19, 0xFF	; 255
    4814:	2d bf       	out	0x3d, r18	; 61
    4816:	3e bf       	out	0x3e, r19	; 62
    4818:	8d b6       	in	r8, 0x3d	; 61
    481a:	9e b6       	in	r9, 0x3e	; 62
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:221
                              const uint8_t method,
                              const uint8_t* header,
                              const uint32_t header_length,
                              const uint32_t timeout_ms) {

    LedCtrl.on(Led::CON, true);
    481c:	81 e0       	ldi	r24, 0x01	; 1
    481e:	90 e0       	ldi	r25, 0x00	; 0
    4820:	85 df       	rcall	.-246    	; 0x472c <LedCtrlClass::on(Led, bool) [clone .constprop.114]>
    4822:	50 e0       	ldi	r21, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:225

    // The modem could hang if several HTTP requests are done quickly after each
    // other, this alleviates this
    SequansController.writeCommand("AT");
    4824:	40 e0       	ldi	r20, 0x00	; 0
    4826:	70 e0       	ldi	r23, 0x00	; 0
    4828:	60 e0       	ldi	r22, 0x00	; 0
    482a:	86 ee       	ldi	r24, 0xE6	; 230
    482c:	9c e4       	ldi	r25, 0x4C	; 76
    482e:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    4832:	eb 2d       	mov	r30, r11
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:230

    HttpResponse http_response = {0, 0};

    // Set up and send the query
    const uint32_t command_length = strlen(HTTP_QUERY) + strlen(endpoint) +
    4834:	fa 2d       	mov	r31, r10
    4836:	df 01       	movw	r26, r30
    4838:	0d 90       	ld	r0, X+
    483a:	00 20       	and	r0, r0
    483c:	e9 f7       	brne	.-6      	; 0x4838 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x104>
    483e:	cd 01       	movw	r24, r26
    4840:	8e 1b       	sub	r24, r30
    4842:	9f 0b       	sbc	r25, r31
    4844:	4b 96       	adiw	r24, 0x1b	; 27
    4846:	1c 01       	movw	r2, r24
    4848:	51 2c       	mov	r5, r1
    484a:	41 2c       	mov	r4, r1
    484c:	2e 0c       	add	r2, r14
    484e:	3f 1c       	adc	r3, r15
    4850:	41 1c       	adc	r4, r1
    4852:	51 1c       	adc	r5, r1
    4854:	b2 01       	movw	r22, r4
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:234
                                    header_length;

    // Append +1 for NULL termination
    char command[command_length + 1];
    4856:	a1 01       	movw	r20, r2
    4858:	4f 5f       	subi	r20, 0xFF	; 255
    485a:	5f 4f       	sbci	r21, 0xFF	; 255
    485c:	6f 4f       	sbci	r22, 0xFF	; 255
    485e:	7f 4f       	sbci	r23, 0xFF	; 255
    4860:	ed b7       	in	r30, 0x3d	; 61
    4862:	fe b7       	in	r31, 0x3e	; 62
    4864:	e4 1b       	sub	r30, r20
    4866:	f5 0b       	sbc	r31, r21
    4868:	ed bf       	out	0x3d, r30	; 61
    486a:	fe bf       	out	0x3e, r31	; 62
    486c:	2d b7       	in	r18, 0x3d	; 61
    486e:	3e b7       	in	r19, 0x3e	; 62
    4870:	2f 5f       	subi	r18, 0xFF	; 255
    4872:	3f 4f       	sbci	r19, 0xFF	; 255
    4874:	69 01       	movw	r12, r18
    4876:	22 ef       	ldi	r18, 0xF2	; 242
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:241
    int bytes_written = snprintf(command,
                                 command_length,
                                 HTTP_QUERY,
                                 method,
                                 endpoint,
                                 header == NULL ? "" : (const char*)header);
    4878:	31 e6       	ldi	r19, 0x61	; 97
    487a:	3f 93       	push	r19
    487c:	2f 93       	push	r18
    487e:	af 92       	push	r10
    4880:	bf 92       	push	r11
    4882:	1f 92       	push	r1
    4884:	1f 92       	push	r1
    4886:	29 ee       	ldi	r18, 0xE9	; 233
    4888:	3c e4       	ldi	r19, 0x4C	; 76
    488a:	3f 93       	push	r19
    488c:	2f 93       	push	r18
    488e:	e8 0e       	add	r14, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:236
                                    header_length;

    // Append +1 for NULL termination
    char command[command_length + 1];

    int bytes_written = snprintf(command,
    4890:	f9 1e       	adc	r15, r25
    4892:	ff 92       	push	r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:241
                                 command_length,
                                 HTTP_QUERY,
                                 method,
                                 endpoint,
                                 header == NULL ? "" : (const char*)header);
    4894:	ef 92       	push	r14
    4896:	df 92       	push	r13
    4898:	cf 92       	push	r12
    489a:	0e 94 83 57 	call	0xaf06	; 0xaf06 <snprintf>
    489e:	ad b7       	in	r26, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:243

    if (bytes_written < 0) {
    48a0:	be b7       	in	r27, 0x3e	; 62
    48a2:	1c 96       	adiw	r26, 0x0c	; 12
    48a4:	ad bf       	out	0x3d, r26	; 61
    48a6:	be bf       	out	0x3e, r27	; 62
    48a8:	97 ff       	sbrs	r25, 7
    48aa:	30 c0       	rjmp	.+96     	; 0x490c <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x1d8>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:244
        Log.errorf(
    48ac:	9f 93       	push	r25
    48ae:	8f 93       	push	r24
    48b0:	86 e0       	ldi	r24, 0x06	; 6
    48b2:	9d e4       	ldi	r25, 0x4D	; 77
    48b4:	9f 93       	push	r25
    48b6:	8f 93       	push	r24
    48b8:	1f 93       	push	r17
    48ba:	0f 93       	push	r16
    48bc:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    48c0:	0f 90       	pop	r0
    48c2:	0f 90       	pop	r0
    48c4:	0f 90       	pop	r0
    48c6:	0f 90       	pop	r0
    48c8:	0f 90       	pop	r0
    48ca:	0f 90       	pop	r0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:255
    if (bytes_written >= (int)command_length) {
        Log.errorf("Failed to write HTTP query command, snprintf returned %d "
                   "but command length is %d\r\n",
                   bytes_written,
                   command_length);
        return HttpResponse{0, 0};
    48cc:	c1 2c       	mov	r12, r1
    48ce:	d1 2c       	mov	r13, r1
    48d0:	76 01       	movw	r14, r12
    48d2:	10 e0       	ldi	r17, 0x00	; 0
    48d4:	00 e0       	ldi	r16, 0x00	; 0
    48d6:	8d be       	out	0x3d, r8	; 61
    48d8:	9e be       	out	0x3e, r9	; 62
iotconnect_https_request():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:39
            HttpClientClass::CONTENT_TYPE_APPLICATION_JSON,
            HTTP_DEFAULT_TIMEOUT_MS
        );
    }

    if (0 == http_rsp.status_code) {
    48da:	01 15       	cp	r16, r1
    48dc:	11 05       	cpc	r17, r1
    48de:	09 f0       	breq	.+2      	; 0x48e2 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x1ae>
    48e0:	2c c2       	rjmp	.+1112   	; 0x4d3a <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x606>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:40
        Log.errorf("Unable to get response from the server for URL https://%s%s\r\n", host, path);
    48e2:	af 92       	push	r10
    48e4:	bf 92       	push	r11
    48e6:	7f 92       	push	r7
    48e8:	6f 92       	push	r6
    48ea:	87 e3       	ldi	r24, 0x37	; 55
    48ec:	9f e4       	ldi	r25, 0x4F	; 79
    48ee:	9f 93       	push	r25
    48f0:	8f 93       	push	r24
    48f2:	89 e6       	ldi	r24, 0x69	; 105
    48f4:	90 e7       	ldi	r25, 0x70	; 112
    48f6:	9f 93       	push	r25
    48f8:	8f 93       	push	r24
    48fa:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    48fe:	2d b7       	in	r18, 0x3d	; 61
    4900:	3e b7       	in	r19, 0x3e	; 62
    4902:	28 5f       	subi	r18, 0xF8	; 248
    4904:	3f 4f       	sbci	r19, 0xFF	; 255
    4906:	2d bf       	out	0x3d, r18	; 61
    4908:	3e bf       	out	0x3e, r19	; 62
    490a:	46 cf       	rjmp	.-372    	; 0x4798 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x64>
queryData():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:250
            "Failed to write HTTP query command, snprintf returned %d\r\n",
            bytes_written);
        return HttpResponse{0, 0};
    }

    if (bytes_written >= (int)command_length) {
    490c:	82 15       	cp	r24, r2
    490e:	93 05       	cpc	r25, r3
    4910:	a4 f0       	brlt	.+40     	; 0x493a <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x206>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:251
        Log.errorf("Failed to write HTTP query command, snprintf returned %d "
    4912:	5f 92       	push	r5
    4914:	4f 92       	push	r4
    4916:	3f 92       	push	r3
    4918:	2f 92       	push	r2
    491a:	9f 93       	push	r25
    491c:	8f 93       	push	r24
    491e:	81 e4       	ldi	r24, 0x41	; 65
    4920:	9d e4       	ldi	r25, 0x4D	; 77
    4922:	9f 93       	push	r25
    4924:	8f 93       	push	r24
    4926:	1f 93       	push	r17
    4928:	0f 93       	push	r16
    492a:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    492e:	ed b7       	in	r30, 0x3d	; 61
    4930:	fe b7       	in	r31, 0x3e	; 62
    4932:	3a 96       	adiw	r30, 0x0a	; 10
    4934:	ed bf       	out	0x3d, r30	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:258
                   bytes_written,
                   command_length);
        return HttpResponse{0, 0};
    }

    command[bytes_written + 1] = '\0';
    4936:	fe bf       	out	0x3e, r31	; 62
    4938:	c9 cf       	rjmp	.-110    	; 0x48cc <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x198>
    493a:	8c 0d       	add	r24, r12
    493c:	9d 1d       	adc	r25, r13
    493e:	dc 01       	movw	r26, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:260

    LedCtrl.on(Led::DATA, true);
    4940:	11 96       	adiw	r26, 0x01	; 1
    4942:	1c 92       	st	X, r1
    4944:	82 e0       	ldi	r24, 0x02	; 2
    4946:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:261
    SequansController.writeCommand(command);
    4948:	f1 de       	rcall	.-542    	; 0x472c <LedCtrlClass::on(Led, bool) [clone .constprop.114]>
    494a:	50 e0       	ldi	r21, 0x00	; 0
    494c:	40 e0       	ldi	r20, 0x00	; 0
    494e:	70 e0       	ldi	r23, 0x00	; 0
    4950:	60 e0       	ldi	r22, 0x00	; 0
    4952:	c6 01       	movw	r24, r12
    4954:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:263

    char http_response_buffer[HTTP_RESPONSE_MAX_LENGTH]                = "";
    4958:	19 82       	std	Y+1, r1	; 0x01
    495a:	1a 82       	std	Y+2, r1	; 0x02
    495c:	fe 01       	movw	r30, r28
    495e:	33 96       	adiw	r30, 0x03	; 3
    4960:	82 e5       	ldi	r24, 0x52	; 82
    4962:	df 01       	movw	r26, r30
    4964:	1d 92       	st	X+, r1
    4966:	8a 95       	dec	r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:264
    char http_status_code_buffer[HTTP_RESPONSE_STATUS_CODE_LENGTH + 1] = "";
    4968:	e9 f7       	brne	.-6      	; 0x4964 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x230>
    496a:	a7 96       	adiw	r28, 0x27	; 39
    496c:	1e ae       	std	Y+62, r1	; 0x3e
    496e:	1f ae       	std	Y+63, r1	; 0x3f
    4970:	a7 97       	sbiw	r28, 0x27	; 39
    4972:	a9 96       	adiw	r28, 0x29	; 41
    4974:	1e ae       	std	Y+62, r1	; 0x3e
    4976:	1f ae       	std	Y+63, r1	; 0x3f
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:265
    char data_size_buffer[HTTP_RESPONSE_DATA_SIZE_LENGTH]              = "";
    4978:	a9 97       	sbiw	r28, 0x29	; 41
    497a:	ee 5a       	subi	r30, 0xAE	; 174
    497c:	ff 4f       	sbci	r31, 0xFF	; 255
    497e:	11 92       	st	Z+, r1
    4980:	11 92       	st	Z+, r1
    4982:	8e e0       	ldi	r24, 0x0E	; 14
    4984:	df 01       	movw	r26, r30
    4986:	1d 92       	st	X+, r1
    4988:	8a 95       	dec	r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:267

    if (!SequansController.waitForURC(HTTP_RING_URC,
    498a:	e9 f7       	brne	.-6      	; 0x4986 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x252>
    498c:	30 e3       	ldi	r19, 0x30	; 48
    498e:	c3 2e       	mov	r12, r19
    4990:	45 e7       	ldi	r20, 0x75	; 117
    4992:	d4 2e       	mov	r13, r20
    4994:	e1 2c       	mov	r14, r1
    4996:	f1 2c       	mov	r15, r1
    4998:	00 e0       	ldi	r16, 0x00	; 0
    499a:	10 e0       	ldi	r17, 0x00	; 0
    499c:	20 e0       	ldi	r18, 0x00	; 0
    499e:	30 e0       	ldi	r19, 0x00	; 0
    49a0:	44 e5       	ldi	r20, 0x54	; 84
    49a2:	50 e0       	ldi	r21, 0x00	; 0
    49a4:	be 01       	movw	r22, r28
    49a6:	6f 5f       	subi	r22, 0xFF	; 255
    49a8:	7f 4f       	sbci	r23, 0xFF	; 255
    49aa:	85 e9       	ldi	r24, 0x95	; 149
    49ac:	9d e4       	ldi	r25, 0x4D	; 77
    49ae:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:271
                                      http_response_buffer,
                                      sizeof(http_response_buffer),
                                      timeout_ms)) {
        Log.warn("Did not get HTTP response before timeout\r\n");
    49b2:	81 11       	cpse	r24, r1
    49b4:	0d c0       	rjmp	.+26     	; 0x49d0 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x29c>
    49b6:	81 ea       	ldi	r24, 0xA1	; 161
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:273

        LedCtrl.off(Led::DATA, true);
    49b8:	9d e4       	ldi	r25, 0x4D	; 77
    49ba:	0e 94 9c 0a 	call	0x1538	; 0x1538 <LogClass::warn(char const*) [clone .constprop.124]>
    49be:	61 e0       	ldi	r22, 0x01	; 1
    49c0:	82 e0       	ldi	r24, 0x02	; 2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:274
        LedCtrl.off(Led::CON, true);
    49c2:	90 e0       	ldi	r25, 0x00	; 0
    49c4:	54 de       	rcall	.-856    	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
    49c6:	61 e0       	ldi	r22, 0x01	; 1
    49c8:	81 e0       	ldi	r24, 0x01	; 1
    49ca:	90 e0       	ldi	r25, 0x00	; 0
    49cc:	50 de       	rcall	.-864    	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:278
        return http_response;
    }

    LedCtrl.off(Led::DATA, true);
    49ce:	7e cf       	rjmp	.-260    	; 0x48cc <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x198>
    49d0:	61 e0       	ldi	r22, 0x01	; 1
    49d2:	82 e0       	ldi	r24, 0x02	; 2
    49d4:	90 e0       	ldi	r25, 0x00	; 0
    49d6:	4b de       	rcall	.-874    	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:285
    bool got_response_code = SequansController.extractValueFromCommandResponse(
        http_response_buffer,
        HTTP_RESPONSE_STATUS_CODE_INDEX,
        http_status_code_buffer,
        HTTP_RESPONSE_STATUS_CODE_LENGTH + 1,
        (char)NULL);
    49d8:	00 e0       	ldi	r16, 0x00	; 0
    49da:	24 e0       	ldi	r18, 0x04	; 4
    49dc:	30 e0       	ldi	r19, 0x00	; 0
    49de:	ae 01       	movw	r20, r28
    49e0:	4b 59       	subi	r20, 0x9B	; 155
    49e2:	5f 4f       	sbci	r21, 0xFF	; 255
    49e4:	61 e0       	ldi	r22, 0x01	; 1
    49e6:	ce 01       	movw	r24, r28
    49e8:	01 96       	adiw	r24, 0x01	; 1
    49ea:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    49ee:	18 2f       	mov	r17, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:292
    bool got_data_size = SequansController.extractValueFromCommandResponse(
        http_response_buffer,
        HTTP_RESPONSE_DATA_SIZE_INDEX,
        data_size_buffer,
        HTTP_RESPONSE_DATA_SIZE_LENGTH,
        (char)NULL);
    49f0:	20 e1       	ldi	r18, 0x10	; 16
    49f2:	30 e0       	ldi	r19, 0x00	; 0
    49f4:	ae 01       	movw	r20, r28
    49f6:	4b 5a       	subi	r20, 0xAB	; 171
    49f8:	5f 4f       	sbci	r21, 0xFF	; 255
    49fa:	63 e0       	ldi	r22, 0x03	; 3
    49fc:	ce 01       	movw	r24, r28
    49fe:	01 96       	adiw	r24, 0x01	; 1
    4a00:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:294

    if (got_response_code) {
    4a04:	f8 2e       	mov	r15, r24
    4a06:	11 23       	and	r17, r17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:295
        http_response.status_code = atoi(http_status_code_buffer);
    4a08:	d1 f0       	breq	.+52     	; 0x4a3e <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x30a>
    4a0a:	ce 01       	movw	r24, r28
    4a0c:	8b 59       	subi	r24, 0x9B	; 155
    4a0e:	9f 4f       	sbci	r25, 0xFF	; 255
    4a10:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:298
    }

    if (got_data_size) {
    4a14:	8c 01       	movw	r16, r24
    4a16:	ff 20       	and	r15, r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:299
        http_response.data_size = atoi(data_size_buffer);
    4a18:	a9 f0       	breq	.+42     	; 0x4a44 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x310>
    4a1a:	ce 01       	movw	r24, r28
    4a1c:	8b 5a       	subi	r24, 0xAB	; 171
    4a1e:	9f 4f       	sbci	r25, 0xFF	; 255
    4a20:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
    4a24:	6c 01       	movw	r12, r24
    4a26:	99 0f       	add	r25, r25
    4a28:	ee 08       	sbc	r14, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:302
    }

    LedCtrl.off(Led::DATA, true);
    4a2a:	ff 08       	sbc	r15, r15
    4a2c:	61 e0       	ldi	r22, 0x01	; 1
    4a2e:	82 e0       	ldi	r24, 0x02	; 2
    4a30:	90 e0       	ldi	r25, 0x00	; 0
    4a32:	1d de       	rcall	.-966    	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:303
    LedCtrl.off(Led::CON, true);
    4a34:	61 e0       	ldi	r22, 0x01	; 1
    4a36:	81 e0       	ldi	r24, 0x01	; 1
    4a38:	90 e0       	ldi	r25, 0x00	; 0
    4a3a:	19 de       	rcall	.-974    	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
    4a3c:	4c cf       	rjmp	.-360    	; 0x48d6 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x1a2>
iotconnect_https_request():
    4a3e:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:227

    // The modem could hang if several HTTP requests are done quickly after each
    // other, this alleviates this
    SequansController.writeCommand("AT");

    HttpResponse http_response = {0, 0};
    4a40:	00 e0       	ldi	r16, 0x00	; 0
    4a42:	e9 cf       	rjmp	.-46     	; 0x4a16 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x2e2>
    4a44:	c1 2c       	mov	r12, r1
    4a46:	d1 2c       	mov	r13, r1
    4a48:	76 01       	movw	r14, r12
    4a4a:	f0 cf       	rjmp	.-32     	; 0x4a2c <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x2f8>
    4a4c:	df 92       	push	r13
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:29
    HttpResponse http_rsp;
    if (!send_str || 0 == strlen(send_str)) {
        Log.debugf("get: %s %s\r\n", host, path);
        http_rsp = HttpClient.get(path);
    } else {
        Log.debugf("post: %s %s >>%s<<\r\n", host, path, send_str);
    4a4e:	cf 92       	push	r12
    4a50:	af 92       	push	r10
    4a52:	bf 92       	push	r11
    4a54:	7f 92       	push	r7
    4a56:	6f 92       	push	r6
    4a58:	8c ec       	ldi	r24, 0xCC	; 204
    4a5a:	9d e4       	ldi	r25, 0x4D	; 77
    4a5c:	9f 93       	push	r25
    4a5e:	8f 93       	push	r24
    4a60:	e9 e6       	ldi	r30, 0x69	; 105
    4a62:	f0 e7       	ldi	r31, 0x70	; 112
    4a64:	ff 93       	push	r31
    4a66:	ef 93       	push	r30
    4a68:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <LogClass::debugf(char const*, ...) [clone .constprop.118]>
post():
    4a6c:	f6 01       	movw	r30, r12
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:387
                                   const char* header,
                                   const ContentType content_type,
                                   const uint32_t timeout_ms) {
    return post(endpoint,
                (uint8_t*)data,
                strlen(data),
    4a6e:	01 90       	ld	r0, Z+
    4a70:	00 20       	and	r0, r0
    4a72:	e9 f7       	brne	.-6      	; 0x4a6e <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x33a>
    4a74:	31 97       	sbiw	r30, 0x01	; 1
    4a76:	4f 01       	movw	r8, r30
    4a78:	8c 18       	sub	r8, r12
    4a7a:	9d 08       	sbc	r9, r13
    4a7c:	8e 01       	movw	r16, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:358
                HTTP_CONTENT_TYPE_APPLICATION_MULTIPART_FORM_DATA,
                sizeof(content_type_buffer));
        break;

    case CONTENT_TYPE_APPLICATION_JSON:
        strncpy(content_type_buffer,
    4a7e:	07 59       	subi	r16, 0x97	; 151
    4a80:	1f 4f       	sbci	r17, 0xFF	; 255
    4a82:	84 e3       	ldi	r24, 0x34	; 52
    4a84:	90 e0       	ldi	r25, 0x00	; 0
    4a86:	d8 01       	movw	r26, r16
    4a88:	8d 93       	st	X+, r24
    4a8a:	9c 93       	st	X, r25
sendData():
    4a8c:	ed b7       	in	r30, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:202
        http_response.data_size = atoi(data_size_buffer);
    }

    LedCtrl.off(Led::CON, true);

    return http_response;
    4a8e:	fe b7       	in	r31, 0x3e	; 62
    4a90:	3a 96       	adiw	r30, 0x0a	; 10
    4a92:	ed bf       	out	0x3d, r30	; 61
    4a94:	fe bf       	out	0x3e, r31	; 62
    4a96:	2d b7       	in	r18, 0x3d	; 61
    4a98:	3e b7       	in	r19, 0x3e	; 62
    4a9a:	e3 96       	adiw	r28, 0x33	; 51
    4a9c:	2e af       	std	Y+62, r18	; 0x3e
    4a9e:	3f af       	std	Y+63, r19	; 0x3f
    4aa0:	e3 97       	sbiw	r28, 0x33	; 51
    4aa2:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:90
         const uint8_t* header        = NULL,
         const uint32_t header_length = 0,
         const char* content_type     = "",
         const uint32_t timeout_ms    = HTTP_DEFAULT_TIMEOUT_MS) {

    LedCtrl.on(Led::CON, true);
    4aa4:	90 e0       	ldi	r25, 0x00	; 0
    4aa6:	42 de       	rcall	.-892    	; 0x472c <LedCtrlClass::on(Led, bool) [clone .constprop.114]>
    4aa8:	50 e0       	ldi	r21, 0x00	; 0
    4aaa:	40 e0       	ldi	r20, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:94

    // The modem could hang if several HTTP requests are done quickly after each
    // other, this alleviates this
    SequansController.writeCommand("AT");
    4aac:	70 e0       	ldi	r23, 0x00	; 0
    4aae:	60 e0       	ldi	r22, 0x00	; 0
    4ab0:	86 ee       	ldi	r24, 0xE6	; 230
    4ab2:	9c e4       	ldi	r25, 0x4C	; 76
    4ab4:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    4ab8:	c4 01       	movw	r24, r8
    4aba:	b0 e0       	ldi	r27, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:99

    HttpResponse http_response = {0, 0};

    // Setup and transmit SEND command before sending the data
    const uint32_t digits_in_data_length = trunc(log10(data_length)) + 1;
    4abc:	a0 e0       	ldi	r26, 0x00	; 0
    4abe:	af 96       	adiw	r28, 0x2f	; 47
    4ac0:	8c af       	std	Y+60, r24	; 0x3c
    4ac2:	9d af       	std	Y+61, r25	; 0x3d
    4ac4:	ae af       	std	Y+62, r26	; 0x3e
    4ac6:	bf af       	std	Y+63, r27	; 0x3f
    4ac8:	af 97       	sbiw	r28, 0x2f	; 47
    4aca:	b4 01       	movw	r22, r8
    4acc:	cd 01       	movw	r24, r26
    4ace:	0e 94 2b 51 	call	0xa256	; 0xa256 <__floatunsisf>
    4ad2:	0e 94 de 53 	call	0xa7bc	; 0xa7bc <log10>
    4ad6:	0e 94 29 54 	call	0xa852	; 0xa852 <trunc>
    4ada:	eb 2d       	mov	r30, r11
    4adc:	fa 2d       	mov	r31, r10
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:101

    const uint32_t command_length = strlen(HTTP_SEND) + strlen(endpoint) +
    4ade:	df 01       	movw	r26, r30
    4ae0:	0d 90       	ld	r0, X+
    4ae2:	00 20       	and	r0, r0
    4ae4:	e9 f7       	brne	.-6      	; 0x4ae0 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x3ac>
    4ae6:	11 97       	sbiw	r26, 0x01	; 1
    4ae8:	7d 01       	movw	r14, r26
    4aea:	ee 1a       	sub	r14, r30
    4aec:	ff 0a       	sbc	r15, r31
    4aee:	20 e0       	ldi	r18, 0x00	; 0
    4af0:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:99
    SequansController.writeCommand("AT");

    HttpResponse http_response = {0, 0};

    // Setup and transmit SEND command before sending the data
    const uint32_t digits_in_data_length = trunc(log10(data_length)) + 1;
    4af2:	40 e8       	ldi	r20, 0x80	; 128
    4af4:	5f e3       	ldi	r21, 0x3F	; 63
    4af6:	0e 94 dd 52 	call	0xa5ba	; 0xa5ba <__addsf3>
    4afa:	0e 94 ae 53 	call	0xa75c	; 0xa75c <__fixunssfsi>
    4afe:	a5 e2       	ldi	r26, 0x25	; 37
    4b00:	ea 0e       	add	r14, r26
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:101

    const uint32_t command_length = strlen(HTTP_SEND) + strlen(endpoint) +
    4b02:	f1 1c       	adc	r15, r1
    4b04:	1b 01       	movw	r2, r22
    4b06:	2c 01       	movw	r4, r24
    4b08:	2e 0c       	add	r2, r14
    4b0a:	3f 1c       	adc	r3, r15
    4b0c:	41 1c       	adc	r4, r1
    4b0e:	51 1c       	adc	r5, r1
    4b10:	d2 01       	movw	r26, r4
    4b12:	c1 01       	movw	r24, r2
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:105
                                    digits_in_data_length + header_length;

    // Append +1 for NULL termination
    char command[command_length + 1];
    4b14:	01 96       	adiw	r24, 0x01	; 1
    4b16:	a1 1d       	adc	r26, r1
    4b18:	b1 1d       	adc	r27, r1
    4b1a:	ed b7       	in	r30, 0x3d	; 61
    4b1c:	fe b7       	in	r31, 0x3e	; 62
    4b1e:	e8 1b       	sub	r30, r24
    4b20:	f9 0b       	sbc	r31, r25
    4b22:	ed bf       	out	0x3d, r30	; 61
    4b24:	fe bf       	out	0x3e, r31	; 62
    4b26:	2d b7       	in	r18, 0x3d	; 61
    4b28:	3e b7       	in	r19, 0x3e	; 62
    4b2a:	2f 5f       	subi	r18, 0xFF	; 255
    4b2c:	3f 4f       	sbci	r19, 0xFF	; 255
    4b2e:	79 01       	movw	r14, r18
    4b30:	82 ef       	ldi	r24, 0xF2	; 242
    4b32:	91 e6       	ldi	r25, 0x61	; 97
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:115
                                 HTTP_SEND,
                                 method,
                                 endpoint,
                                 (unsigned long)data_length,
                                 content_type,
                                 header == NULL ? "" : (const char*)header);
    4b34:	9f 93       	push	r25
    4b36:	8f 93       	push	r24
    4b38:	1f 93       	push	r17
    4b3a:	0f 93       	push	r16
    4b3c:	1f 92       	push	r1
    4b3e:	1f 92       	push	r1
    4b40:	ad 96       	adiw	r28, 0x2d	; 45
    4b42:	3f ad       	ldd	r19, Y+63	; 0x3f
    4b44:	ad 97       	sbiw	r28, 0x2d	; 45
    4b46:	3f 93       	push	r19
    4b48:	ac 96       	adiw	r28, 0x2c	; 44
    4b4a:	8f ad       	ldd	r24, Y+63	; 0x3f
    4b4c:	ac 97       	sbiw	r28, 0x2c	; 44
    4b4e:	8f 93       	push	r24
    4b50:	af 92       	push	r10
    4b52:	bf 92       	push	r11
    4b54:	1f 92       	push	r1
    4b56:	1f 92       	push	r1
    4b58:	81 ee       	ldi	r24, 0xE1	; 225
    4b5a:	9d e4       	ldi	r25, 0x4D	; 77
    4b5c:	9f 93       	push	r25
    4b5e:	8f 93       	push	r24
    4b60:	3f 92       	push	r3
    4b62:	2f 92       	push	r2
    4b64:	ff 92       	push	r15
    4b66:	ef 92       	push	r14
    4b68:	0e 94 83 57 	call	0xaf06	; 0xaf06 <snprintf>
    4b6c:	8c 01       	movw	r16, r24
    4b6e:	ad b7       	in	r26, 0x3d	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:116
    if (bytes_written < 0) {
    4b70:	be b7       	in	r27, 0x3e	; 62
    4b72:	52 96       	adiw	r26, 0x12	; 18
    4b74:	ad bf       	out	0x3d, r26	; 61
    4b76:	be bf       	out	0x3e, r27	; 62
    4b78:	97 ff       	sbrs	r25, 7
    4b7a:	1e c0       	rjmp	.+60     	; 0x4bb8 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x484>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:117
        Log.errorf(
    4b7c:	1f 93       	push	r17
    4b7e:	8f 93       	push	r24
    4b80:	87 e0       	ldi	r24, 0x07	; 7
    4b82:	9e e4       	ldi	r25, 0x4E	; 78
    4b84:	9f 93       	push	r25
    4b86:	8f 93       	push	r24
    4b88:	e9 e6       	ldi	r30, 0x69	; 105
    4b8a:	f0 e7       	ldi	r31, 0x70	; 112
    4b8c:	ff 93       	push	r31
    4b8e:	ef 93       	push	r30
    4b90:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    4b94:	0f 90       	pop	r0
    4b96:	0f 90       	pop	r0
    4b98:	0f 90       	pop	r0
    4b9a:	0f 90       	pop	r0
    4b9c:	0f 90       	pop	r0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:128
    if (bytes_written >= (int)command_length) {
        Log.errorf("Failed to write HTTP send command, snprintf returned %d "
                   "but command length is %d\r\n",
                   bytes_written,
                   command_length);
        return HttpResponse{0, 0};
    4b9e:	0f 90       	pop	r0
    4ba0:	c1 2c       	mov	r12, r1
    4ba2:	d1 2c       	mov	r13, r1
    4ba4:	76 01       	movw	r14, r12
    4ba6:	10 e0       	ldi	r17, 0x00	; 0
    4ba8:	00 e0       	ldi	r16, 0x00	; 0
    4baa:	e3 96       	adiw	r28, 0x33	; 51
    4bac:	ee ad       	ldd	r30, Y+62	; 0x3e
    4bae:	ff ad       	ldd	r31, Y+63	; 0x3f
    4bb0:	e3 97       	sbiw	r28, 0x33	; 51
    4bb2:	ed bf       	out	0x3d, r30	; 61
    4bb4:	fe bf       	out	0x3e, r31	; 62
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:123
            "Failed to write HTTP send command, snprintf returned %d\r\n",
            bytes_written);
        return HttpResponse{0, 0};
    }

    if (bytes_written >= (int)command_length) {
    4bb6:	91 ce       	rjmp	.-734    	; 0x48da <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x1a6>
    4bb8:	82 15       	cp	r24, r2
    4bba:	93 05       	cpc	r25, r3
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:124
        Log.errorf("Failed to write HTTP send command, snprintf returned %d "
    4bbc:	b4 f0       	brlt	.+44     	; 0x4bea <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x4b6>
    4bbe:	5f 92       	push	r5
    4bc0:	4f 92       	push	r4
    4bc2:	3f 92       	push	r3
    4bc4:	2f 92       	push	r2
    4bc6:	1f 93       	push	r17
    4bc8:	8f 93       	push	r24
    4bca:	81 e4       	ldi	r24, 0x41	; 65
    4bcc:	9e e4       	ldi	r25, 0x4E	; 78
    4bce:	9f 93       	push	r25
    4bd0:	8f 93       	push	r24
    4bd2:	89 e6       	ldi	r24, 0x69	; 105
    4bd4:	90 e7       	ldi	r25, 0x70	; 112
    4bd6:	9f 93       	push	r25
    4bd8:	8f 93       	push	r24
    4bda:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    4bde:	ed b7       	in	r30, 0x3d	; 61
    4be0:	fe b7       	in	r31, 0x3e	; 62
    4be2:	3a 96       	adiw	r30, 0x0a	; 10
    4be4:	ed bf       	out	0x3d, r30	; 61
    4be6:	fe bf       	out	0x3e, r31	; 62
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:131
                   bytes_written,
                   command_length);
        return HttpResponse{0, 0};
    }

    command[bytes_written + 1] = '\0';
    4be8:	db cf       	rjmp	.-74     	; 0x4ba0 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x46c>
    4bea:	f7 01       	movw	r30, r14
    4bec:	e8 0f       	add	r30, r24
    4bee:	f9 1f       	adc	r31, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:133

    LedCtrl.on(Led::DATA, true);
    4bf0:	11 82       	std	Z+1, r1	; 0x01
    4bf2:	82 e0       	ldi	r24, 0x02	; 2
    4bf4:	90 e0       	ldi	r25, 0x00	; 0
    4bf6:	9a dd       	rcall	.-1228   	; 0x472c <LedCtrlClass::on(Led, bool) [clone .constprop.114]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:134
    SequansController.writeBytes((uint8_t*)command, bytes_written, true);
    4bf8:	41 e0       	ldi	r20, 0x01	; 1
    4bfa:	b8 01       	movw	r22, r16
    4bfc:	c7 01       	movw	r24, r14
    4bfe:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:137

    // Only send the data payload if there is any
    if (data_length > 0) {
    4c02:	81 14       	cp	r8, r1
    4c04:	91 04       	cpc	r9, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:139

        if (!SequansController.waitForByte(HTTP_SEND_START_CHARACTER,
    4c06:	21 f1       	breq	.+72     	; 0x4c50 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x51c>
    4c08:	40 e2       	ldi	r20, 0x20	; 32
    4c0a:	5e e4       	ldi	r21, 0x4E	; 78
    4c0c:	60 e0       	ldi	r22, 0x00	; 0
    4c0e:	70 e0       	ldi	r23, 0x00	; 0
    4c10:	8e e3       	ldi	r24, 0x3E	; 62
    4c12:	0e 94 b9 07 	call	0xf72	; 0xf72 <SequansControllerClass::waitForByte(unsigned char, unsigned long) [clone .constprop.116]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:141
                                           HTTP_TIMEOUT)) {
            Log.error("Timed out whilst waiting on delivering the HTTP "
    4c16:	81 11       	cpse	r24, r1
    4c18:	0d c0       	rjmp	.+26     	; 0x4c34 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x500>
    4c1a:	84 e9       	ldi	r24, 0x94	; 148
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:146
                      "payload. Is the "
                      "server online? If you're using HTTPS, you might need to "
                      "provision with a different CA certificate.");

            LedCtrl.off(Led::CON, true);
    4c1c:	9e e4       	ldi	r25, 0x4E	; 78
    4c1e:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    4c22:	61 e0       	ldi	r22, 0x01	; 1
    4c24:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:147
            LedCtrl.off(Led::DATA, true);
    4c26:	90 e0       	ldi	r25, 0x00	; 0
    4c28:	22 dd       	rcall	.-1468   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
    4c2a:	61 e0       	ldi	r22, 0x01	; 1
    4c2c:	82 e0       	ldi	r24, 0x02	; 2
    4c2e:	90 e0       	ldi	r25, 0x00	; 0
    4c30:	1e dd       	rcall	.-1476   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:187
    4c32:	b6 cf       	rjmp	.-148    	; 0x4ba0 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x46c>
_delay_ms():
    4c34:	ff ef       	ldi	r31, 0xFF	; 255
    4c36:	22 e5       	ldi	r18, 0x52	; 82
    4c38:	37 e0       	ldi	r19, 0x07	; 7
    4c3a:	f1 50       	subi	r31, 0x01	; 1
    4c3c:	20 40       	sbci	r18, 0x00	; 0
    4c3e:	30 40       	sbci	r19, 0x00	; 0
    4c40:	e1 f7       	brne	.-8      	; 0x4c3a <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x506>
    4c42:	00 c0       	rjmp	.+0      	; 0x4c44 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x510>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:156
        // Wait some before delivering the payload. The modem might hang if we
        // deliver it too quickly
        _delay_ms(100);

        // Now we deliver the payload
        SequansController.writeBytes(data, data_length, true);
    4c44:	00 00       	nop
sendData():
    4c46:	41 e0       	ldi	r20, 0x01	; 1
    4c48:	b4 01       	movw	r22, r8
    4c4a:	c6 01       	movw	r24, r12
    4c4c:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:159
    }

    char http_response_buffer[HTTP_RESPONSE_MAX_LENGTH]                = "";
    4c50:	19 82       	std	Y+1, r1	; 0x01
    4c52:	1a 82       	std	Y+2, r1	; 0x02
    4c54:	fe 01       	movw	r30, r28
    4c56:	33 96       	adiw	r30, 0x03	; 3
    4c58:	82 e5       	ldi	r24, 0x52	; 82
    4c5a:	df 01       	movw	r26, r30
    4c5c:	1d 92       	st	X+, r1
    4c5e:	8a 95       	dec	r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:160
    char http_status_code_buffer[HTTP_RESPONSE_STATUS_CODE_LENGTH + 1] = "";
    4c60:	e9 f7       	brne	.-6      	; 0x4c5c <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x528>
    4c62:	a7 96       	adiw	r28, 0x27	; 39
    4c64:	1e ae       	std	Y+62, r1	; 0x3e
    4c66:	1f ae       	std	Y+63, r1	; 0x3f
    4c68:	a7 97       	sbiw	r28, 0x27	; 39
    4c6a:	a9 96       	adiw	r28, 0x29	; 41
    4c6c:	1e ae       	std	Y+62, r1	; 0x3e
    4c6e:	1f ae       	std	Y+63, r1	; 0x3f
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:161
    char data_size_buffer[HTTP_RESPONSE_DATA_SIZE_LENGTH]              = "";
    4c70:	a9 97       	sbiw	r28, 0x29	; 41
    4c72:	ee 5a       	subi	r30, 0xAE	; 174
    4c74:	ff 4f       	sbci	r31, 0xFF	; 255
    4c76:	11 92       	st	Z+, r1
    4c78:	11 92       	st	Z+, r1
    4c7a:	8e e0       	ldi	r24, 0x0E	; 14
    4c7c:	df 01       	movw	r26, r30
    4c7e:	1d 92       	st	X+, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:164

    // Now we wait for the URC
    if (!SequansController.waitForURC(HTTP_RING_URC,
    4c80:	8a 95       	dec	r24
    4c82:	e9 f7       	brne	.-6      	; 0x4c7e <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x54a>
    4c84:	90 e3       	ldi	r25, 0x30	; 48
    4c86:	c9 2e       	mov	r12, r25
    4c88:	25 e7       	ldi	r18, 0x75	; 117
    4c8a:	d2 2e       	mov	r13, r18
    4c8c:	e1 2c       	mov	r14, r1
    4c8e:	f1 2c       	mov	r15, r1
    4c90:	00 e0       	ldi	r16, 0x00	; 0
    4c92:	10 e0       	ldi	r17, 0x00	; 0
    4c94:	20 e0       	ldi	r18, 0x00	; 0
    4c96:	30 e0       	ldi	r19, 0x00	; 0
    4c98:	44 e5       	ldi	r20, 0x54	; 84
    4c9a:	50 e0       	ldi	r21, 0x00	; 0
    4c9c:	be 01       	movw	r22, r28
    4c9e:	6f 5f       	subi	r22, 0xFF	; 255
    4ca0:	7f 4f       	sbci	r23, 0xFF	; 255
    4ca2:	85 e9       	ldi	r24, 0x95	; 149
    4ca4:	9d e4       	ldi	r25, 0x4D	; 77
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:168
                                      http_response_buffer,
                                      sizeof(http_response_buffer),
                                      timeout_ms)) {
        LedCtrl.off(Led::CON, true);
    4ca6:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:164
    char http_response_buffer[HTTP_RESPONSE_MAX_LENGTH]                = "";
    char http_status_code_buffer[HTTP_RESPONSE_STATUS_CODE_LENGTH + 1] = "";
    char data_size_buffer[HTTP_RESPONSE_DATA_SIZE_LENGTH]              = "";

    // Now we wait for the URC
    if (!SequansController.waitForURC(HTTP_RING_URC,
    4caa:	61 e0       	ldi	r22, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:168
                                      http_response_buffer,
                                      sizeof(http_response_buffer),
                                      timeout_ms)) {
        LedCtrl.off(Led::CON, true);
    4cac:	81 11       	cpse	r24, r1
    4cae:	0c c0       	rjmp	.+24     	; 0x4cc8 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x594>
    4cb0:	81 e0       	ldi	r24, 0x01	; 1
    4cb2:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:169
        LedCtrl.off(Led::DATA, true);
    4cb4:	dc dc       	rcall	.-1608   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
    4cb6:	61 e0       	ldi	r22, 0x01	; 1
    4cb8:	82 e0       	ldi	r24, 0x02	; 2
    4cba:	90 e0       	ldi	r25, 0x00	; 0
    4cbc:	d8 dc       	rcall	.-1616   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:170
        Log.warn("Did not get HTTP response before timeout\r\n");
    4cbe:	81 ea       	ldi	r24, 0xA1	; 161
    4cc0:	9d e4       	ldi	r25, 0x4D	; 77
    4cc2:	0e 94 9c 0a 	call	0x1538	; 0x1538 <LogClass::warn(char const*) [clone .constprop.124]>
    4cc6:	6c cf       	rjmp	.-296    	; 0x4ba0 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x46c>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:174
        return http_response;
    }

    LedCtrl.off(Led::DATA, true);
    4cc8:	82 e0       	ldi	r24, 0x02	; 2
    4cca:	90 e0       	ldi	r25, 0x00	; 0
    4ccc:	d0 dc       	rcall	.-1632   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
    4cce:	00 e0       	ldi	r16, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:183
    bool got_response_code = SequansController.extractValueFromCommandResponse(
        http_response_buffer,
        HTTP_RESPONSE_STATUS_CODE_INDEX,
        http_status_code_buffer,
        HTTP_RESPONSE_STATUS_CODE_LENGTH + 1,
        (char)NULL);
    4cd0:	24 e0       	ldi	r18, 0x04	; 4
    4cd2:	30 e0       	ldi	r19, 0x00	; 0
    4cd4:	ae 01       	movw	r20, r28
    4cd6:	4b 59       	subi	r20, 0x9B	; 155
    4cd8:	5f 4f       	sbci	r21, 0xFF	; 255
    4cda:	61 e0       	ldi	r22, 0x01	; 1
    4cdc:	ce 01       	movw	r24, r28
    4cde:	01 96       	adiw	r24, 0x01	; 1
    4ce0:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    4ce4:	18 2f       	mov	r17, r24
    4ce6:	20 e1       	ldi	r18, 0x10	; 16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:190
    bool got_data_size = SequansController.extractValueFromCommandResponse(
        http_response_buffer,
        HTTP_RESPONSE_DATA_SIZE_INDEX,
        data_size_buffer,
        HTTP_RESPONSE_DATA_SIZE_LENGTH,
        (char)NULL);
    4ce8:	30 e0       	ldi	r19, 0x00	; 0
    4cea:	ae 01       	movw	r20, r28
    4cec:	4b 5a       	subi	r20, 0xAB	; 171
    4cee:	5f 4f       	sbci	r21, 0xFF	; 255
    4cf0:	63 e0       	ldi	r22, 0x03	; 3
    4cf2:	ce 01       	movw	r24, r28
    4cf4:	01 96       	adiw	r24, 0x01	; 1
    4cf6:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    4cfa:	f8 2e       	mov	r15, r24
    4cfc:	11 23       	and	r17, r17
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:192

    if (got_response_code) {
    4cfe:	b1 f0       	breq	.+44     	; 0x4d2c <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x5f8>
    4d00:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:193
        http_response.status_code = atoi(http_status_code_buffer);
    4d02:	8b 59       	subi	r24, 0x9B	; 155
    4d04:	9f 4f       	sbci	r25, 0xFF	; 255
    4d06:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
    4d0a:	8c 01       	movw	r16, r24
    4d0c:	ff 20       	and	r15, r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:196
    }

    if (got_data_size) {
    4d0e:	89 f0       	breq	.+34     	; 0x4d32 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x5fe>
    4d10:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:197
        http_response.data_size = atoi(data_size_buffer);
    4d12:	8b 5a       	subi	r24, 0xAB	; 171
    4d14:	9f 4f       	sbci	r25, 0xFF	; 255
    4d16:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
    4d1a:	6c 01       	movw	r12, r24
    4d1c:	99 0f       	add	r25, r25
    4d1e:	ee 08       	sbc	r14, r14
    4d20:	ff 08       	sbc	r15, r15
    4d22:	61 e0       	ldi	r22, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:200
    }

    LedCtrl.off(Led::CON, true);
    4d24:	81 e0       	ldi	r24, 0x01	; 1
    4d26:	90 e0       	ldi	r25, 0x00	; 0
    4d28:	a2 dc       	rcall	.-1724   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
    4d2a:	3f cf       	rjmp	.-386    	; 0x4baa <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x476>
iotconnect_https_request():
    4d2c:	10 e0       	ldi	r17, 0x00	; 0
    4d2e:	00 e0       	ldi	r16, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:96

    // The modem could hang if several HTTP requests are done quickly after each
    // other, this alleviates this
    SequansController.writeCommand("AT");

    HttpResponse http_response = {0, 0};
    4d30:	ed cf       	rjmp	.-38     	; 0x4d0c <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x5d8>
    4d32:	c1 2c       	mov	r12, r1
    4d34:	d1 2c       	mov	r13, r1
    4d36:	76 01       	movw	r14, r12
    4d38:	f4 cf       	rjmp	.-24     	; 0x4d22 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x5ee>
    4d3a:	08 3c       	cpi	r16, 0xC8	; 200
    4d3c:	11 05       	cpc	r17, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:44
    if (0 == http_rsp.status_code) {
        Log.errorf("Unable to get response from the server for URL https://%s%s\r\n", host, path);
        return -1;
    }

    if (200 != http_rsp.status_code) {
    4d3e:	91 f0       	breq	.+36     	; 0x4d64 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x630>
    4d40:	1f 93       	push	r17
    4d42:	0f 93       	push	r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:45
        Log.warnf("Unexpected HTTP response status code %u\r\n", http_rsp.status_code);
    4d44:	85 e7       	ldi	r24, 0x75	; 117
    4d46:	9f e4       	ldi	r25, 0x4F	; 79
    4d48:	9f 93       	push	r25
    4d4a:	8f 93       	push	r24
    4d4c:	89 e6       	ldi	r24, 0x69	; 105
    4d4e:	90 e7       	ldi	r25, 0x70	; 112
    4d50:	9f 93       	push	r25
    4d52:	8f 93       	push	r24
    4d54:	0e 94 ba 0b 	call	0x1774	; 0x1774 <LogClass::warnf(char const*, ...) [clone .constprop.94]>
    4d58:	0f 90       	pop	r0
    4d5a:	0f 90       	pop	r0
    4d5c:	0f 90       	pop	r0
    4d5e:	0f 90       	pop	r0
    4d60:	0f 90       	pop	r0
    4d62:	0f 90       	pop	r0
    4d64:	08 ee       	ldi	r16, 0xE8	; 232
    4d66:	13 e0       	ldi	r17, 0x03	; 3
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:48
    }

    size_t data_size = 1000;
    4d68:	c1 14       	cp	r12, r1
    4d6a:	d1 04       	cpc	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:49
    if (http_rsp.data_size) {
    4d6c:	e1 04       	cpc	r14, r1
    4d6e:	f1 04       	cpc	r15, r1
    4d70:	b1 f0       	breq	.+44     	; 0x4d9e <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x66a>
    4d72:	86 01       	movw	r16, r12
    4d74:	00 5f       	subi	r16, 0xF0	; 240
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:50
        data_size = http_rsp.data_size + 16;     // Add some extra bytes for termination
    4d76:	1f 4f       	sbci	r17, 0xFF	; 255
    4d78:	ff 92       	push	r15
    4d7a:	ef 92       	push	r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:51
        Log.infof("-------- Reported data size is %u\r\n", http_rsp.data_size);
    4d7c:	df 92       	push	r13
    4d7e:	cf 92       	push	r12
    4d80:	8f e9       	ldi	r24, 0x9F	; 159
    4d82:	9f e4       	ldi	r25, 0x4F	; 79
    4d84:	9f 93       	push	r25
    4d86:	8f 93       	push	r24
    4d88:	89 e6       	ldi	r24, 0x69	; 105
    4d8a:	90 e7       	ldi	r25, 0x70	; 112
    4d8c:	9f 93       	push	r25
    4d8e:	8f 93       	push	r24
    4d90:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
    4d94:	8d b7       	in	r24, 0x3d	; 61
    4d96:	9e b7       	in	r25, 0x3e	; 62
    4d98:	08 96       	adiw	r24, 0x08	; 8
    4d9a:	8d bf       	out	0x3d, r24	; 61
    4d9c:	9e bf       	out	0x3e, r25	; 62
    4d9e:	28 01       	movw	r4, r16
    4da0:	71 2c       	mov	r7, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:55
    }

    // Responses should not be
    String body = HttpClient.readBody(data_size);
    4da2:	61 2c       	mov	r6, r1
readBody():
    4da4:	ad b6       	in	r10, 0x3d	; 61
    4da6:	be b6       	in	r11, 0x3e	; 62
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:500

    if (bytes_read == -1) {
        return "";
    }

    return String(buffer);
    4da8:	ad b7       	in	r26, 0x3d	; 61
    4daa:	be b7       	in	r27, 0x3e	; 62
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:493

    return strlen(buffer);
}

String HttpClientClass::readBody(const uint32_t size) {
    char buffer[size];
    4dac:	a0 1b       	sub	r26, r16
    4dae:	b1 0b       	sbc	r27, r17
    4db0:	ad bf       	out	0x3d, r26	; 61
    4db2:	be bf       	out	0x3e, r27	; 62
    4db4:	ed b7       	in	r30, 0x3d	; 61
    4db6:	fe b7       	in	r31, 0x3e	; 62
    4db8:	31 96       	adiw	r30, 0x01	; 1
    4dba:	6f 01       	movw	r12, r30
    4dbc:	d3 01       	movw	r26, r6
    4dbe:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:456

int16_t HttpClientClass::readBody(char* buffer, const uint32_t buffer_size) {

    // Safeguard against the limitation in the Sequans AT command parameter
    // for the response receive command.
    if (buffer_size < HTTP_BODY_BUFFER_MIN_SIZE ||
    4dc0:	80 54       	subi	r24, 0x40	; 64
    4dc2:	91 09       	sbc	r25, r1
    4dc4:	a1 09       	sbc	r26, r1
    4dc6:	b1 09       	sbc	r27, r1
    4dc8:	9e 01       	movw	r18, r28
    4dca:	2f 5f       	subi	r18, 0xFF	; 255
    4dcc:	3f 4f       	sbci	r19, 0xFF	; 255
    4dce:	79 01       	movw	r14, r18
    4dd0:	62 ef       	ldi	r22, 0xF2	; 242
    4dd2:	71 e6       	ldi	r23, 0x61	; 97
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:497
String HttpClientClass::readBody(const uint32_t size) {
    char buffer[size];
    int16_t bytes_read = readBody(buffer, sizeof(buffer));

    if (bytes_read == -1) {
        return "";
    4dd4:	8d 39       	cpi	r24, 0x9D	; 157
    4dd6:	95 40       	sbci	r25, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:456

int16_t HttpClientClass::readBody(char* buffer, const uint32_t buffer_size) {

    // Safeguard against the limitation in the Sequans AT command parameter
    // for the response receive command.
    if (buffer_size < HTTP_BODY_BUFFER_MIN_SIZE ||
    4dd8:	a1 05       	cpc	r26, r1
    4dda:	b1 05       	cpc	r27, r1
    4ddc:	e0 f5       	brcc	.+120    	; 0x4e56 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x722>
    4dde:	50 e0       	ldi	r21, 0x00	; 0
    4de0:	40 e0       	ldi	r20, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:463
        return -1;
    }

    // Fix for bringing the modem out of idling and prevent timeout whilst
    // waiting for modem response during the next AT command
    SequansController.writeCommand("AT");
    4de2:	70 e0       	ldi	r23, 0x00	; 0
    4de4:	60 e0       	ldi	r22, 0x00	; 0
    4de6:	86 ee       	ldi	r24, 0xE6	; 230
    4de8:	9c e4       	ldi	r25, 0x4C	; 76
    4dea:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    4dee:	19 82       	std	Y+1, r1	; 0x01
    4df0:	1a 82       	std	Y+2, r1	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:467

    // We send the buffer size with the receive command so that we only
    // receive that. The rest will be flushed from the modem.
    char command[HTTP_RECEIVE_LENGTH] = "";
    4df2:	fe 01       	movw	r30, r28
    4df4:	33 96       	adiw	r30, 0x03	; 3
    4df6:	8e e1       	ldi	r24, 0x1E	; 30
    4df8:	df 01       	movw	r26, r30
    4dfa:	1d 92       	st	X+, r1
    4dfc:	8a 95       	dec	r24
    4dfe:	e9 f7       	brne	.-6      	; 0x4dfa <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x6c6>
    4e00:	1f 92       	push	r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:468
    sprintf(command, HTTP_RECEIVE, buffer_size);
    4e02:	1f 92       	push	r1
    4e04:	5f 92       	push	r5
    4e06:	0f 93       	push	r16
    4e08:	83 ec       	ldi	r24, 0xC3	; 195
    4e0a:	9f e4       	ldi	r25, 0x4F	; 79
    4e0c:	9f 93       	push	r25
    4e0e:	8f 93       	push	r24
    4e10:	ff 92       	push	r15
    4e12:	ef 92       	push	r14
    4e14:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:469
    SequansController.writeBytes((uint8_t*)command, strlen(command), true);
    4e18:	f7 01       	movw	r30, r14
    4e1a:	01 90       	ld	r0, Z+
    4e1c:	00 20       	and	r0, r0
    4e1e:	e9 f7       	brne	.-6      	; 0x4e1a <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x6e6>
    4e20:	31 97       	sbiw	r30, 0x01	; 1
    4e22:	bf 01       	movw	r22, r30
    4e24:	6e 19       	sub	r22, r14
    4e26:	7f 09       	sbc	r23, r15
    4e28:	41 e0       	ldi	r20, 0x01	; 1
    4e2a:	c7 01       	movw	r24, r14
    4e2c:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
    4e30:	ed b7       	in	r30, 0x3d	; 61
    4e32:	fe b7       	in	r31, 0x3e	; 62
    4e34:	38 96       	adiw	r30, 0x08	; 8
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:473

    // We receive three start bytes of the character '<', so we wait for
    // them
    uint8_t start_bytes = 3;
    4e36:	ed bf       	out	0x3d, r30	; 61
    4e38:	fe bf       	out	0x3e, r31	; 62
iotconnect_https_request():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:476

    while (start_bytes > 0) {
        if (SequansController.readByte() == HTTP_RECEIVE_START_CHARACTER) {
    4e3a:	83 e0       	ldi	r24, 0x03	; 3
    4e3c:	98 2e       	mov	r9, r24
readBody():
    4e3e:	0e 94 91 07 	call	0xf22	; 0xf22 <SequansControllerClass::readByte() [clone .constprop.117]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:477
            start_bytes--;
    4e42:	cc 97       	sbiw	r24, 0x3c	; 60
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:475

    // We receive three start bytes of the character '<', so we wait for
    // them
    uint8_t start_bytes = 3;

    while (start_bytes > 0) {
    4e44:	e1 f7       	brne	.-8      	; 0x4e3e <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x70a>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:484
    }

    // Now we are ready to receive the payload. We only check for error and
    // not overflow in the receive buffer in comparison to our buffer as we
    // know the size of what we want to receive
    if (SequansController.readResponse(buffer, buffer_size) !=
    4e46:	9a 94       	dec	r9
    4e48:	91 10       	cpse	r9, r1
    4e4a:	f9 cf       	rjmp	.-14     	; 0x4e3e <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x70a>
    4e4c:	b8 01       	movw	r22, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/http_client.cpp:500

    if (bytes_read == -1) {
        return "";
    }

    return String(buffer);
    4e4e:	c6 01       	movw	r24, r12
    4e50:	0e 94 70 17 	call	0x2ee0	; 0x2ee0 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]>
    4e54:	b6 01       	movw	r22, r12
    4e56:	c7 01       	movw	r24, r14
    4e58:	0e 94 be 09 	call	0x137c	; 0x137c <String::String(char const*)>
    4e5c:	ad be       	out	0x3d, r10	; 61
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:57
    size_t body_length = body.length();
    if (0 == body_length) {
    4e5e:	be be       	out	0x3e, r11	; 62
    4e60:	8d 81       	ldd	r24, Y+5	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:58
        Log.error("Http response was empty");
    4e62:	9e 81       	ldd	r25, Y+6	; 0x06
iotconnect_https_request():
    4e64:	00 97       	sbiw	r24, 0x00	; 0
    4e66:	59 f4       	brne	.+22     	; 0x4e7e <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x74a>
    4e68:	87 ed       	ldi	r24, 0xD7	; 215
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:59
        return -1;
    4e6a:	9f e4       	ldi	r25, 0x4F	; 79
    4e6c:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:114
  char buf[33];
  *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String() {
  free(buffer);
    4e70:	0f ef       	ldi	r16, 0xFF	; 255
    4e72:	1f ef       	ldi	r17, 0xFF	; 255
__base_dtor ():
    4e74:	89 81       	ldd	r24, Y+1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:61
    }
    response->data = (char *) malloc(body_length + 1);
    4e76:	9a 81       	ldd	r25, Y+2	; 0x02
    4e78:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    4e7c:	8f cc       	rjmp	.-1762   	; 0x479c <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x68>
iotconnect_https_request():
    4e7e:	01 96       	adiw	r24, 0x01	; 1
    4e80:	0e 94 b8 54 	call	0xa970	; 0xa970 <malloc>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:62
    strcpy(response->data, body.c_str());
    4e84:	e1 96       	adiw	r28, 0x31	; 49
    4e86:	ae ad       	ldd	r26, Y+62	; 0x3e
    4e88:	bf ad       	ldd	r27, Y+63	; 0x3f
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:63
    return 0;
    4e8a:	e1 97       	sbiw	r28, 0x31	; 49
    4e8c:	8d 93       	st	X+, r24
    4e8e:	9c 93       	st	X, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:75

static void connectionStatus(char* buffer) {

    const char stat = buffer[CEREG_STAT_CHARACTER_INDEX];

    if (stat == STAT_REGISTERED_ROAMING ||
    4e90:	69 81       	ldd	r22, Y+1	; 0x01
    4e92:	7a 81       	ldd	r23, Y+2	; 0x02
    4e94:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:78
        stat == STAT_REGISTERED_HOME_NETWORK) {

        is_connected = true;
    4e98:	10 e0       	ldi	r17, 0x00	; 0
    4e9a:	00 e0       	ldi	r16, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:80

        LedCtrl.on(Led::CELL, true);
    4e9c:	eb cf       	rjmp	.-42     	; 0x4e74 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]+0x740>

00004e9e <connectionStatus(char*)>:
connectionStatus():
    4e9e:	fc 01       	movw	r30, r24
    4ea0:	81 81       	ldd	r24, Z+1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:84

    } else {

        if (is_connected) {
    4ea2:	8b 7f       	andi	r24, 0xFB	; 251
    4ea4:	81 33       	cpi	r24, 0x31	; 49
    4ea6:	31 f4       	brne	.+12     	; 0x4eb4 <connectionStatus(char*)+0x16>
    4ea8:	81 e0       	ldi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:85
            is_connected = false;
    4eaa:	80 93 8d 66 	sts	0x668D, r24	; 0x80668d <is_connected>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:86
            LedCtrl.off(Led::CELL, true);
    4eae:	90 e0       	ldi	r25, 0x00	; 0
    4eb0:	80 e0       	ldi	r24, 0x00	; 0
    4eb2:	3c cc       	rjmp	.-1928   	; 0x472c <LedCtrlClass::on(Led, bool) [clone .constprop.114]>
    4eb4:	80 91 8d 66 	lds	r24, 0x668D	; 0x80668d <is_connected>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:90

            // The modem does not give any notification of a MQTT disconnect.
            // This must be called directly following a connection loss
            MqttClient.end();
    4eb8:	88 23       	and	r24, r24
    4eba:	71 f0       	breq	.+28     	; 0x4ed8 <connectionStatus(char*)+0x3a>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:92

            if (disconnected_callback != NULL) {
    4ebc:	10 92 8d 66 	sts	0x668D, r1	; 0x80668d <is_connected>
    4ec0:	61 e0       	ldi	r22, 0x01	; 1
    4ec2:	90 e0       	ldi	r25, 0x00	; 0
    4ec4:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:93
                disconnected_callback();
    4ec6:	d3 db       	rcall	.-2138   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:97
            }
        }
    }
}
    4ec8:	d6 db       	rcall	.-2132   	; 0x4676 <MqttClientClass::end() [clone .constprop.97]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:167
/**
 * @brief Called on MQTT broker connection URC. Will check the URC to see if the
 * connection was successful.
 */
static void internalConnectedCallback(char* urc_data) {
    if (urc_data[MQTT_CONNECTION_RC_INDEX] == MQTT_CONNECTION_SUCCESS_RC) {
    4eca:	e0 91 26 64 	lds	r30, 0x6426	; 0x806426 <_ZL21disconnected_callback.lto_priv.137>
    4ece:	f0 91 27 64 	lds	r31, 0x6427	; 0x806427 <_ZL21disconnected_callback.lto_priv.137+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:169

        connected_to_broker = true;
    4ed2:	30 97       	sbiw	r30, 0x00	; 0
    4ed4:	09 f0       	breq	.+2      	; 0x4ed8 <connectionStatus(char*)+0x3a>
    4ed6:	09 94       	ijmp
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:170
        LedCtrl.on(Led::CON, true);
    4ed8:	08 95       	ret

00004eda <internalConnectedCallback(char*)>:
internalConnectedCallback():
    4eda:	fc 01       	movw	r30, r24
    4edc:	82 81       	ldd	r24, Z+2	; 0x02
    4ede:	80 33       	cpi	r24, 0x30	; 48
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:172

        if (connected_callback != NULL) {
    4ee0:	69 f4       	brne	.+26     	; 0x4efc <internalConnectedCallback(char*)+0x22>
    4ee2:	81 e0       	ldi	r24, 0x01	; 1
    4ee4:	80 93 90 66 	sts	0x6690, r24	; 0x806690 <connected_to_broker>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:184
        SequansController.writeBytes((uint8_t*)MQTT_DISCONNECT,
                                     strlen(MQTT_DISCONNECT),
                                     true);
        SequansController.clearReceiveBuffer();

        if (disconnected_callback != NULL) {
    4ee8:	81 e0       	ldi	r24, 0x01	; 1
    4eea:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:185
            disconnected_callback();
    4eec:	1f dc       	rcall	.-1986   	; 0x472c <LedCtrlClass::on(Led, bool) [clone .constprop.114]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:176

        if (connected_callback != NULL) {
            connected_callback();
        }
    } else {
        connected_to_broker = false;
    4eee:	e0 91 28 64 	lds	r30, 0x6428	; 0x806428 <connected_callback>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:177
        LedCtrl.off(Led::CON, true);
    4ef2:	f0 91 29 64 	lds	r31, 0x6429	; 0x806429 <connected_callback+0x1>
    4ef6:	30 97       	sbiw	r30, 0x00	; 0
    4ef8:	a9 f0       	breq	.+42     	; 0x4f24 <internalConnectedCallback(char*)+0x4a>
    4efa:	09 94       	ijmp
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:179

        SequansController.writeBytes((uint8_t*)MQTT_DISCONNECT,
    4efc:	10 92 90 66 	sts	0x6690, r1	; 0x806690 <connected_to_broker>
    4f00:	61 e0       	ldi	r22, 0x01	; 1
    4f02:	81 e0       	ldi	r24, 0x01	; 1
    4f04:	90 e0       	ldi	r25, 0x00	; 0
    4f06:	b3 db       	rcall	.-2202   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
    4f08:	41 e0       	ldi	r20, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:182
                                     strlen(MQTT_DISCONNECT),
                                     true);
        SequansController.clearReceiveBuffer();
    4f0a:	67 e1       	ldi	r22, 0x17	; 23
    4f0c:	70 e0       	ldi	r23, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:184

        if (disconnected_callback != NULL) {
    4f0e:	8e e5       	ldi	r24, 0x5E	; 94
    4f10:	95 e4       	ldi	r25, 0x45	; 69
    4f12:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:188
            disconnected_callback();
        }
    }
}
    4f16:	0e 94 82 07 	call	0xf04	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:546
}

bool SequansControllerClass::isInitialized(void) { return initialized; }

void SequansControllerClass::end(void) {
    HWSERIALAT.CTRLA = 0;
    4f1a:	e0 91 8e 66 	lds	r30, 0x668E	; 0x80668e <_ZL21disconnected_callback.lto_priv.138>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:547
    HWSERIALAT.CTRLB = 0;
    4f1e:	f0 91 8f 66 	lds	r31, 0x668F	; 0x80668f <_ZL21disconnected_callback.lto_priv.138+0x1>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:154
/* Allow calls with manually OR'ed constants */
void pinConfigure(uint8_t digital_pin, uint16_t pin_config) {
  _pinconfigure(digital_pin, pin_config);
    4f22:	e9 cf       	rjmp	.-46     	; 0x4ef6 <internalConnectedCallback(char*)+0x1c>
    4f24:	08 95       	ret

00004f26 <SequansControllerClass::end() [clone .constprop.103]>:
end():
    4f26:	e0 e2       	ldi	r30, 0x20	; 32
    4f28:	f8 e0       	ldi	r31, 0x08	; 8
    4f2a:	15 82       	std	Z+5, r1	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:554

    pinConfigure(RESET_PIN, PIN_INPUT_DISABLE | PIN_DIR_INPUT);

    // Set RTS high to halt the modem. Has external pull-up, so is just set to
    // input afterwards
    digitalWrite(RTS_PIN, HIGH);
    4f2c:	16 82       	std	Z+6, r1	; 0x06
    4f2e:	17 82       	std	Z+7, r1	; 0x07
pinConfigure():
    4f30:	62 ec       	ldi	r22, 0xC2	; 194
    4f32:	70 e0       	ldi	r23, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:154
    4f34:	83 e1       	ldi	r24, 0x13	; 19
    4f36:	83 da       	rcall	.-2810   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
end():
    4f38:	61 e0       	ldi	r22, 0x01	; 1
    4f3a:	85 e1       	ldi	r24, 0x15	; 21
    4f3c:	b4 da       	rcall	.-2712   	; 0x44a6 <digitalWrite>
pinConfigure():
    4f3e:	62 ec       	ldi	r22, 0xC2	; 194
    4f40:	70 e0       	ldi	r23, 0x00	; 0
    4f42:	85 e1       	ldi	r24, 0x15	; 21
    4f44:	7c da       	rcall	.-2824   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
    4f46:	62 ec       	ldi	r22, 0xC2	; 194
    4f48:	70 e0       	ldi	r23, 0x00	; 0
    4f4a:	84 e1       	ldi	r24, 0x14	; 20
    4f4c:	78 da       	rcall	.-2832   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
detachInterrupt():
    4f4e:	84 e1       	ldi	r24, 0x14	; 20
    4f50:	0e 94 18 03 	call	0x630	; 0x630 <detachInterrupt.part.1>
pinConfigure():
    4f54:	62 ec       	ldi	r22, 0xC2	; 194
    4f56:	70 e0       	ldi	r23, 0x00	; 0
    4f58:	82 e1       	ldi	r24, 0x12	; 18
    4f5a:	71 da       	rcall	.-2846   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
detachInterrupt():
    4f5c:	82 e1       	ldi	r24, 0x12	; 18
    4f5e:	0e 94 18 03 	call	0x630	; 0x630 <detachInterrupt.part.1>
pinConfigure():
    4f62:	62 ec       	ldi	r22, 0xC2	; 194
    4f64:	71 e0       	ldi	r23, 0x01	; 1
    4f66:	8e e0       	ldi	r24, 0x0E	; 14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:566
    detachInterrupt(CTS_PIN);

    pinConfigure(TX_PIN, PIN_DIR_INPUT | PIN_PULLUP_ON | PIN_INPUT_DISABLE);
    pinConfigure(RX_PIN, PIN_DIR_INPUT | PIN_PULLUP_ON | PIN_INPUT_DISABLE);

    initialized = false;
    4f68:	6a da       	rcall	.-2860   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
    4f6a:	62 ec       	ldi	r22, 0xC2	; 194
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:567
}
    4f6c:	71 e0       	ldi	r23, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:293
    SequansController.unregisterCallback(TIMEZONE_CALLBACK);

    return true;
}

void LteClass::end(void) {
    4f6e:	8f e0       	ldi	r24, 0x0F	; 15
    4f70:	66 da       	rcall	.-2868   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
end():
    4f72:	10 92 91 66 	sts	0x6691, r1	; 0x806691 <initialized>
    4f76:	08 95       	ret

00004f78 <LteClass::end() [clone .constprop.95]>:
    4f78:	cf 93       	push	r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:295

    if (SequansController.isInitialized()) {
    4f7a:	df 93       	push	r29
    4f7c:	cd b7       	in	r28, 0x3d	; 61
    4f7e:	de b7       	in	r29, 0x3e	; 62
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:298

        // Terminate active connections (if any)
        MqttClient.end();
    4f80:	28 97       	sbiw	r28, 0x08	; 8
    4f82:	cd bf       	out	0x3d, r28	; 61
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:300

        SequansController.unregisterCallback(TIMEZONE_CALLBACK);
    4f84:	de bf       	out	0x3e, r29	; 62
    4f86:	80 91 91 66 	lds	r24, 0x6691	; 0x806691 <initialized>
    4f8a:	88 23       	and	r24, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:301
        SequansController.writeCommand(AT_DISCONNECT);
    4f8c:	61 f1       	breq	.+88     	; 0x4fe6 <LteClass::end() [clone .constprop.95]+0x6e>
    4f8e:	73 db       	rcall	.-2330   	; 0x4676 <MqttClientClass::end() [clone .constprop.97]>
    4f90:	8f ee       	ldi	r24, 0xEF	; 239
    4f92:	9f e4       	ldi	r25, 0x4F	; 79
    4f94:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
    4f98:	50 e0       	ldi	r21, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:5
#include "timeout_timer.h"

#include <Arduino.h>

TimeoutTimer::TimeoutTimer(const uint32_t ms) : interval_ms(ms) {
    4f9a:	40 e0       	ldi	r20, 0x00	; 0
    4f9c:	70 e0       	ldi	r23, 0x00	; 0
    4f9e:	60 e0       	ldi	r22, 0x00	; 0
    4fa0:	84 ef       	ldi	r24, 0xF4	; 244
    4fa2:	9f e4       	ldi	r25, 0x4F	; 79
    4fa4:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
__base_ctor ():
    4fa8:	80 ed       	ldi	r24, 0xD0	; 208
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:6
    start_ms = millis();
    4faa:	97 e0       	ldi	r25, 0x07	; 7
    4fac:	a0 e0       	ldi	r26, 0x00	; 0
    4fae:	b0 e0       	ldi	r27, 0x00	; 0
    4fb0:	89 83       	std	Y+1, r24	; 0x01
    4fb2:	9a 83       	std	Y+2, r25	; 0x02
    4fb4:	ab 83       	std	Y+3, r26	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:357

void LteClass::onDisconnect(void (*disconnect_callback)(void)) {
    disconnected_callback = disconnect_callback;
}

bool LteClass::isConnected(void) { return is_connected; }
    4fb6:	bc 83       	std	Y+4, r27	; 0x04
    4fb8:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:306
        SequansController.writeCommand(AT_DISCONNECT);

        // Wait for the CEREG URC after disconnect so that the modem doesn't
        // have any pending URCs and won't prevent going to sleep
        const TimeoutTimer timeout_timer(2000);
        while (isConnected() && !timeout_timer.hasTimedOut()) {}
    4fbc:	6d 83       	std	Y+5, r22	; 0x05
    4fbe:	7e 83       	std	Y+6, r23	; 0x06
    4fc0:	8f 83       	std	Y+7, r24	; 0x07
    4fc2:	98 87       	std	Y+8, r25	; 0x08
isConnected():
    4fc4:	80 91 8d 66 	lds	r24, 0x668D	; 0x80668d <is_connected>
end():
    4fc8:	88 23       	and	r24, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:308

        SequansController.unregisterCallback(CEREG_CALLBACK);
    4fca:	31 f0       	breq	.+12     	; 0x4fd8 <LteClass::end() [clone .constprop.95]+0x60>
    4fcc:	ce 01       	movw	r24, r28
    4fce:	01 96       	adiw	r24, 0x01	; 1
    4fd0:	0e 94 2a 07 	call	0xe54	; 0xe54 <TimeoutTimer::hasTimedOut() const>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:310

        SequansController.clearReceiveBuffer();
    4fd4:	88 23       	and	r24, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:311
        SequansController.end();
    4fd6:	b1 f3       	breq	.-20     	; 0x4fc4 <LteClass::end() [clone .constprop.95]+0x4c>
    4fd8:	8e ef       	ldi	r24, 0xFE	; 254
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:314
    }

    got_timezone = false;
    4fda:	9f e4       	ldi	r25, 0x4F	; 79
    4fdc:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:315
    is_connected = false;
    4fe0:	0e 94 82 07 	call	0xf04	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:316
}
    4fe4:	a0 df       	rcall	.-192    	; 0x4f26 <SequansControllerClass::end() [clone .constprop.103]>
    4fe6:	10 92 8c 66 	sts	0x668C, r1	; 0x80668c <got_timezone>
    4fea:	10 92 8d 66 	sts	0x668D, r1	; 0x80668d <is_connected>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:472
    } else {
        HWSERIALAT.CTRLA &= (~USART_DREIE_bm);
    }
}

void SequansControllerClass::begin(void) {
    4fee:	28 96       	adiw	r28, 0x08	; 8
    4ff0:	cd bf       	out	0x3d, r28	; 61
    4ff2:	de bf       	out	0x3e, r29	; 62
    4ff4:	df 91       	pop	r29
    4ff6:	cf 91       	pop	r28
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:154
    4ff8:	08 95       	ret

00004ffa <SequansControllerClass::begin() [clone .constprop.87]>:
begin():
    4ffa:	cf 92       	push	r12
    4ffc:	df 92       	push	r13
    4ffe:	ef 92       	push	r14
    5000:	ff 92       	push	r15
    5002:	0f 93       	push	r16
    5004:	1f 93       	push	r17
pinConfigure():
    5006:	61 e8       	ldi	r22, 0x81	; 129
    5008:	70 e0       	ldi	r23, 0x00	; 0
    500a:	8e e0       	ldi	r24, 0x0E	; 14
    500c:	18 da       	rcall	.-3024   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
    500e:	62 e8       	ldi	r22, 0x82	; 130
    5010:	70 e0       	ldi	r23, 0x00	; 0
    5012:	8f e0       	ldi	r24, 0x0F	; 15
    5014:	14 da       	rcall	.-3032   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:488
    // whether the LTE modem can receive more data or if we have to wait.
    //
    // Both pins are active low.

    pinConfigure(RTS_PIN, PIN_DIR_OUTPUT | PIN_INPUT_ENABLE);
    digitalWrite(RTS_PIN, HIGH);
    5016:	61 e8       	ldi	r22, 0x81	; 129
    5018:	70 e0       	ldi	r23, 0x00	; 0
    501a:	85 e1       	ldi	r24, 0x15	; 21
    501c:	10 da       	rcall	.-3040   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
begin():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:154
    501e:	61 e0       	ldi	r22, 0x01	; 1
    5020:	85 e1       	ldi	r24, 0x15	; 21
    5022:	41 da       	rcall	.-2942   	; 0x44a6 <digitalWrite>
pinConfigure():
    5024:	62 e9       	ldi	r22, 0x92	; 146
    5026:	71 e0       	ldi	r23, 0x01	; 1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:132
        mode = PORT_ISC_LEVEL_gc;
        break;
      default:
        return;
    }
    if (intFunc[port] != NULL && userFunc != NULL) {
    5028:	82 e1       	ldi	r24, 0x12	; 18
    502a:	09 da       	rcall	.-3054   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
attachInterrupt():
    502c:	e0 91 f8 41 	lds	r30, 0x41F8	; 0x8041f8 <intFunc+0x4>
    5030:	f0 91 f9 41 	lds	r31, 0x41F9	; 0x8041f9 <intFunc+0x5>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:134
      // if it is null the port is not enabled for attachInterrupt, and obviously a null user function is invalid too.
      intFunc[port][bitpos] = userFunc;
    5034:	30 97       	sbiw	r30, 0x00	; 0
    5036:	69 f0       	breq	.+26     	; 0x5052 <SequansControllerClass::begin() [clone .constprop.87]+0x58>
    5038:	8d e4       	ldi	r24, 0x4D	; 77
    503a:	97 e0       	ldi	r25, 0x07	; 7
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:136
      uint8_t portoffset = ((port << 5) & 0xE0) + 0x10 + bitpos;
      uint8_t oldSREG = SREG;
    503c:	80 87       	std	Z+8, r24	; 0x08
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:137
      cli();
    503e:	91 87       	std	Z+9, r25	; 0x09
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:139
      // We now have the port, the mode, the bitpos and the pointer
      uint8_t settings = *(portbase + portoffset) & 0xF8;
    5040:	9f b7       	in	r25, 0x3f	; 63
    5042:	f8 94       	cli
    5044:	80 91 54 04 	lds	r24, 0x0454	; 0x800454 <__TEXT_REGION_LENGTH__+0x7e0454>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:140
      *(portbase + portoffset) = settings | mode;
    5048:	88 7f       	andi	r24, 0xF8	; 248
    504a:	81 60       	ori	r24, 0x01	; 1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:141
      SREG = oldSREG;
    504c:	80 93 54 04 	sts	0x0454, r24	; 0x800454 <__TEXT_REGION_LENGTH__+0x7e0454>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_extra.cpp:154
    5050:	9f bf       	out	0x3f, r25	; 63
pinConfigure():
    5052:	61 e8       	ldi	r22, 0x81	; 129
    5054:	70 e0       	ldi	r23, 0x00	; 0
    5056:	83 e1       	ldi	r24, 0x13	; 19
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:503
    // create a linker issue
    attachInterrupt(CTS_PIN, CTSInterrupt, CHANGE);

    // Set reset low to reset the LTE modem
    pinConfigure(RESET_PIN, PIN_DIR_OUTPUT | PIN_INPUT_ENABLE);
    digitalWrite(RESET_PIN, HIGH);
    5058:	f2 d9       	rcall	.-3100   	; 0x443e <_pinconfigure(unsigned char, unsigned int)>
begin():
    505a:	61 e0       	ldi	r22, 0x01	; 1
    505c:	83 e1       	ldi	r24, 0x13	; 19
    505e:	23 da       	rcall	.-3002   	; 0x44a6 <digitalWrite>
_delay_ms():
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:187
    5060:	8f e5       	ldi	r24, 0x5F	; 95
    5062:	9a ee       	ldi	r25, 0xEA	; 234
    5064:	01 97       	sbiw	r24, 0x01	; 1
    5066:	f1 f7       	brne	.-4      	; 0x5064 <SequansControllerClass::begin() [clone .constprop.87]+0x6a>
    5068:	00 c0       	rjmp	.+0      	; 0x506a <SequansControllerClass::begin() [clone .constprop.87]+0x70>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:508

    // Delay for some time to reset the modem
    _delay_ms(10);

    digitalWrite(RESET_PIN, LOW);
    506a:	00 00       	nop
begin():
    506c:	60 e0       	ldi	r22, 0x00	; 0
    506e:	83 e1       	ldi	r24, 0x13	; 19
    5070:	1a da       	rcall	.-3020   	; 0x44a6 <digitalWrite>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:513

    // SERIAL INTERFACE SETUP

    // LTE modules has set baud rate of 115200 for its UART0 interface
    HWSERIALAT.BAUD = (uint16_t)(((float)F_CPU * 64 /
    5072:	81 e4       	ldi	r24, 0x41	; 65
    5074:	93 e0       	ldi	r25, 0x03	; 3
    5076:	80 93 28 08 	sts	0x0828, r24	; 0x800828 <__TEXT_REGION_LENGTH__+0x7e0828>
    507a:	90 93 29 08 	sts	0x0829, r25	; 0x800829 <__TEXT_REGION_LENGTH__+0x7e0829>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:518
                                  (16 * (float)SEQUANS_MODULE_BAUD_RATE)) +
                                 0.5);

    // Interrupt on receive completed
    HWSERIALAT.CTRLA = USART_RXCIE_bm | USART_DREIE_bm;
    507e:	80 ea       	ldi	r24, 0xA0	; 160
    5080:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:520

    HWSERIALAT.CTRLB = USART_RXEN_bm | USART_TXEN_bm;
    5084:	80 ec       	ldi	r24, 0xC0	; 192
    5086:	80 93 26 08 	sts	0x0826, r24	; 0x800826 <__TEXT_REGION_LENGTH__+0x7e0826>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:523

    // LTE module interface requires 8 data bits with one stop bit
    HWSERIALAT.CTRLC = USART_CMODE_ASYNCHRONOUS_gc | USART_SBMODE_1BIT_gc |
    508a:	83 e0       	ldi	r24, 0x03	; 3
    508c:	80 93 27 08 	sts	0x0827, r24	; 0x800827 <__TEXT_REGION_LENGTH__+0x7e0827>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:526
                       USART_CHSIZE_8BIT_gc;

    rtsUpdate();
    5090:	0e 94 6f 07 	call	0xede	; 0xede <rtsUpdate()>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:530

    // Wait for SYSSTART URC before we continue
    // if (!waitForURC("SYSSTART")) {
    if (!waitForURC("SYSSTART")) {
    5094:	80 e2       	ldi	r24, 0x20	; 32
    5096:	c8 2e       	mov	r12, r24
    5098:	9e e4       	ldi	r25, 0x4E	; 78
    509a:	d9 2e       	mov	r13, r25
    509c:	e1 2c       	mov	r14, r1
    509e:	f1 2c       	mov	r15, r1
    50a0:	00 e0       	ldi	r16, 0x00	; 0
    50a2:	10 e0       	ldi	r17, 0x00	; 0
    50a4:	20 e0       	ldi	r18, 0x00	; 0
    50a6:	30 e0       	ldi	r19, 0x00	; 0
    50a8:	40 e8       	ldi	r20, 0x80	; 128
    50aa:	51 e0       	ldi	r21, 0x01	; 1
    50ac:	70 e0       	ldi	r23, 0x00	; 0
    50ae:	60 e0       	ldi	r22, 0x00	; 0
    50b0:	84 e0       	ldi	r24, 0x04	; 4
    50b2:	90 e5       	ldi	r25, 0x50	; 80
    50b4:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]>
    50b8:	81 11       	cpse	r24, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:531
        Log.error("Timed out waiting for cellular modem to start up\r\n");
    50ba:	0b c0       	rjmp	.+22     	; 0x50d2 <SequansControllerClass::begin() [clone .constprop.87]+0xd8>
    50bc:	8d e0       	ldi	r24, 0x0D	; 13
    50be:	90 e5       	ldi	r25, 0x50	; 80
    50c0:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:541
    }

    clearReceiveBuffer();

    initialized = true;
}
    50c4:	1f 91       	pop	r17
    50c6:	0f 91       	pop	r16
    50c8:	ff 90       	pop	r15
    50ca:	ef 90       	pop	r14
    50cc:	df 90       	pop	r13
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:534
    // if (!waitForURC("SYSSTART")) {
    if (!waitForURC("SYSSTART")) {
        Log.error("Timed out waiting for cellular modem to start up\r\n");

        // End the controller to deattach the interrupts
        SequansController.end();
    50ce:	cf 90       	pop	r12
    50d0:	2a cf       	rjmp	.-428    	; 0x4f26 <SequansControllerClass::end() [clone .constprop.103]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:538
        return;
    }

    clearReceiveBuffer();
    50d2:	0e 94 82 07 	call	0xf04	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:540

    initialized = true;
    50d6:	81 e0       	ldi	r24, 0x01	; 1
    50d8:	80 93 91 66 	sts	0x6691, r24	; 0x806691 <initialized>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:541
}
    50dc:	1f 91       	pop	r17
    50de:	0f 91       	pop	r16
    50e0:	ff 90       	pop	r15
    50e2:	ef 90       	pop	r14
    50e4:	df 90       	pop	r13
    50e6:	cf 90       	pop	r12
    50e8:	08 95       	ret

000050ea <iotc_mqtt_client_send_message(char const*)>:
iotc_mqtt_client_send_message():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:30

bool iotc_mqtt_client_is_connected(void) {
    return MqttClient.isConnected();
}

bool iotc_mqtt_client_send_message(const char *message) {
    50ea:	4f 92       	push	r4
    50ec:	5f 92       	push	r5
    50ee:	6f 92       	push	r6
    50f0:	7f 92       	push	r7
    50f2:	8f 92       	push	r8
    50f4:	9f 92       	push	r9
    50f6:	af 92       	push	r10
    50f8:	bf 92       	push	r11
    50fa:	cf 92       	push	r12
    50fc:	df 92       	push	r13
    50fe:	ef 92       	push	r14
    5100:	ff 92       	push	r15
    5102:	0f 93       	push	r16
    5104:	1f 93       	push	r17
    5106:	cf 93       	push	r28
    5108:	df 93       	push	r29
    510a:	cd b7       	in	r28, 0x3d	; 61
    510c:	de b7       	in	r29, 0x3e	; 62
    510e:	a3 97       	sbiw	r28, 0x23	; 35
    5110:	cd bf       	out	0x3d, r28	; 61
    5112:	de bf       	out	0x3e, r29	; 62
    5114:	6c 01       	movw	r12, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:32
    return MqttClient.publish(c->sr->broker.pub_topic, message);
}
    5116:	ad b6       	in	r10, 0x3d	; 61
    5118:	be b6       	in	r11, 0x3e	; 62
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:31
bool iotc_mqtt_client_is_connected(void) {
    return MqttClient.isConnected();
}

bool iotc_mqtt_client_send_message(const char *message) {
    return MqttClient.publish(c->sr->broker.pub_topic, message);
    511a:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    511e:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    5122:	01 90       	ld	r0, Z+
    5124:	f0 81       	ld	r31, Z
    5126:	e0 2d       	mov	r30, r0
    5128:	96 88       	ldd	r9, Z+22	; 0x16
    512a:	87 88       	ldd	r8, Z+23	; 0x17
publish():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:664
                              const char* message,
                              const MqttQoS quality_of_service,
                              const uint32_t timeout_ms) {
    return publish(topic,
                   (uint8_t*)message,
                   strlen(message),
    512c:	dc 01       	movw	r26, r24
    512e:	0d 90       	ld	r0, X+
    5130:	00 20       	and	r0, r0
    5132:	e9 f7       	brne	.-6      	; 0x512e <iotc_mqtt_client_send_message(char const*)+0x44>
    5134:	11 97       	sbiw	r26, 0x01	; 1
    5136:	7d 01       	movw	r14, r26
    5138:	e8 1a       	sub	r14, r24
    513a:	f9 0a       	sbc	r15, r25
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:570
    if (disconnected != NULL) {
        disconnected_callback = disconnected;
    }
}

bool MqttClientClass::isConnected(void) { return connected_to_broker; }
    513c:	10 91 90 66 	lds	r17, 0x6690	; 0x806690 <connected_to_broker>
publish():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:578
                              const uint8_t* buffer,
                              const uint32_t buffer_size,
                              const MqttQoS quality_of_service,
                              const uint32_t timeout_ms) {

    if (!isConnected()) {
    5140:	11 11       	cpse	r17, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:579
        Log.error("Attempted publish without being connected to a broker");
    5142:	1e c0       	rjmp	.+60     	; 0x5180 <iotc_mqtt_client_send_message(char const*)+0x96>
    5144:	80 e4       	ldi	r24, 0x40	; 64
    5146:	90 e5       	ldi	r25, 0x50	; 80
    5148:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
off():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/led_ctrl.cpp:86

void LedCtrlClass::off(Led led, bool is_from_system_event) {
    if (is_from_system_event && manual_control_enabled)
        return;

    digitalWrite(getLedPin(led), 1);
    514c:	61 e0       	ldi	r22, 0x01	; 1
    514e:	82 e0       	ldi	r24, 0x02	; 2
    5150:	aa d9       	rcall	.-3244   	; 0x44a6 <digitalWrite>
iotc_mqtt_client_send_message():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:32
}
    5152:	81 2f       	mov	r24, r17
    5154:	ad be       	out	0x3d, r10	; 61
    5156:	be be       	out	0x3e, r11	; 62
    5158:	a3 96       	adiw	r28, 0x23	; 35
    515a:	cd bf       	out	0x3d, r28	; 61
    515c:	de bf       	out	0x3e, r29	; 62
    515e:	df 91       	pop	r29
    5160:	cf 91       	pop	r28
    5162:	1f 91       	pop	r17
    5164:	0f 91       	pop	r16
    5166:	ff 90       	pop	r15
    5168:	ef 90       	pop	r14
    516a:	df 90       	pop	r13
    516c:	cf 90       	pop	r12
    516e:	bf 90       	pop	r11
    5170:	af 90       	pop	r10
    5172:	9f 90       	pop	r9
    5174:	8f 90       	pop	r8
    5176:	7f 90       	pop	r7
    5178:	6f 90       	pop	r6
    517a:	5f 90       	pop	r5
    517c:	4f 90       	pop	r4
    517e:	08 95       	ret
publish():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:584
        LedCtrl.off(Led::DATA, false);
        return false;
    }

    LedCtrl.on(Led::DATA, true);
    5180:	82 e0       	ldi	r24, 0x02	; 2
    5182:	90 e0       	ldi	r25, 0x00	; 0
    5184:	d3 da       	rcall	.-2650   	; 0x472c <LedCtrlClass::on(Led, bool) [clone .constprop.114]>
    5186:	27 01       	movw	r4, r14
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:586

    const size_t digits_in_buffer_size = trunc(log10(buffer_size)) + 1;
    5188:	71 2c       	mov	r7, r1
    518a:	61 2c       	mov	r6, r1
    518c:	c3 01       	movw	r24, r6
    518e:	b7 01       	movw	r22, r14
    5190:	0e 94 2b 51 	call	0xa256	; 0xa256 <__floatunsisf>
    5194:	0e 94 de 53 	call	0xa7bc	; 0xa7bc <log10>
    5198:	0e 94 29 54 	call	0xa852	; 0xa852 <trunc>
    519c:	20 e0       	ldi	r18, 0x00	; 0
    519e:	30 e0       	ldi	r19, 0x00	; 0
    51a0:	40 e8       	ldi	r20, 0x80	; 128
    51a2:	5f e3       	ldi	r21, 0x3F	; 63
    51a4:	0e 94 dd 52 	call	0xa5ba	; 0xa5ba <__addsf3>
    51a8:	0e 94 ae 53 	call	0xa75c	; 0xa75c <__fixunssfsi>
    51ac:	65 56       	subi	r22, 0x65	; 101
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:587
    char command[MQTT_PUBLISH_LENGTH_PRE_DATA + digits_in_buffer_size];
    51ae:	7f 4f       	sbci	r23, 0xFF	; 255
    51b0:	8d b7       	in	r24, 0x3d	; 61
    51b2:	9e b7       	in	r25, 0x3e	; 62
    51b4:	86 1b       	sub	r24, r22
    51b6:	97 0b       	sbc	r25, r23
    51b8:	8d bf       	out	0x3d, r24	; 61
    51ba:	9e bf       	out	0x3e, r25	; 62
    51bc:	0d b7       	in	r16, 0x3d	; 61
    51be:	1e b7       	in	r17, 0x3e	; 62
    51c0:	0f 5f       	subi	r16, 0xFF	; 255
    51c2:	1f 4f       	sbci	r17, 0xFF	; 255
    51c4:	1f 92       	push	r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:590

    // Fill everything besides the data
    sprintf(command,
    51c6:	1f 92       	push	r1
    51c8:	5f 92       	push	r5
    51ca:	ef 92       	push	r14
    51cc:	1f 92       	push	r1
    51ce:	81 e0       	ldi	r24, 0x01	; 1
    51d0:	8f 93       	push	r24
    51d2:	8f 92       	push	r8
    51d4:	9f 92       	push	r9
    51d6:	86 e7       	ldi	r24, 0x76	; 118
    51d8:	90 e5       	ldi	r25, 0x50	; 80
    51da:	9f 93       	push	r25
    51dc:	8f 93       	push	r24
    51de:	1f 93       	push	r17
    51e0:	0f 93       	push	r16
    51e2:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    51e6:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:596
            MQTT_PUBLISH,
            topic,
            quality_of_service,
            (unsigned long)buffer_size);

    SequansController.writeBytes((uint8_t*)command, strlen(command), true);
    51e8:	01 90       	ld	r0, Z+
    51ea:	00 20       	and	r0, r0
    51ec:	e9 f7       	brne	.-6      	; 0x51e8 <iotc_mqtt_client_send_message(char const*)+0xfe>
    51ee:	31 97       	sbiw	r30, 0x01	; 1
    51f0:	bf 01       	movw	r22, r30
    51f2:	60 1b       	sub	r22, r16
    51f4:	71 0b       	sbc	r23, r17
    51f6:	41 e0       	ldi	r20, 0x01	; 1
    51f8:	c8 01       	movw	r24, r16
    51fa:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:599

    // Wait for start character for delivering payload
    if (!SequansController.waitForByte('>', MQTT_TIMEOUT_MS)) {
    51fe:	40 ed       	ldi	r20, 0xD0	; 208
    5200:	57 e0       	ldi	r21, 0x07	; 7
    5202:	60 e0       	ldi	r22, 0x00	; 0
    5204:	70 e0       	ldi	r23, 0x00	; 0
    5206:	8e e3       	ldi	r24, 0x3E	; 62
    5208:	0e 94 b9 07 	call	0xf72	; 0xf72 <SequansControllerClass::waitForByte(unsigned char, unsigned long) [clone .constprop.116]>
    520c:	18 2f       	mov	r17, r24
    520e:	ad b7       	in	r26, 0x3d	; 61
    5210:	be b7       	in	r27, 0x3e	; 62
    5212:	1c 96       	adiw	r26, 0x0c	; 12
    5214:	ad bf       	out	0x3d, r26	; 61
    5216:	be bf       	out	0x3e, r27	; 62
    5218:	81 11       	cpse	r24, r1
    521a:	09 c0       	rjmp	.+18     	; 0x522e <iotc_mqtt_client_send_message(char const*)+0x144>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:600
        Log.warn("Timed out waiting to deliver MQTT payload.");
    521c:	87 e9       	ldi	r24, 0x97	; 151
    521e:	90 e5       	ldi	r25, 0x50	; 80
    5220:	0e 94 9c 0a 	call	0x1538	; 0x1538 <LogClass::warn(char const*) [clone .constprop.124]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:602

        LedCtrl.off(Led::DATA, true);
    5224:	61 e0       	ldi	r22, 0x01	; 1
    5226:	82 e0       	ldi	r24, 0x02	; 2
    5228:	90 e0       	ldi	r25, 0x00	; 0
    522a:	21 da       	rcall	.-3006   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
    522c:	92 cf       	rjmp	.-220    	; 0x5152 <iotc_mqtt_client_send_message(char const*)+0x68>
    522e:	df 92       	push	r13
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:606
        return false;
    }

    Log.debugf("Publishing MQTT payload: %s\r\n", buffer);
    5230:	cf 92       	push	r12
    5232:	82 ec       	ldi	r24, 0xC2	; 194
    5234:	90 e5       	ldi	r25, 0x50	; 80
    5236:	9f 93       	push	r25
    5238:	8f 93       	push	r24
    523a:	89 e6       	ldi	r24, 0x69	; 105
    523c:	90 e7       	ldi	r25, 0x70	; 112
    523e:	9f 93       	push	r25
    5240:	8f 93       	push	r24
    5242:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <LogClass::debugf(char const*, ...) [clone .constprop.118]>
    5246:	40 e0       	ldi	r20, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:608

    SequansController.writeBytes(buffer, buffer_size);
    5248:	b7 01       	movw	r22, r14
    524a:	c6 01       	movw	r24, r12
    524c:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
    5250:	19 82       	std	Y+1, r1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:610

    char urc[MQTT_PUBLISH_URC_LENGTH] = "";
    5252:	1a 82       	std	Y+2, r1	; 0x02
    5254:	fe 01       	movw	r30, r28
    5256:	33 96       	adiw	r30, 0x03	; 3
    5258:	8e e1       	ldi	r24, 0x1E	; 30
    525a:	df 01       	movw	r26, r30
    525c:	1d 92       	st	X+, r1
    525e:	8a 95       	dec	r24
    5260:	e9 f7       	brne	.-6      	; 0x525c <iotc_mqtt_client_send_message(char const*)+0x172>
    5262:	19 a2       	std	Y+33, r1	; 0x21
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:614

    // At most we can have two character ("-1"). We add an extra for null
    // termination
    char status_code_buffer[3] = "";
    5264:	1a a2       	std	Y+34, r1	; 0x22
    5266:	1b a2       	std	Y+35, r1	; 0x23
    5268:	80 e3       	ldi	r24, 0x30	; 48
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:616

    if (!SequansController.waitForURC(MQTT_ON_PUBLISH_URC,
    526a:	c8 2e       	mov	r12, r24
    526c:	95 e7       	ldi	r25, 0x75	; 117
    526e:	d9 2e       	mov	r13, r25
    5270:	e1 2c       	mov	r14, r1
    5272:	f1 2c       	mov	r15, r1
    5274:	00 e0       	ldi	r16, 0x00	; 0
    5276:	10 e0       	ldi	r17, 0x00	; 0
    5278:	20 e0       	ldi	r18, 0x00	; 0
    527a:	30 e0       	ldi	r19, 0x00	; 0
    527c:	40 e2       	ldi	r20, 0x20	; 32
    527e:	50 e0       	ldi	r21, 0x00	; 0
    5280:	be 01       	movw	r22, r28
    5282:	6f 5f       	subi	r22, 0xFF	; 255
    5284:	7f 4f       	sbci	r23, 0xFF	; 255
    5286:	80 ee       	ldi	r24, 0xE0	; 224
    5288:	90 e5       	ldi	r25, 0x50	; 80
    528a:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]>
    528e:	18 2f       	mov	r17, r24
    5290:	0f 90       	pop	r0
    5292:	0f 90       	pop	r0
    5294:	0f 90       	pop	r0
    5296:	0f 90       	pop	r0
    5298:	0f 90       	pop	r0
    529a:	0f 90       	pop	r0
    529c:	81 11       	cpse	r24, r1
    529e:	05 c0       	rjmp	.+10     	; 0x52aa <iotc_mqtt_client_send_message(char const*)+0x1c0>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:620
                                      urc,
                                      sizeof(urc),
                                      timeout_ms)) {
        Log.warn("Timed out waiting for publish confirmation. Consider "
    52a0:	82 ef       	ldi	r24, 0xF2	; 242
    52a2:	90 e5       	ldi	r25, 0x50	; 80
    52a4:	0e 94 9c 0a 	call	0x1538	; 0x1538 <LogClass::warn(char const*) [clone .constprop.124]>
    52a8:	54 cf       	rjmp	.-344    	; 0x5152 <iotc_mqtt_client_send_message(char const*)+0x68>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:626
                 "increasing timeout for publishing\r\n");
        return false;
    }

    // The modem reports two URCs for publish, so we clear the other one
    SequansController.clearReceiveBuffer();
    52aa:	0e 94 82 07 	call	0xf04	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:628

    if (!SequansController.extractValueFromCommandResponse(
    52ae:	00 e0       	ldi	r16, 0x00	; 0
    52b0:	23 e0       	ldi	r18, 0x03	; 3
    52b2:	30 e0       	ldi	r19, 0x00	; 0
    52b4:	ae 01       	movw	r20, r28
    52b6:	4f 5d       	subi	r20, 0xDF	; 223
    52b8:	5f 4f       	sbci	r21, 0xFF	; 255
    52ba:	62 e0       	ldi	r22, 0x02	; 2
    52bc:	ce 01       	movw	r24, r28
    52be:	01 96       	adiw	r24, 0x01	; 1
    52c0:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    52c4:	18 2f       	mov	r17, r24
    52c6:	81 11       	cpse	r24, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:635
            MQTT_PUB_SUB_URC_STATUS_CODE_INDEX,
            status_code_buffer,
            sizeof(status_code_buffer),
            (char)NULL)) {

        Log.error("Failed to retrieve status code from publish notification");
    52c8:	05 c0       	rjmp	.+10     	; 0x52d4 <iotc_mqtt_client_send_message(char const*)+0x1ea>
    52ca:	8b e4       	ldi	r24, 0x4B	; 75
    52cc:	91 e5       	ldi	r25, 0x51	; 81
    52ce:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:639
        return false;
    }

    int8_t publish_status_code = atoi(status_code_buffer);
    52d2:	3f cf       	rjmp	.-386    	; 0x5152 <iotc_mqtt_client_send_message(char const*)+0x68>
    52d4:	ce 01       	movw	r24, r28
    52d6:	81 96       	adiw	r24, 0x21	; 33
    52d8:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:643

    // One of the status codes is -1, so in order to not overflow the status
    // code table, we swap the place with the last one
    if (publish_status_code == STATUS_CODE_PENDING) {
    52dc:	08 2f       	mov	r16, r24
    52de:	8f 3f       	cpi	r24, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:644
        publish_status_code = NUM_STATUS_CODES - 1;
    52e0:	09 f4       	brne	.+2      	; 0x52e4 <iotc_mqtt_client_send_message(char const*)+0x1fa>
iotc_mqtt_client_send_message():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:647
    }

    LedCtrl.off(Led::DATA, true);
    52e2:	01 e1       	ldi	r16, 0x11	; 17
publish():
    52e4:	61 e0       	ldi	r22, 0x01	; 1
    52e6:	82 e0       	ldi	r24, 0x02	; 2
    52e8:	90 e0       	ldi	r25, 0x00	; 0
    52ea:	c1 d9       	rcall	.-3198   	; 0x466e <LedCtrlClass::off(Led, bool) [clone .constprop.130]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:649

    if (publish_status_code != 0) {
    52ec:	00 23       	and	r16, r16
    52ee:	09 f4       	brne	.+2      	; 0x52f2 <iotc_mqtt_client_send_message(char const*)+0x208>
    52f0:	30 cf       	rjmp	.-416    	; 0x5152 <iotc_mqtt_client_send_message(char const*)+0x68>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:650
        Log.errorf("Error happened while publishing: %s\r\n",
    52f2:	b8 e1       	ldi	r27, 0x18	; 24
    52f4:	0b 02       	muls	r16, r27
    52f6:	c0 01       	movw	r24, r0
    52f8:	11 24       	eor	r1, r1
    52fa:	87 5d       	subi	r24, 0xD7	; 215
    52fc:	9f 4b       	sbci	r25, 0xBF	; 191
    52fe:	9f 93       	push	r25
    5300:	8f 93       	push	r24
    5302:	84 e8       	ldi	r24, 0x84	; 132
    5304:	91 e5       	ldi	r25, 0x51	; 81
    5306:	9f 93       	push	r25
    5308:	8f 93       	push	r24
    530a:	89 e6       	ldi	r24, 0x69	; 105
    530c:	90 e7       	ldi	r25, 0x70	; 112
    530e:	9f 93       	push	r25
    5310:	8f 93       	push	r24
    5312:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    5316:	0f 90       	pop	r0
    5318:	0f 90       	pop	r0
    531a:	0f 90       	pop	r0
    531c:	0f 90       	pop	r0
    531e:	0f 90       	pop	r0
    5320:	0f 90       	pop	r0
iotc_mqtt_client_send_message():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:652
                   status_code_table[publish_status_code]);
        return false;
    5322:	10 e0       	ldi	r17, 0x00	; 0
    5324:	16 cf       	rjmp	.-468    	; 0x5152 <iotc_mqtt_client_send_message(char const*)+0x68>

00005326 <command_status(IotclEventDataTag*, bool, char const*, char const*) [clone .constprop.105]>:
command_status():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:40
            Log.error("IoTConnect Client ERROR");
            break;
    }
}

static void command_status(IotclEventData data, bool status, const char *command_name, const char *message) {
    5326:	0f 93       	push	r16
    5328:	1f 93       	push	r17
    532a:	cf 93       	push	r28
    532c:	df 93       	push	r29
    532e:	16 2f       	mov	r17, r22
    5330:	07 2f       	mov	r16, r23
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:41
    const char *ack = iotcl_create_ack_string_and_destroy_event(data, status, message);
    5332:	46 2f       	mov	r20, r22
    5334:	57 2f       	mov	r21, r23
    5336:	60 e0       	ldi	r22, 0x00	; 0
    5338:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <iotcl_create_ack_string_and_destroy_event>
    533c:	d8 2f       	mov	r29, r24
    533e:	c9 2f       	mov	r28, r25
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:42
    printf("command: %s status=%s: %s\n", command_name, status ? "OK" : "Failed", message);
    5340:	0f 93       	push	r16
    5342:	1f 93       	push	r17
    5344:	8a ea       	ldi	r24, 0xAA	; 170
    5346:	91 e5       	ldi	r25, 0x51	; 81
    5348:	9f 93       	push	r25
    534a:	8f 93       	push	r24
    534c:	8f e1       	ldi	r24, 0x1F	; 31
    534e:	97 e5       	ldi	r25, 0x57	; 87
    5350:	9f 93       	push	r25
    5352:	8f 93       	push	r24
    5354:	81 eb       	ldi	r24, 0xB1	; 177
    5356:	91 e5       	ldi	r25, 0x51	; 81
    5358:	9f 93       	push	r25
    535a:	8f 93       	push	r24
    535c:	0e 94 44 57 	call	0xae88	; 0xae88 <printf>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:43
    printf("Sent CMD ack: %s\n", ack);
    5360:	cf 93       	push	r28
    5362:	df 93       	push	r29
    5364:	8c ec       	ldi	r24, 0xCC	; 204
    5366:	91 e5       	ldi	r25, 0x51	; 81
    5368:	9f 93       	push	r25
    536a:	8f 93       	push	r24
    536c:	0e 94 44 57 	call	0xae88	; 0xae88 <printf>
iotconnect_sdk_send_packet():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:222

bool iotconnect_sdk_send_packet(const char *data) {
    return iotc_mqtt_client_send_message(data);
    5370:	8d 2f       	mov	r24, r29
    5372:	9c 2f       	mov	r25, r28
    5374:	ba de       	rcall	.-652    	; 0x50ea <iotc_mqtt_client_send_message(char const*)>
command_status():
    5376:	8d b7       	in	r24, 0x3d	; 61
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:45
    iotconnect_sdk_send_packet(ack);
    free((void *) ack);
    5378:	9e b7       	in	r25, 0x3e	; 62
    537a:	0c 96       	adiw	r24, 0x0c	; 12
    537c:	8d bf       	out	0x3d, r24	; 61
    537e:	9e bf       	out	0x3e, r25	; 62
    5380:	8d 2f       	mov	r24, r29
    5382:	9c 2f       	mov	r25, r28
    5384:	df 91       	pop	r29
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:46
}
    5386:	cf 91       	pop	r28
    5388:	1f 91       	pop	r17
    538a:	0f 91       	pop	r16
    538c:	0c 94 54 55 	jmp	0xaaa8	; 0xaaa8 <free>

00005390 <on_command(IotclEventDataTag*)>:
on_command():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:45
static void command_status(IotclEventData data, bool status, const char *command_name, const char *message) {
    const char *ack = iotcl_create_ack_string_and_destroy_event(data, status, message);
    printf("command: %s status=%s: %s\n", command_name, status ? "OK" : "Failed", message);
    printf("Sent CMD ack: %s\n", ack);
    iotconnect_sdk_send_packet(ack);
    free((void *) ack);
    5390:	cf 93       	push	r28
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:48
}

static void on_command(IotclEventData data) {
    5392:	df 93       	push	r29
    5394:	ec 01       	movw	r28, r24
    5396:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <iotcl_clone_command>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:49
    char *command = iotcl_clone_command(data);
    539a:	6e ee       	ldi	r22, 0xEE	; 238
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:54
    if (NULL != command) {
        free((void *) command);
        command_status(data, false, "?", "Not implemented");
    } else {
        command_status(data, false, "?", "Internal error");
    539c:	71 e5       	ldi	r23, 0x51	; 81
    539e:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:50
    free((void *) ack);
}

static void on_command(IotclEventData data) {
    char *command = iotcl_clone_command(data);
    if (NULL != command) {
    53a0:	21 f0       	breq	.+8      	; 0x53aa <on_command(IotclEventDataTag*)+0x1a>
    53a2:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:51
        free((void *) command);
    53a6:	6e ed       	ldi	r22, 0xDE	; 222
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:52
        command_status(data, false, "?", "Not implemented");
    53a8:	71 e5       	ldi	r23, 0x51	; 81
    53aa:	ce 01       	movw	r24, r28
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:54
    } else {
        command_status(data, false, "?", "Internal error");
    53ac:	df 91       	pop	r29
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:56
    }
}
    53ae:	cf 91       	pop	r28
    53b0:	ba cf       	rjmp	.-140    	; 0x5326 <command_status(IotclEventDataTag*, bool, char const*, char const*) [clone .constprop.105]>

000053b2 <hal_i2c_send>:
hal_i2c_send():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:54
    char *command = iotcl_clone_command(data);
    if (NULL != command) {
        free((void *) command);
        command_status(data, false, "?", "Not implemented");
    } else {
        command_status(data, false, "?", "Internal error");
    53b2:	ef 92       	push	r14
    53b4:	ff 92       	push	r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:42

ATCA_STATUS hal_i2c_send(ATCAIface iface,
                         uint8_t word_address,
                         uint8_t* txdata,
                         int txlength) {
    53b6:	0f 93       	push	r16
    53b8:	1f 93       	push	r17
    53ba:	cf 93       	push	r28
    53bc:	df 93       	push	r29
    53be:	8a 01       	movw	r16, r20
    53c0:	79 01       	movw	r14, r18
beginTransmission():
    53c2:	66 0f       	add	r22, r22
    53c4:	60 93 a1 6e 	sts	0x6EA1, r22	; 0x806ea1 <Wire+0xc>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:484
  if (__builtin_constant_p(address) > 0x7F) {     // Compile-time check if address is actually 7 bit long
    badArg("Supplied address seems to be 8 bit. Only 7-bit-addresses are supported");
    return;
  }
  // set address of targeted client
  vars._clientAddress = address << 1;
    53c8:	10 92 a2 6e 	sts	0x6EA2, r1	; 0x806ea2 <Wire+0xd>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:485
  (*txHead) = 0;  // fill buffer from 0
    53cc:	d0 e0       	ldi	r29, 0x00	; 0
    53ce:	c0 e0       	ldi	r28, 0x00	; 0
hal_i2c_send():
    53d0:	ce 15       	cp	r28, r14
    53d2:	df 05       	cpc	r29, r15
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:52
    // Wire library doesn't take failing to send a single byte into
    // consideration
    size_t index = 0;
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wsign-compare"
    while (index < txlength) {
    53d4:	60 f4       	brcc	.+24     	; 0x53ee <hal_i2c_send+0x3c>
    53d6:	f8 01       	movw	r30, r16
    53d8:	ec 0f       	add	r30, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:53
        if (WIRE.write(txdata[index])) {
    53da:	fd 1f       	adc	r31, r29
    53dc:	60 81       	ld	r22, Z
    53de:	85 e9       	ldi	r24, 0x95	; 149
    53e0:	9e e6       	ldi	r25, 0x6E	; 110
    53e2:	0e 94 d5 04 	call	0x9aa	; 0x9aa <TwoWire::write(unsigned char)>
    53e6:	89 2b       	or	r24, r25
    53e8:	99 f3       	breq	.-26     	; 0x53d0 <hal_i2c_send+0x1e>
    53ea:	21 96       	adiw	r28, 0x01	; 1
    53ec:	f1 cf       	rjmp	.-30     	; 0x53d0 <hal_i2c_send+0x1e>
TWI_MasterWrite():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:54
            index++;
    53ee:	e0 91 9d 6e 	lds	r30, 0x6E9D	; 0x806e9d <Wire+0x8>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:309
  #else                                                   // Separate tx/rx Buffers
    txHead   = &(_data->_bytesToWrite);
    txBuffer =   _data->_txBuffer;
  #endif

  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
    53f2:	f0 91 9e 6e 	lds	r31, 0x6E9E	; 0x806e9e <Wire+0x9>
    53f6:	85 81       	ldd	r24, Z+5	; 0x05
    53f8:	83 70       	andi	r24, 0x03	; 3
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:320
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = 0;
  #endif


    if (((module->MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_UNKNOWN_gc) || // If the bus was not initialized
    53fa:	b9 f0       	breq	.+46     	; 0x542a <hal_i2c_send+0x78>
    53fc:	83 81       	ldd	r24, Z+3	; 0x03
    53fe:	80 ff       	sbrs	r24, 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:321
      ((module->MCTRLA & TWI_ENABLE_bm) == false)) {  // Or is disabled,
    5400:	14 c0       	rjmp	.+40     	; 0x542a <hal_i2c_send+0x78>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:320
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = 0;
  #endif


    if (((module->MSTATUS & TWI_BUSSTATE_gm) == TWI_BUSSTATE_UNKNOWN_gc) || // If the bus was not initialized
    5402:	40 91 a1 6e 	lds	r20, 0x6EA1	; 0x806ea1 <Wire+0xc>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:349
        TWI_SET_ERROR(TWI_ERR_BUS_ARB);         // set error flag
        break;                                  // leave TX loop
    }

    if (currentSM == TWI_BUSSTATE_IDLE_gc) {                      // Bus has not sent START yet and is not BUSY
        module->MADDR = ADD_WRITE_BIT(_data->_clientAddress);
    5406:	4e 7f       	andi	r20, 0xFE	; 254
hal_i2c_send():
    5408:	90 e0       	ldi	r25, 0x00	; 0
    540a:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:316
  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  twi_buffer_index_t dataWritten = 0;
  #if defined (TWI_TIMEOUT_ENABLE)
    uint16_t timeout = 0;
    540c:	20 e0       	ldi	r18, 0x00	; 0
TWI_MasterWrite():
    540e:	35 81       	ldd	r19, Z+5	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:314
  TWI_t *module = _data->_module;     // Compiler treats the pointer to the TWI module as volatile and
                                      // creates bloat-y code, this fixes it
  TWI_INIT_ERROR;
  uint8_t currentSM;
  uint8_t currentStatus;
  twi_buffer_index_t dataWritten = 0;
    5410:	53 2f       	mov	r21, r19
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:326
      ((module->MCTRLA & TWI_ENABLE_bm) == false)) {  // Or is disabled,
      return TWI_ERR_UNINIT;                          // return
    }

  while (true) {
    currentStatus = module->MSTATUS;
    5412:	53 70       	andi	r21, 0x03	; 3
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:327
    currentSM = currentStatus & TWI_BUSSTATE_gm;  // get the current mode of the state machine
    5414:	01 96       	adiw	r24, 0x01	; 1
    5416:	81 3c       	cpi	r24, 0xC1	; 193
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:330

    #if defined(TWI_TIMEOUT_ENABLE)
      if (++timeout > (F_CPU/1000)) {
    5418:	6d e5       	ldi	r22, 0x5D	; 93
    541a:	96 07       	cpc	r25, r22
    541c:	20 f4       	brcc	.+8      	; 0x5426 <hal_i2c_send+0x74>
    541e:	33 ff       	sbrs	r19, 3
    5420:	0d c0       	rjmp	.+26     	; 0x543c <hal_i2c_send+0x8a>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:342
        }
        break;
      }
    #endif

    if   (currentStatus & TWI_ARBLOST_bm) {     // Check for Bus error
    5422:	88 e0       	ldi	r24, 0x08	; 8
    5424:	85 83       	std	Z+5, r24	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:343
        module->MSTATUS = TWI_ARBLOST_bm;       // reset error flags
    5426:	83 e0       	ldi	r24, 0x03	; 3
    5428:	84 83       	std	Z+4, r24	; 0x04
hal_i2c_send():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:376
    }
  }


  if ((send_stop != 0) || (TWI_ERR_SUCCESS != TWI_GET_ERROR)) {
    module->MCTRLB = TWI_MCMD_STOP_gc;                        // Send STOP
    542a:	90 e0       	ldi	r25, 0x00	; 0
    542c:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:66
    // The Wire interface blocks and checks the TWIx.MSTATUS flag for WIF, which
    // give us the indication that the transmit was completed, so we return
    // success here

    return ATCA_SUCCESS;
}
    542e:	df 91       	pop	r29
    5430:	cf 91       	pop	r28
    5432:	1f 91       	pop	r17
    5434:	0f 91       	pop	r16
    5436:	ff 90       	pop	r15
    5438:	ef 90       	pop	r14
    543a:	08 95       	ret
TWI_MasterWrite():
    543c:	51 30       	cpi	r21, 0x01	; 1
    543e:	21 f4       	brne	.+8      	; 0x5448 <hal_i2c_send+0x96>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:348
        module->MSTATUS = TWI_ARBLOST_bm;       // reset error flags
        TWI_SET_ERROR(TWI_ERR_BUS_ARB);         // set error flag
        break;                                  // leave TX loop
    }

    if (currentSM == TWI_BUSSTATE_IDLE_gc) {                      // Bus has not sent START yet and is not BUSY
    5440:	47 83       	std	Z+7, r20	; 0x07
hal_i2c_send():
    5442:	90 e0       	ldi	r25, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:349
        module->MADDR = ADD_WRITE_BIT(_data->_clientAddress);
    5444:	80 e0       	ldi	r24, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:364
        } else {                                                  // otherwise WRITE was ACKed
          if (dataWritten < (*txHead)) {                          // check if there is data to be written
            module->MDATA = txBuffer[dataWritten];                // Writing to the register to send data
            dataWritten++;                                        // data was Written
            #if defined (TWI_TIMEOUT_ENABLE)
              timeout = 0;                                        // reset timeout
    5446:	e3 cf       	rjmp	.-58     	; 0x540e <hal_i2c_send+0x5c>
TWI_MasterWrite():
    5448:	52 30       	cpi	r21, 0x02	; 2
    544a:	09 f7       	brne	.-62     	; 0x540e <hal_i2c_send+0x5c>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:353
    if (currentSM == TWI_BUSSTATE_IDLE_gc) {                      // Bus has not sent START yet and is not BUSY
        module->MADDR = ADD_WRITE_BIT(_data->_clientAddress);
        #if defined (TWI_TIMEOUT_ENABLE)
          timeout = 0;                           // reset timeout
        #endif
    } else if (currentSM == TWI_BUSSTATE_OWNER_gc) {              // Address was sent, host is owner
    544c:	36 ff       	sbrs	r19, 6
    544e:	df cf       	rjmp	.-66     	; 0x540e <hal_i2c_send+0x5c>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:354
      if     (currentStatus & TWI_WIF_bm) {                       // data sent
    5450:	34 fd       	sbrc	r19, 4
    5452:	e9 cf       	rjmp	.-46     	; 0x5426 <hal_i2c_send+0x74>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:355
        if   (currentStatus & TWI_RXACK_bm) {                     // AND the RXACK bit is set, last byte has failed
    5454:	80 91 a2 6e 	lds	r24, 0x6EA2	; 0x806ea2 <Wire+0xd>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:360
          if (dataWritten == 0) TWI_SET_ERROR(TWI_ERR_ACK_ADR);   // if dataWritten is 0, no payload was sent, so address was NACKed
          else                  TWI_SET_ERROR(TWI_ERR_ACK_DAT);   // else payload was NACKed
          break;                                                  // leave loop
        } else {                                                  // otherwise WRITE was ACKed
          if (dataWritten < (*txHead)) {                          // check if there is data to be written
    5458:	28 17       	cp	r18, r24
    545a:	28 f7       	brcc	.-54     	; 0x5426 <hal_i2c_send+0x74>
    545c:	a2 2f       	mov	r26, r18
    545e:	b0 e0       	ldi	r27, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:361
            module->MDATA = txBuffer[dataWritten];                // Writing to the register to send data
    5460:	a6 55       	subi	r26, 0x56	; 86
    5462:	b1 49       	sbci	r27, 0x91	; 145
    5464:	8c 91       	ld	r24, X
    5466:	80 87       	std	Z+8, r24	; 0x08
    5468:	2f 5f       	subi	r18, 0xFF	; 255
    546a:	eb cf       	rjmp	.-42     	; 0x5442 <hal_i2c_send+0x90>

0000546c <hal_i2c_init>:
swap():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:362
            dataWritten++;                                        // data was Written
    546c:	80 91 9d 6e 	lds	r24, 0x6E9D	; 0x806e9d <Wire+0x8>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:180
    #else
      #error "This library (Wire.h) is for modern AVRs, and all parts announced or in production have a TWI0"
    #endif
  }
  #if defined(TWI1)
    if (&TWI0 == vars._module) {
    5470:	90 91 9e 6e 	lds	r25, 0x6E9E	; 0x806e9e <Wire+0x9>
    5474:	81 15       	cp	r24, r1
    5476:	29 e0       	ldi	r18, 0x09	; 9
    5478:	92 07       	cpc	r25, r18
    547a:	09 f0       	breq	.+2      	; 0x547e <hal_i2c_init+0x12>
    547c:	4a c0       	rjmp	.+148    	; 0x5512 <hal_i2c_init+0xa6>
TWI0_swap():
    547e:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7e05e5>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:292
      } else {
        return !state;
      }
    #endif
  #elif defined(PORTMUX_TWIROUTEA) /* AVR Dx-series */
    uint8_t portmux = PORTMUX.TWIROUTEA & (~PORTMUX_TWI0_gm);
    5482:	8c 7f       	andi	r24, 0xFC	; 252
    5484:	82 60       	ori	r24, 0x02	; 2
TWI1_swap():
    5486:	80 93 e5 05 	sts	0x05E5, r24	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7e05e5>
hal_i2c_init():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:626
  // Elsewhere, 'portmux' refers to the setting for this peripheral only, and we compare it to PORTMUX_TWI1_xxx_gc
  uint8_t portmux =  PORTMUX.TWIROUTEA & (~PORTMUX_TWI1_gm);
  #if defined(PIN_WIRE1_SDA_PINSWAP_2)
    if (state == 2) {
      // Use pin swap
      PORTMUX.TWIROUTEA = portmux | PORTMUX_TWI1_ALT2_gc;
    548a:	fb 01       	movw	r30, r22
    548c:	66 81       	ldd	r22, Z+6	; 0x06
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:31
#endif
#endif

ATCA_STATUS hal_i2c_init(ATCAIface iface, ATCAIfaceCfg* cfg) {
    WIRE.swap(WIRE_MUX);
    WIRE.setClock(cfg->atcai2c.baud);
    548e:	77 81       	ldd	r23, Z+7	; 0x07
    5490:	80 85       	ldd	r24, Z+8	; 0x08
    5492:	91 85       	ldd	r25, Z+9	; 0x09
TWI_MasterSetBaud():
    5494:	68 3e       	cpi	r22, 0xE8	; 232
    5496:	f3 e0       	ldi	r31, 0x03	; 3
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:211
    if ((frequency < 1000) || (frequency > 15000000)) {
      badArg("Invalid frequency was passed for SCL clock!");
      return 1;
    }
  } else {
    if (frequency < 1000) {
    5498:	7f 07       	cpc	r23, r31
    549a:	81 05       	cpc	r24, r1
    549c:	91 05       	cpc	r25, r1
    549e:	28 f0       	brcs	.+10     	; 0x54aa <hal_i2c_init+0x3e>
    54a0:	20 91 9f 6e 	lds	r18, 0x6E9F	; 0x806e9f <Wire+0xa>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:215
      return 1;
    }
  }
  if (_data->_bools._hostEnabled == 1) {                  // Do something only if the host is enabled.
    54a4:	21 fd       	sbrc	r18, 1
    54a6:	0e 94 fe 01 	call	0x3fc	; 0x3fc <TWI_MasterSetBaud.part.3.constprop.23>
TWI_MasterInit():
    54aa:	80 91 9f 6e 	lds	r24, 0x6E9F	; 0x806e9f <Wire+0xa>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:51
  #if defined(TWI_MANDS)                            // Check if the user wants to use Master AND Slave
    if (_data->_bools._hostEnabled == 1) {          // Slave is allowed to be enabled, don't re-enable the host though
      return;
    }
  #else                                             // Master OR Slave
    if ((_data->_bools._hostEnabled | _data->_bools._clientEnabled) == 1) {  //If either are enabled
    54ae:	81 fd       	sbrc	r24, 1
    54b0:	2d c0       	rjmp	.+90     	; 0x550c <hal_i2c_init+0xa0>
    54b2:	82 fd       	sbrc	r24, 2
    54b4:	2b c0       	rjmp	.+86     	; 0x550c <hal_i2c_init+0xa0>
    54b6:	e0 91 9d 6e 	lds	r30, 0x6E9D	; 0x806e9d <Wire+0x8>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:58
    }
  #endif


  #if defined(TWI1)                                 // More then one TWI used
    if        (&TWI0 == _data->_module) {           // check which one this function is working with
    54ba:	f0 91 9e 6e 	lds	r31, 0x6E9E	; 0x806e9e <Wire+0x9>
    54be:	e1 15       	cp	r30, r1
    54c0:	29 e0       	ldi	r18, 0x09	; 9
    54c2:	f2 07       	cpc	r31, r18
    54c4:	a1 f5       	brne	.+104    	; 0x552e <hal_i2c_init+0xc2>
TWI0_ClearPins():
    54c6:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7e05e5>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:87
    // PA2, PA3, PC2, PC3 - Default
    // PA2, PA3, PC6, PC7 - Alt 1
    // PC2, PC3, PC6, PC7 - Alt 2
    // PA0, PA1, PC2, PC3 - Alt 3, not available on DA, DB
    #if defined(__AVR_DA__) || defined(__AVR_DB__)
      uint8_t portmux = PORTMUX.TWIROUTEA & PORTMUX_TWI0_gm; // registers are volatile, so it's bulky to recheck multiple times.
    54ca:	83 70       	andi	r24, 0x03	; 3
    54cc:	9c e0       	ldi	r25, 0x0C	; 12
    54ce:	82 30       	cpi	r24, 0x02	; 2
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:89
      if (portmux == PORTMUX_TWI0_ALT2_gc) {
        PORTC.OUTCLR = 0x0C;  // bits 2 and 3
    54d0:	49 f5       	brne	.+82     	; 0x5524 <hal_i2c_init+0xb8>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:88
    // PA2, PA3, PC6, PC7 - Alt 1
    // PC2, PC3, PC6, PC7 - Alt 2
    // PA0, PA1, PC2, PC3 - Alt 3, not available on DA, DB
    #if defined(__AVR_DA__) || defined(__AVR_DB__)
      uint8_t portmux = PORTMUX.TWIROUTEA & PORTMUX_TWI0_gm; // registers are volatile, so it's bulky to recheck multiple times.
      if (portmux == PORTMUX_TWI0_ALT2_gc) {
    54d2:	90 93 46 04 	sts	0x0446, r25	; 0x800446 <__TEXT_REGION_LENGTH__+0x7e0446>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:89
        PORTC.OUTCLR = 0x0C;  // bits 2 and 3
    54d6:	90 91 01 09 	lds	r25, 0x0901	; 0x800901 <__TEXT_REGION_LENGTH__+0x7e0901>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:98
        #else
          PORTA.OUTCLR = 0x0C;  // bits 2 and 3
        #endif
      }
      #if defined(TWI0_DUALCTRL)
        if (TWI0.DUALCTRL & TWI_ENABLE_bm) {
    54da:	90 ff       	sbrs	r25, 0
    54dc:	05 c0       	rjmp	.+10     	; 0x54e8 <hal_i2c_init+0x7c>
    54de:	88 23       	and	r24, r24
    54e0:	21 f1       	breq	.+72     	; 0x552a <hal_i2c_init+0xbe>
hal_i2c_init():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:111
              else {
                PORTC.OUTCLR = 0xC0;
              }
            #endif
          #else
            PORTC.OUTCLR = (portmux == PORTMUX_TWI0_DEFAULT_gc ? 0x0C : 0xC0);
    54e2:	80 ec       	ldi	r24, 0xC0	; 192
TWI0_ClearPins():
    54e4:	80 93 46 04 	sts	0x0446, r24	; 0x800446 <__TEXT_REGION_LENGTH__+0x7e0446>
TWI_MasterInit():
    54e8:	80 91 9f 6e 	lds	r24, 0x6E9F	; 0x806e9f <Wire+0xa>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:67
    }
  #else                                             // Only one TWI is used
    TWI0_ClearPins();                               // Only one option is possible
  #endif

  _data->_bools._hostEnabled    = 1;
    54ec:	82 60       	ori	r24, 0x02	; 2
    54ee:	80 93 9f 6e 	sts	0x6E9F, r24	; 0x806e9f <Wire+0xa>
    54f2:	81 e0       	ldi	r24, 0x01	; 1
    54f4:	83 83       	std	Z+3, r24	; 0x03
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:68
  _data->_module->MCTRLA        = TWI_ENABLE_bm;  // Master Interrupt flags stay disabled
    54f6:	85 83       	std	Z+5, r24	; 0x05
TWI_MasterSetBaud():
    54f8:	80 91 9f 6e 	lds	r24, 0x6E9F	; 0x806e9f <Wire+0xa>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:215
  } else {
    if (frequency < 1000) {
      return 1;
    }
  }
  if (_data->_bools._hostEnabled == 1) {                  // Do something only if the host is enabled.
    54fc:	81 ff       	sbrs	r24, 1
    54fe:	06 c0       	rjmp	.+12     	; 0x550c <hal_i2c_init+0xa0>
    5500:	60 ea       	ldi	r22, 0xA0	; 160
    5502:	76 e8       	ldi	r23, 0x86	; 134
    5504:	81 e0       	ldi	r24, 0x01	; 1
    5506:	90 e0       	ldi	r25, 0x00	; 0
    5508:	0e 94 fe 01 	call	0x3fc	; 0x3fc <TWI_MasterSetBaud.part.3.constprop.23>
hal_i2c_init():
    550c:	90 e0       	ldi	r25, 0x00	; 0
    550e:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/hal_i2c_driver.cpp:35
    WIRE.begin();

    return ATCA_SUCCESS;
}
    5510:	08 95       	ret
swap():
    5512:	80 32       	cpi	r24, 0x20	; 32
    5514:	99 40       	sbci	r25, 0x09	; 9
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:182
      return TWI0_swap(state);
    } else if (&TWI1 == vars._module) {
    5516:	09 f0       	breq	.+2      	; 0x551a <hal_i2c_init+0xae>
    5518:	b8 cf       	rjmp	.-144    	; 0x548a <hal_i2c_init+0x1e>
TWI1_swap():
    551a:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7e05e5>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:622


bool TWI1_swap(uint8_t state) {
  // Danger: 'portmux' in this context means all the other settings in portmux, since we're replacing the PORTMUX setting for TWI1, and will bitwise-or with the _gc constants.
  // Elsewhere, 'portmux' refers to the setting for this peripheral only, and we compare it to PORTMUX_TWI1_xxx_gc
  uint8_t portmux =  PORTMUX.TWIROUTEA & (~PORTMUX_TWI1_gm);
    551e:	83 7f       	andi	r24, 0xF3	; 243
    5520:	88 60       	ori	r24, 0x08	; 8
    5522:	b1 cf       	rjmp	.-158    	; 0x5486 <hal_i2c_init+0x1a>
TWI0_ClearPins():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:626
  #if defined(PIN_WIRE1_SDA_PINSWAP_2)
    if (state == 2) {
      // Use pin swap
      PORTMUX.TWIROUTEA = portmux | PORTMUX_TWI1_ALT2_gc;
    5524:	90 93 06 04 	sts	0x0406, r25	; 0x800406 <__TEXT_REGION_LENGTH__+0x7e0406>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:94
        PORTC.OUTCLR = 0x0C;  // bits 2 and 3
      } else {
        #if defined(__AVR_DD__) || defined(__AVR_EA__)
          PORTA.OUTCLR = (portmux == PORTMUX_TWI0_ALT3_gc ? 0x03 : 0x0C);
        #else
          PORTA.OUTCLR = 0x0C;  // bits 2 and 3
    5528:	d6 cf       	rjmp	.-84     	; 0x54d6 <hal_i2c_init+0x6a>
hal_i2c_init():
    552a:	8c e0       	ldi	r24, 0x0C	; 12
    552c:	db cf       	rjmp	.-74     	; 0x54e4 <hal_i2c_init+0x78>
TWI_MasterInit():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:111
              else {
                PORTC.OUTCLR = 0xC0;
              }
            #endif
          #else
            PORTC.OUTCLR = (portmux == PORTMUX_TWI0_DEFAULT_gc ? 0x0C : 0xC0);
    552e:	e0 32       	cpi	r30, 0x20	; 32
    5530:	89 e0       	ldi	r24, 0x09	; 9
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi.c:60


  #if defined(TWI1)                                 // More then one TWI used
    if        (&TWI0 == _data->_module) {           // check which one this function is working with
      TWI0_ClearPins();
    } else if (&TWI1 == _data->_module) {
    5532:	f8 07       	cpc	r31, r24
    5534:	c9 f6       	brne	.-78     	; 0x54e8 <hal_i2c_init+0x7c>
TWI1_ClearPins():
    5536:	80 91 e5 05 	lds	r24, 0x05E5	; 0x8005e5 <__TEXT_REGION_LENGTH__+0x7e05e5>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:546


#if defined(TWI1)
void TWI1_ClearPins() {
  #if defined(PIN_WIRE1_SDA_PINSWAP_2) || defined(TWI1_DUALCTRL)
    uint8_t portmux =  PORTMUX.TWIROUTEA & PORTMUX_TWI1_gm;
    553a:	8c 70       	andi	r24, 0x0C	; 12
    553c:	9c e0       	ldi	r25, 0x0C	; 12
    553e:	88 30       	cpi	r24, 0x08	; 8
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:551
  #endif
  #if defined(PIN_WIRE1_SDA_PINSWAP_2)
    if (portmux == PORTMUX_TWI1_ALT2_gc) {  // make sure we don't get errata'ed
      #if defined(PORTB)
        PORTB.OUTCLR = 0x0C;  // bits 2 and 3
    5540:	61 f4       	brne	.+24     	; 0x555a <hal_i2c_init+0xee>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:549
void TWI1_ClearPins() {
  #if defined(PIN_WIRE1_SDA_PINSWAP_2) || defined(TWI1_DUALCTRL)
    uint8_t portmux =  PORTMUX.TWIROUTEA & PORTMUX_TWI1_gm;
  #endif
  #if defined(PIN_WIRE1_SDA_PINSWAP_2)
    if (portmux == PORTMUX_TWI1_ALT2_gc) {  // make sure we don't get errata'ed
    5542:	90 93 26 04 	sts	0x0426, r25	; 0x800426 <__TEXT_REGION_LENGTH__+0x7e0426>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:551
      #if defined(PORTB)
        PORTB.OUTCLR = 0x0C;  // bits 2 and 3
    5546:	90 91 21 09 	lds	r25, 0x0921	; 0x800921 <__TEXT_REGION_LENGTH__+0x7e0921>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:560
  {
    PORTF.OUTCLR = 0x0C;  // bits 2 and 3
  }
  #if defined(TWI1_DUALCTRL)
    #if defined(PORTB)
      if (TWI1.DUALCTRL & TWI_ENABLE_bm) {
    554a:	90 ff       	sbrs	r25, 0
    554c:	cd cf       	rjmp	.-102    	; 0x54e8 <hal_i2c_init+0x7c>
    554e:	81 11       	cpse	r24, r1
    5550:	07 c0       	rjmp	.+14     	; 0x5560 <hal_i2c_init+0xf4>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:561
        if (portmux == PORTMUX_TWI1_DEFAULT_gc) {
    5552:	8c e0       	ldi	r24, 0x0C	; 12
    5554:	80 93 26 04 	sts	0x0426, r24	; 0x800426 <__TEXT_REGION_LENGTH__+0x7e0426>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:564
          PORTB.OUTCLR = 0x0C;  // bits 2 and 3
        } else {
          PORTB.OUTCLR = 0xC0;  // bits 6 and 7
    5558:	c7 cf       	rjmp	.-114    	; 0x54e8 <hal_i2c_init+0x7c>
    555a:	90 93 a6 04 	sts	0x04A6, r25	; 0x8004a6 <__TEXT_REGION_LENGTH__+0x7e04a6>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:556
        PORTB.OUTCLR = 0x0C;  // bits 2 and 3
      #endif
    } else
  #endif
  {
    PORTF.OUTCLR = 0x0C;  // bits 2 and 3
    555e:	f3 cf       	rjmp	.-26     	; 0x5546 <hal_i2c_init+0xda>
    5560:	80 ec       	ldi	r24, 0xC0	; 192
    5562:	f8 cf       	rjmp	.-16     	; 0x5554 <hal_i2c_init+0xe8>

00005564 <cJSON_GetObjectItem>:
cJSON_GetObjectItem():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/twi_pins.c:564
    #if defined(PORTB)
      if (TWI1.DUALCTRL & TWI_ENABLE_bm) {
        if (portmux == PORTMUX_TWI1_DEFAULT_gc) {
          PORTB.OUTCLR = 0x0C;  // bits 2 and 3
        } else {
          PORTB.OUTCLR = 0xC0;  // bits 6 and 7
    5564:	8f 92       	push	r8
    5566:	9f 92       	push	r9
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1909

    return current_element;
}

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
{
    5568:	af 92       	push	r10
    556a:	bf 92       	push	r11
    556c:	df 92       	push	r13
    556e:	ef 92       	push	r14
    5570:	ff 92       	push	r15
    5572:	0f 93       	push	r16
    5574:	1f 93       	push	r17
    5576:	cf 93       	push	r28
    5578:	df 93       	push	r29
get_object_item():
    557a:	00 97       	sbiw	r24, 0x00	; 0
    557c:	b1 f1       	breq	.+108    	; 0x55ea <cJSON_GetObjectItem+0x86>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1880

static cJSON *get_object_item(const cJSON * const object, const char * const name, const cJSON_bool case_sensitive)
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    557e:	61 15       	cp	r22, r1
    5580:	71 05       	cpc	r23, r1
    5582:	99 f1       	breq	.+102    	; 0x55ea <cJSON_GetObjectItem+0x86>
    5584:	7b 01       	movw	r14, r22
    5586:	fc 01       	movw	r30, r24
    5588:	c4 81       	ldd	r28, Z+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1885
    {
        return NULL;
    }

    current_element = object->child;
    558a:	d5 81       	ldd	r29, Z+5	; 0x05
    558c:	20 97       	sbiw	r28, 0x00	; 0
    558e:	01 f1       	breq	.+64     	; 0x55d0 <cJSON_GetObjectItem+0x6c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1895
            current_element = current_element->next;
        }
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
    5590:	08 89       	ldd	r16, Y+16	; 0x10
    5592:	19 89       	ldd	r17, Y+17	; 0x11
case_insensitive_strcmp():
    5594:	01 15       	cp	r16, r1
    5596:	11 05       	cpc	r17, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:135
}

/* Case insensitive string comparison, doesn't consider two NULL pointers equal though */
static int case_insensitive_strcmp(const unsigned char *string1, const unsigned char *string2)
{
    if ((string1 == NULL) || (string2 == NULL))
    5598:	a9 f0       	breq	.+42     	; 0x55c4 <cJSON_GetObjectItem+0x60>
    559a:	e0 16       	cp	r14, r16
    559c:	f1 06       	cpc	r15, r17
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:140
    {
        return 1;
    }

    if (string1 == string2)
    559e:	c1 f0       	breq	.+48     	; 0x55d0 <cJSON_GetObjectItem+0x6c>
    55a0:	57 01       	movw	r10, r14
    55a2:	f5 01       	movw	r30, r10
    55a4:	d1 90       	ld	r13, Z+
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:145
    {
        return 0;
    }

    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
    55a6:	5f 01       	movw	r10, r30
    55a8:	8d 2d       	mov	r24, r13
    55aa:	90 e0       	ldi	r25, 0x00	; 0
    55ac:	0e 94 b9 56 	call	0xad72	; 0xad72 <tolower>
    55b0:	4c 01       	movw	r8, r24
    55b2:	f8 01       	movw	r30, r16
    55b4:	81 91       	ld	r24, Z+
    55b6:	8f 01       	movw	r16, r30
    55b8:	90 e0       	ldi	r25, 0x00	; 0
    55ba:	0e 94 b9 56 	call	0xad72	; 0xad72 <tolower>
    55be:	88 16       	cp	r8, r24
    55c0:	99 06       	cpc	r9, r25
    55c2:	21 f0       	breq	.+8      	; 0x55cc <cJSON_GetObjectItem+0x68>
get_object_item():
    55c4:	09 90       	ld	r0, Y+
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1897
    }
    else
    {
        while ((current_element != NULL) && (case_insensitive_strcmp((const unsigned char*)name, (const unsigned char*)(current_element->string)) != 0))
        {
            current_element = current_element->next;
    55c6:	d8 81       	ld	r29, Y
    55c8:	c0 2d       	mov	r28, r0
    55ca:	e0 cf       	rjmp	.-64     	; 0x558c <cJSON_GetObjectItem+0x28>
case_insensitive_strcmp():
    55cc:	d1 10       	cpse	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:147
        return 0;
    }

    for(; tolower(*string1) == tolower(*string2); (void)string1++, string2++)
    {
        if (*string1 == '\0')
    55ce:	e9 cf       	rjmp	.-46     	; 0x55a2 <cJSON_GetObjectItem+0x3e>
cJSON_GetObjectItem():
    55d0:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1911
}

CJSON_PUBLIC(cJSON *) cJSON_GetObjectItem(const cJSON * const object, const char * const string)
{
    return get_object_item(object, string, false);
}
    55d2:	df 91       	pop	r29
    55d4:	cf 91       	pop	r28
    55d6:	1f 91       	pop	r17
    55d8:	0f 91       	pop	r16
    55da:	ff 90       	pop	r15
    55dc:	ef 90       	pop	r14
    55de:	df 90       	pop	r13
    55e0:	bf 90       	pop	r11
    55e2:	af 90       	pop	r10
    55e4:	9f 90       	pop	r9
    55e6:	8f 90       	pop	r8
    55e8:	08 95       	ret
    55ea:	d0 e0       	ldi	r29, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1882
{
    cJSON *current_element = NULL;

    if ((object == NULL) || (name == NULL))
    {
        return NULL;
    55ec:	c0 e0       	ldi	r28, 0x00	; 0
    55ee:	f0 cf       	rjmp	.-32     	; 0x55d0 <cJSON_GetObjectItem+0x6c>

000055f0 <iotcl_telemetry_add_with_iso_time>:
iotcl_telemetry_add_with_iso_time():
    55f0:	af 92       	push	r10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:159
        }
    }
    return true;
}

bool iotcl_telemetry_add_with_iso_time(IotclMessageHandle message, const char *time) {
    55f2:	bf 92       	push	r11
    55f4:	cf 92       	push	r12
    55f6:	df 92       	push	r13
    55f8:	ff 92       	push	r15
    55fa:	0f 93       	push	r16
    55fc:	1f 93       	push	r17
    55fe:	cf 93       	push	r28
    5600:	df 93       	push	r29
    5602:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:160
    if (!message) return false;
    5604:	11 f4       	brne	.+4      	; 0x560a <iotcl_telemetry_add_with_iso_time+0x1a>
    5606:	f1 2c       	mov	r15, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:165
    cJSON *const telemetry_object = setup_telemetry_object(message);
    if (!telemetry_object) return false;
    if (!cJSON_AddStringToObject(telemetry_object, "dt", time)) return false;
    if (!cJSON_HasObjectItem(message->root_value, "t")) {
        if (!cJSON_AddStringToObject(message->root_value, "t", time)) return false;
    5608:	62 c0       	rjmp	.+196    	; 0x56ce <iotcl_telemetry_add_with_iso_time+0xde>
iotcl_get_config():
    560a:	f0 90 3d 64 	lds	r15, 0x643D	; 0x80643d <config_is_valid>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:44
    560e:	ff 20       	and	r15, r15
    5610:	d1 f3       	breq	.-12     	; 0x5606 <iotcl_telemetry_add_with_iso_time+0x16>
    5612:	6b 01       	movw	r12, r22
    5614:	8c 01       	movw	r16, r24
setup_telemetry_object():
    5616:	0e 94 de 10 	call	0x21bc	; 0x21bc <cJSON_CreateObject>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:77
static cJSON *setup_telemetry_object(IotclMessageHandle message) {
    IotclConfig *config = iotcl_get_config();
    if (!config) return NULL;
    if (!message) return NULL;

    cJSON *telemetry_object = cJSON_CreateObject();
    561a:	ec 01       	movw	r28, r24
    561c:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:78
    if (!telemetry_object) return NULL;
    561e:	99 f3       	breq	.-26     	; 0x5606 <iotcl_telemetry_add_with_iso_time+0x16>
    5620:	40 91 2d 64 	lds	r20, 0x642D	; 0x80642d <config>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:79
    if (!cJSON_AddStringToObject(telemetry_object, "id", config->device.duid)) goto cleanup_to;
    5624:	50 91 2e 64 	lds	r21, 0x642E	; 0x80642e <config+0x1>
    5628:	63 e7       	ldi	r22, 0x73	; 115
    562a:	73 e5       	ldi	r23, 0x53	; 83
    562c:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    5630:	89 2b       	or	r24, r25
    5632:	61 f1       	breq	.+88     	; 0x568c <iotcl_telemetry_add_with_iso_time+0x9c>
    5634:	42 ef       	ldi	r20, 0xF2	; 242
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:80
    if (!cJSON_AddStringToObject(telemetry_object, "tg", "")) goto cleanup_to;
    5636:	51 e6       	ldi	r21, 0x61	; 97
    5638:	66 ee       	ldi	r22, 0xE6	; 230
    563a:	7a e5       	ldi	r23, 0x5A	; 90
    563c:	ce 01       	movw	r24, r28
    563e:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    5642:	89 2b       	or	r24, r25
    5644:	19 f1       	breq	.+70     	; 0x568c <iotcl_telemetry_add_with_iso_time+0x9c>
    5646:	ce 01       	movw	r24, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:81
    cJSON *data_array = cJSON_AddArrayToObject(telemetry_object, "d");
    5648:	0e 94 bb 10 	call	0x2176	; 0x2176 <cJSON_AddArrayToObject.constprop.82>
    564c:	5c 01       	movw	r10, r24
    564e:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:82
    if (!data_array) goto cleanup_to;
    5650:	e9 f0       	breq	.+58     	; 0x568c <iotcl_telemetry_add_with_iso_time+0x9c>
cJSON_AddItemToArray():
    5652:	be 01       	movw	r22, r28
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1988
}

/* Add item to array/object. */
CJSON_PUBLIC(cJSON_bool) cJSON_AddItemToArray(cJSON *array, cJSON *item)
{
    return add_item_to_array(array, item);
    5654:	f8 01       	movw	r30, r16
    5656:	82 81       	ldd	r24, Z+2	; 0x02
    5658:	93 81       	ldd	r25, Z+3	; 0x03
    565a:	0e 94 20 05 	call	0xa40	; 0xa40 <add_item_to_array>
setup_telemetry_object():
    565e:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:83
    if (!cJSON_AddItemToArray(message->telemetry_data_array, telemetry_object)) goto cleanup_da;
    5660:	91 f0       	breq	.+36     	; 0x5686 <iotcl_telemetry_add_with_iso_time+0x96>
    5662:	0e 94 de 10 	call	0x21bc	; 0x21bc <cJSON_CreateObject>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:86

    // setup the actual telemetry object to be used in subsequent calls
    message->current_telemetry_object = cJSON_CreateObject();
    5666:	f8 01       	movw	r30, r16
    5668:	84 83       	std	Z+4, r24	; 0x04
    566a:	95 83       	std	Z+5, r25	; 0x05
    566c:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:87
    if (!message->current_telemetry_object) goto cleanup_da;
    566e:	59 f0       	breq	.+22     	; 0x5686 <iotcl_telemetry_add_with_iso_time+0x96>
cJSON_AddItemToArray():
    5670:	bc 01       	movw	r22, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1988
    5672:	c5 01       	movw	r24, r10
    5674:	0e 94 20 05 	call	0xa40	; 0xa40 <add_item_to_array>
setup_telemetry_object():
    5678:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:89

    if (!cJSON_AddItemToArray(data_array, message->current_telemetry_object)) goto cleanup_cto;
    567a:	61 f4       	brne	.+24     	; 0x5694 <iotcl_telemetry_add_with_iso_time+0xa4>
    567c:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:94

    return telemetry_object; // object inside the "d" array of the the root object

    cleanup_cto:
    cJSON_free(message->current_telemetry_object);
    567e:	84 81       	ldd	r24, Z+4	; 0x04
    5680:	95 81       	ldd	r25, Z+5	; 0x05
    5682:	0e 94 1b 05 	call	0xa36	; 0xa36 <cJSON_free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:97

    cleanup_da:
    cJSON_free(data_array);
    5686:	c5 01       	movw	r24, r10
    5688:	0e 94 1b 05 	call	0xa36	; 0xa36 <cJSON_free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:100

    cleanup_to:
    cJSON_free(telemetry_object);
    568c:	ce 01       	movw	r24, r28
    568e:	0e 94 1b 05 	call	0xa36	; 0xa36 <cJSON_free>
    5692:	b9 cf       	rjmp	.-142    	; 0x5606 <iotcl_telemetry_add_with_iso_time+0x16>
iotcl_telemetry_add_with_iso_time():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:163

bool iotcl_telemetry_add_with_iso_time(IotclMessageHandle message, const char *time) {
    if (!message) return false;
    cJSON *const telemetry_object = setup_telemetry_object(message);
    if (!telemetry_object) return false;
    if (!cJSON_AddStringToObject(telemetry_object, "dt", time)) return false;
    5694:	a6 01       	movw	r20, r12
    5696:	6d ef       	ldi	r22, 0xFD	; 253
    5698:	71 e5       	ldi	r23, 0x51	; 81
    569a:	ce 01       	movw	r24, r28
    569c:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    56a0:	89 2b       	or	r24, r25
    56a2:	09 f4       	brne	.+2      	; 0x56a6 <iotcl_telemetry_add_with_iso_time+0xb6>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:164
    if (!cJSON_HasObjectItem(message->root_value, "t")) {
    56a4:	b0 cf       	rjmp	.-160    	; 0x5606 <iotcl_telemetry_add_with_iso_time+0x16>
    56a6:	f8 01       	movw	r30, r16
    56a8:	c0 81       	ld	r28, Z
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1920
    return get_object_item(object, string, true);
}

CJSON_PUBLIC(cJSON_bool) cJSON_HasObjectItem(const cJSON *object, const char *string)
{
    return cJSON_GetObjectItem(object, string) ? 1 : 0;
    56aa:	d1 81       	ldd	r29, Z+1	; 0x01
cJSON_HasObjectItem():
    56ac:	60 ef       	ldi	r22, 0xF0	; 240
    56ae:	7a e5       	ldi	r23, 0x5A	; 90
    56b0:	ce 01       	movw	r24, r28
    56b2:	58 df       	rcall	.-336    	; 0x5564 <cJSON_GetObjectItem>
iotcl_telemetry_add_with_iso_time():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:164
    56b4:	89 2b       	or	r24, r25
    56b6:	59 f4       	brne	.+22     	; 0x56ce <iotcl_telemetry_add_with_iso_time+0xde>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:165
        if (!cJSON_AddStringToObject(message->root_value, "t", time)) return false;
    56b8:	a6 01       	movw	r20, r12
    56ba:	60 ef       	ldi	r22, 0xF0	; 240
    56bc:	7a e5       	ldi	r23, 0x5A	; 90
    56be:	ce 01       	movw	r24, r28
    56c0:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    56c4:	ff 24       	eor	r15, r15
    56c6:	f3 94       	inc	r15
    56c8:	89 2b       	or	r24, r25
    56ca:	09 f4       	brne	.+2      	; 0x56ce <iotcl_telemetry_add_with_iso_time+0xde>
    56cc:	9c cf       	rjmp	.-200    	; 0x5606 <iotcl_telemetry_add_with_iso_time+0x16>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:168
    }
    return true;
}
    56ce:	8f 2d       	mov	r24, r15
    56d0:	df 91       	pop	r29
    56d2:	cf 91       	pop	r28
    56d4:	1f 91       	pop	r17
    56d6:	0f 91       	pop	r16
    56d8:	ff 90       	pop	r15
    56da:	df 90       	pop	r13
    56dc:	cf 90       	pop	r12
    56de:	bf 90       	pop	r11
    56e0:	af 90       	pop	r10
    56e2:	08 95       	ret

000056e4 <json_object_dotset_locate.constprop.84>:
json_object_dotset_locate():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:28
    cJSON *root_value;
    cJSON *telemetry_data_array;
    cJSON *current_telemetry_object; // an object inside the "d" array inside the "d" array of the root object
};

cJSON *json_object_dotset_locate(cJSON *search_object, char **leaf_name, const char *path) {
    56e4:	af 92       	push	r10
    56e6:	bf 92       	push	r11
    56e8:	cf 92       	push	r12
    56ea:	df 92       	push	r13
    56ec:	ef 92       	push	r14
    56ee:	ff 92       	push	r15
    56f0:	0f 93       	push	r16
    56f2:	1f 93       	push	r17
    56f4:	cf 93       	push	r28
    56f6:	df 93       	push	r29
    56f8:	d8 2f       	mov	r29, r24
    56fa:	c9 2f       	mov	r28, r25
    56fc:	5b 01       	movw	r10, r22
    56fe:	ca 01       	movw	r24, r20
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:30
    static const char *DELIM = ".";
    char *mutable_path = iotcl_strdup(path);
    5700:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <iotcl_strdup>
    5704:	8c 01       	movw	r16, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:31
    char *token = strtok(mutable_path, DELIM);
    5706:	66 eb       	ldi	r22, 0xB6	; 182
    5708:	77 e5       	ldi	r23, 0x57	; 87
    570a:	0e 94 5c 50 	call	0xa0b8	; 0xa0b8 <strtok>
    570e:	6c 01       	movw	r12, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:32
    *leaf_name = NULL;
    5710:	f5 01       	movw	r30, r10
    5712:	10 82       	st	Z, r1
    5714:	11 82       	std	Z+1, r1	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:33
    if (NULL == token) {
    5716:	89 2b       	or	r24, r25
    5718:	a1 f4       	brne	.+40     	; 0x5742 <json_object_dotset_locate.constprop.84+0x5e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:68

    free(mutable_path);
    return target_object;

    cleanup:
    free(mutable_path);
    571a:	c8 01       	movw	r24, r16
    571c:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:69
    return NULL;
    5720:	d0 e0       	ldi	r29, 0x00	; 0
    5722:	c0 e0       	ldi	r28, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:70
}
    5724:	8d 2f       	mov	r24, r29
    5726:	9c 2f       	mov	r25, r28
    5728:	df 91       	pop	r29
    572a:	cf 91       	pop	r28
    572c:	1f 91       	pop	r17
    572e:	0f 91       	pop	r16
    5730:	ff 90       	pop	r15
    5732:	ef 90       	pop	r14
    5734:	df 90       	pop	r13
    5736:	cf 90       	pop	r12
    5738:	bf 90       	pop	r11
    573a:	af 90       	pop	r10
    573c:	08 95       	ret
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:28
    cJSON *root_value;
    cJSON *telemetry_data_array;
    cJSON *current_telemetry_object; // an object inside the "d" array inside the "d" array of the root object
};

cJSON *json_object_dotset_locate(cJSON *search_object, char **leaf_name, const char *path) {
    573e:	d8 2f       	mov	r29, r24
    5740:	c9 2f       	mov	r28, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:40
        free(mutable_path);
        return NULL;
    }
    cJSON *target_object = search_object;
    do {
        free(*leaf_name);
    5742:	f5 01       	movw	r30, r10
    5744:	80 81       	ld	r24, Z
    5746:	91 81       	ldd	r25, Z+1	; 0x01
    5748:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:41
        *leaf_name = iotcl_strdup(token);
    574c:	c6 01       	movw	r24, r12
    574e:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <iotcl_strdup>
    5752:	7c 01       	movw	r14, r24
    5754:	f5 01       	movw	r30, r10
    5756:	80 83       	st	Z, r24
    5758:	91 83       	std	Z+1, r25	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:42
        if (!*leaf_name) {
    575a:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:46
            goto cleanup;
        }
        char *last_token = *leaf_name;
        token = strtok(NULL, DELIM);
    575c:	f1 f2       	breq	.-68     	; 0x571a <json_object_dotset_locate.constprop.84+0x36>
    575e:	66 eb       	ldi	r22, 0xB6	; 182
    5760:	77 e5       	ldi	r23, 0x57	; 87
    5762:	90 e0       	ldi	r25, 0x00	; 0
    5764:	80 e0       	ldi	r24, 0x00	; 0
    5766:	0e 94 5c 50 	call	0xa0b8	; 0xa0b8 <strtok>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:47
        if (NULL != token) {
    576a:	6c 01       	movw	r12, r24
    576c:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1920
    576e:	71 f0       	breq	.+28     	; 0x578c <json_object_dotset_locate.constprop.84+0xa8>
cJSON_HasObjectItem():
    5770:	b7 01       	movw	r22, r14
    5772:	8d 2f       	mov	r24, r29
    5774:	9c 2f       	mov	r25, r28
    5776:	f6 de       	rcall	.-532    	; 0x5564 <cJSON_GetObjectItem>
json_object_dotset_locate():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:50
            // we have more and need to create the nested object
            cJSON *parent_object;
            if (cJSON_HasObjectItem(target_object, last_token)) {
    5778:	00 97       	sbiw	r24, 0x00	; 0
    577a:	09 f7       	brne	.-62     	; 0x573e <json_object_dotset_locate.constprop.84+0x5a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:53
                parent_object = cJSON_GetObjectItem(target_object, last_token);
            } else {
                parent_object = cJSON_AddObjectToObject(target_object, last_token);
    577c:	b7 01       	movw	r22, r14
    577e:	8d 2f       	mov	r24, r29
    5780:	9c 2f       	mov	r25, r28
    5782:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <cJSON_AddObjectToObject>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:58
            }

            // NOTE: The user should clean up the search object if we return
            // That should free all added objects, so this should be safe to do
            if (!parent_object) goto cleanup;
    5786:	00 97       	sbiw	r24, 0x00	; 0
    5788:	d1 f6       	brne	.-76     	; 0x573e <json_object_dotset_locate.constprop.84+0x5a>
    578a:	c7 cf       	rjmp	.-114    	; 0x571a <json_object_dotset_locate.constprop.84+0x36>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:64

            target_object = parent_object;
        }
    } while (token != NULL);

    free(mutable_path);
    578c:	c8 01       	movw	r24, r16
    578e:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    5792:	c8 cf       	rjmp	.-112    	; 0x5724 <json_object_dotset_locate.constprop.84+0x40>

00005794 <safe_get_string_and_strdup>:
safe_get_string_and_strdup():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:17
#include "cJSON.h"
#include "iotconnect_common.h"
#include "iotconnect_discovery.h"

static char *safe_get_string_and_strdup(cJSON *cjson, const char *value_name) {
    cJSON *value = cJSON_GetObjectItem(cjson, value_name);
    5794:	e7 de       	rcall	.-562    	; 0x5564 <cJSON_GetObjectItem>
    5796:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:18
    if (!value) {
    5798:	51 f0       	breq	.+20     	; 0x57ae <safe_get_string_and_strdup+0x1a>
cJSON_IsString():
    579a:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2944
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_String;
    579c:	26 81       	ldd	r18, Z+6	; 0x06
cJSON_GetStringValue():
    579e:	20 31       	cpi	r18, 0x10	; 16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:101
    return (const char*) (global_error.json + global_error.position);
}

CJSON_PUBLIC(char *) cJSON_GetStringValue(const cJSON * const item) 
{
    if (!cJSON_IsString(item)) 
    57a0:	31 f4       	brne	.+12     	; 0x57ae <safe_get_string_and_strdup+0x1a>
    57a2:	80 85       	ldd	r24, Z+8	; 0x08
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:106
    {
        return NULL;
    }

    return item->valuestring;
    57a4:	91 85       	ldd	r25, Z+9	; 0x09
safe_get_string_and_strdup():
    57a6:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:22
        return NULL;
    }
    const char *str_value = cJSON_GetStringValue(value);
    if (!str_value) {
    57a8:	11 f0       	breq	.+4      	; 0x57ae <safe_get_string_and_strdup+0x1a>
    57aa:	0c 94 ef 0f 	jmp	0x1fde	; 0x1fde <iotcl_strdup>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:25
        return NULL;
    }
    return iotcl_strdup(str_value);
    57ae:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:26
}
    57b0:	80 e0       	ldi	r24, 0x00	; 0
    57b2:	08 95       	ret

000057b4 <on_ota(IotclEventDataTag*)>:
on_ota():
    57b4:	af 92       	push	r10
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:66

static bool app_needs_ota_update(const char *version) {
    return strcmp(APP_VERSION, version) < 0;
}

static void on_ota(IotclEventData data) {
    57b6:	bf 92       	push	r11
    57b8:	cf 92       	push	r12
    57ba:	df 92       	push	r13
    57bc:	ff 92       	push	r15
    57be:	0f 93       	push	r16
    57c0:	1f 93       	push	r17
    57c2:	cf 93       	push	r28
    57c4:	df 93       	push	r29
    57c6:	6c 01       	movw	r12, r24
iotcl_clone_download_url():
    57c8:	64 e6       	ldi	r22, 0x64	; 100
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:164

char *iotcl_clone_download_url(IotclEventData data, size_t index) {
    cJSON *urls = cJSON_GetObjectItemCaseSensitive(data->data, "urls");
    57ca:	72 e5       	ldi	r23, 0x52	; 82
    57cc:	fc 01       	movw	r30, r24
    57ce:	80 81       	ld	r24, Z
    57d0:	91 81       	ldd	r25, Z+1	; 0x01
    57d2:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:165
    if (NULL == urls || !cJSON_IsArray(urls)) {
    57d6:	00 97       	sbiw	r24, 0x00	; 0
    57d8:	09 f4       	brne	.+2      	; 0x57dc <on_ota(IotclEventDataTag*)+0x28>
    57da:	9b c0       	rjmp	.+310    	; 0x5912 <on_ota(IotclEventDataTag*)+0x15e>
cJSON_IsArray():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2954
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Array;
    57dc:	fc 01       	movw	r30, r24
    57de:	26 81       	ldd	r18, Z+6	; 0x06
iotcl_clone_download_url():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:165
    57e0:	20 32       	cpi	r18, 0x20	; 32
    57e2:	09 f0       	breq	.+2      	; 0x57e6 <on_ota(IotclEventDataTag*)+0x32>
    57e4:	96 c0       	rjmp	.+300    	; 0x5912 <on_ota(IotclEventDataTag*)+0x15e>
cJSON_GetArraySize():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1834
    if (array == NULL)
    {
        return 0;
    }

    child = array->child;
    57e6:	c4 81       	ldd	r28, Z+4	; 0x04
    57e8:	d5 81       	ldd	r29, Z+5	; 0x05
    57ea:	fe 01       	movw	r30, r28
on_ota():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1827

/* Get Array size/item / object item. */
CJSON_PUBLIC(int) cJSON_GetArraySize(const cJSON *array)
{
    cJSON *child = NULL;
    size_t size = 0;
    57ec:	90 e0       	ldi	r25, 0x00	; 0
    57ee:	80 e0       	ldi	r24, 0x00	; 0
cJSON_GetArraySize():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1836
        return 0;
    }

    child = array->child;

    while(child != NULL)
    57f0:	30 97       	sbiw	r30, 0x00	; 0
    57f2:	09 f0       	breq	.+2      	; 0x57f6 <on_ota(IotclEventDataTag*)+0x42>
    57f4:	7b c0       	rjmp	.+246    	; 0x58ec <on_ota(IotclEventDataTag*)+0x138>
iotcl_clone_download_url():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:168
        return NULL;
    }
    if ((size_t) cJSON_GetArraySize(urls) > index) {
    57f6:	89 2b       	or	r24, r25
    57f8:	09 f4       	brne	.+2      	; 0x57fc <on_ota(IotclEventDataTag*)+0x48>
    57fa:	8b c0       	rjmp	.+278    	; 0x5912 <on_ota(IotclEventDataTag*)+0x15e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:170
        cJSON *url = cJSON_GetArrayItem(urls, index);
        if (is_valid_string(url)) {
    57fc:	ce 01       	movw	r24, r28
    57fe:	0e 94 0d 05 	call	0xa1a	; 0xa1a <is_valid_string>
    5802:	88 23       	and	r24, r24
    5804:	09 f4       	brne	.+2      	; 0x5808 <on_ota(IotclEventDataTag*)+0x54>
    5806:	77 c0       	rjmp	.+238    	; 0x58f6 <on_ota(IotclEventDataTag*)+0x142>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:175
            return iotcl_strdup(url->valuestring);
        } else if (cJSON_IsObject(url)) {
            cJSON *url_str = cJSON_GetObjectItem(url, "url");
            if (is_valid_string(url_str)) {
                return iotcl_strdup(url_str->valuestring);
    5808:	88 85       	ldd	r24, Y+8	; 0x08
    580a:	99 85       	ldd	r25, Y+9	; 0x09
    580c:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <iotcl_strdup>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:70
    const char *message = NULL;
    char *url = iotcl_clone_download_url(data, 0);
    bool success = false;
    if (NULL != url) {
    5810:	5c 01       	movw	r10, r24
on_ota():
    5812:	00 97       	sbiw	r24, 0x00	; 0
    5814:	09 f4       	brne	.+2      	; 0x5818 <on_ota(IotclEventDataTag*)+0x64>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:71
        printf("Download URL is: %s\n", url);
    5816:	7d c0       	rjmp	.+250    	; 0x5912 <on_ota(IotclEventDataTag*)+0x15e>
    5818:	bf 92       	push	r11
    581a:	8f 93       	push	r24
    581c:	8d e6       	ldi	r24, 0x6D	; 109
    581e:	92 e5       	ldi	r25, 0x52	; 82
    5820:	9f 93       	push	r25
    5822:	8f 93       	push	r24
    5824:	0e 94 44 57 	call	0xae88	; 0xae88 <printf>
iotcl_clone_sw_version():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:184
    return NULL;
}


char *iotcl_clone_sw_version(IotclEventData data) {
    cJSON *ver = cJSON_GetObjectItemCaseSensitive(data->data, "ver");
    5828:	6f e4       	ldi	r22, 0x4F	; 79
    582a:	7c e5       	ldi	r23, 0x5C	; 92
    582c:	f6 01       	movw	r30, r12
    582e:	80 81       	ld	r24, Z
    5830:	91 81       	ldd	r25, Z+1	; 0x01
    5832:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
cJSON_IsObject():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2959
    return (item->type & 0xFF) == cJSON_Array;
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
{
    if (item == NULL)
    5836:	0f 90       	pop	r0
    5838:	0f 90       	pop	r0
    583a:	0f 90       	pop	r0
    583c:	0f 90       	pop	r0
    583e:	00 97       	sbiw	r24, 0x00	; 0
    5840:	09 f4       	brne	.+2      	; 0x5844 <on_ota(IotclEventDataTag*)+0x90>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2964
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Object;
    5842:	82 c0       	rjmp	.+260    	; 0x5948 <on_ota(IotclEventDataTag*)+0x194>
    5844:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:185
    if (cJSON_IsObject(ver)) {
    5846:	26 81       	ldd	r18, Z+6	; 0x06
iotcl_clone_sw_version():
    5848:	20 34       	cpi	r18, 0x40	; 64
    584a:	09 f0       	breq	.+2      	; 0x584e <on_ota(IotclEventDataTag*)+0x9a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:186
        cJSON *sw = cJSON_GetObjectItem(ver, "sw");
    584c:	7d c0       	rjmp	.+250    	; 0x5948 <on_ota(IotclEventDataTag*)+0x194>
    584e:	62 e8       	ldi	r22, 0x82	; 130
    5850:	72 e5       	ldi	r23, 0x52	; 82
    5852:	88 de       	rcall	.-752    	; 0x5564 <cJSON_GetObjectItem>
    5854:	ec 01       	movw	r28, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:187
        if (is_valid_string(sw)) {
    5856:	0e 94 0d 05 	call	0xa1a	; 0xa1a <is_valid_string>
    585a:	88 23       	and	r24, r24
    585c:	09 f4       	brne	.+2      	; 0x5860 <on_ota(IotclEventDataTag*)+0xac>
    585e:	74 c0       	rjmp	.+232    	; 0x5948 <on_ota(IotclEventDataTag*)+0x194>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:188
            return iotcl_strdup(sw->valuestring);
    5860:	88 85       	ldd	r24, Y+8	; 0x08
    5862:	99 85       	ldd	r25, Y+9	; 0x09
    5864:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <iotcl_strdup>
    5868:	8c 01       	movw	r16, r24
is_app_version_same_as_ota():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:59
        command_status(data, false, "?", "Internal error");
    }
}

static bool is_app_version_same_as_ota(const char *version) {
    return strcmp(APP_VERSION, version) == 0;
    586a:	b8 01       	movw	r22, r16
    586c:	85 e8       	ldi	r24, 0x85	; 133
    586e:	92 e5       	ldi	r25, 0x52	; 82
    5870:	0e 94 f4 56 	call	0xade8	; 0xade8 <strcmp>
on_ota():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:73
    char *url = iotcl_clone_download_url(data, 0);
    bool success = false;
    if (NULL != url) {
        printf("Download URL is: %s\n", url);
        const char *version = iotcl_clone_sw_version(data);
        if (is_app_version_same_as_ota(version)) {
    5874:	00 97       	sbiw	r24, 0x00	; 0
    5876:	09 f0       	breq	.+2      	; 0x587a <on_ota(IotclEventDataTag*)+0xc6>
    5878:	6a c0       	rjmp	.+212    	; 0x594e <on_ota(IotclEventDataTag*)+0x19a>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:74
            printf("OTA request for same version %s. Sending success\n", version);
    587a:	1f 93       	push	r17
    587c:	0f 93       	push	r16
    587e:	8e e8       	ldi	r24, 0x8E	; 142
    5880:	92 e5       	ldi	r25, 0x52	; 82
    5882:	9f 93       	push	r25
    5884:	8f 93       	push	r24
    5886:	0e 94 44 57 	call	0xae88	; 0xae88 <printf>
    588a:	0f 90       	pop	r0
    588c:	0f 90       	pop	r0
    588e:	0f 90       	pop	r0
    5890:	0f 90       	pop	r0
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:75
            success = true;
    5892:	ff 24       	eor	r15, r15
    5894:	f3 94       	inc	r15
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:76
            message = "Version is matching";
    5896:	c0 e0       	ldi	r28, 0x00	; 0
    5898:	d2 e5       	ldi	r29, 0x52	; 82
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:91
            // The user should decide here.
            success = false;
            message = "Device firmware version is newer";
        }

        free((void *) url);
    589a:	c5 01       	movw	r24, r10
    589c:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:92
        free((void *) version);
    58a0:	c8 01       	movw	r24, r16
    58a2:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:104
            printf("Command is: %s\n", command);
            message = "Old back end URLS are not supported by the app";
            free((void *) command);
        }
    }
    const char *ack = iotcl_create_ack_string_and_destroy_event(data, success, message);
    58a6:	ae 01       	movw	r20, r28
    58a8:	6f 2d       	mov	r22, r15
    58aa:	c6 01       	movw	r24, r12
    58ac:	0e 94 97 1e 	call	0x3d2e	; 0x3d2e <iotcl_create_ack_string_and_destroy_event>
    58b0:	ec 01       	movw	r28, r24
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:105
    if (NULL != ack) {
    58b2:	00 97       	sbiw	r24, 0x00	; 0
    58b4:	09 f4       	brne	.+2      	; 0x58b8 <on_ota(IotclEventDataTag*)+0x104>
    58b6:	75 c0       	rjmp	.+234    	; 0x59a2 <on_ota(IotclEventDataTag*)+0x1ee>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:106
        printf("Sent OTA ack: %s\n", ack);
    58b8:	df 93       	push	r29
    58ba:	8f 93       	push	r24
    58bc:	82 e4       	ldi	r24, 0x42	; 66
    58be:	93 e5       	ldi	r25, 0x53	; 83
    58c0:	9f 93       	push	r25
    58c2:	8f 93       	push	r24
    58c4:	0e 94 44 57 	call	0xae88	; 0xae88 <printf>
iotconnect_sdk_send_packet():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:222
    58c8:	ce 01       	movw	r24, r28
    58ca:	0f dc       	rcall	.-2018   	; 0x50ea <iotc_mqtt_client_send_message(char const*)>
on_ota():
    58cc:	0f 90       	pop	r0
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:108
        iotconnect_sdk_send_packet(ack);
        free((void *) ack);
    58ce:	0f 90       	pop	r0
    58d0:	0f 90       	pop	r0
    58d2:	0f 90       	pop	r0
    58d4:	ce 01       	movw	r24, r28
    58d6:	df 91       	pop	r29
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:110
    }
}
    58d8:	cf 91       	pop	r28
    58da:	1f 91       	pop	r17
    58dc:	0f 91       	pop	r16
    58de:	ff 90       	pop	r15
    58e0:	df 90       	pop	r13
    58e2:	cf 90       	pop	r12
    58e4:	bf 90       	pop	r11
    58e6:	af 90       	pop	r10
    58e8:	0c 94 54 55 	jmp	0xaaa8	; 0xaaa8 <free>
cJSON_GetArraySize():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:108
    }
    const char *ack = iotcl_create_ack_string_and_destroy_event(data, success, message);
    if (NULL != ack) {
        printf("Sent OTA ack: %s\n", ack);
        iotconnect_sdk_send_packet(ack);
        free((void *) ack);
    58ec:	01 96       	adiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1838

    child = array->child;

    while(child != NULL)
    {
        size++;
    58ee:	01 90       	ld	r0, Z+
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1839
        child = child->next;
    58f0:	f0 81       	ld	r31, Z
    58f2:	e0 2d       	mov	r30, r0
    58f4:	7d cf       	rjmp	.-262    	; 0x57f0 <on_ota(IotclEventDataTag*)+0x3c>
cJSON_IsObject():
    58f6:	20 97       	sbiw	r28, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2959
    return (item->type & 0xFF) == cJSON_Array;
}

CJSON_PUBLIC(cJSON_bool) cJSON_IsObject(const cJSON * const item)
{
    if (item == NULL)
    58f8:	61 f0       	breq	.+24     	; 0x5912 <on_ota(IotclEventDataTag*)+0x15e>
    58fa:	8e 81       	ldd	r24, Y+6	; 0x06
iotcl_clone_download_url():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2964
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Object;
    58fc:	80 34       	cpi	r24, 0x40	; 64
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:172
    }
    if ((size_t) cJSON_GetArraySize(urls) > index) {
        cJSON *url = cJSON_GetArrayItem(urls, index);
        if (is_valid_string(url)) {
            return iotcl_strdup(url->valuestring);
        } else if (cJSON_IsObject(url)) {
    58fe:	49 f4       	brne	.+18     	; 0x5912 <on_ota(IotclEventDataTag*)+0x15e>
    5900:	69 e6       	ldi	r22, 0x69	; 105
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:173
            cJSON *url_str = cJSON_GetObjectItem(url, "url");
    5902:	72 e5       	ldi	r23, 0x52	; 82
    5904:	ce 01       	movw	r24, r28
    5906:	2e de       	rcall	.-932    	; 0x5564 <cJSON_GetObjectItem>
    5908:	ec 01       	movw	r28, r24
    590a:	0e 94 0d 05 	call	0xa1a	; 0xa1a <is_valid_string>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:174
            if (is_valid_string(url_str)) {
    590e:	81 11       	cpse	r24, r1
    5910:	7b cf       	rjmp	.-266    	; 0x5808 <on_ota(IotclEventDataTag*)+0x54>
on_ota():
    5912:	c6 01       	movw	r24, r12
    5914:	0e 94 90 1f 	call	0x3f20	; 0x3f20 <iotcl_clone_command>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:96
        free((void *) url);
        free((void *) version);
    } else {
        // compatibility with older events
        // This app does not support FOTA with older back ends, but the user can add the functionality
        const char *command = iotcl_clone_command(data);
    5918:	ec 01       	movw	r28, r24
    591a:	f1 2c       	mov	r15, r1
    591c:	00 97       	sbiw	r24, 0x00	; 0
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:69
}

static void on_ota(IotclEventData data) {
    const char *message = NULL;
    char *url = iotcl_clone_download_url(data, 0);
    bool success = false;
    591e:	09 f4       	brne	.+2      	; 0x5922 <on_ota(IotclEventDataTag*)+0x16e>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:97
        free((void *) version);
    } else {
        // compatibility with older events
        // This app does not support FOTA with older back ends, but the user can add the functionality
        const char *command = iotcl_clone_command(data);
        if (NULL != command) {
    5920:	c2 cf       	rjmp	.-124    	; 0x58a6 <on_ota(IotclEventDataTag*)+0xf2>
    5922:	df 93       	push	r29
    5924:	8f 93       	push	r24
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:99
            // URL will be inside the command
            printf("Command is: %s\n", command);
    5926:	82 e3       	ldi	r24, 0x32	; 50
    5928:	93 e5       	ldi	r25, 0x53	; 83
    592a:	9f 93       	push	r25
    592c:	8f 93       	push	r24
    592e:	0e 94 44 57 	call	0xae88	; 0xae88 <printf>
    5932:	ce 01       	movw	r24, r28
    5934:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:101
            message = "Old back end URLS are not supported by the app";
            free((void *) command);
    5938:	0f 90       	pop	r0
    593a:	0f 90       	pop	r0
    593c:	0f 90       	pop	r0
    593e:	0f 90       	pop	r0
    5940:	f1 2c       	mov	r15, r1
    5942:	c5 e3       	ldi	r28, 0x35	; 53
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:69
}

static void on_ota(IotclEventData data) {
    const char *message = NULL;
    char *url = iotcl_clone_download_url(data, 0);
    bool success = false;
    5944:	d2 e5       	ldi	r29, 0x52	; 82
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:100
        // This app does not support FOTA with older back ends, but the user can add the functionality
        const char *command = iotcl_clone_command(data);
        if (NULL != command) {
            // URL will be inside the command
            printf("Command is: %s\n", command);
            message = "Old back end URLS are not supported by the app";
    5946:	af cf       	rjmp	.-162    	; 0x58a6 <on_ota(IotclEventDataTag*)+0xf2>
    5948:	00 e0       	ldi	r16, 0x00	; 0
    594a:	10 e0       	ldi	r17, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:191
        cJSON *sw = cJSON_GetObjectItem(ver, "sw");
        if (is_valid_string(sw)) {
            return iotcl_strdup(sw->valuestring);
        }
    }
    return NULL;
    594c:	8e cf       	rjmp	.-228    	; 0x586a <on_ota(IotclEventDataTag*)+0xb6>
app_needs_ota_update():
    594e:	f9 2e       	mov	r15, r25
    5950:	ff 1c       	adc	r15, r15
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:63
static bool is_app_version_same_as_ota(const char *version) {
    return strcmp(APP_VERSION, version) == 0;
}

static bool app_needs_ota_update(const char *version) {
    return strcmp(APP_VERSION, version) < 0;
    5952:	ff 24       	eor	r15, r15
    5954:	ff 1c       	adc	r15, r15
on_ota():
    5956:	81 f0       	breq	.+32     	; 0x5978 <on_ota(IotclEventDataTag*)+0x1c4>
    5958:	1f 93       	push	r17
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:77
        const char *version = iotcl_clone_sw_version(data);
        if (is_app_version_same_as_ota(version)) {
            printf("OTA request for same version %s. Sending success\n", version);
            success = true;
            message = "Version is matching";
        } else if (app_needs_ota_update(version)) {
    595a:	0f 93       	push	r16
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:78
            printf("OTA update is required for version %s.\n", version);
    595c:	80 ec       	ldi	r24, 0xC0	; 192
    595e:	92 e5       	ldi	r25, 0x52	; 82
    5960:	9f 93       	push	r25
    5962:	8f 93       	push	r24
    5964:	0e 94 44 57 	call	0xae88	; 0xae88 <printf>
    5968:	0f 90       	pop	r0
    596a:	0f 90       	pop	r0
    596c:	0f 90       	pop	r0
    596e:	0f 90       	pop	r0
    5970:	f1 2c       	mov	r15, r1
    5972:	ce ed       	ldi	r28, 0xDE	; 222
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:79
            success = false;
    5974:	d1 e5       	ldi	r29, 0x51	; 81
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:80
            message = "Not implemented";
    5976:	91 cf       	rjmp	.-222    	; 0x589a <on_ota(IotclEventDataTag*)+0xe6>
    5978:	1f 93       	push	r17
    597a:	0f 93       	push	r16
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:82
        } else {
            printf("Device firmware version %s is newer than OTA version %s. Sending failure\n", APP_VERSION,
    597c:	85 e8       	ldi	r24, 0x85	; 133
    597e:	92 e5       	ldi	r25, 0x52	; 82
    5980:	9f 93       	push	r25
    5982:	8f 93       	push	r24
    5984:	88 ee       	ldi	r24, 0xE8	; 232
    5986:	92 e5       	ldi	r25, 0x52	; 82
    5988:	9f 93       	push	r25
    598a:	8f 93       	push	r24
    598c:	0e 94 44 57 	call	0xae88	; 0xae88 <printf>
    5990:	0f 90       	pop	r0
    5992:	0f 90       	pop	r0
    5994:	0f 90       	pop	r0
    5996:	0f 90       	pop	r0
    5998:	0f 90       	pop	r0
    599a:	0f 90       	pop	r0
    599c:	c4 e1       	ldi	r28, 0x14	; 20
    599e:	d2 e5       	ldi	r29, 0x52	; 82
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:88
                   version);
            // Not sure what to do here. The app version is better than OTA version.
            // Probably a development version, so return failure?
            // The user should decide here.
            success = false;
            message = "Device firmware version is newer";
    59a0:	7c cf       	rjmp	.-264    	; 0x589a <on_ota(IotclEventDataTag*)+0xe6>
    59a2:	df 91       	pop	r29
    59a4:	cf 91       	pop	r28
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:110
    if (NULL != ack) {
        printf("Sent OTA ack: %s\n", ack);
        iotconnect_sdk_send_packet(ack);
        free((void *) ack);
    }
}
    59a6:	1f 91       	pop	r17
    59a8:	0f 91       	pop	r16
    59aa:	ff 90       	pop	r15
    59ac:	df 90       	pop	r13
    59ae:	cf 90       	pop	r12
    59b0:	bf 90       	pop	r11
    59b2:	af 90       	pop	r10
    59b4:	08 95       	ret

000059b6 <parse_value>:
parse_value():
    59b6:	4f 92       	push	r4
    59b8:	5f 92       	push	r5
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1309
    return print_value(item, &p);
}

/* Parser core - when encountering text, process appropriately. */
static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
{
    59ba:	6f 92       	push	r6
    59bc:	7f 92       	push	r7
    59be:	8f 92       	push	r8
    59c0:	9f 92       	push	r9
    59c2:	af 92       	push	r10
    59c4:	bf 92       	push	r11
    59c6:	cf 92       	push	r12
    59c8:	df 92       	push	r13
    59ca:	ef 92       	push	r14
    59cc:	ff 92       	push	r15
    59ce:	0f 93       	push	r16
    59d0:	1f 93       	push	r17
    59d2:	cf 93       	push	r28
    59d4:	df 93       	push	r29
    59d6:	cd b7       	in	r28, 0x3d	; 61
    59d8:	de b7       	in	r29, 0x3e	; 62
    59da:	c2 54       	subi	r28, 0x42	; 66
    59dc:	d1 09       	sbc	r29, r1
    59de:	cd bf       	out	0x3d, r28	; 61
    59e0:	de bf       	out	0x3e, r29	; 62
    59e2:	61 15       	cp	r22, r1
    59e4:	71 05       	cpc	r23, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1310
    if ((input_buffer == NULL) || (input_buffer->content == NULL))
    59e6:	19 f4       	brne	.+6      	; 0x59ee <parse_value+0x38>
    59e8:	90 e0       	ldi	r25, 0x00	; 0
    59ea:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1706
    if (head != NULL)
    {
        cJSON_Delete(head);
    }

    return false;
    59ec:	4a c0       	rjmp	.+148    	; 0x5a82 <parse_value+0xcc>
    59ee:	db 01       	movw	r26, r22
    59f0:	ad 90       	ld	r10, X+
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1310
}

/* Parser core - when encountering text, process appropriately. */
static cJSON_bool parse_value(cJSON * const item, parse_buffer * const input_buffer)
{
    if ((input_buffer == NULL) || (input_buffer->content == NULL))
    59f2:	bc 90       	ld	r11, X
    59f4:	11 97       	sbiw	r26, 0x01	; 1
    59f6:	a1 14       	cp	r10, r1
    59f8:	b1 04       	cpc	r11, r1
    59fa:	b1 f3       	breq	.-20     	; 0x59e8 <parse_value+0x32>
    59fc:	8b 01       	movw	r16, r22
    59fe:	7c 01       	movw	r14, r24
    5a00:	fb 01       	movw	r30, r22
    5a02:	c4 80       	ldd	r12, Z+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1317
        return false; /* no input */
    }

    /* parse the different types of values */
    /* null */
    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "null", 4) == 0))
    5a04:	d5 80       	ldd	r13, Z+5	; 0x05
    5a06:	26 01       	movw	r4, r12
    5a08:	f4 e0       	ldi	r31, 0x04	; 4
    5a0a:	4f 0e       	add	r4, r31
    5a0c:	51 1c       	adc	r5, r1
    5a0e:	12 96       	adiw	r26, 0x02	; 2
    5a10:	6d 90       	ld	r6, X+
    5a12:	7c 90       	ld	r7, X
    5a14:	64 14       	cp	r6, r4
    5a16:	75 04       	cpc	r7, r5
    5a18:	c0 f0       	brcs	.+48     	; 0x5a4a <parse_value+0x94>
    5a1a:	44 e0       	ldi	r20, 0x04	; 4
    5a1c:	50 e0       	ldi	r21, 0x00	; 0
    5a1e:	6c e1       	ldi	r22, 0x1C	; 28
    5a20:	77 e4       	ldi	r23, 0x47	; 71
    5a22:	c5 01       	movw	r24, r10
    5a24:	8c 0d       	add	r24, r12
    5a26:	9d 1d       	adc	r25, r13
    5a28:	0e 94 0d 57 	call	0xae1a	; 0xae1a <strncmp>
    5a2c:	89 2b       	or	r24, r25
    5a2e:	69 f4       	brne	.+26     	; 0x5a4a <parse_value+0x94>
    5a30:	84 e0       	ldi	r24, 0x04	; 4
    5a32:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1319
    {
        item->type = cJSON_NULL;
    5a34:	f7 01       	movw	r30, r14
    5a36:	86 83       	std	Z+6, r24	; 0x06
    5a38:	97 83       	std	Z+7, r25	; 0x07
    5a3a:	d8 01       	movw	r26, r16
    5a3c:	14 96       	adiw	r26, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1320
        input_buffer->offset += 4;
    5a3e:	4d 92       	st	X+, r4
    5a40:	5c 92       	st	X, r5
    5a42:	15 97       	sbiw	r26, 0x05	; 5
    5a44:	81 e0       	ldi	r24, 0x01	; 1
    5a46:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1698

    item->type = cJSON_Object;
    item->child = head;

    input_buffer->offset++;
    return true;
    5a48:	1c c0       	rjmp	.+56     	; 0x5a82 <parse_value+0xcc>
    5a4a:	46 01       	movw	r8, r12
    5a4c:	b5 e0       	ldi	r27, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1324
        item->type = cJSON_NULL;
        input_buffer->offset += 4;
        return true;
    }
    /* false */
    if (can_read(input_buffer, 5) && (strncmp((const char*)buffer_at_offset(input_buffer), "false", 5) == 0))
    5a4e:	8b 0e       	add	r8, r27
    5a50:	91 1c       	adc	r9, r1
    5a52:	68 14       	cp	r6, r8
    5a54:	79 04       	cpc	r7, r9
    5a56:	50 f1       	brcs	.+84     	; 0x5aac <parse_value+0xf6>
    5a58:	45 e0       	ldi	r20, 0x05	; 5
    5a5a:	50 e0       	ldi	r21, 0x00	; 0
    5a5c:	61 e2       	ldi	r22, 0x21	; 33
    5a5e:	77 e4       	ldi	r23, 0x47	; 71
    5a60:	c5 01       	movw	r24, r10
    5a62:	8c 0d       	add	r24, r12
    5a64:	9d 1d       	adc	r25, r13
    5a66:	0e 94 0d 57 	call	0xae1a	; 0xae1a <strncmp>
    5a6a:	89 2b       	or	r24, r25
    5a6c:	f9 f4       	brne	.+62     	; 0x5aac <parse_value+0xf6>
    5a6e:	81 e0       	ldi	r24, 0x01	; 1
    5a70:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1326
    {
        item->type = cJSON_False;
    5a72:	f7 01       	movw	r30, r14
    5a74:	86 83       	std	Z+6, r24	; 0x06
    5a76:	97 83       	std	Z+7, r25	; 0x07
    5a78:	d8 01       	movw	r26, r16
    5a7a:	14 96       	adiw	r26, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1327
        input_buffer->offset += 5;
    5a7c:	8d 92       	st	X+, r8
    5a7e:	9c 92       	st	X, r9
    5a80:	15 97       	sbiw	r26, 0x05	; 5
    5a82:	ce 5b       	subi	r28, 0xBE	; 190
    5a84:	df 4f       	sbci	r29, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1360
    {
        return parse_object(item, input_buffer);
    }

    return false;
}
    5a86:	cd bf       	out	0x3d, r28	; 61
    5a88:	de bf       	out	0x3e, r29	; 62
    5a8a:	df 91       	pop	r29
    5a8c:	cf 91       	pop	r28
    5a8e:	1f 91       	pop	r17
    5a90:	0f 91       	pop	r16
    5a92:	ff 90       	pop	r15
    5a94:	ef 90       	pop	r14
    5a96:	df 90       	pop	r13
    5a98:	cf 90       	pop	r12
    5a9a:	bf 90       	pop	r11
    5a9c:	af 90       	pop	r10
    5a9e:	9f 90       	pop	r9
    5aa0:	8f 90       	pop	r8
    5aa2:	7f 90       	pop	r7
    5aa4:	6f 90       	pop	r6
    5aa6:	5f 90       	pop	r5
    5aa8:	4f 90       	pop	r4
    5aaa:	08 95       	ret
    5aac:	64 14       	cp	r6, r4
    5aae:	75 04       	cpc	r7, r5
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1331
        item->type = cJSON_False;
        input_buffer->offset += 5;
        return true;
    }
    /* true */
    if (can_read(input_buffer, 4) && (strncmp((const char*)buffer_at_offset(input_buffer), "true", 4) == 0))
    5ab0:	d0 f0       	brcs	.+52     	; 0x5ae6 <parse_value+0x130>
    5ab2:	44 e0       	ldi	r20, 0x04	; 4
    5ab4:	50 e0       	ldi	r21, 0x00	; 0
    5ab6:	67 e2       	ldi	r22, 0x27	; 39
    5ab8:	77 e4       	ldi	r23, 0x47	; 71
    5aba:	c5 01       	movw	r24, r10
    5abc:	8c 0d       	add	r24, r12
    5abe:	9d 1d       	adc	r25, r13
    5ac0:	0e 94 0d 57 	call	0xae1a	; 0xae1a <strncmp>
    5ac4:	89 2b       	or	r24, r25
    5ac6:	79 f4       	brne	.+30     	; 0x5ae6 <parse_value+0x130>
    5ac8:	82 e0       	ldi	r24, 0x02	; 2
    5aca:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1333
    {
        item->type = cJSON_True;
    5acc:	f7 01       	movw	r30, r14
    5ace:	86 83       	std	Z+6, r24	; 0x06
    5ad0:	97 83       	std	Z+7, r25	; 0x07
    5ad2:	81 e0       	ldi	r24, 0x01	; 1
    5ad4:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1334
        item->valueint = 1;
    5ad6:	82 87       	std	Z+10, r24	; 0x0a
    5ad8:	93 87       	std	Z+11, r25	; 0x0b
    5ada:	d8 01       	movw	r26, r16
    5adc:	14 96       	adiw	r26, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1335
        input_buffer->offset += 4;
    5ade:	4d 92       	st	X+, r4
    5ae0:	5c 92       	st	X, r5
    5ae2:	15 97       	sbiw	r26, 0x05	; 5
    5ae4:	ce cf       	rjmp	.-100    	; 0x5a82 <parse_value+0xcc>
    5ae6:	c6 14       	cp	r12, r6
    5ae8:	d7 04       	cpc	r13, r7
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1339
        return true;
    }
    /* string */
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '\"'))
    5aea:	08 f0       	brcs	.+2      	; 0x5aee <parse_value+0x138>
    5aec:	7d cf       	rjmp	.-262    	; 0x59e8 <parse_value+0x32>
    5aee:	f5 01       	movw	r30, r10
    5af0:	ec 0d       	add	r30, r12
    5af2:	fd 1d       	adc	r31, r13
    5af4:	80 81       	ld	r24, Z
    5af6:	82 32       	cpi	r24, 0x22	; 34
    5af8:	29 f4       	brne	.+10     	; 0x5b04 <parse_value+0x14e>
    5afa:	b8 01       	movw	r22, r16
    5afc:	c7 01       	movw	r24, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1341
    {
        return parse_string(item, input_buffer);
    5afe:	0e 94 a2 05 	call	0xb44	; 0xb44 <parse_string>
    5b02:	bf cf       	rjmp	.-130    	; 0x5a82 <parse_value+0xcc>
    5b04:	8d 32       	cpi	r24, 0x2D	; 45
    5b06:	29 f0       	breq	.+10     	; 0x5b12 <parse_value+0x15c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1344
    }
    /* number */
    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
    5b08:	90 ed       	ldi	r25, 0xD0	; 208
    5b0a:	98 0f       	add	r25, r24
    5b0c:	9a 30       	cpi	r25, 0x0A	; 10
    5b0e:	08 f0       	brcs	.+2      	; 0x5b12 <parse_value+0x15c>
    5b10:	7c c0       	rjmp	.+248    	; 0x5c0a <parse_value+0x254>
parse_number():
    5b12:	23 96       	adiw	r28, 0x03	; 3
    5b14:	1e ae       	std	Y+62, r1	; 0x3e
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:308

/* Parse the input text to generate a number, and populate the result into item. */
static cJSON_bool parse_number(cJSON * const item, parse_buffer * const input_buffer)
{
    double number = 0;
    unsigned char *after_end = NULL;
    5b16:	1f ae       	std	Y+63, r1	; 0x3f
    5b18:	23 97       	sbiw	r28, 0x03	; 3
    5b1a:	6c 18       	sub	r6, r12
    5b1c:	7d 08       	sbc	r7, r13
parse_value():
    5b1e:	90 e0       	ldi	r25, 0x00	; 0
    5b20:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:321
    }

    /* copy the number into a temporary buffer and replace '.' with the decimal point
     * of the current locale (for strtod)
     * This also takes care of '\0' not necessarily being available for marking the end of the input */
    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
    5b22:	9e 01       	movw	r18, r28
    5b24:	2f 5f       	subi	r18, 0xFF	; 255
    5b26:	3f 4f       	sbci	r19, 0xFF	; 255
    5b28:	69 01       	movw	r12, r18
parse_number():
    5b2a:	21 91       	ld	r18, Z+
    5b2c:	2a 33       	cpi	r18, 0x3A	; 58
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:323
    {
        switch (buffer_at_offset(input_buffer)[i])
    5b2e:	a0 f4       	brcc	.+40     	; 0x5b58 <parse_value+0x1a2>
    5b30:	20 33       	cpi	r18, 0x30	; 48
    5b32:	30 f4       	brcc	.+12     	; 0x5b40 <parse_value+0x18a>
    5b34:	2d 32       	cpi	r18, 0x2D	; 45
    5b36:	21 f0       	breq	.+8      	; 0x5b40 <parse_value+0x18a>
    5b38:	2e 32       	cpi	r18, 0x2E	; 46
    5b3a:	11 f0       	breq	.+4      	; 0x5b40 <parse_value+0x18a>
    5b3c:	2b 32       	cpi	r18, 0x2B	; 43
    5b3e:	81 f4       	brne	.+32     	; 0x5b60 <parse_value+0x1aa>
    5b40:	d6 01       	movw	r26, r12
    5b42:	a8 0f       	add	r26, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:343
            case 'E':
                number_c_string[i] = buffer_at_offset(input_buffer)[i];
                break;

            case '.':
                number_c_string[i] = decimal_point;
    5b44:	b9 1f       	adc	r27, r25
    5b46:	2c 93       	st	X, r18
    5b48:	01 96       	adiw	r24, 0x01	; 1
    5b4a:	8f 33       	cpi	r24, 0x3F	; 63
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:321
    }

    /* copy the number into a temporary buffer and replace '.' with the decimal point
     * of the current locale (for strtod)
     * This also takes care of '\0' not necessarily being available for marking the end of the input */
    for (i = 0; (i < (sizeof(number_c_string) - 1)) && can_access_at_index(input_buffer, i); i++)
    5b4c:	91 05       	cpc	r25, r1
    5b4e:	41 f0       	breq	.+16     	; 0x5b60 <parse_value+0x1aa>
    5b50:	86 15       	cp	r24, r6
    5b52:	97 05       	cpc	r25, r7
    5b54:	51 f7       	brne	.-44     	; 0x5b2a <parse_value+0x174>
    5b56:	04 c0       	rjmp	.+8      	; 0x5b60 <parse_value+0x1aa>
    5b58:	25 34       	cpi	r18, 0x45	; 69
    5b5a:	91 f3       	breq	.-28     	; 0x5b40 <parse_value+0x18a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:323
    {
        switch (buffer_at_offset(input_buffer)[i])
    5b5c:	25 36       	cpi	r18, 0x65	; 101
    5b5e:	81 f3       	breq	.-32     	; 0x5b40 <parse_value+0x18a>
    5b60:	8c 0d       	add	r24, r12
    5b62:	9d 1d       	adc	r25, r13
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:351
            default:
                goto loop_end;
        }
    }
loop_end:
    number_c_string[i] = '\0';
    5b64:	dc 01       	movw	r26, r24
    5b66:	1c 92       	st	X, r1
    5b68:	be 01       	movw	r22, r28
    5b6a:	6f 5b       	subi	r22, 0xBF	; 191
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:353

    number = strtod((const char*)number_c_string, (char**)&after_end);
    5b6c:	7f 4f       	sbci	r23, 0xFF	; 255
    5b6e:	c6 01       	movw	r24, r12
    5b70:	0e 94 bc 4c 	call	0x9978	; 0x9978 <strtod>
    5b74:	2b 01       	movw	r4, r22
    5b76:	3c 01       	movw	r6, r24
    5b78:	23 96       	adiw	r28, 0x03	; 3
    5b7a:	ae ac       	ldd	r10, Y+62	; 0x3e
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:354
    if (number_c_string == after_end)
    5b7c:	bf ac       	ldd	r11, Y+63	; 0x3f
    5b7e:	23 97       	sbiw	r28, 0x03	; 3
    5b80:	ca 14       	cp	r12, r10
    5b82:	db 04       	cpc	r13, r11
    5b84:	09 f4       	brne	.+2      	; 0x5b88 <parse_value+0x1d2>
    5b86:	30 cf       	rjmp	.-416    	; 0x59e8 <parse_value+0x32>
    5b88:	f7 01       	movw	r30, r14
    5b8a:	44 86       	std	Z+12, r4	; 0x0c
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:359
    {
        return false; /* parse_error */
    }

    item->valuedouble = number;
    5b8c:	55 86       	std	Z+13, r5	; 0x0d
    5b8e:	66 86       	std	Z+14, r6	; 0x0e
    5b90:	77 86       	std	Z+15, r7	; 0x0f
    5b92:	20 e0       	ldi	r18, 0x00	; 0
    5b94:	3e ef       	ldi	r19, 0xFE	; 254
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:362

    /* use saturation in case of overflow */
    if (number >= INT_MAX)
    5b96:	4f ef       	ldi	r20, 0xFF	; 255
    5b98:	56 e4       	ldi	r21, 0x46	; 70
    5b9a:	0e 94 da 53 	call	0xa7b4	; 0xa7b4 <__gesf2>
    5b9e:	87 fd       	sbrc	r24, 7
    5ba0:	1a c0       	rjmp	.+52     	; 0x5bd6 <parse_value+0x220>
    5ba2:	8f ef       	ldi	r24, 0xFF	; 255
    5ba4:	9f e7       	ldi	r25, 0x7F	; 127
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:364
    {
        item->valueint = INT_MAX;
    5ba6:	d7 01       	movw	r26, r14
    5ba8:	1a 96       	adiw	r26, 0x0a	; 10
    5baa:	8d 93       	st	X+, r24
    5bac:	9c 93       	st	X, r25
    5bae:	1b 97       	sbiw	r26, 0x0b	; 11
    5bb0:	88 e0       	ldi	r24, 0x08	; 8
    5bb2:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:375
    else
    {
        item->valueint = (int)number;
    }

    item->type = cJSON_Number;
    5bb4:	f7 01       	movw	r30, r14
    5bb6:	86 83       	std	Z+6, r24	; 0x06
    5bb8:	97 83       	std	Z+7, r25	; 0x07
    5bba:	ac 18       	sub	r10, r12
    5bbc:	bd 08       	sbc	r11, r13
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:377

    input_buffer->offset += (size_t)(after_end - number_c_string);
    5bbe:	d8 01       	movw	r26, r16
    5bc0:	14 96       	adiw	r26, 0x04	; 4
    5bc2:	8d 91       	ld	r24, X+
    5bc4:	9c 91       	ld	r25, X
    5bc6:	15 97       	sbiw	r26, 0x05	; 5
    5bc8:	a8 0e       	add	r10, r24
    5bca:	b9 1e       	adc	r11, r25
    5bcc:	14 96       	adiw	r26, 0x04	; 4
    5bce:	ad 92       	st	X+, r10
    5bd0:	bc 92       	st	X, r11
    5bd2:	15 97       	sbiw	r26, 0x05	; 5
    5bd4:	37 cf       	rjmp	.-402    	; 0x5a44 <parse_value+0x8e>
    5bd6:	20 e0       	ldi	r18, 0x00	; 0
    5bd8:	30 e0       	ldi	r19, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:366
    /* use saturation in case of overflow */
    if (number >= INT_MAX)
    {
        item->valueint = INT_MAX;
    }
    else if (number <= (double)INT_MIN)
    5bda:	40 e0       	ldi	r20, 0x00	; 0
    5bdc:	57 ec       	ldi	r21, 0xC7	; 199
    5bde:	c3 01       	movw	r24, r6
    5be0:	b2 01       	movw	r22, r4
    5be2:	0e 94 27 51 	call	0xa24e	; 0xa24e <__cmpsf2>
    5be6:	18 16       	cp	r1, r24
    5be8:	34 f0       	brlt	.+12     	; 0x5bf6 <parse_value+0x240>
    5bea:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:368
    {
        item->valueint = INT_MIN;
    5bec:	90 e8       	ldi	r25, 0x80	; 128
    5bee:	f7 01       	movw	r30, r14
    5bf0:	82 87       	std	Z+10, r24	; 0x0a
    5bf2:	93 87       	std	Z+11, r25	; 0x0b
    5bf4:	dd cf       	rjmp	.-70     	; 0x5bb0 <parse_value+0x1fa>
    5bf6:	c3 01       	movw	r24, r6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:372
    }
    else
    {
        item->valueint = (int)number;
    5bf8:	b2 01       	movw	r22, r4
    5bfa:	0e 94 a9 53 	call	0xa752	; 0xa752 <__fixsfsi>
    5bfe:	d7 01       	movw	r26, r14
    5c00:	1a 96       	adiw	r26, 0x0a	; 10
    5c02:	6d 93       	st	X+, r22
    5c04:	7c 93       	st	X, r23
    5c06:	1b 97       	sbiw	r26, 0x0b	; 11
    5c08:	d3 cf       	rjmp	.-90     	; 0x5bb0 <parse_value+0x1fa>
parse_value():
    5c0a:	8b 35       	cpi	r24, 0x5B	; 91
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1349
    if (can_access_at_index(input_buffer, 0) && ((buffer_at_offset(input_buffer)[0] == '-') || ((buffer_at_offset(input_buffer)[0] >= '0') && (buffer_at_offset(input_buffer)[0] <= '9'))))
    {
        return parse_number(item, input_buffer);
    }
    /* array */
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
    5c0c:	09 f0       	breq	.+2      	; 0x5c10 <parse_value+0x25a>
    5c0e:	b0 c0       	rjmp	.+352    	; 0x5d70 <parse_value+0x3ba>
parse_array():
    5c10:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1442
static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* head of the linked list */
    cJSON *current_item = NULL;

    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
    5c12:	16 96       	adiw	r26, 0x06	; 6
    5c14:	8d 91       	ld	r24, X+
    5c16:	9c 91       	ld	r25, X
    5c18:	88 3e       	cpi	r24, 0xE8	; 232
    5c1a:	b3 e0       	ldi	r27, 0x03	; 3
    5c1c:	9b 07       	cpc	r25, r27
    5c1e:	08 f0       	brcs	.+2      	; 0x5c22 <parse_value+0x26c>
    5c20:	e3 ce       	rjmp	.-570    	; 0x59e8 <parse_value+0x32>
    5c22:	01 96       	adiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1446
    {
        return false; /* to deeply nested */
    }
    input_buffer->depth++;
    5c24:	d8 01       	movw	r26, r16
    5c26:	16 96       	adiw	r26, 0x06	; 6
    5c28:	8d 93       	st	X+, r24
    5c2a:	9c 93       	st	X, r25
    5c2c:	17 97       	sbiw	r26, 0x07	; 7
    5c2e:	80 81       	ld	r24, Z
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1448

    if (buffer_at_offset(input_buffer)[0] != '[')
    5c30:	8b 35       	cpi	r24, 0x5B	; 91
    5c32:	09 f0       	breq	.+2      	; 0x5c36 <parse_value+0x280>
    5c34:	d9 ce       	rjmp	.-590    	; 0x59e8 <parse_value+0x32>
    5c36:	bf ef       	ldi	r27, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1454
    {
        /* not an array */
        goto fail;
    }

    input_buffer->offset++;
    5c38:	cb 1a       	sub	r12, r27
    5c3a:	db 0a       	sbc	r13, r27
    5c3c:	f8 01       	movw	r30, r16
    5c3e:	c4 82       	std	Z+4, r12	; 0x04
    5c40:	d5 82       	std	Z+5, r13	; 0x05
    5c42:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1455
    buffer_skip_whitespace(input_buffer);
    5c44:	0e 94 4c 05 	call	0xa98	; 0xa98 <buffer_skip_whitespace>
    5c48:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1456
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ']'))
    5c4a:	14 96       	adiw	r26, 0x04	; 4
    5c4c:	8d 91       	ld	r24, X+
    5c4e:	9c 91       	ld	r25, X
    5c50:	15 97       	sbiw	r26, 0x05	; 5
    5c52:	12 96       	adiw	r26, 0x02	; 2
    5c54:	4d 91       	ld	r20, X+
    5c56:	5c 91       	ld	r21, X
    5c58:	13 97       	sbiw	r26, 0x03	; 3
    5c5a:	84 17       	cp	r24, r20
    5c5c:	95 07       	cpc	r25, r21
    5c5e:	40 f4       	brcc	.+16     	; 0x5c70 <parse_value+0x2ba>
    5c60:	ed 91       	ld	r30, X+
    5c62:	fc 91       	ld	r31, X
    5c64:	e8 0f       	add	r30, r24
    5c66:	f9 1f       	adc	r31, r25
    5c68:	20 81       	ld	r18, Z
    5c6a:	2d 35       	cpi	r18, 0x5D	; 93
    5c6c:	09 f4       	brne	.+2      	; 0x5c70 <parse_value+0x2ba>
    5c6e:	73 c0       	rjmp	.+230    	; 0x5d56 <parse_value+0x3a0>
    5c70:	9c 01       	movw	r18, r24
    5c72:	21 50       	subi	r18, 0x01	; 1
    5c74:	31 09       	sbc	r19, r1
    5c76:	84 17       	cp	r24, r20
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1463
        /* empty array */
        goto success;
    }

    /* check if we skipped to the end of the buffer */
    if (cannot_access_at_index(input_buffer, 0))
    5c78:	95 07       	cpc	r25, r21
    5c7a:	20 f0       	brcs	.+8      	; 0x5c84 <parse_value+0x2ce>
    5c7c:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1465
    {
        input_buffer->offset--;
    5c7e:	24 83       	std	Z+4, r18	; 0x04
    5c80:	35 83       	std	Z+5, r19	; 0x05
    5c82:	b2 ce       	rjmp	.-668    	; 0x59e8 <parse_value+0x32>
    5c84:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1470
        goto fail;
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
    5c86:	14 96       	adiw	r26, 0x04	; 4
    5c88:	2d 93       	st	X+, r18
    5c8a:	3c 93       	st	X, r19
    5c8c:	15 97       	sbiw	r26, 0x05	; 5
parse_value():
    5c8e:	91 2c       	mov	r9, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1440

/* Build an array from input text. */
static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* head of the linked list */
    cJSON *current_item = NULL;
    5c90:	81 2c       	mov	r8, r1
    5c92:	d1 2c       	mov	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1439
}

/* Build an array from input text. */
static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* head of the linked list */
    5c94:	c1 2c       	mov	r12, r1
parse_array():
    5c96:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1475
    input_buffer->offset--;
    /* loop through the comma separated array elements */
    do
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
    5c98:	80 85       	ldd	r24, Z+8	; 0x08
    5c9a:	91 85       	ldd	r25, Z+9	; 0x09
    5c9c:	0e 94 af 10 	call	0x215e	; 0x215e <cJSON_New_Item.isra.5>
    5ca0:	5c 01       	movw	r10, r24
    5ca2:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1476
        if (new_item == NULL)
    5ca4:	09 f4       	brne	.+2      	; 0x5ca8 <parse_value+0x2f2>
    5ca6:	5c c0       	rjmp	.+184    	; 0x5d60 <parse_value+0x3aa>
    5ca8:	c1 14       	cp	r12, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1482
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
    5caa:	d1 04       	cpc	r13, r1
    5cac:	09 f4       	brne	.+2      	; 0x5cb0 <parse_value+0x2fa>
    5cae:	51 c0       	rjmp	.+162    	; 0x5d52 <parse_value+0x39c>
    5cb0:	d4 01       	movw	r26, r8
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1490
            current_item = head = new_item;
        }
        else
        {
            /* add to the end and advance */
            current_item->next = new_item;
    5cb2:	8d 93       	st	X+, r24
    5cb4:	9c 93       	st	X, r25
    5cb6:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1491
            new_item->prev = current_item;
    5cb8:	82 82       	std	Z+2, r8	; 0x02
    5cba:	93 82       	std	Z+3, r9	; 0x03
    5cbc:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1496
            current_item = new_item;
        }

        /* parse next value */
        input_buffer->offset++;
    5cbe:	14 96       	adiw	r26, 0x04	; 4
    5cc0:	8d 91       	ld	r24, X+
    5cc2:	9c 91       	ld	r25, X
    5cc4:	15 97       	sbiw	r26, 0x05	; 5
    5cc6:	01 96       	adiw	r24, 0x01	; 1
    5cc8:	14 96       	adiw	r26, 0x04	; 4
    5cca:	8d 93       	st	X+, r24
    5ccc:	9c 93       	st	X, r25
    5cce:	15 97       	sbiw	r26, 0x05	; 5
    5cd0:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1497
        buffer_skip_whitespace(input_buffer);
    5cd2:	0e 94 4c 05 	call	0xa98	; 0xa98 <buffer_skip_whitespace>
    5cd6:	b8 01       	movw	r22, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1498
        if (!parse_value(current_item, input_buffer))
    5cd8:	c5 01       	movw	r24, r10
    5cda:	6d de       	rcall	.-806    	; 0x59b6 <parse_value>
    5cdc:	89 2b       	or	r24, r25
    5cde:	09 f4       	brne	.+2      	; 0x5ce2 <parse_value+0x32c>
    5ce0:	43 c0       	rjmp	.+134    	; 0x5d68 <parse_value+0x3b2>
    5ce2:	c8 01       	movw	r24, r16
    5ce4:	0e 94 4c 05 	call	0xa98	; 0xa98 <buffer_skip_whitespace>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1502
        {
            goto fail; /* failed to parse value */
        }
        buffer_skip_whitespace(input_buffer);
    5ce8:	f8 01       	movw	r30, r16
    5cea:	84 81       	ldd	r24, Z+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1504
    }
    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
    5cec:	95 81       	ldd	r25, Z+5	; 0x05
    5cee:	22 81       	ldd	r18, Z+2	; 0x02
    5cf0:	33 81       	ldd	r19, Z+3	; 0x03
    5cf2:	82 17       	cp	r24, r18
    5cf4:	93 07       	cpc	r25, r19
    5cf6:	c0 f5       	brcc	.+112    	; 0x5d68 <parse_value+0x3b2>
    5cf8:	01 90       	ld	r0, Z+
    5cfa:	f0 81       	ld	r31, Z
    5cfc:	e0 2d       	mov	r30, r0
    5cfe:	e8 0f       	add	r30, r24
    5d00:	f9 1f       	adc	r31, r25
    5d02:	80 81       	ld	r24, Z
    5d04:	45 01       	movw	r8, r10
    5d06:	8c 32       	cpi	r24, 0x2C	; 44
    5d08:	31 f2       	breq	.-116    	; 0x5c96 <parse_value+0x2e0>
    5d0a:	8d 35       	cpi	r24, 0x5D	; 93
    5d0c:	69 f5       	brne	.+90     	; 0x5d68 <parse_value+0x3b2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1506

    if (cannot_access_at_index(input_buffer, 0) || buffer_at_offset(input_buffer)[0] != ']')
    5d0e:	d8 01       	movw	r26, r16
    5d10:	16 96       	adiw	r26, 0x06	; 6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1512
    {
        goto fail; /* expected end of array */
    }

success:
    input_buffer->depth--;
    5d12:	8d 91       	ld	r24, X+
    5d14:	9c 91       	ld	r25, X
    5d16:	17 97       	sbiw	r26, 0x07	; 7
    5d18:	01 97       	sbiw	r24, 0x01	; 1
    5d1a:	16 96       	adiw	r26, 0x06	; 6
    5d1c:	8d 93       	st	X+, r24
    5d1e:	9c 93       	st	X, r25
    5d20:	17 97       	sbiw	r26, 0x07	; 7
    5d22:	c1 14       	cp	r12, r1
    5d24:	d1 04       	cpc	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1514

    if (head != NULL) {
    5d26:	19 f0       	breq	.+6      	; 0x5d2e <parse_value+0x378>
    5d28:	f6 01       	movw	r30, r12
    5d2a:	a2 82       	std	Z+2, r10	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1515
        head->prev = current_item;
    5d2c:	b3 82       	std	Z+3, r11	; 0x03
    5d2e:	80 e2       	ldi	r24, 0x20	; 32
    5d30:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1518
    }

    item->type = cJSON_Array;
    5d32:	d7 01       	movw	r26, r14
    5d34:	16 96       	adiw	r26, 0x06	; 6
    5d36:	8d 93       	st	X+, r24
    5d38:	9c 93       	st	X, r25
    5d3a:	17 97       	sbiw	r26, 0x07	; 7
    5d3c:	14 96       	adiw	r26, 0x04	; 4
    5d3e:	cd 92       	st	X+, r12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1519
    item->child = head;
    5d40:	dc 92       	st	X, r13
    5d42:	15 97       	sbiw	r26, 0x05	; 5
parse_object():
    5d44:	f8 01       	movw	r30, r16
    5d46:	84 81       	ldd	r24, Z+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1697
    }

    item->type = cJSON_Object;
    item->child = head;

    input_buffer->offset++;
    5d48:	95 81       	ldd	r25, Z+5	; 0x05
    5d4a:	01 96       	adiw	r24, 0x01	; 1
    5d4c:	84 83       	std	Z+4, r24	; 0x04
    5d4e:	95 83       	std	Z+5, r25	; 0x05
    5d50:	79 ce       	rjmp	.-782    	; 0x5a44 <parse_value+0x8e>
parse_array():
    5d52:	6c 01       	movw	r12, r24
    5d54:	b3 cf       	rjmp	.-154    	; 0x5cbc <parse_value+0x306>
parse_value():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1482
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
    5d56:	b1 2c       	mov	r11, r1
    5d58:	a1 2c       	mov	r10, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1440

/* Build an array from input text. */
static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* head of the linked list */
    cJSON *current_item = NULL;
    5d5a:	d1 2c       	mov	r13, r1
    5d5c:	c1 2c       	mov	r12, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1439
}

/* Build an array from input text. */
static cJSON_bool parse_array(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* head of the linked list */
    5d5e:	d7 cf       	rjmp	.-82     	; 0x5d0e <parse_value+0x358>
parse_array():
    5d60:	c1 14       	cp	r12, r1
    5d62:	d1 04       	cpc	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1526
    input_buffer->offset++;

    return true;

fail:
    if (head != NULL)
    5d64:	09 f4       	brne	.+2      	; 0x5d68 <parse_value+0x3b2>
    5d66:	40 ce       	rjmp	.-896    	; 0x59e8 <parse_value+0x32>
    5d68:	c6 01       	movw	r24, r12
parse_object():
    5d6a:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1703
    return true;

fail:
    if (head != NULL)
    {
        cJSON_Delete(head);
    5d6e:	3c ce       	rjmp	.-904    	; 0x59e8 <parse_value+0x32>
parse_value():
    5d70:	8b 37       	cpi	r24, 0x7B	; 123
    5d72:	09 f0       	breq	.+2      	; 0x5d76 <parse_value+0x3c0>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1354
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '['))
    {
        return parse_array(item, input_buffer);
    }
    /* object */
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '{'))
    5d74:	39 ce       	rjmp	.-910    	; 0x59e8 <parse_value+0x32>
parse_object():
    5d76:	d8 01       	movw	r26, r16
    5d78:	16 96       	adiw	r26, 0x06	; 6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1602
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* linked list head */
    cJSON *current_item = NULL;

    if (input_buffer->depth >= CJSON_NESTING_LIMIT)
    5d7a:	8d 91       	ld	r24, X+
    5d7c:	9c 91       	ld	r25, X
    5d7e:	88 3e       	cpi	r24, 0xE8	; 232
    5d80:	b3 e0       	ldi	r27, 0x03	; 3
    5d82:	9b 07       	cpc	r25, r27
    5d84:	08 f0       	brcs	.+2      	; 0x5d88 <parse_value+0x3d2>
    5d86:	30 ce       	rjmp	.-928    	; 0x59e8 <parse_value+0x32>
    5d88:	01 96       	adiw	r24, 0x01	; 1
    5d8a:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1606
    {
        return false; /* to deeply nested */
    }
    input_buffer->depth++;
    5d8c:	16 96       	adiw	r26, 0x06	; 6
    5d8e:	8d 93       	st	X+, r24
    5d90:	9c 93       	st	X, r25
    5d92:	17 97       	sbiw	r26, 0x07	; 7
    5d94:	80 81       	ld	r24, Z
    5d96:	8b 37       	cpi	r24, 0x7B	; 123
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1608

    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '{'))
    5d98:	09 f0       	breq	.+2      	; 0x5d9c <parse_value+0x3e6>
    5d9a:	26 ce       	rjmp	.-948    	; 0x59e8 <parse_value+0x32>
    5d9c:	bf ef       	ldi	r27, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1613
    {
        goto fail; /* not an object */
    }

    input_buffer->offset++;
    5d9e:	cb 1a       	sub	r12, r27
    5da0:	db 0a       	sbc	r13, r27
    5da2:	f8 01       	movw	r30, r16
    5da4:	c4 82       	std	Z+4, r12	; 0x04
    5da6:	d5 82       	std	Z+5, r13	; 0x05
    5da8:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1614
    buffer_skip_whitespace(input_buffer);
    5daa:	0e 94 4c 05 	call	0xa98	; 0xa98 <buffer_skip_whitespace>
    5dae:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1615
    if (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == '}'))
    5db0:	14 96       	adiw	r26, 0x04	; 4
    5db2:	8d 91       	ld	r24, X+
    5db4:	9c 91       	ld	r25, X
    5db6:	15 97       	sbiw	r26, 0x05	; 5
    5db8:	12 96       	adiw	r26, 0x02	; 2
    5dba:	2d 91       	ld	r18, X+
    5dbc:	3c 91       	ld	r19, X
    5dbe:	13 97       	sbiw	r26, 0x03	; 3
    5dc0:	82 17       	cp	r24, r18
    5dc2:	93 07       	cpc	r25, r19
    5dc4:	68 f4       	brcc	.+26     	; 0x5de0 <parse_value+0x42a>
    5dc6:	ed 91       	ld	r30, X+
    5dc8:	fc 91       	ld	r31, X
    5dca:	11 97       	sbiw	r26, 0x01	; 1
    5dcc:	e8 0f       	add	r30, r24
    5dce:	f9 1f       	adc	r31, r25
    5dd0:	20 81       	ld	r18, Z
    5dd2:	2d 37       	cpi	r18, 0x7D	; 125
    5dd4:	51 f4       	brne	.+20     	; 0x5dea <parse_value+0x434>
parse_value():
    5dd6:	d1 2c       	mov	r13, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1600

/* Build an object from the text. */
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* linked list head */
    cJSON *current_item = NULL;
    5dd8:	c1 2c       	mov	r12, r1
    5dda:	b1 2c       	mov	r11, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1599
}

/* Build an object from the text. */
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* linked list head */
    5ddc:	a1 2c       	mov	r10, r1
    5dde:	79 c0       	rjmp	.+242    	; 0x5ed2 <parse_value+0x51c>
parse_object():
    5de0:	01 97       	sbiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1623
    }

    /* check if we skipped to the end of the buffer */
    if (cannot_access_at_index(input_buffer, 0))
    {
        input_buffer->offset--;
    5de2:	f8 01       	movw	r30, r16
    5de4:	84 83       	std	Z+4, r24	; 0x04
    5de6:	95 83       	std	Z+5, r25	; 0x05
    5de8:	ff cd       	rjmp	.-1026   	; 0x59e8 <parse_value+0x32>
    5dea:	01 97       	sbiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1628
        goto fail;
    }

    /* step back to character in front of the first element */
    input_buffer->offset--;
    5dec:	14 96       	adiw	r26, 0x04	; 4
    5dee:	8d 93       	st	X+, r24
    5df0:	9c 93       	st	X, r25
    5df2:	15 97       	sbiw	r26, 0x05	; 5
parse_value():
    5df4:	91 2c       	mov	r9, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1600

/* Build an object from the text. */
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* linked list head */
    cJSON *current_item = NULL;
    5df6:	81 2c       	mov	r8, r1
    5df8:	b1 2c       	mov	r11, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1599
}

/* Build an object from the text. */
static cJSON_bool parse_object(cJSON * const item, parse_buffer * const input_buffer)
{
    cJSON *head = NULL; /* linked list head */
    5dfa:	a1 2c       	mov	r10, r1
parse_object():
    5dfc:	f8 01       	movw	r30, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1633
    input_buffer->offset--;
    /* loop through the comma separated array elements */
    do
    {
        /* allocate next item */
        cJSON *new_item = cJSON_New_Item(&(input_buffer->hooks));
    5dfe:	80 85       	ldd	r24, Z+8	; 0x08
    5e00:	91 85       	ldd	r25, Z+9	; 0x09
    5e02:	0e 94 af 10 	call	0x215e	; 0x215e <cJSON_New_Item.isra.5>
    5e06:	6c 01       	movw	r12, r24
    5e08:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1634
        if (new_item == NULL)
    5e0a:	09 f4       	brne	.+2      	; 0x5e0e <parse_value+0x458>
    5e0c:	80 c0       	rjmp	.+256    	; 0x5f0e <parse_value+0x558>
    5e0e:	a1 14       	cp	r10, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1640
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
    5e10:	b1 04       	cpc	r11, r1
    5e12:	09 f4       	brne	.+2      	; 0x5e16 <parse_value+0x460>
    5e14:	7a c0       	rjmp	.+244    	; 0x5f0a <parse_value+0x554>
    5e16:	d4 01       	movw	r26, r8
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1648
            current_item = head = new_item;
        }
        else
        {
            /* add to the end and advance */
            current_item->next = new_item;
    5e18:	8d 93       	st	X+, r24
    5e1a:	9c 93       	st	X, r25
    5e1c:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1649
            new_item->prev = current_item;
    5e1e:	82 82       	std	Z+2, r8	; 0x02
    5e20:	93 82       	std	Z+3, r9	; 0x03
    5e22:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1654
            current_item = new_item;
        }

        /* parse the name of the child */
        input_buffer->offset++;
    5e24:	14 96       	adiw	r26, 0x04	; 4
    5e26:	8d 91       	ld	r24, X+
    5e28:	9c 91       	ld	r25, X
    5e2a:	15 97       	sbiw	r26, 0x05	; 5
    5e2c:	01 96       	adiw	r24, 0x01	; 1
    5e2e:	14 96       	adiw	r26, 0x04	; 4
    5e30:	8d 93       	st	X+, r24
    5e32:	9c 93       	st	X, r25
    5e34:	15 97       	sbiw	r26, 0x05	; 5
    5e36:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1655
        buffer_skip_whitespace(input_buffer);
    5e38:	0e 94 4c 05 	call	0xa98	; 0xa98 <buffer_skip_whitespace>
    5e3c:	b8 01       	movw	r22, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1656
        if (!parse_string(current_item, input_buffer))
    5e3e:	c6 01       	movw	r24, r12
    5e40:	0e 94 a2 05 	call	0xb44	; 0xb44 <parse_string>
    5e44:	89 2b       	or	r24, r25
    5e46:	09 f4       	brne	.+2      	; 0x5e4a <parse_value+0x494>
    5e48:	66 c0       	rjmp	.+204    	; 0x5f16 <parse_value+0x560>
    5e4a:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1660
        {
            goto fail; /* failed to parse name */
        }
        buffer_skip_whitespace(input_buffer);
    5e4c:	0e 94 4c 05 	call	0xa98	; 0xa98 <buffer_skip_whitespace>
    5e50:	f6 01       	movw	r30, r12
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1663

        /* swap valuestring and string, because we parsed the name */
        current_item->string = current_item->valuestring;
    5e52:	80 85       	ldd	r24, Z+8	; 0x08
    5e54:	91 85       	ldd	r25, Z+9	; 0x09
    5e56:	80 8b       	std	Z+16, r24	; 0x10
    5e58:	91 8b       	std	Z+17, r25	; 0x11
    5e5a:	10 86       	std	Z+8, r1	; 0x08
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1664
        current_item->valuestring = NULL;
    5e5c:	11 86       	std	Z+9, r1	; 0x09
    5e5e:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1666

        if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != ':'))
    5e60:	14 96       	adiw	r26, 0x04	; 4
    5e62:	8d 91       	ld	r24, X+
    5e64:	9c 91       	ld	r25, X
    5e66:	15 97       	sbiw	r26, 0x05	; 5
    5e68:	12 96       	adiw	r26, 0x02	; 2
    5e6a:	2d 91       	ld	r18, X+
    5e6c:	3c 91       	ld	r19, X
    5e6e:	13 97       	sbiw	r26, 0x03	; 3
    5e70:	82 17       	cp	r24, r18
    5e72:	93 07       	cpc	r25, r19
    5e74:	08 f0       	brcs	.+2      	; 0x5e78 <parse_value+0x4c2>
    5e76:	4f c0       	rjmp	.+158    	; 0x5f16 <parse_value+0x560>
    5e78:	ed 91       	ld	r30, X+
    5e7a:	fc 91       	ld	r31, X
    5e7c:	11 97       	sbiw	r26, 0x01	; 1
    5e7e:	e8 0f       	add	r30, r24
    5e80:	f9 1f       	adc	r31, r25
    5e82:	20 81       	ld	r18, Z
    5e84:	2a 33       	cpi	r18, 0x3A	; 58
    5e86:	09 f0       	breq	.+2      	; 0x5e8a <parse_value+0x4d4>
    5e88:	46 c0       	rjmp	.+140    	; 0x5f16 <parse_value+0x560>
    5e8a:	01 96       	adiw	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1672
        {
            goto fail; /* invalid object */
        }

        /* parse the value */
        input_buffer->offset++;
    5e8c:	14 96       	adiw	r26, 0x04	; 4
    5e8e:	8d 93       	st	X+, r24
    5e90:	9c 93       	st	X, r25
    5e92:	15 97       	sbiw	r26, 0x05	; 5
    5e94:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1673
        buffer_skip_whitespace(input_buffer);
    5e96:	0e 94 4c 05 	call	0xa98	; 0xa98 <buffer_skip_whitespace>
    5e9a:	b8 01       	movw	r22, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1674
        if (!parse_value(current_item, input_buffer))
    5e9c:	c6 01       	movw	r24, r12
    5e9e:	8b dd       	rcall	.-1258   	; 0x59b6 <parse_value>
    5ea0:	89 2b       	or	r24, r25
    5ea2:	c9 f1       	breq	.+114    	; 0x5f16 <parse_value+0x560>
    5ea4:	c8 01       	movw	r24, r16
    5ea6:	0e 94 4c 05 	call	0xa98	; 0xa98 <buffer_skip_whitespace>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1678
        {
            goto fail; /* failed to parse value */
        }
        buffer_skip_whitespace(input_buffer);
    5eaa:	f8 01       	movw	r30, r16
    5eac:	84 81       	ldd	r24, Z+4	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1680
    }
    while (can_access_at_index(input_buffer, 0) && (buffer_at_offset(input_buffer)[0] == ','));
    5eae:	95 81       	ldd	r25, Z+5	; 0x05
    5eb0:	22 81       	ldd	r18, Z+2	; 0x02
    5eb2:	33 81       	ldd	r19, Z+3	; 0x03
    5eb4:	82 17       	cp	r24, r18
    5eb6:	93 07       	cpc	r25, r19
    5eb8:	70 f5       	brcc	.+92     	; 0x5f16 <parse_value+0x560>
    5eba:	01 90       	ld	r0, Z+
    5ebc:	f0 81       	ld	r31, Z
    5ebe:	e0 2d       	mov	r30, r0
    5ec0:	e8 0f       	add	r30, r24
    5ec2:	f9 1f       	adc	r31, r25
    5ec4:	80 81       	ld	r24, Z
    5ec6:	46 01       	movw	r8, r12
    5ec8:	8c 32       	cpi	r24, 0x2C	; 44
    5eca:	09 f4       	brne	.+2      	; 0x5ece <parse_value+0x518>
    5ecc:	97 cf       	rjmp	.-210    	; 0x5dfc <parse_value+0x446>
    5ece:	8d 37       	cpi	r24, 0x7D	; 125
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1682

    if (cannot_access_at_index(input_buffer, 0) || (buffer_at_offset(input_buffer)[0] != '}'))
    5ed0:	11 f5       	brne	.+68     	; 0x5f16 <parse_value+0x560>
    5ed2:	d8 01       	movw	r26, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1688
    {
        goto fail; /* expected end of object */
    }

success:
    input_buffer->depth--;
    5ed4:	16 96       	adiw	r26, 0x06	; 6
    5ed6:	8d 91       	ld	r24, X+
    5ed8:	9c 91       	ld	r25, X
    5eda:	17 97       	sbiw	r26, 0x07	; 7
    5edc:	01 97       	sbiw	r24, 0x01	; 1
    5ede:	16 96       	adiw	r26, 0x06	; 6
    5ee0:	8d 93       	st	X+, r24
    5ee2:	9c 93       	st	X, r25
    5ee4:	17 97       	sbiw	r26, 0x07	; 7
    5ee6:	a1 14       	cp	r10, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1690

    if (head != NULL) {
    5ee8:	b1 04       	cpc	r11, r1
    5eea:	19 f0       	breq	.+6      	; 0x5ef2 <parse_value+0x53c>
    5eec:	f5 01       	movw	r30, r10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1691
        head->prev = current_item;
    5eee:	c2 82       	std	Z+2, r12	; 0x02
    5ef0:	d3 82       	std	Z+3, r13	; 0x03
    5ef2:	80 e4       	ldi	r24, 0x40	; 64
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1694
    }

    item->type = cJSON_Object;
    5ef4:	90 e0       	ldi	r25, 0x00	; 0
    5ef6:	d7 01       	movw	r26, r14
    5ef8:	16 96       	adiw	r26, 0x06	; 6
    5efa:	8d 93       	st	X+, r24
    5efc:	9c 93       	st	X, r25
    5efe:	17 97       	sbiw	r26, 0x07	; 7
    5f00:	14 96       	adiw	r26, 0x04	; 4
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1695
    item->child = head;
    5f02:	ad 92       	st	X+, r10
    5f04:	bc 92       	st	X, r11
    5f06:	15 97       	sbiw	r26, 0x05	; 5
    5f08:	1d cf       	rjmp	.-454    	; 0x5d44 <parse_value+0x38e>
    5f0a:	5c 01       	movw	r10, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1640
        {
            goto fail; /* allocation failure */
        }

        /* attach next item to list */
        if (head == NULL)
    5f0c:	8a cf       	rjmp	.-236    	; 0x5e22 <parse_value+0x46c>
    5f0e:	a1 14       	cp	r10, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1701

    input_buffer->offset++;
    return true;

fail:
    if (head != NULL)
    5f10:	b1 04       	cpc	r11, r1
    5f12:	09 f4       	brne	.+2      	; 0x5f16 <parse_value+0x560>
    5f14:	69 cd       	rjmp	.-1326   	; 0x59e8 <parse_value+0x32>
    5f16:	c5 01       	movw	r24, r10
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1703
    {
        cJSON_Delete(head);
    5f18:	28 cf       	rjmp	.-432    	; 0x5d6a <parse_value+0x3b4>

00005f1a <cJSON_Parse>:
cJSON_Parse():
    5f1a:	ef 92       	push	r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1172
    return NULL;
}

/* Default options for cJSON_Parse */
CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
{
    5f1c:	ff 92       	push	r15
    5f1e:	0f 93       	push	r16
    5f20:	1f 93       	push	r17
    5f22:	cf 93       	push	r28
    5f24:	df 93       	push	r29
    5f26:	cd b7       	in	r28, 0x3d	; 61
    5f28:	de b7       	in	r29, 0x3e	; 62
    5f2a:	2e 97       	sbiw	r28, 0x0e	; 14
    5f2c:	cd bf       	out	0x3d, r28	; 61
    5f2e:	de bf       	out	0x3e, r29	; 62
cJSON_ParseWithOpts():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1079

CJSON_PUBLIC(cJSON *) cJSON_ParseWithOpts(const char *value, const char **return_parse_end, cJSON_bool require_null_terminated)
{
    size_t buffer_length;

    if (NULL == value)
    5f30:	00 97       	sbiw	r24, 0x00	; 0
    5f32:	09 f4       	brne	.+2      	; 0x5f36 <cJSON_Parse+0x1c>
    5f34:	58 c0       	rjmp	.+176    	; 0x5fe6 <cJSON_Parse+0xcc>
    5f36:	fc 01       	movw	r30, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1085
    {
        return NULL;
    }

    /* Adding null character size due to require_null_terminated. */
    buffer_length = strlen(value) + sizeof("");
    5f38:	dc 01       	movw	r26, r24
    5f3a:	0d 90       	ld	r0, X+
    5f3c:	00 20       	and	r0, r0
    5f3e:	e9 f7       	brne	.-6      	; 0x5f3a <cJSON_Parse+0x20>
    5f40:	cd 01       	movw	r24, r26
cJSON_ParseWithLengthOpts():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1093
}

/* Parse an object - create a new root, and populate. */
CJSON_PUBLIC(cJSON *) cJSON_ParseWithLengthOpts(const char *value, size_t buffer_length, const char **return_parse_end, cJSON_bool require_null_terminated)
{
    parse_buffer buffer = { 0, 0, 0, 0, { 0, 0, 0 } };
    5f42:	1d 82       	std	Y+5, r1	; 0x05
    5f44:	1e 82       	std	Y+6, r1	; 0x06
    5f46:	1f 82       	std	Y+7, r1	; 0x07
    5f48:	18 86       	std	Y+8, r1	; 0x08
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1105
    if (value == NULL || 0 == buffer_length)
    {
        goto fail;
    }

    buffer.content = (const unsigned char*)value;
    5f4a:	e9 83       	std	Y+1, r30	; 0x01
    5f4c:	fa 83       	std	Y+2, r31	; 0x02
cJSON_ParseWithOpts():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1085
    {
        return NULL;
    }

    /* Adding null character size due to require_null_terminated. */
    buffer_length = strlen(value) + sizeof("");
    5f4e:	8e 1b       	sub	r24, r30
    5f50:	9f 0b       	sbc	r25, r31
cJSON_ParseWithLengthOpts():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1106
    {
        goto fail;
    }

    buffer.content = (const unsigned char*)value;
    buffer.length = buffer_length; 
    5f52:	8b 83       	std	Y+3, r24	; 0x03
    5f54:	9c 83       	std	Y+4, r25	; 0x04
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1108
    buffer.offset = 0;
    buffer.hooks = global_hooks;
    5f56:	86 e0       	ldi	r24, 0x06	; 6
    5f58:	e2 e0       	ldi	r30, 0x02	; 2
    5f5a:	f2 e4       	ldi	r31, 0x42	; 66
    5f5c:	de 01       	movw	r26, r28
    5f5e:	19 96       	adiw	r26, 0x09	; 9
    5f60:	01 90       	ld	r0, Z+
    5f62:	0d 92       	st	X+, r0
    5f64:	8a 95       	dec	r24
    5f66:	e1 f7       	brne	.-8      	; 0x5f60 <cJSON_Parse+0x46>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1110

    item = cJSON_New_Item(&global_hooks);
    5f68:	80 91 02 42 	lds	r24, 0x4202	; 0x804202 <global_hooks>
    5f6c:	90 91 03 42 	lds	r25, 0x4203	; 0x804203 <global_hooks+0x1>
    5f70:	0e 94 af 10 	call	0x215e	; 0x215e <cJSON_New_Item.isra.5>
    5f74:	8c 01       	movw	r16, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1111
    if (item == NULL) /* memory fail */
    5f76:	89 2b       	or	r24, r25
    5f78:	b1 f1       	breq	.+108    	; 0x5fe6 <cJSON_Parse+0xcc>
skip_utf8_bom():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1062
}

/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
{
    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
    5f7a:	89 81       	ldd	r24, Y+1	; 0x01
    5f7c:	9a 81       	ldd	r25, Y+2	; 0x02
    5f7e:	00 97       	sbiw	r24, 0x00	; 0
    5f80:	d9 f0       	breq	.+54     	; 0x5fb8 <cJSON_Parse+0x9e>
    5f82:	2d 81       	ldd	r18, Y+5	; 0x05
    5f84:	3e 81       	ldd	r19, Y+6	; 0x06
    5f86:	23 2b       	or	r18, r19
    5f88:	b9 f4       	brne	.+46     	; 0x5fb8 <cJSON_Parse+0x9e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1067
    {
        return NULL;
    }

    if (can_access_at_index(buffer, 4) && (strncmp((const char*)buffer_at_offset(buffer), "\xEF\xBB\xBF", 3) == 0))
    5f8a:	2b 81       	ldd	r18, Y+3	; 0x03
    5f8c:	3c 81       	ldd	r19, Y+4	; 0x04
    5f8e:	ae 01       	movw	r20, r28
    5f90:	4f 5f       	subi	r20, 0xFF	; 255
    5f92:	5f 4f       	sbci	r21, 0xFF	; 255
    5f94:	7a 01       	movw	r14, r20
    5f96:	25 30       	cpi	r18, 0x05	; 5
    5f98:	31 05       	cpc	r19, r1
    5f9a:	60 f0       	brcs	.+24     	; 0x5fb4 <cJSON_Parse+0x9a>
    5f9c:	43 e0       	ldi	r20, 0x03	; 3
    5f9e:	50 e0       	ldi	r21, 0x00	; 0
    5fa0:	64 e5       	ldi	r22, 0x54	; 84
    5fa2:	73 e5       	ldi	r23, 0x53	; 83
    5fa4:	0e 94 0d 57 	call	0xae1a	; 0xae1a <strncmp>
    5fa8:	89 2b       	or	r24, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1069
    {
        buffer->offset += 3;
    5faa:	21 f4       	brne	.+8      	; 0x5fb4 <cJSON_Parse+0x9a>
    5fac:	83 e0       	ldi	r24, 0x03	; 3
    5fae:	90 e0       	ldi	r25, 0x00	; 0
    5fb0:	8d 83       	std	Y+5, r24	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1072
    }

    return buffer;
    5fb2:	9e 83       	std	Y+6, r25	; 0x06
cJSON_Parse():
    5fb4:	c7 01       	movw	r24, r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1064
/* skip the UTF-8 BOM (byte order mark) if it is at the beginning of a buffer */
static parse_buffer *skip_utf8_bom(parse_buffer * const buffer)
{
    if ((buffer == NULL) || (buffer->content == NULL) || (buffer->offset != 0))
    {
        return NULL;
    5fb6:	02 c0       	rjmp	.+4      	; 0x5fbc <cJSON_Parse+0xa2>
    5fb8:	80 e0       	ldi	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1116
    if (item == NULL) /* memory fail */
    {
        goto fail;
    }

    if (!parse_value(item, buffer_skip_whitespace(skip_utf8_bom(&buffer))))
    5fba:	90 e0       	ldi	r25, 0x00	; 0
cJSON_ParseWithLengthOpts():
    5fbc:	0e 94 4c 05 	call	0xa98	; 0xa98 <buffer_skip_whitespace>
    5fc0:	bc 01       	movw	r22, r24
    5fc2:	c8 01       	movw	r24, r16
    5fc4:	f8 dc       	rcall	.-1552   	; 0x59b6 <parse_value>
    5fc6:	89 2b       	or	r24, r25
    5fc8:	59 f0       	breq	.+22     	; 0x5fe0 <cJSON_Parse+0xc6>
cJSON_Parse():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1174

/* Default options for cJSON_Parse */
CJSON_PUBLIC(cJSON *) cJSON_Parse(const char *value)
{
    return cJSON_ParseWithOpts(value, 0, 0);
}
    5fca:	c8 01       	movw	r24, r16
    5fcc:	2e 96       	adiw	r28, 0x0e	; 14
    5fce:	cd bf       	out	0x3d, r28	; 61
    5fd0:	de bf       	out	0x3e, r29	; 62
    5fd2:	df 91       	pop	r29
    5fd4:	cf 91       	pop	r28
    5fd6:	1f 91       	pop	r17
    5fd8:	0f 91       	pop	r16
    5fda:	ff 90       	pop	r15
    5fdc:	ef 90       	pop	r14
    5fde:	08 95       	ret
cJSON_ParseWithLengthOpts():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1141
    return item;

fail:
    if (item != NULL)
    {
        cJSON_Delete(item);
    5fe0:	c8 01       	movw	r24, r16
    5fe2:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
cJSON_Parse():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1081
{
    size_t buffer_length;

    if (NULL == value)
    {
        return NULL;
    5fe6:	10 e0       	ldi	r17, 0x00	; 0
    5fe8:	00 e0       	ldi	r16, 0x00	; 0
    5fea:	ef cf       	rjmp	.-34     	; 0x5fca <cJSON_Parse+0xb0>

00005fec <on_mqtt_c2d_message(char const*)>:
on_mqtt_c2d_message():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:178
    // fall through

    return ret;
}

static void on_mqtt_c2d_message(const char* message) {
    5fec:	8f 92       	push	r8
    5fee:	9f 92       	push	r9
    5ff0:	af 92       	push	r10
    5ff2:	bf 92       	push	r11
    5ff4:	ef 92       	push	r14
    5ff6:	ff 92       	push	r15
    5ff8:	0f 93       	push	r16
    5ffa:	1f 93       	push	r17
    5ffc:	cf 93       	push	r28
    5ffe:	df 93       	push	r29
    6000:	d8 2f       	mov	r29, r24
    6002:	c9 2f       	mov	r28, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:179
    Log.infof("event>>> %s", message);
    6004:	9f 93       	push	r25
    6006:	8f 93       	push	r24
    6008:	88 e5       	ldi	r24, 0x58	; 88
    600a:	93 e5       	ldi	r25, 0x53	; 83
    600c:	9f 93       	push	r25
    600e:	8f 93       	push	r24
    6010:	89 e6       	ldi	r24, 0x69	; 105
    6012:	90 e7       	ldi	r25, 0x70	; 112
    6014:	9f 93       	push	r25
    6016:	8f 93       	push	r24
    6018:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
iotcl_process_event():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:91
    return (NULL != json && cJSON_IsString(json) && json->valuestring != NULL);
}

bool iotcl_process_event(const char *event) {
    bool status = false;
    cJSON *root = cJSON_Parse(event);
    601c:	8d 2f       	mov	r24, r29
    601e:	9c 2f       	mov	r25, r28
    6020:	7c df       	rcall	.-264    	; 0x5f1a <cJSON_Parse>
    6022:	8c 01       	movw	r16, r24
    6024:	0f 90       	pop	r0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:93

    if (!root) {
    6026:	0f 90       	pop	r0
    6028:	0f 90       	pop	r0
    602a:	0f 90       	pop	r0
    602c:	0f 90       	pop	r0
    602e:	0f 90       	pop	r0
    6030:	00 97       	sbiw	r24, 0x00	; 0
    6032:	09 f4       	brne	.+2      	; 0x6036 <on_mqtt_c2d_message(char const*)+0x4a>
    6034:	94 c0       	rjmp	.+296    	; 0x615e <on_mqtt_c2d_message(char const*)+0x172>
    6036:	64 e6       	ldi	r22, 0x64	; 100
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:99
       return false;
    }

    { // scope out the on-the fly varialble declarations for cleanup jump
        // root object should only have cmdType
        cJSON *j_type = cJSON_GetObjectItemCaseSensitive(root, "cmdType");
    6038:	73 e5       	ldi	r23, 0x53	; 83
    603a:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
    603e:	ec 01       	movw	r28, r24
    6040:	0e 94 0d 05 	call	0xa1a	; 0xa1a <is_valid_string>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:100
        if (!is_valid_string(j_type)) goto cleanup;
    6044:	88 23       	and	r24, r24
    6046:	09 f4       	brne	.+2      	; 0x604a <on_mqtt_c2d_message(char const*)+0x5e>
    6048:	87 c0       	rjmp	.+270    	; 0x6158 <on_mqtt_c2d_message(char const*)+0x16c>
    604a:	6c e6       	ldi	r22, 0x6C	; 108
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:105

        cJSON *j_ack_id = NULL;
        cJSON *data = NULL; // data should have ackId
        if (!is_valid_string(j_ack_id)) {
            data = cJSON_GetObjectItemCaseSensitive(root, "data");
    604c:	73 e5       	ldi	r23, 0x53	; 83
    604e:	c8 01       	movw	r24, r16
    6050:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
    6054:	7c 01       	movw	r14, r24
    6056:	00 97       	sbiw	r24, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:106
            if (!data) goto cleanup;
    6058:	09 f4       	brne	.+2      	; 0x605c <on_mqtt_c2d_message(char const*)+0x70>
    605a:	7e c0       	rjmp	.+252    	; 0x6158 <on_mqtt_c2d_message(char const*)+0x16c>
    605c:	60 e6       	ldi	r22, 0x60	; 96
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:107
            j_ack_id = cJSON_GetObjectItemCaseSensitive(data, "ackId");
    605e:	78 e4       	ldi	r23, 0x48	; 72
    6060:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
    6064:	0e 94 0d 05 	call	0xa1a	; 0xa1a <is_valid_string>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:108
            if (!is_valid_string(j_ack_id)) goto cleanup;
    6068:	88 23       	and	r24, r24
    606a:	09 f4       	brne	.+2      	; 0x606e <on_mqtt_c2d_message(char const*)+0x82>
    606c:	75 c0       	rjmp	.+234    	; 0x6158 <on_mqtt_c2d_message(char const*)+0x16c>
    606e:	88 85       	ldd	r24, Y+8	; 0x08
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:111
        }

        if (4 != strlen(j_type->valuestring)) {
    6070:	99 85       	ldd	r25, Y+9	; 0x09
    6072:	fc 01       	movw	r30, r24
    6074:	01 90       	ld	r0, Z+
    6076:	00 20       	and	r0, r0
    6078:	e9 f7       	brne	.-6      	; 0x6074 <on_mqtt_c2d_message(char const*)+0x88>
    607a:	9f 01       	movw	r18, r30
    607c:	25 50       	subi	r18, 0x05	; 5
    607e:	31 09       	sbc	r19, r1
    6080:	28 17       	cp	r18, r24
    6082:	39 07       	cpc	r19, r25
    6084:	09 f0       	breq	.+2      	; 0x6088 <on_mqtt_c2d_message(char const*)+0x9c>
    6086:	68 c0       	rjmp	.+208    	; 0x6158 <on_mqtt_c2d_message(char const*)+0x16c>
    6088:	40 e1       	ldi	r20, 0x10	; 16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:116
            // Don't know how to parse it then...
            goto cleanup;
        }

        IotConnectEventType type = (IotConnectEventType) strtol(&j_type->valuestring[2], NULL, 16);
    608a:	50 e0       	ldi	r21, 0x00	; 0
    608c:	70 e0       	ldi	r23, 0x00	; 0
    608e:	60 e0       	ldi	r22, 0x00	; 0
    6090:	02 96       	adiw	r24, 0x02	; 2
    6092:	0e 94 11 4e 	call	0x9c22	; 0x9c22 <strtol>
    6096:	4b 01       	movw	r8, r22
    6098:	61 15       	cp	r22, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:118

        if (type < DEVICE_COMMAND) {
    609a:	71 05       	cpc	r23, r1
    609c:	09 f4       	brne	.+2      	; 0x60a0 <on_mqtt_c2d_message(char const*)+0xb4>
    609e:	5c c0       	rjmp	.+184    	; 0x6158 <on_mqtt_c2d_message(char const*)+0x16c>
    60a0:	cb 01       	movw	r24, r22
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:124
            goto cleanup;
        }

        // In case we have a supported command. Do some checks before allowing further processing of acks
        // NOTE: "i" in cpId is lower case, but per spec it's supposed to be in upper case
        if (type == DEVICE_COMMAND || type == DEVICE_OTA) {
    60a2:	01 97       	sbiw	r24, 0x01	; 1
    60a4:	02 97       	sbiw	r24, 0x02	; 2
    60a6:	98 f4       	brcc	.+38     	; 0x60ce <on_mqtt_c2d_message(char const*)+0xe2>
    60a8:	61 e7       	ldi	r22, 0x71	; 113
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:126
            if (
                    !is_valid_string(cJSON_GetObjectItem(data, "cpid"))
    60aa:	73 e5       	ldi	r23, 0x53	; 83
    60ac:	c7 01       	movw	r24, r14
    60ae:	5a da       	rcall	.-2892   	; 0x5564 <cJSON_GetObjectItem>
    60b0:	0e 94 0d 05 	call	0xa1a	; 0xa1a <is_valid_string>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:125
        }

        // In case we have a supported command. Do some checks before allowing further processing of acks
        // NOTE: "i" in cpId is lower case, but per spec it's supposed to be in upper case
        if (type == DEVICE_COMMAND || type == DEVICE_OTA) {
            if (
    60b4:	88 23       	and	r24, r24
    60b6:	09 f4       	brne	.+2      	; 0x60ba <on_mqtt_c2d_message(char const*)+0xce>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:127
                    !is_valid_string(cJSON_GetObjectItem(data, "cpid"))
                    || !is_valid_string(cJSON_GetObjectItemCaseSensitive(data, "uniqueId"))
    60b8:	4f c0       	rjmp	.+158    	; 0x6158 <on_mqtt_c2d_message(char const*)+0x16c>
    60ba:	69 e6       	ldi	r22, 0x69	; 105
    60bc:	78 e4       	ldi	r23, 0x48	; 72
    60be:	c7 01       	movw	r24, r14
    60c0:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
    60c4:	0e 94 0d 05 	call	0xa1a	; 0xa1a <is_valid_string>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:133
                    ) {
                goto cleanup;
            }
        }

        struct IotclEventDataTag *eventData = (struct IotclEventDataTag *) calloc(
    60c8:	88 23       	and	r24, r24
    60ca:	09 f4       	brne	.+2      	; 0x60ce <on_mqtt_c2d_message(char const*)+0xe2>
    60cc:	45 c0       	rjmp	.+138    	; 0x6158 <on_mqtt_c2d_message(char const*)+0x16c>
    60ce:	61 e0       	ldi	r22, 0x01	; 1
    60d0:	70 e0       	ldi	r23, 0x00	; 0
    60d2:	86 e0       	ldi	r24, 0x06	; 6
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:135
                sizeof(struct IotclEventDataTag), 1);
        if (NULL == eventData) goto cleanup;
    60d4:	90 e0       	ldi	r25, 0x00	; 0
    60d6:	0e 94 9e 54 	call	0xa93c	; 0xa93c <calloc>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:137

        eventData->root = root;
    60da:	ec 01       	movw	r28, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:138
        eventData->data = data;
    60dc:	89 2b       	or	r24, r25
    60de:	e1 f1       	breq	.+120    	; 0x6158 <on_mqtt_c2d_message(char const*)+0x16c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:139
        eventData->type = type;
    60e0:	0a 83       	std	Y+2, r16	; 0x02
    60e2:	1b 83       	std	Y+3, r17	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:44
    60e4:	e8 82       	st	Y, r14
    60e6:	f9 82       	std	Y+1, r15	; 0x01
    60e8:	8c 82       	std	Y+4, r8	; 0x04
    60ea:	9d 82       	std	Y+5, r9	; 0x05
iotcl_get_config():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:62
    if (!eventData) return false;

    IotclConfig *config = iotcl_get_config();
    if (!config) return false;

    if (config->event_functions.msg_cb) {
    60ec:	80 91 3d 64 	lds	r24, 0x643D	; 0x80643d <config_is_valid>
    60f0:	88 23       	and	r24, r24
    60f2:	a9 f1       	breq	.+106    	; 0x615e <on_mqtt_c2d_message(char const*)+0x172>
iotc_process_callback():
    60f4:	e0 91 39 64 	lds	r30, 0x6439	; 0x806439 <config+0xc>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:63
        config->event_functions.msg_cb(eventData, eventData->type);
    60f8:	f0 91 3a 64 	lds	r31, 0x643A	; 0x80643a <config+0xd>
    60fc:	30 97       	sbiw	r30, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:65
    }
    switch (eventData->type) {
    60fe:	19 f0       	breq	.+6      	; 0x6106 <on_mqtt_c2d_message(char const*)+0x11a>
    6100:	b4 01       	movw	r22, r8
    6102:	ce 01       	movw	r24, r28
    6104:	09 95       	icall
    6106:	8c 81       	ldd	r24, Y+4	; 0x04
    6108:	9d 81       	ldd	r25, Y+5	; 0x05
    610a:	81 30       	cpi	r24, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:183
    if (!iotcl_process_event(message)) {
        Log.error("Error encountered while processing the message");
    }
}
    610c:	91 05       	cpc	r25, r1
    610e:	69 f0       	breq	.+26     	; 0x612a <on_mqtt_c2d_message(char const*)+0x13e>
    6110:	02 97       	sbiw	r24, 0x02	; 2
    6112:	e9 f0       	breq	.+58     	; 0x614e <on_mqtt_c2d_message(char const*)+0x162>
on_mqtt_c2d_message():
    6114:	df 91       	pop	r29
    6116:	cf 91       	pop	r28
    6118:	1f 91       	pop	r17
    611a:	0f 91       	pop	r16
    611c:	ff 90       	pop	r15
    611e:	ef 90       	pop	r14
    6120:	bf 90       	pop	r11
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:67
        case DEVICE_COMMAND:
            if (config->event_functions.cmd_cb) {
    6122:	af 90       	pop	r10
    6124:	9f 90       	pop	r9
    6126:	8f 90       	pop	r8
    6128:	08 95       	ret
iotc_process_callback():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:72
                config->event_functions.cmd_cb(eventData);
            }
            break;
        case DEVICE_OTA:
            if (config->event_functions.ota_cb) {
    612a:	e0 91 37 64 	lds	r30, 0x6437	; 0x806437 <config+0xa>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:73
                config->event_functions.ota_cb(eventData);
    612e:	f0 91 38 64 	lds	r31, 0x6438	; 0x806438 <config+0xb>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:183
    6132:	30 97       	sbiw	r30, 0x00	; 0
    6134:	79 f3       	breq	.-34     	; 0x6114 <on_mqtt_c2d_message(char const*)+0x128>
    6136:	ce 01       	movw	r24, r28
on_mqtt_c2d_message():
    6138:	df 91       	pop	r29
    613a:	cf 91       	pop	r28
    613c:	1f 91       	pop	r17
    613e:	0f 91       	pop	r16
    6140:	ff 90       	pop	r15
    6142:	ef 90       	pop	r14
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:73
    6144:	bf 90       	pop	r11
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:72
            if (config->event_functions.cmd_cb) {
                config->event_functions.cmd_cb(eventData);
            }
            break;
        case DEVICE_OTA:
            if (config->event_functions.ota_cb) {
    6146:	af 90       	pop	r10
    6148:	9f 90       	pop	r9
    614a:	8f 90       	pop	r8
iotc_process_callback():
    614c:	09 94       	ijmp
    614e:	e0 91 35 64 	lds	r30, 0x6435	; 0x806435 <config+0x8>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_event.c:150
        return iotc_process_callback(eventData);
    }

    cleanup:

    cJSON_Delete(root);
    6152:	f0 91 36 64 	lds	r31, 0x6436	; 0x806436 <config+0x9>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:181
}

static void on_mqtt_c2d_message(const char* message) {
    Log.infof("event>>> %s", message);
    if (!iotcl_process_event(message)) {
        Log.error("Error encountered while processing the message");
    6156:	ed cf       	rjmp	.-38     	; 0x6132 <on_mqtt_c2d_message(char const*)+0x146>
iotcl_process_event():
    6158:	c8 01       	movw	r24, r16
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:183
    }
}
    615a:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
on_mqtt_c2d_message():
    615e:	86 e7       	ldi	r24, 0x76	; 118
    6160:	93 e5       	ldi	r25, 0x53	; 83
    6162:	df 91       	pop	r29
    6164:	cf 91       	pop	r28
    6166:	1f 91       	pop	r17
    6168:	0f 91       	pop	r16
    616a:	ff 90       	pop	r15
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:181
}

static void on_mqtt_c2d_message(const char* message) {
    Log.infof("event>>> %s", message);
    if (!iotcl_process_event(message)) {
        Log.error("Error encountered while processing the message");
    616c:	ef 90       	pop	r14
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:194
      }
      RTC.INTFLAGS = RTC_OVF_bm | RTC_CMP_bm; // clear flag
    }
  #else
    ISR(MILLIS_VECTOR, ISR_NAKED) {
      __asm__ __volatile__(
    616e:	bf 90       	pop	r11
    6170:	af 90       	pop	r10
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:199
      "push       r30"          "\n\t" // First we make room for the pointer to timingStruct by pushing the Z registers
      "push       r31"          "\n\t" //
      ::);
    #if defined(MILLIS_USE_TCB)
      __asm__ __volatile__(
    6172:	9f 90       	pop	r9
    6174:	8f 90       	pop	r8
    6176:	0c 94 47 0a 	jmp	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>

0000617a <__vector_31>:
__vector_31():
    617a:	ef 93       	push	r30
    617c:	ff 93       	push	r31
    617e:	e5 e8       	ldi	r30, 0x85	; 133
    6180:	f6 e6       	ldi	r31, 0x66	; 102
    6182:	8f 93       	push	r24
    6184:	8f b7       	in	r24, 0x3f	; 63
    6186:	8f 93       	push	r24
    6188:	80 81       	ld	r24, Z
    618a:	8f 5f       	subi	r24, 0xFF	; 255
    618c:	80 83       	st	Z, r24
    618e:	81 81       	ldd	r24, Z+1	; 0x01
    6190:	8f 4f       	sbci	r24, 0xFF	; 255
    6192:	81 83       	std	Z+1, r24	; 0x01
    6194:	82 81       	ldd	r24, Z+2	; 0x02
    6196:	8f 4f       	sbci	r24, 0xFF	; 255
    6198:	82 83       	std	Z+2, r24	; 0x02
    619a:	83 81       	ldd	r24, Z+3	; 0x03
    619c:	8f 4f       	sbci	r24, 0xFF	; 255
    619e:	83 83       	std	Z+3, r24	; 0x03
    61a0:	81 e0       	ldi	r24, 0x01	; 1
    61a2:	80 93 26 0b 	sts	0x0B26, r24	; 0x800b26 <__TEXT_REGION_LENGTH__+0x7e0b26>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:433
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTF
      ISR(PORTF_PORT_vect, ISR_NAKED){
      asm volatile(
    61a6:	8f 91       	pop	r24
    61a8:	8f bf       	out	0x3f, r24	; 63
    61aa:	8f 91       	pop	r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:419
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTE
      ISR(PORTE_PORT_vect, ISR_NAKED){
      asm volatile(
    61ac:	ff 91       	pop	r31
    61ae:	ef 91       	pop	r30
    61b0:	18 95       	reti

000061b2 <__vector_35>:
__vector_35():
    61b2:	0f 93       	push	r16
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:405
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTD
      ISR(PORTD_PORT_vect, ISR_NAKED){
      asm volatile(
    61b4:	0a e0       	ldi	r16, 0x0A	; 10
    61b6:	0f c0       	rjmp	.+30     	; 0x61d6 <isrBody>

000061b8 <__vector_46>:
__vector_46():
    61b8:	0f 93       	push	r16
    61ba:	08 e0       	ldi	r16, 0x08	; 8
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:391
      __builtin_unreachable();
    }
    #endif
    #ifdef PORTC
      ISR(PORTC_PORT_vect, ISR_NAKED) {
      asm volatile(
    61bc:	0c c0       	rjmp	.+24     	; 0x61d6 <isrBody>

000061be <__vector_24>:
__vector_24():
    61be:	0f 93       	push	r16
    61c0:	06 e0       	ldi	r16, 0x06	; 6
    61c2:	09 c0       	rjmp	.+18     	; 0x61d6 <isrBody>

000061c4 <__vector_30>:
__vector_30():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:377
      ::);
    __builtin_unreachable();
    }
    #ifdef PORTB
      ISR(PORTB_PORT_vect, ISR_NAKED){
      asm volatile(
    61c4:	0f 93       	push	r16
    61c6:	04 e0       	ldi	r16, 0x04	; 4
    61c8:	06 c0       	rjmp	.+12     	; 0x61d6 <isrBody>

000061ca <__vector_45>:
__vector_45():
    61ca:	0f 93       	push	r16
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:364
 * then it's just a matter of making sure we pop everything we pushed onto the stack in the reverse order, including r16 followed by the reti to exit the interrupt..
*/

  #if defined(CORE_ATTACH_ALL)
    ISR(PORTA_PORT_vect, ISR_NAKED) {
    asm volatile(
    61cc:	02 e0       	ldi	r16, 0x02	; 2
    61ce:	03 c0       	rjmp	.+6      	; 0x61d6 <isrBody>

000061d0 <__vector_8>:
__vector_8():
    61d0:	0f 93       	push	r16
    61d2:	00 e0       	ldi	r16, 0x00	; 0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:148

  }

#if !defined(CORE_ATTACH_EARLYCLEAR)
  void __attribute__((naked)) __attribute__((used)) __attribute__((noreturn)) isrBody() {
    asm volatile (
    61d4:	00 c0       	rjmp	.+0      	; 0x61d6 <isrBody>

000061d6 <isrBody>:
isrBody():
    61d6:	0f 92       	push	r0
    61d8:	0f b6       	in	r0, 0x3f	; 63
    61da:	0f 92       	push	r0
    61dc:	0b b6       	in	r0, 0x3b	; 59
    61de:	0f 92       	push	r0
    61e0:	1f 92       	push	r1
    61e2:	11 24       	eor	r1, r1
    61e4:	ff 92       	push	r15
    61e6:	1f 93       	push	r17
    61e8:	2f 93       	push	r18
    61ea:	3f 93       	push	r19
    61ec:	4f 93       	push	r20
    61ee:	5f 93       	push	r21
    61f0:	6f 93       	push	r22
    61f2:	7f 93       	push	r23
    61f4:	8f 93       	push	r24
    61f6:	9f 93       	push	r25
    61f8:	af 93       	push	r26
    61fa:	bf 93       	push	r27
    61fc:	cf 93       	push	r28
    61fe:	df 93       	push	r29
    6200:	ef 93       	push	r30
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/WInterrupts.c:176
      "push  r28"        "\n\t" // Not call used, but we use it.
      "push  r29"        "\n\t" // same thing.
      "push  r30"        "\n\t"
      "push  r31"        "\n\t"
      ::);
    asm volatile (  // This gets us the address of intFunc in Y pointer reg.
    6202:	ff 93       	push	r31
    6204:	a4 ef       	ldi	r26, 0xF4	; 244
    6206:	b1 e4       	ldi	r27, 0x41	; 65
    6208:	a0 0f       	add	r26, r16
    620a:	b1 1d       	adc	r27, r1
    620c:	cd 91       	ld	r28, X+
    620e:	dc 91       	ld	r29, X
    6210:	00 0f       	add	r16, r16
    6212:	0d 5f       	subi	r16, 0xFD	; 253
    6214:	a0 2f       	mov	r26, r16
    6216:	b0 e0       	ldi	r27, 0x00	; 0
    6218:	fc 90       	ld	r15, X
    621a:	10 97       	sbiw	r26, 0x00	; 0
    621c:	61 f0       	breq	.+24     	; 0x6236 <AIntEnd>
    621e:	1f 2d       	mov	r17, r15

00006220 <AIntLoop>:
    6220:	16 95       	lsr	r17
    6222:	18 f0       	brcs	.+6      	; 0x622a <AIntLoop+0xa>
    6224:	41 f0       	breq	.+16     	; 0x6236 <AIntEnd>
    6226:	22 96       	adiw	r28, 0x02	; 2
    6228:	fb cf       	rjmp	.-10     	; 0x6220 <AIntLoop>
    622a:	e9 91       	ld	r30, Y+
    622c:	f9 91       	ld	r31, Y+
    622e:	30 97       	sbiw	r30, 0x00	; 0
    6230:	b9 f3       	breq	.-18     	; 0x6220 <AIntLoop>
    6232:	09 95       	icall
    6234:	f5 cf       	rjmp	.-22     	; 0x6220 <AIntLoop>

00006236 <AIntEnd>:
    6236:	a0 2f       	mov	r26, r16
    6238:	b0 e0       	ldi	r27, 0x00	; 0
    623a:	fc 92       	st	X, r15
    623c:	ff 91       	pop	r31
    623e:	ef 91       	pop	r30
    6240:	df 91       	pop	r29
    6242:	cf 91       	pop	r28
    6244:	bf 91       	pop	r27
    6246:	af 91       	pop	r26
    6248:	9f 91       	pop	r25
    624a:	8f 91       	pop	r24
    624c:	7f 91       	pop	r23
    624e:	6f 91       	pop	r22
    6250:	5f 91       	pop	r21
    6252:	4f 91       	pop	r20
    6254:	3f 91       	pop	r19
    6256:	2f 91       	pop	r18
    6258:	1f 91       	pop	r17
    625a:	ff 90       	pop	r15
    625c:	1f 90       	pop	r1
    625e:	0f 90       	pop	r0
    6260:	0b be       	out	0x3b, r0	; 59
    6262:	0f 90       	pop	r0
    6264:	0f be       	out	0x3f, r0	; 63
    6266:	0f 90       	pop	r0
    6268:	0f 91       	pop	r16
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART3.cpp:95
    ISR(USART3_DRE_vect, ISR_NAKED) {
      __asm__ __volatile__(
                "push  r30"       "\n\t"
                "push  r31"       "\n\t"
                "cbi   0x1F, 0"   "\n\t"
                :::);
    626a:	18 95       	reti

0000626c <__vector_54>:
__vector_54():
    626c:	ef 93       	push	r30
    626e:	ff 93       	push	r31
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART3.cpp:102
#if PROGMEM_SIZE > 8192
                "jmp _do_dre"     "\n\t"
#else
                "rjmp _do_dre"    "\n\t"
#endif
                ::"z"(&Serial3));
    6270:	f8 98       	cbi	0x1f, 0	; 31
    6272:	e6 ed       	ldi	r30, 0xD6	; 214
    6274:	ff e6       	ldi	r31, 0x6F	; 111
    6276:	0b c0       	rjmp	.+22     	; 0x628e <_do_dre()>

00006278 <__vector_53>:
__vector_53():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART3.cpp:72
      ISR(USART3_RXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t" //we start out 5-6 clocks behind the ball, then do 2 push + 2 ldi + 2-3 for jump = 11 or 13 clocks to _do_rxc (and dre is the same)
              "push      r31"     "\n\t"
              "cbi   0x1F, 0"     "\n\t"
              :::);
    6278:	ef 93       	push	r30
    627a:	ff 93       	push	r31
    627c:	f8 98       	cbi	0x1f, 0	; 31
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART3.cpp:79
#if PROGMEM_SIZE > 8192
              "jmp   _do_rxc"     "\n\t"
#else
              "rjmp   _do_rxc"    "\n\t"
#endif
              ::"z"(&Serial3));
    627e:	e6 ed       	ldi	r30, 0xD6	; 214
    6280:	ff e6       	ldi	r31, 0x6F	; 111
    6282:	34 c0       	rjmp	.+104    	; 0x62ec <_do_rxc()>

00006284 <__vector_55>:
__vector_55():
    6284:	ef 93       	push	r30
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART3.cpp:35
#elif defined(USE_ASM_TXC) && USE_ASM_TXC == 2
    ISR(USART3_TXC_vect, ISR_NAKED) {
        __asm__ __volatile__(
              "push      r30"     "\n\t"
              "push      r31"     "\n\t"
              :::);
    6286:	ff 93       	push	r31
    6288:	e6 ed       	ldi	r30, 0xD6	; 214
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART3.cpp:42
#if PROGMEM_SIZE > 8192
              "jmp   _do_txc"     "\n\t"
#else
              "rjmp   _do_txc"    "\n\t"
#endif
              ::"z"(&Serial3));
    628a:	ff e6       	ldi	r31, 0x6F	; 111
    628c:	5f c0       	rjmp	.+190    	; 0x634c <_do_txc()>

0000628e <_do_dre()>:
_Z7_do_drev():
    628e:	2f 93       	push	r18
    6290:	2f b7       	in	r18, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:387
          "out        0x3f,     r18"      "\n\t"  // restore SREG
          "pop         r18"               "\n\t"  // pop old r18
          "pop         r31"               "\n\t"  // pop the Z that the isr pushed.
          "pop         r30"               "\n\t"
          "reti"                          "\n"   // and RETI!
          ::);
    6292:	2f 93       	push	r18
    6294:	8f 93       	push	r24
    6296:	9f 93       	push	r25
    6298:	af 93       	push	r26
    629a:	bf 93       	push	r27
    629c:	68 94       	set

0000629e <_poll_dre>:
    629e:	cf 93       	push	r28
    62a0:	df 93       	push	r29
    62a2:	20 e0       	ldi	r18, 0x00	; 0
    62a4:	c0 85       	ldd	r28, Z+8	; 0x08
    62a6:	d8 e0       	ldi	r29, 0x08	; 8
    62a8:	92 89       	ldd	r25, Z+18	; 0x12
    62aa:	df 01       	movw	r26, r30
    62ac:	a9 0f       	add	r26, r25
    62ae:	b2 1f       	adc	r27, r18
    62b0:	ad 5a       	subi	r26, 0xAD	; 173
    62b2:	bf 4f       	sbci	r27, 0xFF	; 255
    62b4:	8c 91       	ld	r24, X
    62b6:	20 e4       	ldi	r18, 0x40	; 64
    62b8:	2c 83       	std	Y+4, r18	; 0x04
    62ba:	8a 83       	std	Y+2, r24	; 0x02
    62bc:	9f 5f       	subi	r25, 0xFF	; 255
    62be:	9f 73       	andi	r25, 0x3F	; 63
    62c0:	8d 81       	ldd	r24, Y+5	; 0x05
    62c2:	21 89       	ldd	r18, Z+17	; 0x11
    62c4:	29 13       	cpse	r18, r25
    62c6:	02 c0       	rjmp	.+4      	; 0x62cc <_done_dre_irq>
    62c8:	8f 7d       	andi	r24, 0xDF	; 223
    62ca:	8d 83       	std	Y+5, r24	; 0x05

000062cc <_done_dre_irq>:
    62cc:	92 8b       	std	Z+18, r25	; 0x12
    62ce:	df 91       	pop	r29
    62d0:	cf 91       	pop	r28
    62d2:	16 f0       	brts	.+4      	; 0x62d8 <_done_dre_irq+0xc>
    62d4:	0c 94 a7 03 	jmp	0x74e	; 0x74e <_poll_dre_done>
    62d8:	bf 91       	pop	r27
    62da:	af 91       	pop	r26
    62dc:	9f 91       	pop	r25
    62de:	8f 91       	pop	r24
    62e0:	2f 91       	pop	r18
    62e2:	2f bf       	out	0x3f, r18	; 63
    62e4:	2f 91       	pop	r18
    62e6:	ff 91       	pop	r31
    62e8:	ef 91       	pop	r30
    62ea:	18 95       	reti

000062ec <_do_rxc()>:
_Z7_do_rxcv():
    62ec:	2f 93       	push	r18
    62ee:	2f b7       	in	r18, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:252
            "pop        r30"              "\n\t" // pointer to serial instance
            "reti"                        "\n\t" // return
          "_buff_full_rxc:"               "\n\t" // _buff_full_rxc moved to after the reti, and then rjmps back, saving 2 clocks for the common case
            "ori        r19,      0x40"   "\n\t" // record that there was a ring buffer overflow. 1 clk
            "rjmp _end_rxc"               "\n\t" // and now jump back to end. That way we don't need to jump over this in the middle of the common case.
            ::); // total: 77 or 79 clocks, just barely squeaks by for cyclic RX of up to RX_BUFFER_SIZE characters.
    62f0:	2f 93       	push	r18
    62f2:	3f 93       	push	r19
    62f4:	8f 93       	push	r24
    62f6:	9f 93       	push	r25
    62f8:	cf 93       	push	r28
    62fa:	df 93       	push	r29
    62fc:	c0 85       	ldd	r28, Z+8	; 0x08
    62fe:	d8 e0       	ldi	r29, 0x08	; 8
    6300:	2e 81       	ldd	r18, Y+6	; 0x06
    6302:	2f 7e       	andi	r18, 0xEF	; 239
    6304:	2e 83       	std	Y+6, r18	; 0x06
    6306:	89 81       	ldd	r24, Y+1	; 0x01
    6308:	98 81       	ld	r25, Y
    630a:	86 74       	andi	r24, 0x46	; 70
    630c:	88 0f       	add	r24, r24
    630e:	36 85       	ldd	r19, Z+14	; 0x0e
    6310:	38 2b       	or	r19, r24
    6312:	82 fd       	sbrc	r24, 2
    6314:	0d c0       	rjmp	.+26     	; 0x6330 <_end_rxc>
    6316:	c7 85       	ldd	r28, Z+15	; 0x0f
    6318:	81 e0       	ldi	r24, 0x01	; 1
    631a:	8c 0f       	add	r24, r28
    631c:	8f 73       	andi	r24, 0x3F	; 63
    631e:	20 89       	ldd	r18, Z+16	; 0x10
    6320:	28 17       	cp	r18, r24
    6322:	91 f0       	breq	.+36     	; 0x6348 <_buff_full_rxc>
    6324:	ce 0f       	add	r28, r30
    6326:	df 2f       	mov	r29, r31
    6328:	20 e0       	ldi	r18, 0x00	; 0
    632a:	d2 1f       	adc	r29, r18
    632c:	9b 8b       	std	Y+19, r25	; 0x13
    632e:	87 87       	std	Z+15, r24	; 0x0f

00006330 <_end_rxc>:
    6330:	36 87       	std	Z+14, r19	; 0x0e
    6332:	df 91       	pop	r29
    6334:	cf 91       	pop	r28
    6336:	9f 91       	pop	r25
    6338:	8f 91       	pop	r24
    633a:	3f 91       	pop	r19
    633c:	2f 91       	pop	r18
    633e:	2f bf       	out	0x3f, r18	; 63
    6340:	2f 91       	pop	r18
    6342:	ff 91       	pop	r31
    6344:	ef 91       	pop	r30
    6346:	18 95       	reti

00006348 <_buff_full_rxc>:
    6348:	30 64       	ori	r19, 0x40	; 64
    634a:	f2 cf       	rjmp	.-28     	; 0x6330 <_end_rxc>

0000634c <_do_txc()>:
_Z7_do_txcv():
    634c:	8f 93       	push	r24
    634e:	8f b7       	in	r24, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:127
            "pop        r24"              "\n\t"  // pop r24 restore it
            "pop        r31"              "\n\t"  // and r31
            "pop        r30"              "\n\t"  // Pop the register the ISR did
            "reti"                        "\n"    // return from the interrupt.
            ::
          );
    6350:	8f 93       	push	r24
    6352:	9f 93       	push	r25
    6354:	cf 93       	push	r28
    6356:	df 93       	push	r29
    6358:	c0 85       	ldd	r28, Z+8	; 0x08
    635a:	d8 e0       	ldi	r29, 0x08	; 8
    635c:	9d 81       	ldd	r25, Y+5	; 0x05

0000635e <_txc_flush_rx>:
    635e:	88 81       	ld	r24, Y
    6360:	8c 81       	ldd	r24, Y+4	; 0x04
    6362:	87 fd       	sbrc	r24, 7
    6364:	fc cf       	rjmp	.-8      	; 0x635e <_txc_flush_rx>
    6366:	9f 7b       	andi	r25, 0xBF	; 191
    6368:	90 68       	ori	r25, 0x80	; 128
    636a:	9d 83       	std	Y+5, r25	; 0x05
    636c:	df 91       	pop	r29
    636e:	cf 91       	pop	r28
    6370:	9f 91       	pop	r25
    6372:	8f 91       	pop	r24
    6374:	8f bf       	out	0x3f, r24	; 63
    6376:	8f 91       	pop	r24
    6378:	ff 91       	pop	r31
    637a:	ef 91       	pop	r30
    637c:	18 95       	reti

0000637e <__vector_42>:
__vector_42():
    637e:	1f 92       	push	r1
    6380:	0f 92       	push	r0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:986

/**
 *@brief      TWI1 Slave Interrupt vector
 */
#if defined(TWI1)
  ISR(TWI1_TWIS_vect) {
    6382:	0f b6       	in	r0, 0x3f	; 63
    6384:	0f 92       	push	r0
    6386:	11 24       	eor	r1, r1
    6388:	0b b6       	in	r0, 0x3b	; 59
    638a:	0f 92       	push	r0
    638c:	2f 93       	push	r18
    638e:	3f 93       	push	r19
    6390:	4f 93       	push	r20
    6392:	5f 93       	push	r21
    6394:	6f 93       	push	r22
    6396:	7f 93       	push	r23
    6398:	8f 93       	push	r24
    639a:	9f 93       	push	r25
    639c:	af 93       	push	r26
    639e:	bf 93       	push	r27
    63a0:	ef 93       	push	r30
    63a2:	ff 93       	push	r31
onSlaveIRQ():
    63a4:	84 e8       	ldi	r24, 0x84	; 132
    63a6:	9d e6       	ldi	r25, 0x6D	; 109
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:929
                                                    // Wire interfaces. Here is decoded which interrupt was fired.
  #if defined(TWI1) &&  defined(TWI_USING_WIRE1)   // Two TWIs available and TWI1 is used. Need to check the module
    if (module == &TWI0) {
      TWI_HandleSlaveIRQ(&(Wire.vars));
    } else if (module == &TWI1) {
      TWI_HandleSlaveIRQ(&(Wire1.vars));
    63a8:	0e 94 16 04 	call	0x82c	; 0x82c <TWI_HandleSlaveIRQ>
__vector_42():
    63ac:	ff 91       	pop	r31
    63ae:	ef 91       	pop	r30
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:988
 *@brief      TWI1 Slave Interrupt vector
 */
#if defined(TWI1)
  ISR(TWI1_TWIS_vect) {
    TwoWire::onSlaveIRQ(&TWI1);
  }
    63b0:	bf 91       	pop	r27
    63b2:	af 91       	pop	r26
    63b4:	9f 91       	pop	r25
    63b6:	8f 91       	pop	r24
    63b8:	7f 91       	pop	r23
    63ba:	6f 91       	pop	r22
    63bc:	5f 91       	pop	r21
    63be:	4f 91       	pop	r20
    63c0:	3f 91       	pop	r19
    63c2:	2f 91       	pop	r18
    63c4:	0f 90       	pop	r0
    63c6:	0b be       	out	0x3b, r0	; 59
    63c8:	0f 90       	pop	r0
    63ca:	0f be       	out	0x3f, r0	; 63
    63cc:	0f 90       	pop	r0
    63ce:	1f 90       	pop	r1
    63d0:	18 95       	reti

000063d2 <__vector_18>:
__vector_18():
    63d2:	1f 92       	push	r1
    63d4:	0f 92       	push	r0
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:977


/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
    63d6:	0f b6       	in	r0, 0x3f	; 63
    63d8:	0f 92       	push	r0
    63da:	11 24       	eor	r1, r1
    63dc:	0b b6       	in	r0, 0x3b	; 59
    63de:	0f 92       	push	r0
    63e0:	2f 93       	push	r18
    63e2:	3f 93       	push	r19
    63e4:	4f 93       	push	r20
    63e6:	5f 93       	push	r21
    63e8:	6f 93       	push	r22
    63ea:	7f 93       	push	r23
    63ec:	8f 93       	push	r24
    63ee:	9f 93       	push	r25
    63f0:	af 93       	push	r26
    63f2:	bf 93       	push	r27
    63f4:	ef 93       	push	r30
    63f6:	ff 93       	push	r31
onSlaveIRQ():
    63f8:	8d e9       	ldi	r24, 0x9D	; 157
    63fa:	9e e6       	ldi	r25, 0x6E	; 110
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:927
 */
void TwoWire::onSlaveIRQ(TWI_t *module) {          // This function is static and is, thus, the only one for both
                                                    // Wire interfaces. Here is decoded which interrupt was fired.
  #if defined(TWI1) &&  defined(TWI_USING_WIRE1)   // Two TWIs available and TWI1 is used. Need to check the module
    if (module == &TWI0) {
      TWI_HandleSlaveIRQ(&(Wire.vars));
    63fc:	0e 94 16 04 	call	0x82c	; 0x82c <TWI_HandleSlaveIRQ>
__vector_18():
    6400:	ff 91       	pop	r31
    6402:	ef 91       	pop	r30
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\libraries\Wire\src/Wire.cpp:979
/**
 *@brief      TWI0 Slave Interrupt vector
 */
ISR(TWI0_TWIS_vect) {
  TwoWire::onSlaveIRQ(&TWI0);
}
    6404:	bf 91       	pop	r27
    6406:	af 91       	pop	r26
    6408:	9f 91       	pop	r25
    640a:	8f 91       	pop	r24
    640c:	7f 91       	pop	r23
    640e:	6f 91       	pop	r22
    6410:	5f 91       	pop	r21
    6412:	4f 91       	pop	r20
    6414:	3f 91       	pop	r19
    6416:	2f 91       	pop	r18
    6418:	0f 90       	pop	r0
    641a:	0b be       	out	0x3b, r0	; 59
    641c:	0f 90       	pop	r0
    641e:	0f be       	out	0x3f, r0	; 63
    6420:	0f 90       	pop	r0
    6422:	1f 90       	pop	r1
    6424:	18 95       	reti

00006426 <__vector_33>:
__vector_33():
    6426:	1f 92       	push	r1
    6428:	0f 92       	push	r0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:462
/**
 * @brief Data register empty. Allows us to keep track of when the data has
 * been transmitted on the line and set up new data to be transmitted from
 * the ring buffer.
 */
ISR(USART1_DRE_vect) {
    642a:	0f b6       	in	r0, 0x3f	; 63
    642c:	0f 92       	push	r0
    642e:	11 24       	eor	r1, r1
    6430:	0b b6       	in	r0, 0x3b	; 59
    6432:	0f 92       	push	r0
    6434:	8f 93       	push	r24
    6436:	9f 93       	push	r25
    6438:	ef 93       	push	r30
    643a:	ff 93       	push	r31
    643c:	80 91 b1 6a 	lds	r24, 0x6AB1	; 0x806ab1 <tx_num_elements>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:463
    if (tx_num_elements != 0) {
    6440:	90 91 b2 6a 	lds	r25, 0x6AB2	; 0x806ab2 <tx_num_elements+0x1>
    6444:	89 2b       	or	r24, r25
    6446:	39 f1       	breq	.+78     	; 0x6496 <__vector_33+0x70>
    6448:	80 91 23 64 	lds	r24, 0x6423	; 0x806423 <tx_tail_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:464
        tx_tail_index      = (tx_tail_index + 1) & TX_BUFFER_MASK;
    644c:	90 91 24 64 	lds	r25, 0x6424	; 0x806424 <tx_tail_index+0x1>
    6450:	01 96       	adiw	r24, 0x01	; 1
    6452:	91 70       	andi	r25, 0x01	; 1
    6454:	80 93 23 64 	sts	0x6423, r24	; 0x806423 <tx_tail_index>
    6458:	90 93 24 64 	sts	0x6424, r25	; 0x806424 <tx_tail_index+0x1>
    645c:	e0 91 23 64 	lds	r30, 0x6423	; 0x806423 <tx_tail_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:465
        HWSERIALAT.TXDATAL = tx_buffer[tx_tail_index];
    6460:	f0 91 24 64 	lds	r31, 0x6424	; 0x806424 <tx_tail_index+0x1>
    6464:	e1 55       	subi	r30, 0x51	; 81
    6466:	f7 49       	sbci	r31, 0x97	; 151
    6468:	80 81       	ld	r24, Z
    646a:	80 93 22 08 	sts	0x0822, r24	; 0x800822 <__TEXT_REGION_LENGTH__+0x7e0822>
    646e:	80 91 b1 6a 	lds	r24, 0x6AB1	; 0x806ab1 <tx_num_elements>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:466
        tx_num_elements--;
    6472:	90 91 b2 6a 	lds	r25, 0x6AB2	; 0x806ab2 <tx_num_elements+0x1>
    6476:	01 97       	sbiw	r24, 0x01	; 1
    6478:	80 93 b1 6a 	sts	0x6AB1, r24	; 0x806ab1 <tx_num_elements>
    647c:	90 93 b2 6a 	sts	0x6AB2, r25	; 0x806ab2 <tx_num_elements+0x1>
    6480:	ff 91       	pop	r31
    6482:	ef 91       	pop	r30
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:470
    } else {
        HWSERIALAT.CTRLA &= (~USART_DREIE_bm);
    }
}
    6484:	9f 91       	pop	r25
    6486:	8f 91       	pop	r24
    6488:	0f 90       	pop	r0
    648a:	0b be       	out	0x3b, r0	; 59
    648c:	0f 90       	pop	r0
    648e:	0f be       	out	0x3f, r0	; 63
    6490:	0f 90       	pop	r0
    6492:	1f 90       	pop	r1
    6494:	18 95       	reti
    6496:	80 91 25 08 	lds	r24, 0x0825	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:468
    if (tx_num_elements != 0) {
        tx_tail_index      = (tx_tail_index + 1) & TX_BUFFER_MASK;
        HWSERIALAT.TXDATAL = tx_buffer[tx_tail_index];
        tx_num_elements--;
    } else {
        HWSERIALAT.CTRLA &= (~USART_DREIE_bm);
    649a:	8f 7d       	andi	r24, 0xDF	; 223
    649c:	80 93 25 08 	sts	0x0825, r24	; 0x800825 <__TEXT_REGION_LENGTH__+0x7e0825>
    64a0:	ef cf       	rjmp	.-34     	; 0x6480 <__vector_33+0x5a>

000064a2 <__vector_32>:
__vector_32():
    64a2:	1f 92       	push	r1
    64a4:	0f 92       	push	r0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:320
        VPORTC.INTFLAGS = RING_INT_bm;
    }
}

// RX complete
ISR(USART1_RXC_vect) {
    64a6:	0f b6       	in	r0, 0x3f	; 63
    64a8:	0f 92       	push	r0
    64aa:	11 24       	eor	r1, r1
    64ac:	0b b6       	in	r0, 0x3b	; 59
    64ae:	0f 92       	push	r0
    64b0:	0f 93       	push	r16
    64b2:	1f 93       	push	r17
    64b4:	2f 93       	push	r18
    64b6:	3f 93       	push	r19
    64b8:	4f 93       	push	r20
    64ba:	5f 93       	push	r21
    64bc:	6f 93       	push	r22
    64be:	7f 93       	push	r23
    64c0:	8f 93       	push	r24
    64c2:	9f 93       	push	r25
    64c4:	af 93       	push	r26
    64c6:	bf 93       	push	r27
    64c8:	cf 93       	push	r28
    64ca:	df 93       	push	r29
    64cc:	ef 93       	push	r30
    64ce:	ff 93       	push	r31
    64d0:	80 91 20 08 	lds	r24, 0x0820	; 0x800820 <__TEXT_REGION_LENGTH__+0x7e0820>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:321
    uint8_t data = USART1.RXDATAL;
    64d4:	20 91 78 6d 	lds	r18, 0x6D78	; 0x806d78 <rx_head_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:325

    // We do an logical AND here as a means of allowing the index to wrap
    // around since we have a circular buffer
    rx_head_index            = (rx_head_index + 1) & RX_BUFFER_MASK;
    64d8:	30 91 79 6d 	lds	r19, 0x6D79	; 0x806d79 <rx_head_index+0x1>
    64dc:	2f 5f       	subi	r18, 0xFF	; 255
    64de:	3f 4f       	sbci	r19, 0xFF	; 255
    64e0:	31 70       	andi	r19, 0x01	; 1
    64e2:	20 93 78 6d 	sts	0x6D78, r18	; 0x806d78 <rx_head_index>
    64e6:	30 93 79 6d 	sts	0x6D79, r19	; 0x806d79 <rx_head_index+0x1>
    64ea:	e0 91 78 6d 	lds	r30, 0x6D78	; 0x806d78 <rx_head_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:326
    rx_buffer[rx_head_index] = data;
    64ee:	f0 91 79 6d 	lds	r31, 0x6D79	; 0x806d79 <rx_head_index+0x1>
    64f2:	e1 55       	subi	r30, 0x51	; 81
    64f4:	f9 49       	sbci	r31, 0x99	; 153
    64f6:	80 83       	st	Z, r24
    64f8:	20 91 7a 6d 	lds	r18, 0x6D7A	; 0x806d7a <rx_num_elements>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:327
    rx_num_elements++;
    64fc:	30 91 7b 6d 	lds	r19, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
    6500:	2f 5f       	subi	r18, 0xFF	; 255
    6502:	3f 4f       	sbci	r19, 0xFF	; 255
    6504:	20 93 7a 6d 	sts	0x6D7A, r18	; 0x806d7a <rx_num_elements>
    6508:	30 93 7b 6d 	sts	0x6D7B, r19	; 0x806d7b <rx_num_elements+0x1>
    650c:	20 91 0c 40 	lds	r18, 0x400C	; 0x80400c <urc_parse_state>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:334
    // Here we keep track of the length of the URC when it starts and
    // compare it against the look up table of lengths of the strings we are
    // looking for. We compare against them first in order to save some
    // cycles in the ISR and if the lengths match, we compare the string for
    // the URC and against the buffer. If they match, call the callback
    switch (urc_parse_state) {
    6510:	30 91 0d 40 	lds	r19, 0x400D	; 0x80400d <urc_parse_state+0x1>
    6514:	21 30       	cpi	r18, 0x01	; 1
    6516:	31 05       	cpc	r19, r1
    6518:	71 f1       	breq	.+92     	; 0x6576 <__vector_32+0xd4>
    651a:	08 f4       	brcc	.+2      	; 0x651e <__vector_32+0x7c>
    651c:	47 c0       	rjmp	.+142    	; 0x65ac <__vector_32+0x10a>
    651e:	22 30       	cpi	r18, 0x02	; 2
    6520:	31 05       	cpc	r19, r1
    6522:	09 f4       	brne	.+2      	; 0x6526 <__vector_32+0x84>
    6524:	d7 c0       	rjmp	.+430    	; 0x66d4 <__vector_32+0x232>
    6526:	23 30       	cpi	r18, 0x03	; 3
    6528:	31 05       	cpc	r19, r1
    652a:	61 f4       	brne	.+24     	; 0x6544 <__vector_32+0xa2>
    652c:	8b 32       	cpi	r24, 0x2B	; 43
    652e:	51 f4       	brne	.+20     	; 0x6544 <__vector_32+0xa2>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:338

    case URC_NOT_PARSING:

        if (data == URC_IDENTIFIER_START_CHARACTER) {
    6530:	10 92 21 64 	sts	0x6421, r1	; 0x806421 <urc_identifier_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:339
            urc_identifier_buffer_length = 0;
    6534:	10 92 22 64 	sts	0x6422, r1	; 0x806422 <urc_identifier_buffer_length+0x1>
    6538:	81 e0       	ldi	r24, 0x01	; 1
    653a:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:340
            urc_parse_state              = URC_EVALUATING_IDENTIFIER;
    653c:	80 93 0c 40 	sts	0x400C, r24	; 0x80400c <urc_parse_state>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:351

        // Some commands return a '+' followed by numbers which can be mistaken
        // for an URC, so we check against that and disregard the data if that
        // is the case
        if (data >= '0' && data <= '9') {
            urc_parse_state = URC_NOT_PARSING;
    6540:	90 93 0d 40 	sts	0x400D, r25	; 0x80400d <urc_parse_state+0x1>
    6544:	0e 94 6f 07 	call	0xede	; 0xede <rtsUpdate()>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:454

    default:
        break;
    }

    rtsUpdate();
    6548:	ff 91       	pop	r31
    654a:	ef 91       	pop	r30
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:455
}
    654c:	df 91       	pop	r29
    654e:	cf 91       	pop	r28
    6550:	bf 91       	pop	r27
    6552:	af 91       	pop	r26
    6554:	9f 91       	pop	r25
    6556:	8f 91       	pop	r24
    6558:	7f 91       	pop	r23
    655a:	6f 91       	pop	r22
    655c:	5f 91       	pop	r21
    655e:	4f 91       	pop	r20
    6560:	3f 91       	pop	r19
    6562:	2f 91       	pop	r18
    6564:	1f 91       	pop	r17
    6566:	0f 91       	pop	r16
    6568:	0f 90       	pop	r0
    656a:	0b be       	out	0x3b, r0	; 59
    656c:	0f 90       	pop	r0
    656e:	0f be       	out	0x3f, r0	; 63
    6570:	0f 90       	pop	r0
    6572:	1f 90       	pop	r1
    6574:	18 95       	reti
    6576:	90 ed       	ldi	r25, 0xD0	; 208
    6578:	98 0f       	add	r25, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:350
    case URC_EVALUATING_IDENTIFIER:

        // Some commands return a '+' followed by numbers which can be mistaken
        // for an URC, so we check against that and disregard the data if that
        // is the case
        if (data >= '0' && data <= '9') {
    657a:	9a 30       	cpi	r25, 0x0A	; 10
    657c:	18 f4       	brcc	.+6      	; 0x6584 <__vector_32+0xe2>
    657e:	83 e0       	ldi	r24, 0x03	; 3
    6580:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:351
            urc_parse_state = URC_NOT_PARSING;
    6582:	dc cf       	rjmp	.-72     	; 0x653c <__vector_32+0x9a>
    6584:	20 91 21 64 	lds	r18, 0x6421	; 0x806421 <urc_identifier_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:353
        } else {
            urc_identifier_buffer[urc_identifier_buffer_length++] = data;
    6588:	30 91 22 64 	lds	r19, 0x6422	; 0x806422 <urc_identifier_buffer_length+0x1>
    658c:	a9 01       	movw	r20, r18
    658e:	4f 5f       	subi	r20, 0xFF	; 255
    6590:	5f 4f       	sbci	r21, 0xFF	; 255
    6592:	40 93 21 64 	sts	0x6421, r20	; 0x806421 <urc_identifier_buffer_length>
    6596:	50 93 22 64 	sts	0x6422, r21	; 0x806422 <urc_identifier_buffer_length+0x1>
    659a:	2b 5f       	subi	r18, 0xFB	; 251
    659c:	3b 49       	sbci	r19, 0x9B	; 155
    659e:	f9 01       	movw	r30, r18
    65a0:	80 83       	st	Z, r24
    65a2:	10 92 0c 40 	sts	0x400C, r1	; 0x80400c <urc_parse_state>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:354
            urc_parse_state = URC_PARSING_IDENTIFIER;
    65a6:	10 92 0d 40 	sts	0x400D, r1	; 0x80400d <urc_parse_state+0x1>
    65aa:	cc cf       	rjmp	.-104    	; 0x6544 <__vector_32+0xa2>
    65ac:	8a 33       	cpi	r24, 0x3A	; 58
    65ae:	19 f0       	breq	.+6      	; 0x65b6 <__vector_32+0x114>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:360
        }
        break;

    case URC_PARSING_IDENTIFIER:

        if (data == URC_IDENTIFIER_END_CHARACTER || data == CARRIAGE_RETURN) {
    65b0:	8d 30       	cpi	r24, 0x0D	; 13
    65b2:	09 f0       	breq	.+2      	; 0x65b6 <__vector_32+0x114>
    65b4:	77 c0       	rjmp	.+238    	; 0x66a4 <__vector_32+0x202>
    65b6:	83 e0       	ldi	r24, 0x03	; 3
    65b8:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:364

            // We set this as the initial condition and if we find a match
            // for the URC we go on parsing the data
            urc_parse_state = URC_NOT_PARSING;
    65ba:	80 93 0c 40 	sts	0x400C, r24	; 0x80400c <urc_parse_state>
    65be:	90 93 0d 40 	sts	0x400D, r25	; 0x80400d <urc_parse_state+0x1>
    65c2:	10 e0       	ldi	r17, 0x00	; 0
    65c4:	00 e0       	ldi	r16, 0x00	; 0
    65c6:	e8 01       	movw	r28, r16
    65c8:	85 e0       	ldi	r24, 0x05	; 5
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:368

            for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {

                if (urcs[i].identifier_length == urc_identifier_buffer_length) {
    65ca:	cc 0f       	add	r28, r28
    65cc:	dd 1f       	adc	r29, r29
    65ce:	8a 95       	dec	r24
    65d0:	e1 f7       	brne	.-8      	; 0x65ca <__vector_32+0x128>
    65d2:	ca 5c       	subi	r28, 0xCA	; 202
    65d4:	d3 49       	sbci	r29, 0x93	; 147
    65d6:	2c 8d       	ldd	r18, Y+28	; 0x1c
    65d8:	80 91 21 64 	lds	r24, 0x6421	; 0x806421 <urc_identifier_buffer_length>
    65dc:	90 91 22 64 	lds	r25, 0x6422	; 0x806422 <urc_identifier_buffer_length+0x1>
    65e0:	28 17       	cp	r18, r24
    65e2:	19 06       	cpc	r1, r25
    65e4:	09 f0       	breq	.+2      	; 0x65e8 <__vector_32+0x146>
    65e6:	57 c0       	rjmp	.+174    	; 0x6696 <__vector_32+0x1f4>
    65e8:	4c 8d       	ldd	r20, Y+28	; 0x1c
    65ea:	50 e0       	ldi	r21, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:371
                    if (memcmp((const void*)urc_identifier_buffer,
                               (const void*)urcs[i].identifier,
                               urcs[i].identifier_length) == 0) {
    65ec:	be 01       	movw	r22, r28
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:369
            urc_parse_state = URC_NOT_PARSING;

            for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {

                if (urcs[i].identifier_length == urc_identifier_buffer_length) {
                    if (memcmp((const void*)urc_identifier_buffer,
    65ee:	85 e0       	ldi	r24, 0x05	; 5
    65f0:	94 e6       	ldi	r25, 0x64	; 100
    65f2:	0e 94 c1 56 	call	0xad82	; 0xad82 <memcmp>
    65f6:	89 2b       	or	r24, r25
    65f8:	09 f0       	breq	.+2      	; 0x65fc <__vector_32+0x15a>
    65fa:	4d c0       	rjmp	.+154    	; 0x6696 <__vector_32+0x1f4>
    65fc:	00 93 04 64 	sts	0x6404, r16	; 0x806404 <urc_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:373
                               (const void*)urcs[i].identifier,
                               urcs[i].identifier_length) == 0) {

                        urc_index            = i;
    6600:	8e 8d       	ldd	r24, Y+30	; 0x1e
    6602:	9f 8d       	ldd	r25, Y+31	; 0x1f
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:374
                        urc_current_callback = urcs[i].callback;
    6604:	80 93 02 64 	sts	0x6402, r24	; 0x806402 <urc_current_callback>
    6608:	90 93 03 64 	sts	0x6403, r25	; 0x806403 <urc_current_callback+0x1>
    660c:	82 e0       	ldi	r24, 0x02	; 2
    660e:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:375
                        urc_parse_state      = URC_PARSING_DATA;
    6610:	80 93 0c 40 	sts	0x400C, r24	; 0x80400c <urc_parse_state>
    6614:	90 93 0d 40 	sts	0x400D, r25	; 0x80400d <urc_parse_state+0x1>
    6618:	e0 91 04 64 	lds	r30, 0x6404	; 0x806404 <urc_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:382
                        // Clear data if requested and if the data hasn't
                        // already been read
                        // We apply the + 2 here as we also want to remove the
                        // start character and the end character of the URC (+
                        // and :/line feed)
                        if (urcs[urc_index].should_clear &&
    661c:	80 e2       	ldi	r24, 0x20	; 32
    661e:	e8 9f       	mul	r30, r24
    6620:	f0 01       	movw	r30, r0
    6622:	11 24       	eor	r1, r1
    6624:	ea 5c       	subi	r30, 0xCA	; 202
    6626:	f3 49       	sbci	r31, 0x93	; 147
    6628:	85 8d       	ldd	r24, Z+29	; 0x1d
    662a:	88 23       	and	r24, r24
    662c:	59 f1       	breq	.+86     	; 0x6684 <__vector_32+0x1e2>
    662e:	80 91 21 64 	lds	r24, 0x6421	; 0x806421 <urc_identifier_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:384
                            rx_num_elements >=
                                (urc_identifier_buffer_length + 2)) {
    6632:	90 91 22 64 	lds	r25, 0x6422	; 0x806422 <urc_identifier_buffer_length+0x1>
    6636:	20 91 7a 6d 	lds	r18, 0x6D7A	; 0x806d7a <rx_num_elements>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:383
                        // already been read
                        // We apply the + 2 here as we also want to remove the
                        // start character and the end character of the URC (+
                        // and :/line feed)
                        if (urcs[urc_index].should_clear &&
                            rx_num_elements >=
    663a:	30 91 7b 6d 	lds	r19, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
    663e:	02 96       	adiw	r24, 0x02	; 2
    6640:	28 17       	cp	r18, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:384
                                (urc_identifier_buffer_length + 2)) {
    6642:	39 07       	cpc	r19, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:382
                        // Clear data if requested and if the data hasn't
                        // already been read
                        // We apply the + 2 here as we also want to remove the
                        // start character and the end character of the URC (+
                        // and :/line feed)
                        if (urcs[urc_index].should_clear &&
    6644:	f8 f0       	brcs	.+62     	; 0x6684 <__vector_32+0x1e2>
    6646:	80 91 78 6d 	lds	r24, 0x6D78	; 0x806d78 <rx_head_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:387
                            rx_num_elements >=
                                (urc_identifier_buffer_length + 2)) {

                            rx_head_index =
                                (rx_head_index -
    664a:	90 91 79 6d 	lds	r25, 0x6D79	; 0x806d79 <rx_head_index+0x1>
    664e:	20 91 21 64 	lds	r18, 0x6421	; 0x806421 <urc_identifier_buffer_length>
    6652:	30 91 22 64 	lds	r19, 0x6422	; 0x806422 <urc_identifier_buffer_length+0x1>
    6656:	02 97       	sbiw	r24, 0x02	; 2
    6658:	82 1b       	sub	r24, r18
    665a:	93 0b       	sbc	r25, r19
    665c:	91 70       	andi	r25, 0x01	; 1
    665e:	80 93 78 6d 	sts	0x6D78, r24	; 0x806d78 <rx_head_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:386
                        // and :/line feed)
                        if (urcs[urc_index].should_clear &&
                            rx_num_elements >=
                                (urc_identifier_buffer_length + 2)) {

                            rx_head_index =
    6662:	90 93 79 6d 	sts	0x6D79, r25	; 0x806d79 <rx_head_index+0x1>
    6666:	20 91 21 64 	lds	r18, 0x6421	; 0x806421 <urc_identifier_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:391
                                (rx_head_index -
                                 (urc_identifier_buffer_length + 2)) &
                                RX_BUFFER_MASK;

                            rx_num_elements -= (urc_identifier_buffer_length +
    666a:	30 91 22 64 	lds	r19, 0x6422	; 0x806422 <urc_identifier_buffer_length+0x1>
    666e:	80 91 7a 6d 	lds	r24, 0x6D7A	; 0x806d7a <rx_num_elements>
    6672:	90 91 7b 6d 	lds	r25, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
    6676:	02 97       	sbiw	r24, 0x02	; 2
    6678:	82 1b       	sub	r24, r18
    667a:	93 0b       	sbc	r25, r19
    667c:	80 93 7a 6d 	sts	0x6D7A, r24	; 0x806d7a <rx_num_elements>
    6680:	90 93 7b 6d 	sts	0x6D7B, r25	; 0x806d7b <rx_num_elements+0x1>
    6684:	10 92 00 64 	sts	0x6400, r1	; 0x806400 <urc_data_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:397
                                                2);
                        }

                        // Reset the index in order to prepare the URC
                        // buffer for data
                        urc_data_buffer_length = 0;
    6688:	10 92 01 64 	sts	0x6401, r1	; 0x806401 <urc_data_buffer_length+0x1>
    668c:	10 92 21 64 	sts	0x6421, r1	; 0x806421 <urc_identifier_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:403

                        break;
                    }
                }
            }
            urc_identifier_buffer_length = 0;
    6690:	10 92 22 64 	sts	0x6422, r1	; 0x806422 <urc_identifier_buffer_length+0x1>
    6694:	57 cf       	rjmp	.-338    	; 0x6544 <__vector_32+0xa2>
    6696:	0f 5f       	subi	r16, 0xFF	; 255
    6698:	1f 4f       	sbci	r17, 0xFF	; 255
    669a:	0a 30       	cpi	r16, 0x0A	; 10
    669c:	11 05       	cpc	r17, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:366

            // We set this as the initial condition and if we find a match
            // for the URC we go on parsing the data
            urc_parse_state = URC_NOT_PARSING;

            for (uint8_t i = 0; i < MAX_URC_CALLBACKS; i++) {
    669e:	09 f0       	breq	.+2      	; 0x66a2 <__vector_32+0x200>
    66a0:	92 cf       	rjmp	.-220    	; 0x65c6 <__vector_32+0x124>
    66a2:	f4 cf       	rjmp	.-24     	; 0x668c <__vector_32+0x1ea>
    66a4:	20 91 21 64 	lds	r18, 0x6421	; 0x806421 <urc_identifier_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:405
                    }
                }
            }
            urc_identifier_buffer_length = 0;

        } else if (urc_identifier_buffer_length == URC_IDENTIFIER_BUFFER_SIZE) {
    66a8:	30 91 22 64 	lds	r19, 0x6422	; 0x806422 <urc_identifier_buffer_length+0x1>
    66ac:	2c 31       	cpi	r18, 0x1C	; 28
    66ae:	31 05       	cpc	r19, r1
    66b0:	09 f4       	brne	.+2      	; 0x66b4 <__vector_32+0x212>
    66b2:	65 cf       	rjmp	.-310    	; 0x657e <__vector_32+0xdc>
    66b4:	20 91 21 64 	lds	r18, 0x6421	; 0x806421 <urc_identifier_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:408
            urc_parse_state = URC_NOT_PARSING;
        } else {
            urc_identifier_buffer[urc_identifier_buffer_length++] = data;
    66b8:	30 91 22 64 	lds	r19, 0x6422	; 0x806422 <urc_identifier_buffer_length+0x1>
    66bc:	a9 01       	movw	r20, r18
    66be:	4f 5f       	subi	r20, 0xFF	; 255
    66c0:	5f 4f       	sbci	r21, 0xFF	; 255
    66c2:	40 93 21 64 	sts	0x6421, r20	; 0x806421 <urc_identifier_buffer_length>
    66c6:	50 93 22 64 	sts	0x6422, r21	; 0x806422 <urc_identifier_buffer_length+0x1>
    66ca:	2b 5f       	subi	r18, 0xFB	; 251
    66cc:	3b 49       	sbci	r19, 0x9B	; 155
    66ce:	f9 01       	movw	r30, r18
    66d0:	80 83       	st	Z, r24
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:446

        } else if (urc_data_buffer_length == URC_DATA_BUFFER_SIZE) {
            // This is just a failsafe
            urc_parse_state = URC_NOT_PARSING;
        } else {
            urc_data_buffer[urc_data_buffer_length++] = data;
    66d2:	38 cf       	rjmp	.-400    	; 0x6544 <__vector_32+0xa2>
    66d4:	8d 30       	cpi	r24, 0x0D	; 13
    66d6:	19 f0       	breq	.+6      	; 0x66de <__vector_32+0x23c>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:415

        break;

    case URC_PARSING_DATA:

        if (data == CARRIAGE_RETURN || data == LINE_FEED) {
    66d8:	8a 30       	cpi	r24, 0x0A	; 10
    66da:	09 f0       	breq	.+2      	; 0x66de <__vector_32+0x23c>
    66dc:	57 c0       	rjmp	.+174    	; 0x678c <__vector_32+0x2ea>
    66de:	e0 91 00 64 	lds	r30, 0x6400	; 0x806400 <urc_data_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:418

            // Add termination since we're done
            urc_data_buffer[urc_data_buffer_length] = 0;
    66e2:	f0 91 01 64 	lds	r31, 0x6401	; 0x806401 <urc_data_buffer_length+0x1>
    66e6:	e0 58       	subi	r30, 0x80	; 128
    66e8:	fd 49       	sbci	r31, 0x9D	; 157
    66ea:	10 82       	st	Z, r1
    66ec:	e0 91 04 64 	lds	r30, 0x6404	; 0x806404 <urc_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:422

            // Clear the buffer for the URC if requested and if it already
            // hasn't been read
            if (urcs[urc_index].should_clear &&
    66f0:	80 e2       	ldi	r24, 0x20	; 32
    66f2:	e8 9f       	mul	r30, r24
    66f4:	f0 01       	movw	r30, r0
    66f6:	11 24       	eor	r1, r1
    66f8:	ea 5c       	subi	r30, 0xCA	; 202
    66fa:	f3 49       	sbci	r31, 0x93	; 147
    66fc:	85 8d       	ldd	r24, Z+29	; 0x1d
    66fe:	88 23       	and	r24, r24
    6700:	41 f1       	breq	.+80     	; 0x6752 <__vector_32+0x2b0>
    6702:	20 91 7a 6d 	lds	r18, 0x6D7A	; 0x806d7a <rx_num_elements>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:423
                rx_num_elements >= urc_data_buffer_length) {
    6706:	30 91 7b 6d 	lds	r19, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
    670a:	80 91 00 64 	lds	r24, 0x6400	; 0x806400 <urc_data_buffer_length>
    670e:	90 91 01 64 	lds	r25, 0x6401	; 0x806401 <urc_data_buffer_length+0x1>
    6712:	28 17       	cp	r18, r24
    6714:	39 07       	cpc	r19, r25
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:422
            // Add termination since we're done
            urc_data_buffer[urc_data_buffer_length] = 0;

            // Clear the buffer for the URC if requested and if it already
            // hasn't been read
            if (urcs[urc_index].should_clear &&
    6716:	e8 f0       	brcs	.+58     	; 0x6752 <__vector_32+0x2b0>
    6718:	80 91 78 6d 	lds	r24, 0x6D78	; 0x806d78 <rx_head_index>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:425
                rx_num_elements >= urc_data_buffer_length) {

                rx_head_index = (rx_head_index - urc_data_buffer_length) &
    671c:	90 91 79 6d 	lds	r25, 0x6D79	; 0x806d79 <rx_head_index+0x1>
    6720:	20 91 00 64 	lds	r18, 0x6400	; 0x806400 <urc_data_buffer_length>
    6724:	30 91 01 64 	lds	r19, 0x6401	; 0x806401 <urc_data_buffer_length+0x1>
    6728:	82 1b       	sub	r24, r18
    672a:	93 0b       	sbc	r25, r19
    672c:	91 70       	andi	r25, 0x01	; 1
    672e:	80 93 78 6d 	sts	0x6D78, r24	; 0x806d78 <rx_head_index>
    6732:	90 93 79 6d 	sts	0x6D79, r25	; 0x806d79 <rx_head_index+0x1>
    6736:	80 91 7a 6d 	lds	r24, 0x6D7A	; 0x806d7a <rx_num_elements>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:427
                                RX_BUFFER_MASK;
                rx_num_elements = (rx_num_elements - urc_data_buffer_length);
    673a:	90 91 7b 6d 	lds	r25, 0x6D7B	; 0x806d7b <rx_num_elements+0x1>
    673e:	20 91 00 64 	lds	r18, 0x6400	; 0x806400 <urc_data_buffer_length>
    6742:	30 91 01 64 	lds	r19, 0x6401	; 0x806401 <urc_data_buffer_length+0x1>
    6746:	82 1b       	sub	r24, r18
    6748:	93 0b       	sbc	r25, r19
    674a:	80 93 7a 6d 	sts	0x6D7A, r24	; 0x806d7a <rx_num_elements>
    674e:	90 93 7b 6d 	sts	0x6D7B, r25	; 0x806d7b <rx_num_elements+0x1>
    6752:	e0 91 02 64 	lds	r30, 0x6402	; 0x806402 <urc_current_callback>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:430
            }

            if (urc_current_callback != NULL) {
    6756:	f0 91 03 64 	lds	r31, 0x6403	; 0x806403 <urc_current_callback+0x1>
    675a:	30 97       	sbiw	r30, 0x00	; 0
    675c:	61 f0       	breq	.+24     	; 0x6776 <__vector_32+0x2d4>
    675e:	c0 e8       	ldi	r28, 0x80	; 128
    6760:	c0 93 45 04 	sts	0x0445, r28	; 0x800445 <__TEXT_REGION_LENGTH__+0x7e0445>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:433
                // Apply flow control here for the modem, we make it wait to
                // send more data until we've finished the URC callback
                RTS_PORT.OUTSET = RTS_PIN_bm;
    6764:	80 e8       	ldi	r24, 0x80	; 128
    6766:	92 e6       	ldi	r25, 0x62	; 98
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:434
                urc_current_callback((char*)urc_data_buffer);
    6768:	09 95       	icall
    676a:	10 92 02 64 	sts	0x6402, r1	; 0x806402 <urc_current_callback>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:435
                urc_current_callback = NULL;
    676e:	10 92 03 64 	sts	0x6403, r1	; 0x806403 <urc_current_callback+0x1>
    6772:	c0 93 46 04 	sts	0x0446, r28	; 0x800446 <__TEXT_REGION_LENGTH__+0x7e0446>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:436
                RTS_PORT.OUTCLR      = RTS_PIN_bm;
    6776:	83 e0       	ldi	r24, 0x03	; 3
    6778:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:439
            }

            urc_parse_state        = URC_NOT_PARSING;
    677a:	80 93 0c 40 	sts	0x400C, r24	; 0x80400c <urc_parse_state>
    677e:	90 93 0d 40 	sts	0x400D, r25	; 0x80400d <urc_parse_state+0x1>
    6782:	10 92 00 64 	sts	0x6400, r1	; 0x806400 <urc_data_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:440
            urc_data_buffer_length = 0;
    6786:	10 92 01 64 	sts	0x6401, r1	; 0x806401 <urc_data_buffer_length+0x1>
    678a:	dc ce       	rjmp	.-584    	; 0x6544 <__vector_32+0xa2>
    678c:	20 91 00 64 	lds	r18, 0x6400	; 0x806400 <urc_data_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:442

        } else if (urc_data_buffer_length == URC_DATA_BUFFER_SIZE) {
    6790:	30 91 01 64 	lds	r19, 0x6401	; 0x806401 <urc_data_buffer_length+0x1>
    6794:	20 38       	cpi	r18, 0x80	; 128
    6796:	31 40       	sbci	r19, 0x01	; 1
    6798:	09 f4       	brne	.+2      	; 0x679c <__vector_32+0x2fa>
    679a:	f1 ce       	rjmp	.-542    	; 0x657e <__vector_32+0xdc>
    679c:	20 91 00 64 	lds	r18, 0x6400	; 0x806400 <urc_data_buffer_length>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/sequans_controller.cpp:446
            // This is just a failsafe
            urc_parse_state = URC_NOT_PARSING;
        } else {
            urc_data_buffer[urc_data_buffer_length++] = data;
    67a0:	30 91 01 64 	lds	r19, 0x6401	; 0x806401 <urc_data_buffer_length+0x1>
    67a4:	a9 01       	movw	r20, r18
    67a6:	4f 5f       	subi	r20, 0xFF	; 255
    67a8:	5f 4f       	sbci	r21, 0xFF	; 255
    67aa:	40 93 00 64 	sts	0x6400, r20	; 0x806400 <urc_data_buffer_length>
    67ae:	50 93 01 64 	sts	0x6401, r21	; 0x806401 <urc_data_buffer_length+0x1>
    67b2:	20 58       	subi	r18, 0x80	; 128
    67b4:	3d 49       	sbci	r19, 0x9D	; 157
    67b6:	8b cf       	rjmp	.-234    	; 0x66ce <__vector_32+0x22c>

000067b8 <__vector_6>:
__vector_6():
    67b8:	1f 92       	push	r1
    67ba:	0f 92       	push	r0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/low_power.cpp:134
/**
 * @brief Contains stored values of the OUT register for the respective ports.
 */
static uint8_t pin_out_state[6];

ISR(RTC_PIT_vect) {
    67bc:	0f b6       	in	r0, 0x3f	; 63
    67be:	0f 92       	push	r0
    67c0:	11 24       	eor	r1, r1
    67c2:	8f 93       	push	r24
    67c4:	81 e0       	ldi	r24, 0x01	; 1
    67c6:	80 93 53 01 	sts	0x0153, r24	; 0x800153 <__TEXT_REGION_LENGTH__+0x7e0153>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/low_power.cpp:135
    RTC.PITINTFLAGS = RTC_PI_bm;
    67ca:	80 93 7e 62 	sts	0x627E, r24	; 0x80627e <pit_triggered>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/low_power.cpp:136
    pit_triggered   = true;
    67ce:	8f 91       	pop	r24
    67d0:	0f 90       	pop	r0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/low_power.cpp:137
}
    67d2:	0f be       	out	0x3f, r0	; 63
    67d4:	0f 90       	pop	r0
    67d6:	1f 90       	pop	r1
    67d8:	18 95       	reti

000067da <gmtime>:
gmtime():
    67da:	67 e8       	ldi	r22, 0x87	; 135
    67dc:	70 e7       	ldi	r23, 0x70	; 112
    67de:	03 d0       	rcall	.+6      	; 0x67e6 <gmtime_r>
    67e0:	87 e8       	ldi	r24, 0x87	; 135
    67e2:	90 e7       	ldi	r25, 0x70	; 112
    67e4:	08 95       	ret

000067e6 <gmtime_r>:
gmtime_r():
    67e6:	cf 92       	push	r12
    67e8:	df 92       	push	r13
    67ea:	ef 92       	push	r14
    67ec:	ff 92       	push	r15
    67ee:	0f 93       	push	r16
    67f0:	1f 93       	push	r17
    67f2:	cf 93       	push	r28
    67f4:	df 93       	push	r29
    67f6:	cd b7       	in	r28, 0x3d	; 61
    67f8:	de b7       	in	r29, 0x3e	; 62
    67fa:	28 97       	sbiw	r28, 0x08	; 8
    67fc:	cd bf       	out	0x3d, r28	; 61
    67fe:	de bf       	out	0x3e, r29	; 62
    6800:	8b 01       	movw	r16, r22
    6802:	fc 01       	movw	r30, r24
    6804:	60 81       	ld	r22, Z
    6806:	71 81       	ldd	r23, Z+1	; 0x01
    6808:	82 81       	ldd	r24, Z+2	; 0x02
    680a:	93 81       	ldd	r25, Z+3	; 0x03
    680c:	20 e8       	ldi	r18, 0x80	; 128
    680e:	31 e5       	ldi	r19, 0x51	; 81
    6810:	41 e0       	ldi	r20, 0x01	; 1
    6812:	50 e0       	ldi	r21, 0x00	; 0
    6814:	0e 94 79 52 	call	0xa4f2	; 0xa4f2 <__udivmodsi4>
    6818:	69 01       	movw	r12, r18
    681a:	7a 01       	movw	r14, r20
    681c:	2c e3       	ldi	r18, 0x3C	; 60
    681e:	30 e0       	ldi	r19, 0x00	; 0
    6820:	40 e0       	ldi	r20, 0x00	; 0
    6822:	50 e0       	ldi	r21, 0x00	; 0
    6824:	0e 94 9b 52 	call	0xa536	; 0xa536 <__divmodsi4>
    6828:	29 83       	std	Y+1, r18	; 0x01
    682a:	3a 83       	std	Y+2, r19	; 0x02
    682c:	4b 83       	std	Y+3, r20	; 0x03
    682e:	5c 83       	std	Y+4, r21	; 0x04
    6830:	89 81       	ldd	r24, Y+1	; 0x01
    6832:	9a 81       	ldd	r25, Y+2	; 0x02
    6834:	ab 81       	ldd	r26, Y+3	; 0x03
    6836:	bc 81       	ldd	r27, Y+4	; 0x04
    6838:	f8 01       	movw	r30, r16
    683a:	60 83       	st	Z, r22
    683c:	6c e3       	ldi	r22, 0x3C	; 60
    683e:	70 e0       	ldi	r23, 0x00	; 0
    6840:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    6844:	dc 01       	movw	r26, r24
    6846:	f8 01       	movw	r30, r16
    6848:	a1 83       	std	Z+1, r26	; 0x01
    684a:	62 83       	std	Z+2, r22	; 0x02
    684c:	c6 01       	movw	r24, r12
    684e:	06 96       	adiw	r24, 0x06	; 6
    6850:	67 e0       	ldi	r22, 0x07	; 7
    6852:	70 e0       	ldi	r23, 0x00	; 0
    6854:	0e 94 52 52 	call	0xa4a4	; 0xa4a4 <__udivmodhi4>
    6858:	84 83       	std	Z+4, r24	; 0x04
    685a:	2d ea       	ldi	r18, 0xAD	; 173
    685c:	3e e8       	ldi	r19, 0x8E	; 142
    685e:	40 e0       	ldi	r20, 0x00	; 0
    6860:	50 e0       	ldi	r21, 0x00	; 0
    6862:	c7 01       	movw	r24, r14
    6864:	b6 01       	movw	r22, r12
    6866:	0e 94 9b 52 	call	0xa536	; 0xa536 <__divmodsi4>
    686a:	29 83       	std	Y+1, r18	; 0x01
    686c:	3a 83       	std	Y+2, r19	; 0x02
    686e:	6d 83       	std	Y+5, r22	; 0x05
    6870:	7e 83       	std	Y+6, r23	; 0x06
    6872:	8f 83       	std	Y+7, r24	; 0x07
    6874:	98 87       	std	Y+8, r25	; 0x08
    6876:	89 81       	ldd	r24, Y+1	; 0x01
    6878:	9a 81       	ldd	r25, Y+2	; 0x02
    687a:	24 e6       	ldi	r18, 0x64	; 100
    687c:	28 9f       	mul	r18, r24
    687e:	60 01       	movw	r12, r0
    6880:	29 9f       	mul	r18, r25
    6882:	d0 0c       	add	r13, r0
    6884:	11 24       	eor	r1, r1
    6886:	6d 81       	ldd	r22, Y+5	; 0x05
    6888:	7e 81       	ldd	r23, Y+6	; 0x06
    688a:	8f 81       	ldd	r24, Y+7	; 0x07
    688c:	98 85       	ldd	r25, Y+8	; 0x08
    688e:	25 eb       	ldi	r18, 0xB5	; 181
    6890:	35 e0       	ldi	r19, 0x05	; 5
    6892:	40 e0       	ldi	r20, 0x00	; 0
    6894:	50 e0       	ldi	r21, 0x00	; 0
    6896:	0e 94 9b 52 	call	0xa536	; 0xa536 <__divmodsi4>
    689a:	29 83       	std	Y+1, r18	; 0x01
    689c:	3a 83       	std	Y+2, r19	; 0x02
    689e:	6d 83       	std	Y+5, r22	; 0x05
    68a0:	7e 83       	std	Y+6, r23	; 0x06
    68a2:	e9 80       	ldd	r14, Y+1	; 0x01
    68a4:	fa 80       	ldd	r15, Y+2	; 0x02
    68a6:	ee 0c       	add	r14, r14
    68a8:	ff 1c       	adc	r15, r15
    68aa:	ee 0c       	add	r14, r14
    68ac:	ff 1c       	adc	r15, r15
    68ae:	ec 0c       	add	r14, r12
    68b0:	fd 1c       	adc	r15, r13
    68b2:	8d 81       	ldd	r24, Y+5	; 0x05
    68b4:	9e 81       	ldd	r25, Y+6	; 0x06
    68b6:	f5 e6       	ldi	r31, 0x65	; 101
    68b8:	ef 16       	cp	r14, r31
    68ba:	f1 04       	cpc	r15, r1
    68bc:	e0 f1       	brcs	.+120    	; 0x6936 <gmtime_r+0x150>
    68be:	01 96       	adiw	r24, 0x01	; 1
    68c0:	21 e0       	ldi	r18, 0x01	; 1
    68c2:	30 e0       	ldi	r19, 0x00	; 0
    68c4:	a9 01       	movw	r20, r18
    68c6:	44 59       	subi	r20, 0x94	; 148
    68c8:	5e 4f       	sbci	r21, 0xFE	; 254
    68ca:	48 17       	cp	r20, r24
    68cc:	59 07       	cpc	r21, r25
    68ce:	60 f4       	brcc	.+24     	; 0x68e8 <gmtime_r+0x102>
    68d0:	6d e6       	ldi	r22, 0x6D	; 109
    68d2:	71 e0       	ldi	r23, 0x01	; 1
    68d4:	82 1b       	sub	r24, r18
    68d6:	93 0b       	sbc	r25, r19
    68d8:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    68dc:	dc 01       	movw	r26, r24
    68de:	e6 0e       	add	r14, r22
    68e0:	f7 1e       	adc	r15, r23
    68e2:	cd 01       	movw	r24, r26
    68e4:	30 e0       	ldi	r19, 0x00	; 0
    68e6:	20 e0       	ldi	r18, 0x00	; 0
    68e8:	44 e6       	ldi	r20, 0x64	; 100
    68ea:	e4 0e       	add	r14, r20
    68ec:	f1 1c       	adc	r15, r1
    68ee:	f8 01       	movw	r30, r16
    68f0:	e6 82       	std	Z+6, r14	; 0x06
    68f2:	f7 82       	std	Z+7, r15	; 0x07
    68f4:	80 87       	std	Z+8, r24	; 0x08
    68f6:	91 87       	std	Z+9, r25	; 0x09
    68f8:	25 5c       	subi	r18, 0xC5	; 197
    68fa:	3f 4f       	sbci	r19, 0xFF	; 255
    68fc:	82 17       	cp	r24, r18
    68fe:	93 07       	cpc	r25, r19
    6900:	20 f5       	brcc	.+72     	; 0x694a <gmtime_r+0x164>
    6902:	6f e1       	ldi	r22, 0x1F	; 31
    6904:	70 e0       	ldi	r23, 0x00	; 0
    6906:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    690a:	dc 01       	movw	r26, r24
    690c:	f8 01       	movw	r30, r16
    690e:	65 83       	std	Z+5, r22	; 0x05
    6910:	a3 83       	std	Z+3, r26	; 0x03
    6912:	f8 01       	movw	r30, r16
    6914:	12 86       	std	Z+10, r1	; 0x0a
    6916:	13 86       	std	Z+11, r1	; 0x0b
    6918:	83 81       	ldd	r24, Z+3	; 0x03
    691a:	8f 5f       	subi	r24, 0xFF	; 255
    691c:	83 83       	std	Z+3, r24	; 0x03
    691e:	28 96       	adiw	r28, 0x08	; 8
    6920:	cd bf       	out	0x3d, r28	; 61
    6922:	de bf       	out	0x3e, r29	; 62
    6924:	df 91       	pop	r29
    6926:	cf 91       	pop	r28
    6928:	1f 91       	pop	r17
    692a:	0f 91       	pop	r16
    692c:	ff 90       	pop	r15
    692e:	ef 90       	pop	r14
    6930:	df 90       	pop	r13
    6932:	cf 90       	pop	r12
    6934:	08 95       	ret
    6936:	51 e0       	ldi	r21, 0x01	; 1
    6938:	40 e0       	ldi	r20, 0x00	; 0
    693a:	24 e6       	ldi	r18, 0x64	; 100
    693c:	e2 16       	cp	r14, r18
    693e:	f1 04       	cpc	r15, r1
    6940:	09 f4       	brne	.+2      	; 0x6944 <gmtime_r+0x15e>
    6942:	50 e0       	ldi	r21, 0x00	; 0
    6944:	25 2f       	mov	r18, r21
    6946:	34 2f       	mov	r19, r20
    6948:	bd cf       	rjmp	.-134    	; 0x68c4 <gmtime_r+0xde>
    694a:	69 e9       	ldi	r22, 0x99	; 153
    694c:	70 e0       	ldi	r23, 0x00	; 0
    694e:	82 1b       	sub	r24, r18
    6950:	93 0b       	sbc	r25, r19
    6952:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    6956:	dc 01       	movw	r26, r24
    6958:	26 2f       	mov	r18, r22
    695a:	22 0f       	add	r18, r18
    695c:	22 0f       	add	r18, r18
    695e:	f2 2e       	mov	r15, r18
    6960:	f6 0e       	add	r15, r22
    6962:	6d e3       	ldi	r22, 0x3D	; 61
    6964:	70 e0       	ldi	r23, 0x00	; 0
    6966:	cd 01       	movw	r24, r26
    6968:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    696c:	dc 01       	movw	r26, r24
    696e:	e6 2e       	mov	r14, r22
    6970:	ee 0c       	add	r14, r14
    6972:	6f e1       	ldi	r22, 0x1F	; 31
    6974:	70 e0       	ldi	r23, 0x00	; 0
    6976:	cd 01       	movw	r24, r26
    6978:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    697c:	dc 01       	movw	r26, r24
    697e:	22 e0       	ldi	r18, 0x02	; 2
    6980:	26 0f       	add	r18, r22
    6982:	2f 0d       	add	r18, r15
    6984:	2e 0d       	add	r18, r14
    6986:	f8 01       	movw	r30, r16
    6988:	25 83       	std	Z+5, r18	; 0x05
    698a:	c2 cf       	rjmp	.-124    	; 0x6910 <gmtime_r+0x12a>

0000698c <mktime>:
mktime():
    698c:	0f 93       	push	r16
    698e:	1f 93       	push	r17
    6990:	cf 93       	push	r28
    6992:	df 93       	push	r29
    6994:	00 d0       	rcall	.+0      	; 0x6996 <mktime+0xa>
    6996:	00 d0       	rcall	.+0      	; 0x6998 <mktime+0xc>
    6998:	cd b7       	in	r28, 0x3d	; 61
    699a:	de b7       	in	r29, 0x3e	; 62
    699c:	8c 01       	movw	r16, r24
    699e:	a0 d0       	rcall	.+320    	; 0x6ae0 <mk_gmtime>
    69a0:	69 83       	std	Y+1, r22	; 0x01
    69a2:	7a 83       	std	Y+2, r23	; 0x02
    69a4:	8b 83       	std	Y+3, r24	; 0x03
    69a6:	9c 83       	std	Y+4, r25	; 0x04
    69a8:	f8 01       	movw	r30, r16
    69aa:	82 85       	ldd	r24, Z+10	; 0x0a
    69ac:	93 85       	ldd	r25, Z+11	; 0x0b
    69ae:	97 ff       	sbrs	r25, 7
    69b0:	0e c0       	rjmp	.+28     	; 0x69ce <mktime+0x42>
    69b2:	e0 91 99 70 	lds	r30, 0x7099	; 0x807099 <__dst_ptr>
    69b6:	f0 91 9a 70 	lds	r31, 0x709A	; 0x80709a <__dst_ptr+0x1>
    69ba:	30 97       	sbiw	r30, 0x00	; 0
    69bc:	41 f0       	breq	.+16     	; 0x69ce <mktime+0x42>
    69be:	63 e9       	ldi	r22, 0x93	; 147
    69c0:	70 e7       	ldi	r23, 0x70	; 112
    69c2:	ce 01       	movw	r24, r28
    69c4:	01 96       	adiw	r24, 0x01	; 1
    69c6:	09 95       	icall
    69c8:	f8 01       	movw	r30, r16
    69ca:	82 87       	std	Z+10, r24	; 0x0a
    69cc:	93 87       	std	Z+11, r25	; 0x0b
    69ce:	f8 01       	movw	r30, r16
    69d0:	82 85       	ldd	r24, Z+10	; 0x0a
    69d2:	93 85       	ldd	r25, Z+11	; 0x0b
    69d4:	18 16       	cp	r1, r24
    69d6:	19 06       	cpc	r1, r25
    69d8:	84 f4       	brge	.+32     	; 0x69fa <mktime+0x6e>
    69da:	09 2e       	mov	r0, r25
    69dc:	00 0c       	add	r0, r0
    69de:	aa 0b       	sbc	r26, r26
    69e0:	bb 0b       	sbc	r27, r27
    69e2:	49 81       	ldd	r20, Y+1	; 0x01
    69e4:	5a 81       	ldd	r21, Y+2	; 0x02
    69e6:	6b 81       	ldd	r22, Y+3	; 0x03
    69e8:	7c 81       	ldd	r23, Y+4	; 0x04
    69ea:	48 1b       	sub	r20, r24
    69ec:	59 0b       	sbc	r21, r25
    69ee:	6a 0b       	sbc	r22, r26
    69f0:	7b 0b       	sbc	r23, r27
    69f2:	49 83       	std	Y+1, r20	; 0x01
    69f4:	5a 83       	std	Y+2, r21	; 0x02
    69f6:	6b 83       	std	Y+3, r22	; 0x03
    69f8:	7c 83       	std	Y+4, r23	; 0x04
    69fa:	89 81       	ldd	r24, Y+1	; 0x01
    69fc:	9a 81       	ldd	r25, Y+2	; 0x02
    69fe:	ab 81       	ldd	r26, Y+3	; 0x03
    6a00:	bc 81       	ldd	r27, Y+4	; 0x04
    6a02:	40 91 93 70 	lds	r20, 0x7093	; 0x807093 <__utc_offset>
    6a06:	50 91 94 70 	lds	r21, 0x7094	; 0x807094 <__utc_offset+0x1>
    6a0a:	60 91 95 70 	lds	r22, 0x7095	; 0x807095 <__utc_offset+0x2>
    6a0e:	70 91 96 70 	lds	r23, 0x7096	; 0x807096 <__utc_offset+0x3>
    6a12:	84 1b       	sub	r24, r20
    6a14:	95 0b       	sbc	r25, r21
    6a16:	a6 0b       	sbc	r26, r22
    6a18:	b7 0b       	sbc	r27, r23
    6a1a:	89 83       	std	Y+1, r24	; 0x01
    6a1c:	9a 83       	std	Y+2, r25	; 0x02
    6a1e:	ab 83       	std	Y+3, r26	; 0x03
    6a20:	bc 83       	std	Y+4, r27	; 0x04
    6a22:	b8 01       	movw	r22, r16
    6a24:	ce 01       	movw	r24, r28
    6a26:	01 96       	adiw	r24, 0x01	; 1
    6a28:	0c d0       	rcall	.+24     	; 0x6a42 <localtime_r>
    6a2a:	69 81       	ldd	r22, Y+1	; 0x01
    6a2c:	7a 81       	ldd	r23, Y+2	; 0x02
    6a2e:	8b 81       	ldd	r24, Y+3	; 0x03
    6a30:	9c 81       	ldd	r25, Y+4	; 0x04
    6a32:	24 96       	adiw	r28, 0x04	; 4
    6a34:	cd bf       	out	0x3d, r28	; 61
    6a36:	de bf       	out	0x3e, r29	; 62
    6a38:	df 91       	pop	r29
    6a3a:	cf 91       	pop	r28
    6a3c:	1f 91       	pop	r17
    6a3e:	0f 91       	pop	r16
    6a40:	08 95       	ret

00006a42 <localtime_r>:
localtime_r():
    6a42:	cf 92       	push	r12
    6a44:	df 92       	push	r13
    6a46:	ef 92       	push	r14
    6a48:	ff 92       	push	r15
    6a4a:	0f 93       	push	r16
    6a4c:	1f 93       	push	r17
    6a4e:	cf 93       	push	r28
    6a50:	df 93       	push	r29
    6a52:	00 d0       	rcall	.+0      	; 0x6a54 <localtime_r+0x12>
    6a54:	00 d0       	rcall	.+0      	; 0x6a56 <localtime_r+0x14>
    6a56:	cd b7       	in	r28, 0x3d	; 61
    6a58:	de b7       	in	r29, 0x3e	; 62
    6a5a:	6c 01       	movw	r12, r24
    6a5c:	7b 01       	movw	r14, r22
    6a5e:	e0 91 99 70 	lds	r30, 0x7099	; 0x807099 <__dst_ptr>
    6a62:	f0 91 9a 70 	lds	r31, 0x709A	; 0x80709a <__dst_ptr+0x1>
    6a66:	0f ef       	ldi	r16, 0xFF	; 255
    6a68:	1f ef       	ldi	r17, 0xFF	; 255
    6a6a:	30 97       	sbiw	r30, 0x00	; 0
    6a6c:	21 f0       	breq	.+8      	; 0x6a76 <localtime_r+0x34>
    6a6e:	63 e9       	ldi	r22, 0x93	; 147
    6a70:	70 e7       	ldi	r23, 0x70	; 112
    6a72:	09 95       	icall
    6a74:	8c 01       	movw	r16, r24
    6a76:	f6 01       	movw	r30, r12
    6a78:	80 81       	ld	r24, Z
    6a7a:	91 81       	ldd	r25, Z+1	; 0x01
    6a7c:	a2 81       	ldd	r26, Z+2	; 0x02
    6a7e:	b3 81       	ldd	r27, Z+3	; 0x03
    6a80:	40 91 93 70 	lds	r20, 0x7093	; 0x807093 <__utc_offset>
    6a84:	50 91 94 70 	lds	r21, 0x7094	; 0x807094 <__utc_offset+0x1>
    6a88:	60 91 95 70 	lds	r22, 0x7095	; 0x807095 <__utc_offset+0x2>
    6a8c:	70 91 96 70 	lds	r23, 0x7096	; 0x807096 <__utc_offset+0x3>
    6a90:	84 0f       	add	r24, r20
    6a92:	95 1f       	adc	r25, r21
    6a94:	a6 1f       	adc	r26, r22
    6a96:	b7 1f       	adc	r27, r23
    6a98:	10 16       	cp	r1, r16
    6a9a:	11 06       	cpc	r1, r17
    6a9c:	bc f0       	brlt	.+46     	; 0x6acc <localtime_r+0x8a>
    6a9e:	89 83       	std	Y+1, r24	; 0x01
    6aa0:	9a 83       	std	Y+2, r25	; 0x02
    6aa2:	ab 83       	std	Y+3, r26	; 0x03
    6aa4:	bc 83       	std	Y+4, r27	; 0x04
    6aa6:	b7 01       	movw	r22, r14
    6aa8:	ce 01       	movw	r24, r28
    6aaa:	01 96       	adiw	r24, 0x01	; 1
    6aac:	9c de       	rcall	.-712    	; 0x67e6 <gmtime_r>
    6aae:	f7 01       	movw	r30, r14
    6ab0:	02 87       	std	Z+10, r16	; 0x0a
    6ab2:	13 87       	std	Z+11, r17	; 0x0b
    6ab4:	24 96       	adiw	r28, 0x04	; 4
    6ab6:	cd bf       	out	0x3d, r28	; 61
    6ab8:	de bf       	out	0x3e, r29	; 62
    6aba:	df 91       	pop	r29
    6abc:	cf 91       	pop	r28
    6abe:	1f 91       	pop	r17
    6ac0:	0f 91       	pop	r16
    6ac2:	ff 90       	pop	r15
    6ac4:	ef 90       	pop	r14
    6ac6:	df 90       	pop	r13
    6ac8:	cf 90       	pop	r12
    6aca:	08 95       	ret
    6acc:	a8 01       	movw	r20, r16
    6ace:	01 2e       	mov	r0, r17
    6ad0:	00 0c       	add	r0, r0
    6ad2:	66 0b       	sbc	r22, r22
    6ad4:	77 0b       	sbc	r23, r23
    6ad6:	84 0f       	add	r24, r20
    6ad8:	95 1f       	adc	r25, r21
    6ada:	a6 1f       	adc	r26, r22
    6adc:	b7 1f       	adc	r27, r23
    6ade:	df cf       	rjmp	.-66     	; 0x6a9e <localtime_r+0x5c>

00006ae0 <mk_gmtime>:
mk_gmtime():
    6ae0:	8f 92       	push	r8
    6ae2:	9f 92       	push	r9
    6ae4:	af 92       	push	r10
    6ae6:	bf 92       	push	r11
    6ae8:	cf 92       	push	r12
    6aea:	df 92       	push	r13
    6aec:	ef 92       	push	r14
    6aee:	ff 92       	push	r15
    6af0:	cf 93       	push	r28
    6af2:	df 93       	push	r29
    6af4:	ec 01       	movw	r28, r24
    6af6:	ee 81       	ldd	r30, Y+6	; 0x06
    6af8:	ff 81       	ldd	r31, Y+7	; 0x07
    6afa:	7f 01       	movw	r14, r30
    6afc:	24 e6       	ldi	r18, 0x64	; 100
    6afe:	e2 1a       	sub	r14, r18
    6b00:	f1 08       	sbc	r15, r1
    6b02:	d1 2c       	mov	r13, r1
    6b04:	c1 2c       	mov	r12, r1
    6b06:	b1 f0       	breq	.+44     	; 0x6b34 <mk_gmtime+0x54>
    6b08:	cf 01       	movw	r24, r30
    6b0a:	85 56       	subi	r24, 0x65	; 101
    6b0c:	91 09       	sbc	r25, r1
    6b0e:	6c 01       	movw	r12, r24
    6b10:	97 ff       	sbrs	r25, 7
    6b12:	03 c0       	rjmp	.+6      	; 0x6b1a <mk_gmtime+0x3a>
    6b14:	23 e0       	ldi	r18, 0x03	; 3
    6b16:	c2 0e       	add	r12, r18
    6b18:	d1 1c       	adc	r13, r1
    6b1a:	d5 94       	asr	r13
    6b1c:	c7 94       	ror	r12
    6b1e:	d5 94       	asr	r13
    6b20:	c7 94       	ror	r12
    6b22:	6c e9       	ldi	r22, 0x9C	; 156
    6b24:	7f ef       	ldi	r23, 0xFF	; 255
    6b26:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    6b2a:	c6 0e       	add	r12, r22
    6b2c:	d7 1e       	adc	r13, r23
    6b2e:	8f ef       	ldi	r24, 0xFF	; 255
    6b30:	c8 1a       	sub	r12, r24
    6b32:	d8 0a       	sbc	r13, r24
    6b34:	2d e6       	ldi	r18, 0x6D	; 109
    6b36:	31 e0       	ldi	r19, 0x01	; 1
    6b38:	d7 01       	movw	r26, r14
    6b3a:	0e 94 b7 52 	call	0xa56e	; 0xa56e <__usmulhisi3>
    6b3e:	46 01       	movw	r8, r12
    6b40:	dd 0c       	add	r13, r13
    6b42:	aa 08       	sbc	r10, r10
    6b44:	bb 08       	sbc	r11, r11
    6b46:	86 0e       	add	r8, r22
    6b48:	97 1e       	adc	r9, r23
    6b4a:	a8 1e       	adc	r10, r24
    6b4c:	b9 1e       	adc	r11, r25
    6b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    6b50:	08 2e       	mov	r0, r24
    6b52:	00 0c       	add	r0, r0
    6b54:	99 0b       	sbc	r25, r25
    6b56:	7c 01       	movw	r14, r24
    6b58:	21 e0       	ldi	r18, 0x01	; 1
    6b5a:	e2 1a       	sub	r14, r18
    6b5c:	f1 08       	sbc	r15, r1
    6b5e:	2d 81       	ldd	r18, Y+5	; 0x05
    6b60:	22 30       	cpi	r18, 0x02	; 2
    6b62:	0c f0       	brlt	.+2      	; 0x6b66 <mk_gmtime+0x86>
    6b64:	49 c0       	rjmp	.+146    	; 0x6bf8 <mk_gmtime+0x118>
    6b66:	22 23       	and	r18, r18
    6b68:	21 f0       	breq	.+8      	; 0x6b72 <mk_gmtime+0x92>
    6b6a:	7c 01       	movw	r14, r24
    6b6c:	2e e1       	ldi	r18, 0x1E	; 30
    6b6e:	e2 0e       	add	r14, r18
    6b70:	f1 1c       	adc	r15, r1
    6b72:	67 01       	movw	r12, r14
    6b74:	ff 0c       	add	r15, r15
    6b76:	ee 08       	sbc	r14, r14
    6b78:	ff 08       	sbc	r15, r15
    6b7a:	c8 0c       	add	r12, r8
    6b7c:	d9 1c       	adc	r13, r9
    6b7e:	ea 1c       	adc	r14, r10
    6b80:	fb 1c       	adc	r15, r11
    6b82:	aa 81       	ldd	r26, Y+2	; 0x02
    6b84:	0a 2e       	mov	r0, r26
    6b86:	00 0c       	add	r0, r0
    6b88:	bb 0b       	sbc	r27, r27
    6b8a:	20 e1       	ldi	r18, 0x10	; 16
    6b8c:	3e e0       	ldi	r19, 0x0E	; 14
    6b8e:	0e 94 b7 52 	call	0xa56e	; 0xa56e <__usmulhisi3>
    6b92:	4b 01       	movw	r8, r22
    6b94:	5c 01       	movw	r10, r24
    6b96:	a9 81       	ldd	r26, Y+1	; 0x01
    6b98:	0a 2e       	mov	r0, r26
    6b9a:	00 0c       	add	r0, r0
    6b9c:	bb 0b       	sbc	r27, r27
    6b9e:	2c e3       	ldi	r18, 0x3C	; 60
    6ba0:	30 e0       	ldi	r19, 0x00	; 0
    6ba2:	0e 94 b7 52 	call	0xa56e	; 0xa56e <__usmulhisi3>
    6ba6:	ab 01       	movw	r20, r22
    6ba8:	bc 01       	movw	r22, r24
    6baa:	48 0d       	add	r20, r8
    6bac:	59 1d       	adc	r21, r9
    6bae:	6a 1d       	adc	r22, r10
    6bb0:	7b 1d       	adc	r23, r11
    6bb2:	88 81       	ld	r24, Y
    6bb4:	08 2e       	mov	r0, r24
    6bb6:	00 0c       	add	r0, r0
    6bb8:	99 0b       	sbc	r25, r25
    6bba:	aa 0b       	sbc	r26, r26
    6bbc:	bb 0b       	sbc	r27, r27
    6bbe:	4c 01       	movw	r8, r24
    6bc0:	5d 01       	movw	r10, r26
    6bc2:	84 0e       	add	r8, r20
    6bc4:	95 1e       	adc	r9, r21
    6bc6:	a6 1e       	adc	r10, r22
    6bc8:	b7 1e       	adc	r11, r23
    6bca:	a7 01       	movw	r20, r14
    6bcc:	96 01       	movw	r18, r12
    6bce:	60 e8       	ldi	r22, 0x80	; 128
    6bd0:	71 e5       	ldi	r23, 0x51	; 81
    6bd2:	81 e0       	ldi	r24, 0x01	; 1
    6bd4:	90 e0       	ldi	r25, 0x00	; 0
    6bd6:	0e 94 43 52 	call	0xa486	; 0xa486 <__mulsi3>
    6bda:	68 0d       	add	r22, r8
    6bdc:	79 1d       	adc	r23, r9
    6bde:	8a 1d       	adc	r24, r10
    6be0:	9b 1d       	adc	r25, r11
    6be2:	df 91       	pop	r29
    6be4:	cf 91       	pop	r28
    6be6:	ff 90       	pop	r15
    6be8:	ef 90       	pop	r14
    6bea:	df 90       	pop	r13
    6bec:	cf 90       	pop	r12
    6bee:	bf 90       	pop	r11
    6bf0:	af 90       	pop	r10
    6bf2:	9f 90       	pop	r9
    6bf4:	8f 90       	pop	r8
    6bf6:	08 95       	ret
    6bf8:	cf 01       	movw	r24, r30
    6bfa:	84 59       	subi	r24, 0x94	; 148
    6bfc:	98 4f       	sbci	r25, 0xF8	; 248
    6bfe:	2b d0       	rcall	.+86     	; 0x6c56 <is_leap_year>
    6c00:	c8 2e       	mov	r12, r24
    6c02:	d1 2c       	mov	r13, r1
    6c04:	8b e3       	ldi	r24, 0x3B	; 59
    6c06:	c8 0e       	add	r12, r24
    6c08:	d1 1c       	adc	r13, r1
    6c0a:	ce 0c       	add	r12, r14
    6c0c:	df 1c       	adc	r13, r15
    6c0e:	8d 81       	ldd	r24, Y+5	; 0x05
    6c10:	08 2e       	mov	r0, r24
    6c12:	00 0c       	add	r0, r0
    6c14:	99 0b       	sbc	r25, r25
    6c16:	02 97       	sbiw	r24, 0x02	; 2
    6c18:	85 30       	cpi	r24, 0x05	; 5
    6c1a:	91 05       	cpc	r25, r1
    6c1c:	1c f0       	brlt	.+6      	; 0x6c24 <mk_gmtime+0x144>
    6c1e:	29 e9       	ldi	r18, 0x99	; 153
    6c20:	c2 0e       	add	r12, r18
    6c22:	d1 1c       	adc	r13, r1
    6c24:	65 e0       	ldi	r22, 0x05	; 5
    6c26:	70 e0       	ldi	r23, 0x00	; 0
    6c28:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    6c2c:	9c 01       	movw	r18, r24
    6c2e:	97 ff       	sbrs	r25, 7
    6c30:	02 c0       	rjmp	.+4      	; 0x6c36 <mk_gmtime+0x156>
    6c32:	2f 5f       	subi	r18, 0xFF	; 255
    6c34:	3f 4f       	sbci	r19, 0xFF	; 255
    6c36:	35 95       	asr	r19
    6c38:	27 95       	ror	r18
    6c3a:	9d e3       	ldi	r25, 0x3D	; 61
    6c3c:	92 9f       	mul	r25, r18
    6c3e:	70 01       	movw	r14, r0
    6c40:	93 9f       	mul	r25, r19
    6c42:	f0 0c       	add	r15, r0
    6c44:	11 24       	eor	r1, r1
    6c46:	ec 0c       	add	r14, r12
    6c48:	fd 1c       	adc	r15, r13
    6c4a:	80 ff       	sbrs	r24, 0
    6c4c:	92 cf       	rjmp	.-220    	; 0x6b72 <mk_gmtime+0x92>
    6c4e:	8f e1       	ldi	r24, 0x1F	; 31
    6c50:	e8 0e       	add	r14, r24
    6c52:	f1 1c       	adc	r15, r1
    6c54:	8e cf       	rjmp	.-228    	; 0x6b72 <mk_gmtime+0x92>

00006c56 <is_leap_year>:
is_leap_year():
    6c56:	9c 01       	movw	r18, r24
    6c58:	23 70       	andi	r18, 0x03	; 3
    6c5a:	33 27       	eor	r19, r19
    6c5c:	23 2b       	or	r18, r19
    6c5e:	59 f4       	brne	.+22     	; 0x6c76 <is_leap_year+0x20>
    6c60:	64 e6       	ldi	r22, 0x64	; 100
    6c62:	70 e0       	ldi	r23, 0x00	; 0
    6c64:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    6c68:	89 2b       	or	r24, r25
    6c6a:	39 f4       	brne	.+14     	; 0x6c7a <is_leap_year+0x24>
    6c6c:	63 70       	andi	r22, 0x03	; 3
    6c6e:	77 27       	eor	r23, r23
    6c70:	81 e0       	ldi	r24, 0x01	; 1
    6c72:	67 2b       	or	r22, r23
    6c74:	19 f0       	breq	.+6      	; 0x6c7c <is_leap_year+0x26>
    6c76:	80 e0       	ldi	r24, 0x00	; 0
    6c78:	08 95       	ret
    6c7a:	81 e0       	ldi	r24, 0x01	; 1
    6c7c:	08 95       	ret

00006c7e <pgm_copystring>:
pgm_copystring():
    6c7e:	cf 92       	push	r12
    6c80:	df 92       	push	r13
    6c82:	ef 92       	push	r14
    6c84:	0f 93       	push	r16
    6c86:	6b 01       	movw	r12, r22
    6c88:	e8 2e       	mov	r14, r24
    6c8a:	84 2f       	mov	r24, r20
    6c8c:	f6 01       	movw	r30, r12
    6c8e:	5e 2d       	mov	r21, r14
    6c90:	0e 94 10 5b 	call	0xb620	; 0xb620 <__xload_1>
    6c94:	9f ef       	ldi	r25, 0xFF	; 255
    6c96:	c9 1a       	sub	r12, r25
    6c98:	d9 0a       	sbc	r13, r25
    6c9a:	e9 0a       	sbc	r14, r25
    6c9c:	81 11       	cpse	r24, r1
    6c9e:	0b c0       	rjmp	.+22     	; 0x6cb6 <pgm_copystring+0x38>
    6ca0:	d9 01       	movw	r26, r18
    6ca2:	60 32       	cpi	r22, 0x20	; 32
    6ca4:	11 f0       	breq	.+4      	; 0x6caa <pgm_copystring+0x2c>
    6ca6:	80 13       	cpse	r24, r16
    6ca8:	0a c0       	rjmp	.+20     	; 0x6cbe <pgm_copystring+0x40>
    6caa:	1c 92       	st	X, r1
    6cac:	0f 91       	pop	r16
    6cae:	ef 90       	pop	r14
    6cb0:	df 90       	pop	r13
    6cb2:	cf 90       	pop	r12
    6cb4:	08 95       	ret
    6cb6:	60 32       	cpi	r22, 0x20	; 32
    6cb8:	49 f7       	brne	.-46     	; 0x6c8c <pgm_copystring+0xe>
    6cba:	81 50       	subi	r24, 0x01	; 1
    6cbc:	e7 cf       	rjmp	.-50     	; 0x6c8c <pgm_copystring+0xe>
    6cbe:	6d 93       	st	X+, r22
    6cc0:	8f 5f       	subi	r24, 0xFF	; 255
    6cc2:	f6 01       	movw	r30, r12
    6cc4:	5e 2d       	mov	r21, r14
    6cc6:	0e 94 10 5b 	call	0xb620	; 0xb620 <__xload_1>
    6cca:	9f ef       	ldi	r25, 0xFF	; 255
    6ccc:	c9 1a       	sub	r12, r25
    6cce:	d9 0a       	sbc	r13, r25
    6cd0:	e9 0a       	sbc	r14, r25
    6cd2:	e7 cf       	rjmp	.-50     	; 0x6ca2 <pgm_copystring+0x24>

00006cd4 <strftime>:
strftime():
    6cd4:	2f 92       	push	r2
    6cd6:	3f 92       	push	r3
    6cd8:	4f 92       	push	r4
    6cda:	5f 92       	push	r5
    6cdc:	6f 92       	push	r6
    6cde:	7f 92       	push	r7
    6ce0:	8f 92       	push	r8
    6ce2:	9f 92       	push	r9
    6ce4:	af 92       	push	r10
    6ce6:	bf 92       	push	r11
    6ce8:	cf 92       	push	r12
    6cea:	df 92       	push	r13
    6cec:	ef 92       	push	r14
    6cee:	ff 92       	push	r15
    6cf0:	0f 93       	push	r16
    6cf2:	1f 93       	push	r17
    6cf4:	cf 93       	push	r28
    6cf6:	df 93       	push	r29
    6cf8:	cd b7       	in	r28, 0x3d	; 61
    6cfa:	de b7       	in	r29, 0x3e	; 62
    6cfc:	a2 97       	sbiw	r28, 0x22	; 34
    6cfe:	cd bf       	out	0x3d, r28	; 61
    6d00:	de bf       	out	0x3e, r29	; 62
    6d02:	4c 01       	movw	r8, r24
    6d04:	69 a3       	std	Y+33, r22	; 0x21
    6d06:	7a a3       	std	Y+34, r23	; 0x22
    6d08:	fa 01       	movw	r30, r20
    6d0a:	79 01       	movw	r14, r18
    6d0c:	71 2c       	mov	r7, r1
    6d0e:	61 2c       	mov	r6, r1
    6d10:	9e 01       	movw	r18, r28
    6d12:	2f 5f       	subi	r18, 0xFF	; 255
    6d14:	3f 4f       	sbci	r19, 0xFF	; 255
    6d16:	69 01       	movw	r12, r18
    6d18:	84 e6       	ldi	r24, 0x64	; 100
    6d1a:	48 2e       	mov	r4, r24
    6d1c:	51 2c       	mov	r5, r1
    6d1e:	90 ec       	ldi	r25, 0xC0	; 192
    6d20:	a9 2e       	mov	r10, r25
    6d22:	91 e6       	ldi	r25, 0x61	; 97
    6d24:	b9 2e       	mov	r11, r25
    6d26:	29 a1       	ldd	r18, Y+33	; 0x21
    6d28:	3a a1       	ldd	r19, Y+34	; 0x22
    6d2a:	62 16       	cp	r6, r18
    6d2c:	73 06       	cpc	r7, r19
    6d2e:	18 f0       	brcs	.+6      	; 0x6d36 <strftime+0x62>
    6d30:	d4 01       	movw	r26, r8
    6d32:	1c 92       	st	X, r1
    6d34:	ad c2       	rjmp	.+1370   	; 0x7290 <strftime+0x5bc>
    6d36:	1f 01       	movw	r2, r30
    6d38:	3f ef       	ldi	r19, 0xFF	; 255
    6d3a:	23 1a       	sub	r2, r19
    6d3c:	33 0a       	sbc	r3, r19
    6d3e:	80 81       	ld	r24, Z
    6d40:	85 32       	cpi	r24, 0x25	; 37
    6d42:	09 f0       	breq	.+2      	; 0x6d46 <strftime+0x72>
    6d44:	9d c2       	rjmp	.+1338   	; 0x7280 <strftime+0x5ac>
    6d46:	11 81       	ldd	r17, Z+1	; 0x01
    6d48:	1f 01       	movw	r2, r30
    6d4a:	15 34       	cpi	r17, 0x45	; 69
    6d4c:	f9 f0       	breq	.+62     	; 0x6d8c <strftime+0xb8>
    6d4e:	1f 34       	cpi	r17, 0x4F	; 79
    6d50:	e9 f0       	breq	.+58     	; 0x6d8c <strftime+0xb8>
    6d52:	42 e0       	ldi	r20, 0x02	; 2
    6d54:	24 0e       	add	r2, r20
    6d56:	31 1c       	adc	r3, r1
    6d58:	19 35       	cpi	r17, 0x59	; 89
    6d5a:	09 f4       	brne	.+2      	; 0x6d5e <strftime+0x8a>
    6d5c:	87 c2       	rjmp	.+1294   	; 0x726c <strftime+0x598>
    6d5e:	0c f0       	brlt	.+2      	; 0x6d62 <strftime+0x8e>
    6d60:	81 c0       	rjmp	.+258    	; 0x6e64 <strftime+0x190>
    6d62:	19 34       	cpi	r17, 0x49	; 73
    6d64:	09 f4       	brne	.+2      	; 0x6d68 <strftime+0x94>
    6d66:	c6 c1       	rjmp	.+908    	; 0x70f4 <strftime+0x420>
    6d68:	0c f0       	brlt	.+2      	; 0x6d6c <strftime+0x98>
    6d6a:	45 c0       	rjmp	.+138    	; 0x6df6 <strftime+0x122>
    6d6c:	13 34       	cpi	r17, 0x43	; 67
    6d6e:	09 f4       	brne	.+2      	; 0x6d72 <strftime+0x9e>
    6d70:	5d c1       	rjmp	.+698    	; 0x702c <strftime+0x358>
    6d72:	8c f4       	brge	.+34     	; 0x6d96 <strftime+0xc2>
    6d74:	11 34       	cpi	r17, 0x41	; 65
    6d76:	09 f4       	brne	.+2      	; 0x6d7a <strftime+0xa6>
    6d78:	3b c1       	rjmp	.+630    	; 0x6ff0 <strftime+0x31c>
    6d7a:	0c f0       	brlt	.+2      	; 0x6d7e <strftime+0xaa>
    6d7c:	47 c1       	rjmp	.+654    	; 0x700c <strftime+0x338>
    6d7e:	15 32       	cpi	r17, 0x25	; 37
    6d80:	09 f4       	brne	.+2      	; 0x6d84 <strftime+0xb0>
    6d82:	32 c1       	rjmp	.+612    	; 0x6fe8 <strftime+0x314>
    6d84:	8f e3       	ldi	r24, 0x3F	; 63
    6d86:	89 83       	std	Y+1, r24	; 0x01
    6d88:	1a 82       	std	Y+2, r1	; 0x02
    6d8a:	2f c1       	rjmp	.+606    	; 0x6fea <strftime+0x316>
    6d8c:	53 e0       	ldi	r21, 0x03	; 3
    6d8e:	25 0e       	add	r2, r21
    6d90:	31 1c       	adc	r3, r1
    6d92:	12 81       	ldd	r17, Z+2	; 0x02
    6d94:	e1 cf       	rjmp	.-62     	; 0x6d58 <strftime+0x84>
    6d96:	16 34       	cpi	r17, 0x46	; 70
    6d98:	09 f4       	brne	.+2      	; 0x6d9c <strftime+0xc8>
    6d9a:	62 c1       	rjmp	.+708    	; 0x7060 <strftime+0x38c>
    6d9c:	1c f5       	brge	.+70     	; 0x6de4 <strftime+0x110>
    6d9e:	14 34       	cpi	r17, 0x44	; 68
    6da0:	89 f7       	brne	.-30     	; 0x6d84 <strftime+0xb0>
    6da2:	f7 01       	movw	r30, r14
    6da4:	86 81       	ldd	r24, Z+6	; 0x06
    6da6:	97 81       	ldd	r25, Z+7	; 0x07
    6da8:	b2 01       	movw	r22, r4
    6daa:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    6dae:	9f 93       	push	r25
    6db0:	8f 93       	push	r24
    6db2:	83 81       	ldd	r24, Z+3	; 0x03
    6db4:	28 2f       	mov	r18, r24
    6db6:	08 2e       	mov	r0, r24
    6db8:	00 0c       	add	r0, r0
    6dba:	33 0b       	sbc	r19, r19
    6dbc:	3f 93       	push	r19
    6dbe:	8f 93       	push	r24
    6dc0:	85 81       	ldd	r24, Z+5	; 0x05
    6dc2:	08 2e       	mov	r0, r24
    6dc4:	00 0c       	add	r0, r0
    6dc6:	99 0b       	sbc	r25, r25
    6dc8:	01 96       	adiw	r24, 0x01	; 1
    6dca:	9f 93       	push	r25
    6dcc:	8f 93       	push	r24
    6dce:	26 eb       	ldi	r18, 0xB6	; 182
    6dd0:	31 e6       	ldi	r19, 0x61	; 97
    6dd2:	3f 93       	push	r19
    6dd4:	2f 93       	push	r18
    6dd6:	df 92       	push	r13
    6dd8:	cf 92       	push	r12
    6dda:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    6dde:	cd bf       	out	0x3d, r28	; 61
    6de0:	de bf       	out	0x3e, r29	; 62
    6de2:	5b c0       	rjmp	.+182    	; 0x6e9a <strftime+0x1c6>
    6de4:	17 34       	cpi	r17, 0x47	; 71
    6de6:	09 f4       	brne	.+2      	; 0x6dea <strftime+0x116>
    6de8:	5a c1       	rjmp	.+692    	; 0x709e <strftime+0x3ca>
    6dea:	18 34       	cpi	r17, 0x48	; 72
    6dec:	59 f6       	brne	.-106    	; 0x6d84 <strftime+0xb0>
    6dee:	d7 01       	movw	r26, r14
    6df0:	12 96       	adiw	r26, 0x02	; 2
    6df2:	8c 91       	ld	r24, X
    6df4:	2e c1       	rjmp	.+604    	; 0x7052 <strftime+0x37e>
    6df6:	14 35       	cpi	r17, 0x54	; 84
    6df8:	09 f4       	brne	.+2      	; 0x6dfc <strftime+0x128>
    6dfa:	ef c1       	rjmp	.+990    	; 0x71da <strftime+0x506>
    6dfc:	64 f4       	brge	.+24     	; 0x6e16 <strftime+0x142>
    6dfe:	12 35       	cpi	r17, 0x52	; 82
    6e00:	09 f4       	brne	.+2      	; 0x6e04 <strftime+0x130>
    6e02:	d0 c1       	rjmp	.+928    	; 0x71a4 <strftime+0x4d0>
    6e04:	0c f0       	brlt	.+2      	; 0x6e08 <strftime+0x134>
    6e06:	e6 c1       	rjmp	.+972    	; 0x71d4 <strftime+0x500>
    6e08:	1d 34       	cpi	r17, 0x4D	; 77
    6e0a:	09 f0       	breq	.+2      	; 0x6e0e <strftime+0x13a>
    6e0c:	bb cf       	rjmp	.-138    	; 0x6d84 <strftime+0xb0>
    6e0e:	d7 01       	movw	r26, r14
    6e10:	11 96       	adiw	r26, 0x01	; 1
    6e12:	8c 91       	ld	r24, X
    6e14:	1e c1       	rjmp	.+572    	; 0x7052 <strftime+0x37e>
    6e16:	16 35       	cpi	r17, 0x56	; 86
    6e18:	09 f4       	brne	.+2      	; 0x6e1c <strftime+0x148>
    6e1a:	0c c2       	rjmp	.+1048   	; 0x7234 <strftime+0x560>
    6e1c:	0c f4       	brge	.+2      	; 0x6e20 <strftime+0x14c>
    6e1e:	05 c2       	rjmp	.+1034   	; 0x722a <strftime+0x556>
    6e20:	17 35       	cpi	r17, 0x57	; 87
    6e22:	09 f4       	brne	.+2      	; 0x6e26 <strftime+0x152>
    6e24:	19 c2       	rjmp	.+1074   	; 0x7258 <strftime+0x584>
    6e26:	18 35       	cpi	r17, 0x58	; 88
    6e28:	09 f0       	breq	.+2      	; 0x6e2c <strftime+0x158>
    6e2a:	ac cf       	rjmp	.-168    	; 0x6d84 <strftime+0xb0>
    6e2c:	d7 01       	movw	r26, r14
    6e2e:	8c 91       	ld	r24, X
    6e30:	28 2f       	mov	r18, r24
    6e32:	08 2e       	mov	r0, r24
    6e34:	00 0c       	add	r0, r0
    6e36:	33 0b       	sbc	r19, r19
    6e38:	3f 93       	push	r19
    6e3a:	8f 93       	push	r24
    6e3c:	11 96       	adiw	r26, 0x01	; 1
    6e3e:	8c 91       	ld	r24, X
    6e40:	11 97       	sbiw	r26, 0x01	; 1
    6e42:	28 2f       	mov	r18, r24
    6e44:	08 2e       	mov	r0, r24
    6e46:	00 0c       	add	r0, r0
    6e48:	33 0b       	sbc	r19, r19
    6e4a:	3f 93       	push	r19
    6e4c:	8f 93       	push	r24
    6e4e:	12 96       	adiw	r26, 0x02	; 2
    6e50:	8c 91       	ld	r24, X
    6e52:	28 2f       	mov	r18, r24
    6e54:	08 2e       	mov	r0, r24
    6e56:	00 0c       	add	r0, r0
    6e58:	33 0b       	sbc	r19, r19
    6e5a:	3f 93       	push	r19
    6e5c:	8f 93       	push	r24
    6e5e:	82 e0       	ldi	r24, 0x02	; 2
    6e60:	92 e6       	ldi	r25, 0x62	; 98
    6e62:	1a c1       	rjmp	.+564    	; 0x7098 <strftime+0x3c4>
    6e64:	1d 36       	cpi	r17, 0x6D	; 109
    6e66:	09 f4       	brne	.+2      	; 0x6e6a <strftime+0x196>
    6e68:	56 c1       	rjmp	.+684    	; 0x7116 <strftime+0x442>
    6e6a:	0c f0       	brlt	.+2      	; 0x6e6e <strftime+0x19a>
    6e6c:	55 c0       	rjmp	.+170    	; 0x6f18 <strftime+0x244>
    6e6e:	14 36       	cpi	r17, 0x64	; 100
    6e70:	09 f4       	brne	.+2      	; 0x6e74 <strftime+0x1a0>
    6e72:	ec c0       	rjmp	.+472    	; 0x704c <strftime+0x378>
    6e74:	6c f5       	brge	.+90     	; 0x6ed0 <strftime+0x1fc>
    6e76:	12 36       	cpi	r17, 0x62	; 98
    6e78:	09 f4       	brne	.+2      	; 0x6e7c <strftime+0x1a8>
    6e7a:	bf c0       	rjmp	.+382    	; 0x6ffa <strftime+0x326>
    6e7c:	0c f0       	brlt	.+2      	; 0x6e80 <strftime+0x1ac>
    6e7e:	cb c0       	rjmp	.+406    	; 0x7016 <strftime+0x342>
    6e80:	11 36       	cpi	r17, 0x61	; 97
    6e82:	09 f0       	breq	.+2      	; 0x6e86 <strftime+0x1b2>
    6e84:	7f cf       	rjmp	.-258    	; 0x6d84 <strftime+0xb0>
    6e86:	03 e0       	ldi	r16, 0x03	; 3
    6e88:	96 01       	movw	r18, r12
    6e8a:	d7 01       	movw	r26, r14
    6e8c:	14 96       	adiw	r26, 0x04	; 4
    6e8e:	4c 91       	ld	r20, X
    6e90:	67 ef       	ldi	r22, 0xF7	; 247
    6e92:	72 e0       	ldi	r23, 0x02	; 2
    6e94:	80 e0       	ldi	r24, 0x00	; 0
    6e96:	f3 de       	rcall	.-538    	; 0x6c7e <pgm_copystring>
    6e98:	90 e0       	ldi	r25, 0x00	; 0
    6e9a:	93 01       	movw	r18, r6
    6e9c:	28 0f       	add	r18, r24
    6e9e:	39 1f       	adc	r19, r25
    6ea0:	49 a1       	ldd	r20, Y+33	; 0x21
    6ea2:	5a a1       	ldd	r21, Y+34	; 0x22
    6ea4:	d4 01       	movw	r26, r8
    6ea6:	24 17       	cp	r18, r20
    6ea8:	35 07       	cpc	r19, r21
    6eaa:	08 f0       	brcs	.+2      	; 0x6eae <strftime+0x1da>
    6eac:	42 cf       	rjmp	.-380    	; 0x6d32 <strftime+0x5e>
    6eae:	f6 01       	movw	r30, r12
    6eb0:	af 01       	movw	r20, r30
    6eb2:	4c 19       	sub	r20, r12
    6eb4:	5d 09       	sbc	r21, r13
    6eb6:	48 17       	cp	r20, r24
    6eb8:	59 07       	cpc	r21, r25
    6eba:	0c f4       	brge	.+2      	; 0x6ebe <strftime+0x1ea>
    6ebc:	de c1       	rjmp	.+956    	; 0x727a <strftime+0x5a6>
    6ebe:	97 ff       	sbrs	r25, 7
    6ec0:	02 c0       	rjmp	.+4      	; 0x6ec6 <strftime+0x1f2>
    6ec2:	90 e0       	ldi	r25, 0x00	; 0
    6ec4:	80 e0       	ldi	r24, 0x00	; 0
    6ec6:	88 0e       	add	r8, r24
    6ec8:	99 1e       	adc	r9, r25
    6eca:	39 01       	movw	r6, r18
    6ecc:	f1 01       	movw	r30, r2
    6ece:	2b cf       	rjmp	.-426    	; 0x6d26 <strftime+0x52>
    6ed0:	17 36       	cpi	r17, 0x67	; 103
    6ed2:	09 f4       	brne	.+2      	; 0x6ed6 <strftime+0x202>
    6ed4:	e4 c0       	rjmp	.+456    	; 0x709e <strftime+0x3ca>
    6ed6:	84 f4       	brge	.+32     	; 0x6ef8 <strftime+0x224>
    6ed8:	15 36       	cpi	r17, 0x65	; 101
    6eda:	09 f0       	breq	.+2      	; 0x6ede <strftime+0x20a>
    6edc:	53 cf       	rjmp	.-346    	; 0x6d84 <strftime+0xb0>
    6ede:	f7 01       	movw	r30, r14
    6ee0:	83 81       	ldd	r24, Z+3	; 0x03
    6ee2:	28 2f       	mov	r18, r24
    6ee4:	08 2e       	mov	r0, r24
    6ee6:	00 0c       	add	r0, r0
    6ee8:	33 0b       	sbc	r19, r19
    6eea:	3f 93       	push	r19
    6eec:	8f 93       	push	r24
    6eee:	85 ec       	ldi	r24, 0xC5	; 197
    6ef0:	91 e6       	ldi	r25, 0x61	; 97
    6ef2:	9f 93       	push	r25
    6ef4:	8f 93       	push	r24
    6ef6:	f3 c0       	rjmp	.+486    	; 0x70de <strftime+0x40a>
    6ef8:	18 36       	cpi	r17, 0x68	; 104
    6efa:	09 f4       	brne	.+2      	; 0x6efe <strftime+0x22a>
    6efc:	7e c0       	rjmp	.+252    	; 0x6ffa <strftime+0x326>
    6efe:	1a 36       	cpi	r17, 0x6A	; 106
    6f00:	09 f0       	breq	.+2      	; 0x6f04 <strftime+0x230>
    6f02:	40 cf       	rjmp	.-384    	; 0x6d84 <strftime+0xb0>
    6f04:	d7 01       	movw	r26, r14
    6f06:	18 96       	adiw	r26, 0x08	; 8
    6f08:	8d 91       	ld	r24, X+
    6f0a:	9c 91       	ld	r25, X
    6f0c:	01 96       	adiw	r24, 0x01	; 1
    6f0e:	9f 93       	push	r25
    6f10:	8f 93       	push	r24
    6f12:	8b ed       	ldi	r24, 0xDB	; 219
    6f14:	91 e6       	ldi	r25, 0x61	; 97
    6f16:	ed cf       	rjmp	.-38     	; 0x6ef2 <strftime+0x21e>
    6f18:	15 37       	cpi	r17, 0x75	; 117
    6f1a:	09 f4       	brne	.+2      	; 0x6f1e <strftime+0x24a>
    6f1c:	77 c1       	rjmp	.+750    	; 0x720c <strftime+0x538>
    6f1e:	b4 f4       	brge	.+44     	; 0x6f4c <strftime+0x278>
    6f20:	10 37       	cpi	r17, 0x70	; 112
    6f22:	09 f4       	brne	.+2      	; 0x6f26 <strftime+0x252>
    6f24:	00 c1       	rjmp	.+512    	; 0x7126 <strftime+0x452>
    6f26:	34 f4       	brge	.+12     	; 0x6f34 <strftime+0x260>
    6f28:	1e 36       	cpi	r17, 0x6E	; 110
    6f2a:	09 f0       	breq	.+2      	; 0x6f2e <strftime+0x25a>
    6f2c:	2b cf       	rjmp	.-426    	; 0x6d84 <strftime+0xb0>
    6f2e:	8a e0       	ldi	r24, 0x0A	; 10
    6f30:	89 83       	std	Y+1, r24	; 0x01
    6f32:	5b c0       	rjmp	.+182    	; 0x6fea <strftime+0x316>
    6f34:	12 37       	cpi	r17, 0x72	; 114
    6f36:	09 f4       	brne	.+2      	; 0x6f3a <strftime+0x266>
    6f38:	04 c1       	rjmp	.+520    	; 0x7142 <strftime+0x46e>
    6f3a:	14 37       	cpi	r17, 0x74	; 116
    6f3c:	09 f0       	breq	.+2      	; 0x6f40 <strftime+0x26c>
    6f3e:	22 cf       	rjmp	.-444    	; 0x6d84 <strftime+0xb0>
    6f40:	61 ef       	ldi	r22, 0xF1	; 241
    6f42:	71 e6       	ldi	r23, 0x61	; 97
    6f44:	c6 01       	movw	r24, r12
    6f46:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
    6f4a:	4f c0       	rjmp	.+158    	; 0x6fea <strftime+0x316>
    6f4c:	18 37       	cpi	r17, 0x78	; 120
    6f4e:	09 f4       	brne	.+2      	; 0x6f52 <strftime+0x27e>
    6f50:	28 cf       	rjmp	.-432    	; 0x6da2 <strftime+0xce>
    6f52:	84 f4       	brge	.+32     	; 0x6f74 <strftime+0x2a0>
    6f54:	17 37       	cpi	r17, 0x77	; 119
    6f56:	09 f0       	breq	.+2      	; 0x6f5a <strftime+0x286>
    6f58:	15 cf       	rjmp	.-470    	; 0x6d84 <strftime+0xb0>
    6f5a:	f7 01       	movw	r30, r14
    6f5c:	84 81       	ldd	r24, Z+4	; 0x04
    6f5e:	28 2f       	mov	r18, r24
    6f60:	08 2e       	mov	r0, r24
    6f62:	00 0c       	add	r0, r0
    6f64:	33 0b       	sbc	r19, r19
    6f66:	3f 93       	push	r19
    6f68:	8f 93       	push	r24
    6f6a:	24 e8       	ldi	r18, 0x84	; 132
    6f6c:	39 e4       	ldi	r19, 0x49	; 73
    6f6e:	3f 93       	push	r19
    6f70:	2f 93       	push	r18
    6f72:	b5 c0       	rjmp	.+362    	; 0x70de <strftime+0x40a>
    6f74:	19 37       	cpi	r17, 0x79	; 121
    6f76:	09 f4       	brne	.+2      	; 0x6f7a <strftime+0x2a6>
    6f78:	71 c1       	rjmp	.+738    	; 0x725c <strftime+0x588>
    6f7a:	1a 37       	cpi	r17, 0x7A	; 122
    6f7c:	09 f0       	breq	.+2      	; 0x6f80 <strftime+0x2ac>
    6f7e:	02 cf       	rjmp	.-508    	; 0x6d84 <strftime+0xb0>
    6f80:	60 91 93 70 	lds	r22, 0x7093	; 0x807093 <__utc_offset>
    6f84:	70 91 94 70 	lds	r23, 0x7094	; 0x807094 <__utc_offset+0x1>
    6f88:	80 91 95 70 	lds	r24, 0x7095	; 0x807095 <__utc_offset+0x2>
    6f8c:	90 91 96 70 	lds	r25, 0x7096	; 0x807096 <__utc_offset+0x3>
    6f90:	2c e3       	ldi	r18, 0x3C	; 60
    6f92:	30 e0       	ldi	r19, 0x00	; 0
    6f94:	40 e0       	ldi	r20, 0x00	; 0
    6f96:	50 e0       	ldi	r21, 0x00	; 0
    6f98:	0e 94 9b 52 	call	0xa536	; 0xa536 <__divmodsi4>
    6f9c:	89 01       	movw	r16, r18
    6f9e:	f9 01       	movw	r30, r18
    6fa0:	d7 01       	movw	r26, r14
    6fa2:	1a 96       	adiw	r26, 0x0a	; 10
    6fa4:	8d 91       	ld	r24, X+
    6fa6:	9c 91       	ld	r25, X
    6fa8:	6c e3       	ldi	r22, 0x3C	; 60
    6faa:	70 e0       	ldi	r23, 0x00	; 0
    6fac:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    6fb0:	16 16       	cp	r1, r22
    6fb2:	17 06       	cpc	r1, r23
    6fb4:	1c f4       	brge	.+6      	; 0x6fbc <strftime+0x2e8>
    6fb6:	fb 01       	movw	r30, r22
    6fb8:	e0 0f       	add	r30, r16
    6fba:	f1 1f       	adc	r31, r17
    6fbc:	cf 01       	movw	r24, r30
    6fbe:	6c e3       	ldi	r22, 0x3C	; 60
    6fc0:	70 e0       	ldi	r23, 0x00	; 0
    6fc2:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    6fc6:	97 ff       	sbrs	r25, 7
    6fc8:	03 c0       	rjmp	.+6      	; 0x6fd0 <strftime+0x2fc>
    6fca:	91 95       	neg	r25
    6fcc:	81 95       	neg	r24
    6fce:	91 09       	sbc	r25, r1
    6fd0:	9f 93       	push	r25
    6fd2:	8f 93       	push	r24
    6fd4:	cf 01       	movw	r24, r30
    6fd6:	6c e3       	ldi	r22, 0x3C	; 60
    6fd8:	70 e0       	ldi	r23, 0x00	; 0
    6fda:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    6fde:	7f 93       	push	r23
    6fe0:	6f 93       	push	r22
    6fe2:	81 e1       	ldi	r24, 0x11	; 17
    6fe4:	92 e6       	ldi	r25, 0x62	; 98
    6fe6:	ef c0       	rjmp	.+478    	; 0x71c6 <strftime+0x4f2>
    6fe8:	19 83       	std	Y+1, r17	; 0x01
    6fea:	81 e0       	ldi	r24, 0x01	; 1
    6fec:	90 e0       	ldi	r25, 0x00	; 0
    6fee:	55 cf       	rjmp	.-342    	; 0x6e9a <strftime+0x1c6>
    6ff0:	0f ef       	ldi	r16, 0xFF	; 255
    6ff2:	96 01       	movw	r18, r12
    6ff4:	f7 01       	movw	r30, r14
    6ff6:	44 81       	ldd	r20, Z+4	; 0x04
    6ff8:	4b cf       	rjmp	.-362    	; 0x6e90 <strftime+0x1bc>
    6ffa:	03 e0       	ldi	r16, 0x03	; 3
    6ffc:	96 01       	movw	r18, r12
    6ffe:	d7 01       	movw	r26, r14
    7000:	15 96       	adiw	r26, 0x05	; 5
    7002:	4c 91       	ld	r20, X
    7004:	60 ea       	ldi	r22, 0xA0	; 160
    7006:	72 e0       	ldi	r23, 0x02	; 2
    7008:	80 e0       	ldi	r24, 0x00	; 0
    700a:	45 cf       	rjmp	.-374    	; 0x6e96 <strftime+0x1c2>
    700c:	0f ef       	ldi	r16, 0xFF	; 255
    700e:	96 01       	movw	r18, r12
    7010:	f7 01       	movw	r30, r14
    7012:	45 81       	ldd	r20, Z+5	; 0x05
    7014:	f7 cf       	rjmp	.-18     	; 0x7004 <strftime+0x330>
    7016:	b6 01       	movw	r22, r12
    7018:	c7 01       	movw	r24, r14
    701a:	70 d1       	rcall	.+736    	; 0x72fc <asctime_r>
    701c:	f6 01       	movw	r30, r12
    701e:	cf 01       	movw	r24, r30
    7020:	8c 19       	sub	r24, r12
    7022:	9d 09       	sbc	r25, r13
    7024:	21 91       	ld	r18, Z+
    7026:	21 11       	cpse	r18, r1
    7028:	fa cf       	rjmp	.-12     	; 0x701e <strftime+0x34a>
    702a:	37 cf       	rjmp	.-402    	; 0x6e9a <strftime+0x1c6>
    702c:	d7 01       	movw	r26, r14
    702e:	16 96       	adiw	r26, 0x06	; 6
    7030:	8d 91       	ld	r24, X+
    7032:	9c 91       	ld	r25, X
    7034:	84 59       	subi	r24, 0x94	; 148
    7036:	98 4f       	sbci	r25, 0xF8	; 248
    7038:	b2 01       	movw	r22, r4
    703a:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    703e:	7f 93       	push	r23
    7040:	6f 93       	push	r22
    7042:	e1 ed       	ldi	r30, 0xD1	; 209
    7044:	f1 e6       	ldi	r31, 0x61	; 97
    7046:	ff 93       	push	r31
    7048:	ef 93       	push	r30
    704a:	49 c0       	rjmp	.+146    	; 0x70de <strftime+0x40a>
    704c:	d7 01       	movw	r26, r14
    704e:	13 96       	adiw	r26, 0x03	; 3
    7050:	8c 91       	ld	r24, X
    7052:	28 2f       	mov	r18, r24
    7054:	08 2e       	mov	r0, r24
    7056:	00 0c       	add	r0, r0
    7058:	33 0b       	sbc	r19, r19
    705a:	3f 93       	push	r19
    705c:	8f 93       	push	r24
    705e:	58 c0       	rjmp	.+176    	; 0x7110 <strftime+0x43c>
    7060:	d7 01       	movw	r26, r14
    7062:	13 96       	adiw	r26, 0x03	; 3
    7064:	8c 91       	ld	r24, X
    7066:	13 97       	sbiw	r26, 0x03	; 3
    7068:	28 2f       	mov	r18, r24
    706a:	08 2e       	mov	r0, r24
    706c:	00 0c       	add	r0, r0
    706e:	33 0b       	sbc	r19, r19
    7070:	3f 93       	push	r19
    7072:	8f 93       	push	r24
    7074:	15 96       	adiw	r26, 0x05	; 5
    7076:	8c 91       	ld	r24, X
    7078:	15 97       	sbiw	r26, 0x05	; 5
    707a:	08 2e       	mov	r0, r24
    707c:	00 0c       	add	r0, r0
    707e:	99 0b       	sbc	r25, r25
    7080:	01 96       	adiw	r24, 0x01	; 1
    7082:	9f 93       	push	r25
    7084:	8f 93       	push	r24
    7086:	16 96       	adiw	r26, 0x06	; 6
    7088:	8d 91       	ld	r24, X+
    708a:	9c 91       	ld	r25, X
    708c:	84 59       	subi	r24, 0x94	; 148
    708e:	98 4f       	sbci	r25, 0xF8	; 248
    7090:	9f 93       	push	r25
    7092:	8f 93       	push	r24
    7094:	89 ec       	ldi	r24, 0xC9	; 201
    7096:	91 e6       	ldi	r25, 0x61	; 97
    7098:	9f 93       	push	r25
    709a:	8f 93       	push	r24
    709c:	9c ce       	rjmp	.-712    	; 0x6dd6 <strftime+0x102>
    709e:	d7 01       	movw	r26, r14
    70a0:	18 96       	adiw	r26, 0x08	; 8
    70a2:	6d 91       	ld	r22, X+
    70a4:	7c 91       	ld	r23, X
    70a6:	19 97       	sbiw	r26, 0x09	; 9
    70a8:	16 96       	adiw	r26, 0x06	; 6
    70aa:	8d 91       	ld	r24, X+
    70ac:	9c 91       	ld	r25, X
    70ae:	ae 01       	movw	r20, r28
    70b0:	45 5e       	subi	r20, 0xE5	; 229
    70b2:	5f 4f       	sbci	r21, 0xFF	; 255
    70b4:	84 59       	subi	r24, 0x94	; 148
    70b6:	98 4f       	sbci	r25, 0xF8	; 248
    70b8:	9e d1       	rcall	.+828    	; 0x73f6 <iso_week_date_r>
    70ba:	17 36       	cpi	r17, 0x67	; 103
    70bc:	41 f4       	brne	.+16     	; 0x70ce <strftime+0x3fa>
    70be:	8b 8d       	ldd	r24, Y+27	; 0x1b
    70c0:	9c 8d       	ldd	r25, Y+28	; 0x1c
    70c2:	b2 01       	movw	r22, r4
    70c4:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    70c8:	9f 93       	push	r25
    70ca:	8f 93       	push	r24
    70cc:	ba cf       	rjmp	.-140    	; 0x7042 <strftime+0x36e>
    70ce:	8c 8d       	ldd	r24, Y+28	; 0x1c
    70d0:	8f 93       	push	r24
    70d2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    70d4:	8f 93       	push	r24
    70d6:	46 ed       	ldi	r20, 0xD6	; 214
    70d8:	51 e6       	ldi	r21, 0x61	; 97
    70da:	5f 93       	push	r21
    70dc:	4f 93       	push	r20
    70de:	df 92       	push	r13
    70e0:	cf 92       	push	r12
    70e2:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    70e6:	0f 90       	pop	r0
    70e8:	0f 90       	pop	r0
    70ea:	0f 90       	pop	r0
    70ec:	0f 90       	pop	r0
    70ee:	0f 90       	pop	r0
    70f0:	0f 90       	pop	r0
    70f2:	d3 ce       	rjmp	.-602    	; 0x6e9a <strftime+0x1c6>
    70f4:	f7 01       	movw	r30, r14
    70f6:	82 81       	ldd	r24, Z+2	; 0x02
    70f8:	6c e0       	ldi	r22, 0x0C	; 12
    70fa:	0e 94 03 5b 	call	0xb606	; 0xb606 <__divmodqi4>
    70fe:	91 11       	cpse	r25, r1
    7100:	01 c0       	rjmp	.+2      	; 0x7104 <strftime+0x430>
    7102:	9c e0       	ldi	r25, 0x0C	; 12
    7104:	29 2f       	mov	r18, r25
    7106:	09 2e       	mov	r0, r25
    7108:	00 0c       	add	r0, r0
    710a:	33 0b       	sbc	r19, r19
    710c:	3f 93       	push	r19
    710e:	9f 93       	push	r25
    7110:	bf 92       	push	r11
    7112:	af 92       	push	r10
    7114:	e4 cf       	rjmp	.-56     	; 0x70de <strftime+0x40a>
    7116:	f7 01       	movw	r30, r14
    7118:	85 81       	ldd	r24, Z+5	; 0x05
    711a:	08 2e       	mov	r0, r24
    711c:	00 0c       	add	r0, r0
    711e:	99 0b       	sbc	r25, r25
    7120:	01 96       	adiw	r24, 0x01	; 1
    7122:	9f 93       	push	r25
    7124:	9b cf       	rjmp	.-202    	; 0x705c <strftime+0x388>
    7126:	81 e4       	ldi	r24, 0x41	; 65
    7128:	89 83       	std	Y+1, r24	; 0x01
    712a:	f7 01       	movw	r30, r14
    712c:	82 81       	ldd	r24, Z+2	; 0x02
    712e:	8c 30       	cpi	r24, 0x0C	; 12
    7130:	14 f0       	brlt	.+4      	; 0x7136 <strftime+0x462>
    7132:	80 e5       	ldi	r24, 0x50	; 80
    7134:	89 83       	std	Y+1, r24	; 0x01
    7136:	8d e4       	ldi	r24, 0x4D	; 77
    7138:	8a 83       	std	Y+2, r24	; 0x02
    713a:	1b 82       	std	Y+3, r1	; 0x03
    713c:	82 e0       	ldi	r24, 0x02	; 2
    713e:	90 e0       	ldi	r25, 0x00	; 0
    7140:	ac ce       	rjmp	.-680    	; 0x6e9a <strftime+0x1c6>
    7142:	d7 01       	movw	r26, r14
    7144:	12 96       	adiw	r26, 0x02	; 2
    7146:	8c 91       	ld	r24, X
    7148:	6c e0       	ldi	r22, 0x0C	; 12
    714a:	0e 94 03 5b 	call	0xb606	; 0xb606 <__divmodqi4>
    714e:	91 11       	cpse	r25, r1
    7150:	01 c0       	rjmp	.+2      	; 0x7154 <strftime+0x480>
    7152:	9c e0       	ldi	r25, 0x0C	; 12
    7154:	f7 01       	movw	r30, r14
    7156:	80 81       	ld	r24, Z
    7158:	28 2f       	mov	r18, r24
    715a:	08 2e       	mov	r0, r24
    715c:	00 0c       	add	r0, r0
    715e:	33 0b       	sbc	r19, r19
    7160:	3f 93       	push	r19
    7162:	8f 93       	push	r24
    7164:	81 81       	ldd	r24, Z+1	; 0x01
    7166:	28 2f       	mov	r18, r24
    7168:	08 2e       	mov	r0, r24
    716a:	00 0c       	add	r0, r0
    716c:	33 0b       	sbc	r19, r19
    716e:	3f 93       	push	r19
    7170:	8f 93       	push	r24
    7172:	29 2f       	mov	r18, r25
    7174:	09 2e       	mov	r0, r25
    7176:	00 0c       	add	r0, r0
    7178:	33 0b       	sbc	r19, r19
    717a:	3f 93       	push	r19
    717c:	9f 93       	push	r25
    717e:	80 ee       	ldi	r24, 0xE0	; 224
    7180:	91 e6       	ldi	r25, 0x61	; 97
    7182:	9f 93       	push	r25
    7184:	8f 93       	push	r24
    7186:	df 92       	push	r13
    7188:	cf 92       	push	r12
    718a:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    718e:	cd bf       	out	0x3d, r28	; 61
    7190:	de bf       	out	0x3e, r29	; 62
    7192:	d7 01       	movw	r26, r14
    7194:	12 96       	adiw	r26, 0x02	; 2
    7196:	2c 91       	ld	r18, X
    7198:	2c 30       	cpi	r18, 0x0C	; 12
    719a:	0c f4       	brge	.+2      	; 0x719e <strftime+0x4ca>
    719c:	7e ce       	rjmp	.-772    	; 0x6e9a <strftime+0x1c6>
    719e:	20 e5       	ldi	r18, 0x50	; 80
    71a0:	2b 87       	std	Y+11, r18	; 0x0b
    71a2:	7b ce       	rjmp	.-778    	; 0x6e9a <strftime+0x1c6>
    71a4:	f7 01       	movw	r30, r14
    71a6:	81 81       	ldd	r24, Z+1	; 0x01
    71a8:	28 2f       	mov	r18, r24
    71aa:	08 2e       	mov	r0, r24
    71ac:	00 0c       	add	r0, r0
    71ae:	33 0b       	sbc	r19, r19
    71b0:	3f 93       	push	r19
    71b2:	8f 93       	push	r24
    71b4:	82 81       	ldd	r24, Z+2	; 0x02
    71b6:	28 2f       	mov	r18, r24
    71b8:	08 2e       	mov	r0, r24
    71ba:	00 0c       	add	r0, r0
    71bc:	33 0b       	sbc	r19, r19
    71be:	3f 93       	push	r19
    71c0:	8f 93       	push	r24
    71c2:	88 ef       	ldi	r24, 0xF8	; 248
    71c4:	91 e6       	ldi	r25, 0x61	; 97
    71c6:	9f 93       	push	r25
    71c8:	8f 93       	push	r24
    71ca:	df 92       	push	r13
    71cc:	cf 92       	push	r12
    71ce:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
    71d2:	05 ce       	rjmp	.-1014   	; 0x6dde <strftime+0x10a>
    71d4:	d7 01       	movw	r26, r14
    71d6:	8c 91       	ld	r24, X
    71d8:	3c cf       	rjmp	.-392    	; 0x7052 <strftime+0x37e>
    71da:	f7 01       	movw	r30, r14
    71dc:	80 81       	ld	r24, Z
    71de:	28 2f       	mov	r18, r24
    71e0:	08 2e       	mov	r0, r24
    71e2:	00 0c       	add	r0, r0
    71e4:	33 0b       	sbc	r19, r19
    71e6:	3f 93       	push	r19
    71e8:	8f 93       	push	r24
    71ea:	81 81       	ldd	r24, Z+1	; 0x01
    71ec:	28 2f       	mov	r18, r24
    71ee:	08 2e       	mov	r0, r24
    71f0:	00 0c       	add	r0, r0
    71f2:	33 0b       	sbc	r19, r19
    71f4:	3f 93       	push	r19
    71f6:	8f 93       	push	r24
    71f8:	82 81       	ldd	r24, Z+2	; 0x02
    71fa:	28 2f       	mov	r18, r24
    71fc:	08 2e       	mov	r0, r24
    71fe:	00 0c       	add	r0, r0
    7200:	33 0b       	sbc	r19, r19
    7202:	3f 93       	push	r19
    7204:	8f 93       	push	r24
    7206:	83 ef       	ldi	r24, 0xF3	; 243
    7208:	91 e6       	ldi	r25, 0x61	; 97
    720a:	46 cf       	rjmp	.-372    	; 0x7098 <strftime+0x3c4>
    720c:	d7 01       	movw	r26, r14
    720e:	14 96       	adiw	r26, 0x04	; 4
    7210:	8c 91       	ld	r24, X
    7212:	08 2e       	mov	r0, r24
    7214:	00 0c       	add	r0, r0
    7216:	99 0b       	sbc	r25, r25
    7218:	00 97       	sbiw	r24, 0x00	; 0
    721a:	11 f4       	brne	.+4      	; 0x7220 <strftime+0x54c>
    721c:	87 e0       	ldi	r24, 0x07	; 7
    721e:	90 e0       	ldi	r25, 0x00	; 0
    7220:	9f 93       	push	r25
    7222:	8f 93       	push	r24
    7224:	e4 e8       	ldi	r30, 0x84	; 132
    7226:	f6 e4       	ldi	r31, 0x46	; 70
    7228:	0e cf       	rjmp	.-484    	; 0x7046 <strftime+0x372>
    722a:	60 e0       	ldi	r22, 0x00	; 0
    722c:	c7 01       	movw	r24, r14
    722e:	47 d0       	rcall	.+142    	; 0x72be <week_of_year>
    7230:	1f 92       	push	r1
    7232:	14 cf       	rjmp	.-472    	; 0x705c <strftime+0x388>
    7234:	d7 01       	movw	r26, r14
    7236:	18 96       	adiw	r26, 0x08	; 8
    7238:	6d 91       	ld	r22, X+
    723a:	7c 91       	ld	r23, X
    723c:	19 97       	sbiw	r26, 0x09	; 9
    723e:	16 96       	adiw	r26, 0x06	; 6
    7240:	8d 91       	ld	r24, X+
    7242:	9c 91       	ld	r25, X
    7244:	ae 01       	movw	r20, r28
    7246:	45 5e       	subi	r20, 0xE5	; 229
    7248:	5f 4f       	sbci	r21, 0xFF	; 255
    724a:	84 59       	subi	r24, 0x94	; 148
    724c:	98 4f       	sbci	r25, 0xF8	; 248
    724e:	d3 d0       	rcall	.+422    	; 0x73f6 <iso_week_date_r>
    7250:	8e 8d       	ldd	r24, Y+30	; 0x1e
    7252:	8f 93       	push	r24
    7254:	8d 8d       	ldd	r24, Y+29	; 0x1d
    7256:	02 cf       	rjmp	.-508    	; 0x705c <strftime+0x388>
    7258:	61 e0       	ldi	r22, 0x01	; 1
    725a:	e8 cf       	rjmp	.-48     	; 0x722c <strftime+0x558>
    725c:	d7 01       	movw	r26, r14
    725e:	16 96       	adiw	r26, 0x06	; 6
    7260:	8d 91       	ld	r24, X+
    7262:	9c 91       	ld	r25, X
    7264:	b2 01       	movw	r22, r4
    7266:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    726a:	5b cf       	rjmp	.-330    	; 0x7122 <strftime+0x44e>
    726c:	f7 01       	movw	r30, r14
    726e:	86 81       	ldd	r24, Z+6	; 0x06
    7270:	97 81       	ldd	r25, Z+7	; 0x07
    7272:	84 59       	subi	r24, 0x94	; 148
    7274:	98 4f       	sbci	r25, 0xF8	; 248
    7276:	9f 93       	push	r25
    7278:	77 ce       	rjmp	.-786    	; 0x6f68 <strftime+0x294>
    727a:	41 91       	ld	r20, Z+
    727c:	4d 93       	st	X+, r20
    727e:	18 ce       	rjmp	.-976    	; 0x6eb0 <strftime+0x1dc>
    7280:	f4 01       	movw	r30, r8
    7282:	81 93       	st	Z+, r24
    7284:	4f 01       	movw	r8, r30
    7286:	ff ef       	ldi	r31, 0xFF	; 255
    7288:	6f 1a       	sub	r6, r31
    728a:	7f 0a       	sbc	r7, r31
    728c:	81 11       	cpse	r24, r1
    728e:	1e ce       	rjmp	.-964    	; 0x6ecc <strftime+0x1f8>
    7290:	c3 01       	movw	r24, r6
    7292:	a2 96       	adiw	r28, 0x22	; 34
    7294:	cd bf       	out	0x3d, r28	; 61
    7296:	de bf       	out	0x3e, r29	; 62
    7298:	df 91       	pop	r29
    729a:	cf 91       	pop	r28
    729c:	1f 91       	pop	r17
    729e:	0f 91       	pop	r16
    72a0:	ff 90       	pop	r15
    72a2:	ef 90       	pop	r14
    72a4:	df 90       	pop	r13
    72a6:	cf 90       	pop	r12
    72a8:	bf 90       	pop	r11
    72aa:	af 90       	pop	r10
    72ac:	9f 90       	pop	r9
    72ae:	8f 90       	pop	r8
    72b0:	7f 90       	pop	r7
    72b2:	6f 90       	pop	r6
    72b4:	5f 90       	pop	r5
    72b6:	4f 90       	pop	r4
    72b8:	3f 90       	pop	r3
    72ba:	2f 90       	pop	r2
    72bc:	08 95       	ret

000072be <week_of_year>:
week_of_year():
    72be:	fc 01       	movw	r30, r24
    72c0:	20 85       	ldd	r18, Z+8	; 0x08
    72c2:	31 85       	ldd	r19, Z+9	; 0x09
    72c4:	c9 01       	movw	r24, r18
    72c6:	07 96       	adiw	r24, 0x07	; 7
    72c8:	44 81       	ldd	r20, Z+4	; 0x04
    72ca:	84 1b       	sub	r24, r20
    72cc:	91 09       	sbc	r25, r1
    72ce:	47 fd       	sbrc	r20, 7
    72d0:	93 95       	inc	r25
    72d2:	86 0f       	add	r24, r22
    72d4:	91 1d       	adc	r25, r1
    72d6:	e7 e0       	ldi	r30, 0x07	; 7
    72d8:	f0 e0       	ldi	r31, 0x00	; 0
    72da:	bf 01       	movw	r22, r30
    72dc:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    72e0:	a9 01       	movw	r20, r18
    72e2:	48 1b       	sub	r20, r24
    72e4:	59 0b       	sbc	r21, r25
    72e6:	ca 01       	movw	r24, r20
    72e8:	57 fd       	sbrc	r21, 7
    72ea:	06 c0       	rjmp	.+12     	; 0x72f8 <week_of_year+0x3a>
    72ec:	bf 01       	movw	r22, r30
    72ee:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    72f2:	81 e0       	ldi	r24, 0x01	; 1
    72f4:	86 0f       	add	r24, r22
    72f6:	08 95       	ret
    72f8:	80 e0       	ldi	r24, 0x00	; 0
    72fa:	08 95       	ret

000072fc <asctime_r>:
asctime_r():
    72fc:	cf 92       	push	r12
    72fe:	df 92       	push	r13
    7300:	ef 92       	push	r14
    7302:	ff 92       	push	r15
    7304:	0f 93       	push	r16
    7306:	1f 93       	push	r17
    7308:	cf 93       	push	r28
    730a:	df 93       	push	r29
    730c:	8c 01       	movw	r16, r24
    730e:	eb 01       	movw	r28, r22
    7310:	fc 01       	movw	r30, r24
    7312:	84 81       	ldd	r24, Z+4	; 0x04
    7314:	b8 2f       	mov	r27, r24
    7316:	bb 0f       	add	r27, r27
    7318:	b8 0f       	add	r27, r24
    731a:	85 81       	ldd	r24, Z+5	; 0x05
    731c:	78 2f       	mov	r23, r24
    731e:	77 0f       	add	r23, r23
    7320:	78 0f       	add	r23, r24
    7322:	9e 01       	movw	r18, r28
    7324:	40 e0       	ldi	r20, 0x00	; 0
    7326:	8b 2f       	mov	r24, r27
    7328:	84 0f       	add	r24, r20
    732a:	90 e0       	ldi	r25, 0x00	; 0
    732c:	a0 e0       	ldi	r26, 0x00	; 0
    732e:	8f 5c       	subi	r24, 0xCF	; 207
    7330:	9c 4f       	sbci	r25, 0xFC	; 252
    7332:	af 4f       	sbci	r26, 0xFF	; 255
    7334:	fc 01       	movw	r30, r24
    7336:	5a 2f       	mov	r21, r26
    7338:	0e 94 10 5b 	call	0xb620	; 0xb620 <__xload_1>
    733c:	f9 01       	movw	r30, r18
    733e:	61 93       	st	Z+, r22
    7340:	9f 01       	movw	r18, r30
    7342:	87 2f       	mov	r24, r23
    7344:	84 0f       	add	r24, r20
    7346:	90 e0       	ldi	r25, 0x00	; 0
    7348:	a0 e0       	ldi	r26, 0x00	; 0
    734a:	89 5b       	subi	r24, 0xB9	; 185
    734c:	9c 4f       	sbci	r25, 0xFC	; 252
    734e:	af 4f       	sbci	r26, 0xFF	; 255
    7350:	fc 01       	movw	r30, r24
    7352:	5a 2f       	mov	r21, r26
    7354:	0e 94 10 5b 	call	0xb620	; 0xb620 <__xload_1>
    7358:	f9 01       	movw	r30, r18
    735a:	63 83       	std	Z+3, r22	; 0x03
    735c:	4f 5f       	subi	r20, 0xFF	; 255
    735e:	43 30       	cpi	r20, 0x03	; 3
    7360:	11 f7       	brne	.-60     	; 0x7326 <asctime_r+0x2a>
    7362:	80 e2       	ldi	r24, 0x20	; 32
    7364:	8f 83       	std	Y+7, r24	; 0x07
    7366:	8b 83       	std	Y+3, r24	; 0x03
    7368:	be 01       	movw	r22, r28
    736a:	68 5f       	subi	r22, 0xF8	; 248
    736c:	7f 4f       	sbci	r23, 0xFF	; 255
    736e:	f8 01       	movw	r30, r16
    7370:	83 81       	ldd	r24, Z+3	; 0x03
    7372:	40 e2       	ldi	r20, 0x20	; 32
    7374:	08 2e       	mov	r0, r24
    7376:	00 0c       	add	r0, r0
    7378:	99 0b       	sbc	r25, r25
    737a:	b4 d0       	rcall	.+360    	; 0x74e4 <__print_lz>
    737c:	be 01       	movw	r22, r28
    737e:	65 5f       	subi	r22, 0xF5	; 245
    7380:	7f 4f       	sbci	r23, 0xFF	; 255
    7382:	f8 01       	movw	r30, r16
    7384:	82 81       	ldd	r24, Z+2	; 0x02
    7386:	4a e3       	ldi	r20, 0x3A	; 58
    7388:	08 2e       	mov	r0, r24
    738a:	00 0c       	add	r0, r0
    738c:	99 0b       	sbc	r25, r25
    738e:	aa d0       	rcall	.+340    	; 0x74e4 <__print_lz>
    7390:	be 01       	movw	r22, r28
    7392:	62 5f       	subi	r22, 0xF2	; 242
    7394:	7f 4f       	sbci	r23, 0xFF	; 255
    7396:	f8 01       	movw	r30, r16
    7398:	81 81       	ldd	r24, Z+1	; 0x01
    739a:	4a e3       	ldi	r20, 0x3A	; 58
    739c:	08 2e       	mov	r0, r24
    739e:	00 0c       	add	r0, r0
    73a0:	99 0b       	sbc	r25, r25
    73a2:	a0 d0       	rcall	.+320    	; 0x74e4 <__print_lz>
    73a4:	be 01       	movw	r22, r28
    73a6:	6f 5e       	subi	r22, 0xEF	; 239
    73a8:	7f 4f       	sbci	r23, 0xFF	; 255
    73aa:	f8 01       	movw	r30, r16
    73ac:	80 81       	ld	r24, Z
    73ae:	40 e2       	ldi	r20, 0x20	; 32
    73b0:	08 2e       	mov	r0, r24
    73b2:	00 0c       	add	r0, r0
    73b4:	99 0b       	sbc	r25, r25
    73b6:	96 d0       	rcall	.+300    	; 0x74e4 <__print_lz>
    73b8:	f8 01       	movw	r30, r16
    73ba:	86 81       	ldd	r24, Z+6	; 0x06
    73bc:	97 81       	ldd	r25, Z+7	; 0x07
    73be:	64 e6       	ldi	r22, 0x64	; 100
    73c0:	70 e0       	ldi	r23, 0x00	; 0
    73c2:	84 59       	subi	r24, 0x94	; 148
    73c4:	98 4f       	sbci	r25, 0xF8	; 248
    73c6:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    73ca:	6b 01       	movw	r12, r22
    73cc:	7c 01       	movw	r14, r24
    73ce:	be 01       	movw	r22, r28
    73d0:	6c 5e       	subi	r22, 0xEC	; 236
    73d2:	7f 4f       	sbci	r23, 0xFF	; 255
    73d4:	40 e2       	ldi	r20, 0x20	; 32
    73d6:	c6 01       	movw	r24, r12
    73d8:	85 d0       	rcall	.+266    	; 0x74e4 <__print_lz>
    73da:	be 01       	movw	r22, r28
    73dc:	6a 5e       	subi	r22, 0xEA	; 234
    73de:	7f 4f       	sbci	r23, 0xFF	; 255
    73e0:	40 e0       	ldi	r20, 0x00	; 0
    73e2:	c7 01       	movw	r24, r14
    73e4:	df 91       	pop	r29
    73e6:	cf 91       	pop	r28
    73e8:	1f 91       	pop	r17
    73ea:	0f 91       	pop	r16
    73ec:	ff 90       	pop	r15
    73ee:	ef 90       	pop	r14
    73f0:	df 90       	pop	r13
    73f2:	cf 90       	pop	r12
    73f4:	77 c0       	rjmp	.+238    	; 0x74e4 <__print_lz>

000073f6 <iso_week_date_r>:
iso_week_date_r():
    73f6:	cf 92       	push	r12
    73f8:	df 92       	push	r13
    73fa:	ef 92       	push	r14
    73fc:	ff 92       	push	r15
    73fe:	0f 93       	push	r16
    7400:	1f 93       	push	r17
    7402:	cf 93       	push	r28
    7404:	df 93       	push	r29
    7406:	8c 01       	movw	r16, r24
    7408:	7b 01       	movw	r14, r22
    740a:	ea 01       	movw	r28, r20
    740c:	88 83       	st	Y, r24
    740e:	99 83       	std	Y+1, r25	; 0x01
    7410:	22 dc       	rcall	.-1980   	; 0x6c56 <is_leap_year>
    7412:	28 2f       	mov	r18, r24
    7414:	a8 01       	movw	r20, r16
    7416:	40 5d       	subi	r20, 0xD0	; 208
    7418:	57 40       	sbci	r21, 0x07	; 7
    741a:	6d e6       	ldi	r22, 0x6D	; 109
    741c:	71 e0       	ldi	r23, 0x01	; 1
    741e:	46 9f       	mul	r20, r22
    7420:	c0 01       	movw	r24, r0
    7422:	47 9f       	mul	r20, r23
    7424:	90 0d       	add	r25, r0
    7426:	56 9f       	mul	r21, r22
    7428:	90 0d       	add	r25, r0
    742a:	11 24       	eor	r1, r1
    742c:	8e 0d       	add	r24, r14
    742e:	9f 1d       	adc	r25, r15
    7430:	41 15       	cp	r20, r1
    7432:	51 05       	cpc	r21, r1
    7434:	79 f0       	breq	.+30     	; 0x7454 <iso_week_date_r+0x5e>
    7436:	ba 01       	movw	r22, r20
    7438:	76 95       	lsr	r23
    743a:	67 95       	ror	r22
    743c:	76 95       	lsr	r23
    743e:	67 95       	ror	r22
    7440:	6f 5f       	subi	r22, 0xFF	; 255
    7442:	7f 4f       	sbci	r23, 0xFF	; 255
    7444:	86 0f       	add	r24, r22
    7446:	97 1f       	adc	r25, r23
    7448:	82 1b       	sub	r24, r18
    744a:	91 09       	sbc	r25, r1
    744c:	45 36       	cpi	r20, 0x65	; 101
    744e:	51 05       	cpc	r21, r1
    7450:	08 f0       	brcs	.+2      	; 0x7454 <iso_week_date_r+0x5e>
    7452:	01 97       	sbiw	r24, 0x01	; 1
    7454:	06 96       	adiw	r24, 0x06	; 6
    7456:	67 e0       	ldi	r22, 0x07	; 7
    7458:	70 e0       	ldi	r23, 0x00	; 0
    745a:	0e 94 52 52 	call	0xa4a4	; 0xa4a4 <__udivmodhi4>
    745e:	6c 01       	movw	r12, r24
    7460:	89 2b       	or	r24, r25
    7462:	19 f4       	brne	.+6      	; 0x746a <iso_week_date_r+0x74>
    7464:	87 e0       	ldi	r24, 0x07	; 7
    7466:	c8 2e       	mov	r12, r24
    7468:	d1 2c       	mov	r13, r1
    746a:	cc 82       	std	Y+4, r12	; 0x04
    746c:	dd 82       	std	Y+5, r13	; 0x05
    746e:	c7 01       	movw	r24, r14
    7470:	0b 96       	adiw	r24, 0x0b	; 11
    7472:	8c 19       	sub	r24, r12
    7474:	9d 09       	sbc	r25, r13
    7476:	67 e0       	ldi	r22, 0x07	; 7
    7478:	70 e0       	ldi	r23, 0x00	; 0
    747a:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    747e:	65 33       	cpi	r22, 0x35	; 53
    7480:	71 05       	cpc	r23, r1
    7482:	b1 f4       	brne	.+44     	; 0x74b0 <iso_week_date_r+0xba>
    7484:	81 e0       	ldi	r24, 0x01	; 1
    7486:	c8 1a       	sub	r12, r24
    7488:	d1 08       	sbc	r13, r1
    748a:	ec 18       	sub	r14, r12
    748c:	fd 08       	sbc	r15, r13
    748e:	82 2f       	mov	r24, r18
    7490:	90 e0       	ldi	r25, 0x00	; 0
    7492:	84 59       	subi	r24, 0x94	; 148
    7494:	9e 4f       	sbci	r25, 0xFE	; 254
    7496:	23 e0       	ldi	r18, 0x03	; 3
    7498:	e2 0e       	add	r14, r18
    749a:	f1 1c       	adc	r15, r1
    749c:	8e 15       	cp	r24, r14
    749e:	9f 05       	cpc	r25, r15
    74a0:	3c f4       	brge	.+14     	; 0x74b0 <iso_week_date_r+0xba>
    74a2:	88 81       	ld	r24, Y
    74a4:	99 81       	ldd	r25, Y+1	; 0x01
    74a6:	01 96       	adiw	r24, 0x01	; 1
    74a8:	88 83       	st	Y, r24
    74aa:	99 83       	std	Y+1, r25	; 0x01
    74ac:	61 e0       	ldi	r22, 0x01	; 1
    74ae:	70 e0       	ldi	r23, 0x00	; 0
    74b0:	6a 83       	std	Y+2, r22	; 0x02
    74b2:	7b 83       	std	Y+3, r23	; 0x03
    74b4:	67 2b       	or	r22, r23
    74b6:	69 f4       	brne	.+26     	; 0x74d2 <iso_week_date_r+0xdc>
    74b8:	01 50       	subi	r16, 0x01	; 1
    74ba:	11 09       	sbc	r17, r1
    74bc:	c8 01       	movw	r24, r16
    74be:	cb db       	rcall	.-2154   	; 0x6c56 <is_leap_year>
    74c0:	68 2f       	mov	r22, r24
    74c2:	70 e0       	ldi	r23, 0x00	; 0
    74c4:	64 59       	subi	r22, 0x94	; 148
    74c6:	7e 4f       	sbci	r23, 0xFE	; 254
    74c8:	ae 01       	movw	r20, r28
    74ca:	c8 01       	movw	r24, r16
    74cc:	94 df       	rcall	.-216    	; 0x73f6 <iso_week_date_r>
    74ce:	cc 82       	std	Y+4, r12	; 0x04
    74d0:	dd 82       	std	Y+5, r13	; 0x05
    74d2:	df 91       	pop	r29
    74d4:	cf 91       	pop	r28
    74d6:	1f 91       	pop	r17
    74d8:	0f 91       	pop	r16
    74da:	ff 90       	pop	r15
    74dc:	ef 90       	pop	r14
    74de:	df 90       	pop	r13
    74e0:	cf 90       	pop	r12
    74e2:	08 95       	ret

000074e4 <__print_lz>:
__print_lz():
    74e4:	1f 93       	push	r17
    74e6:	cf 93       	push	r28
    74e8:	df 93       	push	r29
    74ea:	eb 01       	movw	r28, r22
    74ec:	14 2f       	mov	r17, r20
    74ee:	6a e0       	ldi	r22, 0x0A	; 10
    74f0:	70 e0       	ldi	r23, 0x00	; 0
    74f2:	0e 94 66 52 	call	0xa4cc	; 0xa4cc <__divmodhi4>
    74f6:	60 5d       	subi	r22, 0xD0	; 208
    74f8:	68 83       	st	Y, r22
    74fa:	80 5d       	subi	r24, 0xD0	; 208
    74fc:	89 83       	std	Y+1, r24	; 0x01
    74fe:	1a 83       	std	Y+2, r17	; 0x02
    7500:	df 91       	pop	r29
    7502:	cf 91       	pop	r28
    7504:	1f 91       	pop	r17
    7506:	08 95       	ret

00007508 <vfprintf>:
vfprintf():
    7508:	2f 92       	push	r2
    750a:	3f 92       	push	r3
    750c:	4f 92       	push	r4
    750e:	5f 92       	push	r5
    7510:	6f 92       	push	r6
    7512:	7f 92       	push	r7
    7514:	8f 92       	push	r8
    7516:	9f 92       	push	r9
    7518:	af 92       	push	r10
    751a:	bf 92       	push	r11
    751c:	cf 92       	push	r12
    751e:	df 92       	push	r13
    7520:	ef 92       	push	r14
    7522:	ff 92       	push	r15
    7524:	0f 93       	push	r16
    7526:	1f 93       	push	r17
    7528:	cf 93       	push	r28
    752a:	df 93       	push	r29
    752c:	cd b7       	in	r28, 0x3d	; 61
    752e:	de b7       	in	r29, 0x3e	; 62
    7530:	2f 97       	sbiw	r28, 0x0f	; 15
    7532:	cd bf       	out	0x3d, r28	; 61
    7534:	de bf       	out	0x3e, r29	; 62
    7536:	6c 01       	movw	r12, r24
    7538:	1b 01       	movw	r2, r22
    753a:	5a 01       	movw	r10, r20
    753c:	fc 01       	movw	r30, r24
    753e:	16 82       	std	Z+6, r1	; 0x06
    7540:	17 82       	std	Z+7, r1	; 0x07
    7542:	83 81       	ldd	r24, Z+3	; 0x03
    7544:	9e 01       	movw	r18, r28
    7546:	2f 5f       	subi	r18, 0xFF	; 255
    7548:	3f 4f       	sbci	r19, 0xFF	; 255
    754a:	49 01       	movw	r8, r18
    754c:	81 fd       	sbrc	r24, 1
    754e:	d2 c0       	rjmp	.+420    	; 0x76f4 <vfprintf+0x1ec>
    7550:	8f ef       	ldi	r24, 0xFF	; 255
    7552:	9f ef       	ldi	r25, 0xFF	; 255
    7554:	ee c2       	rjmp	.+1500   	; 0x7b32 <vfprintf+0x62a>
    7556:	f1 2c       	mov	r15, r1
    7558:	51 2c       	mov	r5, r1
    755a:	00 e0       	ldi	r16, 0x00	; 0
    755c:	00 32       	cpi	r16, 0x20	; 32
    755e:	38 f4       	brcc	.+14     	; 0x756e <vfprintf+0x66>
    7560:	8b 32       	cpi	r24, 0x2B	; 43
    7562:	09 f1       	breq	.+66     	; 0x75a6 <vfprintf+0x9e>
    7564:	90 f4       	brcc	.+36     	; 0x758a <vfprintf+0x82>
    7566:	80 32       	cpi	r24, 0x20	; 32
    7568:	f9 f0       	breq	.+62     	; 0x75a8 <vfprintf+0xa0>
    756a:	83 32       	cpi	r24, 0x23	; 35
    756c:	09 f1       	breq	.+66     	; 0x75b0 <vfprintf+0xa8>
    756e:	07 fd       	sbrc	r16, 7
    7570:	34 c0       	rjmp	.+104    	; 0x75da <vfprintf+0xd2>
    7572:	20 ed       	ldi	r18, 0xD0	; 208
    7574:	28 0f       	add	r18, r24
    7576:	2a 30       	cpi	r18, 0x0A	; 10
    7578:	20 f5       	brcc	.+72     	; 0x75c2 <vfprintf+0xba>
    757a:	06 ff       	sbrs	r16, 6
    757c:	1b c0       	rjmp	.+54     	; 0x75b4 <vfprintf+0xac>
    757e:	fa e0       	ldi	r31, 0x0A	; 10
    7580:	ff 9e       	mul	r15, r31
    7582:	20 0d       	add	r18, r0
    7584:	11 24       	eor	r1, r1
    7586:	f2 2e       	mov	r15, r18
    7588:	05 c0       	rjmp	.+10     	; 0x7594 <vfprintf+0x8c>
    758a:	8d 32       	cpi	r24, 0x2D	; 45
    758c:	79 f0       	breq	.+30     	; 0x75ac <vfprintf+0xa4>
    758e:	80 33       	cpi	r24, 0x30	; 48
    7590:	71 f7       	brne	.-36     	; 0x756e <vfprintf+0x66>
    7592:	01 60       	ori	r16, 0x01	; 1
    7594:	f1 01       	movw	r30, r2
    7596:	93 fd       	sbrc	r25, 3
    7598:	85 91       	lpm	r24, Z+
    759a:	93 ff       	sbrs	r25, 3
    759c:	81 91       	ld	r24, Z+
    759e:	1f 01       	movw	r2, r30
    75a0:	81 11       	cpse	r24, r1
    75a2:	dc cf       	rjmp	.-72     	; 0x755c <vfprintf+0x54>
    75a4:	1a c0       	rjmp	.+52     	; 0x75da <vfprintf+0xd2>
    75a6:	02 60       	ori	r16, 0x02	; 2
    75a8:	04 60       	ori	r16, 0x04	; 4
    75aa:	f4 cf       	rjmp	.-24     	; 0x7594 <vfprintf+0x8c>
    75ac:	08 60       	ori	r16, 0x08	; 8
    75ae:	f2 cf       	rjmp	.-28     	; 0x7594 <vfprintf+0x8c>
    75b0:	00 61       	ori	r16, 0x10	; 16
    75b2:	f0 cf       	rjmp	.-32     	; 0x7594 <vfprintf+0x8c>
    75b4:	3a e0       	ldi	r19, 0x0A	; 10
    75b6:	53 9e       	mul	r5, r19
    75b8:	20 0d       	add	r18, r0
    75ba:	11 24       	eor	r1, r1
    75bc:	52 2e       	mov	r5, r18
    75be:	00 62       	ori	r16, 0x20	; 32
    75c0:	e9 cf       	rjmp	.-46     	; 0x7594 <vfprintf+0x8c>
    75c2:	8e 32       	cpi	r24, 0x2E	; 46
    75c4:	21 f4       	brne	.+8      	; 0x75ce <vfprintf+0xc6>
    75c6:	06 fd       	sbrc	r16, 6
    75c8:	b1 c2       	rjmp	.+1378   	; 0x7b2c <vfprintf+0x624>
    75ca:	00 64       	ori	r16, 0x40	; 64
    75cc:	e3 cf       	rjmp	.-58     	; 0x7594 <vfprintf+0x8c>
    75ce:	8c 36       	cpi	r24, 0x6C	; 108
    75d0:	11 f4       	brne	.+4      	; 0x75d6 <vfprintf+0xce>
    75d2:	00 68       	ori	r16, 0x80	; 128
    75d4:	df cf       	rjmp	.-66     	; 0x7594 <vfprintf+0x8c>
    75d6:	88 36       	cpi	r24, 0x68	; 104
    75d8:	e9 f2       	breq	.-70     	; 0x7594 <vfprintf+0x8c>
    75da:	9b eb       	ldi	r25, 0xBB	; 187
    75dc:	98 0f       	add	r25, r24
    75de:	93 30       	cpi	r25, 0x03	; 3
    75e0:	08 f0       	brcs	.+2      	; 0x75e4 <vfprintf+0xdc>
    75e2:	5f c0       	rjmp	.+190    	; 0x76a2 <vfprintf+0x19a>
    75e4:	00 61       	ori	r16, 0x10	; 16
    75e6:	80 5e       	subi	r24, 0xE0	; 224
    75e8:	06 fd       	sbrc	r16, 6
    75ea:	02 c0       	rjmp	.+4      	; 0x75f0 <vfprintf+0xe8>
    75ec:	46 e0       	ldi	r20, 0x06	; 6
    75ee:	f4 2e       	mov	r15, r20
    75f0:	10 2f       	mov	r17, r16
    75f2:	1f 73       	andi	r17, 0x3F	; 63
    75f4:	85 36       	cpi	r24, 0x65	; 101
    75f6:	09 f0       	breq	.+2      	; 0x75fa <vfprintf+0xf2>
    75f8:	5b c0       	rjmp	.+182    	; 0x76b0 <vfprintf+0x1a8>
    75fa:	10 64       	ori	r17, 0x40	; 64
    75fc:	17 ff       	sbrs	r17, 7
    75fe:	61 c0       	rjmp	.+194    	; 0x76c2 <vfprintf+0x1ba>
    7600:	8f 2d       	mov	r24, r15
    7602:	9b e3       	ldi	r25, 0x3B	; 59
    7604:	9f 15       	cp	r25, r15
    7606:	08 f4       	brcc	.+2      	; 0x760a <vfprintf+0x102>
    7608:	8b e3       	ldi	r24, 0x3B	; 59
    760a:	44 24       	eor	r4, r4
    760c:	43 94       	inc	r4
    760e:	48 0e       	add	r4, r24
    7610:	27 e0       	ldi	r18, 0x07	; 7
    7612:	35 01       	movw	r6, r10
    7614:	f4 e0       	ldi	r31, 0x04	; 4
    7616:	6f 0e       	add	r6, r31
    7618:	71 1c       	adc	r7, r1
    761a:	f5 01       	movw	r30, r10
    761c:	60 81       	ld	r22, Z
    761e:	71 81       	ldd	r23, Z+1	; 0x01
    7620:	82 81       	ldd	r24, Z+2	; 0x02
    7622:	93 81       	ldd	r25, Z+3	; 0x03
    7624:	04 2d       	mov	r16, r4
    7626:	a4 01       	movw	r20, r8
    7628:	0e 94 59 4f 	call	0x9eb2	; 0x9eb2 <__ftoa_engine>
    762c:	5c 01       	movw	r10, r24
    762e:	f9 81       	ldd	r31, Y+1	; 0x01
    7630:	fc 87       	std	Y+12, r31	; 0x0c
    7632:	f0 ff       	sbrs	r31, 0
    7634:	03 c0       	rjmp	.+6      	; 0x763c <vfprintf+0x134>
    7636:	0d e2       	ldi	r16, 0x2D	; 45
    7638:	f3 ff       	sbrs	r31, 3
    763a:	07 c0       	rjmp	.+14     	; 0x764a <vfprintf+0x142>
    763c:	0b e2       	ldi	r16, 0x2B	; 43
    763e:	11 fd       	sbrc	r17, 1
    7640:	04 c0       	rjmp	.+8      	; 0x764a <vfprintf+0x142>
    7642:	01 2f       	mov	r16, r17
    7644:	04 70       	andi	r16, 0x04	; 4
    7646:	12 fd       	sbrc	r17, 2
    7648:	00 e2       	ldi	r16, 0x20	; 32
    764a:	2c 85       	ldd	r18, Y+12	; 0x0c
    764c:	2c 70       	andi	r18, 0x0C	; 12
    764e:	e2 2e       	mov	r14, r18
    7650:	09 f4       	brne	.+2      	; 0x7654 <vfprintf+0x14c>
    7652:	6b c0       	rjmp	.+214    	; 0x772a <vfprintf+0x222>
    7654:	01 11       	cpse	r16, r1
    7656:	d5 c2       	rjmp	.+1450   	; 0x7c02 <vfprintf+0x6fa>
    7658:	f3 e0       	ldi	r31, 0x03	; 3
    765a:	e1 2c       	mov	r14, r1
    765c:	f5 15       	cp	r31, r5
    765e:	a0 f4       	brcc	.+40     	; 0x7688 <vfprintf+0x180>
    7660:	83 e0       	ldi	r24, 0x03	; 3
    7662:	e5 2c       	mov	r14, r5
    7664:	e8 1a       	sub	r14, r24
    7666:	13 fd       	sbrc	r17, 3
    7668:	08 c0       	rjmp	.+16     	; 0x767a <vfprintf+0x172>
    766a:	b6 01       	movw	r22, r12
    766c:	80 e2       	ldi	r24, 0x20	; 32
    766e:	90 e0       	ldi	r25, 0x00	; 0
    7670:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7674:	ea 94       	dec	r14
    7676:	e1 10       	cpse	r14, r1
    7678:	f8 cf       	rjmp	.-16     	; 0x766a <vfprintf+0x162>
    767a:	00 23       	and	r16, r16
    767c:	29 f0       	breq	.+10     	; 0x7688 <vfprintf+0x180>
    767e:	b6 01       	movw	r22, r12
    7680:	80 2f       	mov	r24, r16
    7682:	90 e0       	ldi	r25, 0x00	; 0
    7684:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7688:	3c 85       	ldd	r19, Y+12	; 0x0c
    768a:	2e e4       	ldi	r18, 0x4E	; 78
    768c:	a2 2e       	mov	r10, r18
    768e:	21 e0       	ldi	r18, 0x01	; 1
    7690:	b2 2e       	mov	r11, r18
    7692:	33 fd       	sbrc	r19, 3
    7694:	04 c0       	rjmp	.+8      	; 0x769e <vfprintf+0x196>
    7696:	92 e5       	ldi	r25, 0x52	; 82
    7698:	a9 2e       	mov	r10, r25
    769a:	91 e0       	ldi	r25, 0x01	; 1
    769c:	b9 2e       	mov	r11, r25
    769e:	10 71       	andi	r17, 0x10	; 16
    76a0:	22 c0       	rjmp	.+68     	; 0x76e6 <vfprintf+0x1de>
    76a2:	9b e9       	ldi	r25, 0x9B	; 155
    76a4:	98 0f       	add	r25, r24
    76a6:	93 30       	cpi	r25, 0x03	; 3
    76a8:	08 f0       	brcs	.+2      	; 0x76ac <vfprintf+0x1a4>
    76aa:	47 c1       	rjmp	.+654    	; 0x793a <vfprintf+0x432>
    76ac:	0f 7e       	andi	r16, 0xEF	; 239
    76ae:	9c cf       	rjmp	.-200    	; 0x75e8 <vfprintf+0xe0>
    76b0:	86 36       	cpi	r24, 0x66	; 102
    76b2:	11 f4       	brne	.+4      	; 0x76b8 <vfprintf+0x1b0>
    76b4:	10 68       	ori	r17, 0x80	; 128
    76b6:	a2 cf       	rjmp	.-188    	; 0x75fc <vfprintf+0xf4>
    76b8:	ff 20       	and	r15, r15
    76ba:	09 f4       	brne	.+2      	; 0x76be <vfprintf+0x1b6>
    76bc:	9f cf       	rjmp	.-194    	; 0x75fc <vfprintf+0xf4>
    76be:	fa 94       	dec	r15
    76c0:	9d cf       	rjmp	.-198    	; 0x75fc <vfprintf+0xf4>
    76c2:	e7 e0       	ldi	r30, 0x07	; 7
    76c4:	2f 2d       	mov	r18, r15
    76c6:	ef 15       	cp	r30, r15
    76c8:	18 f4       	brcc	.+6      	; 0x76d0 <vfprintf+0x1c8>
    76ca:	27 e0       	ldi	r18, 0x07	; 7
    76cc:	37 e0       	ldi	r19, 0x07	; 7
    76ce:	f3 2e       	mov	r15, r19
    76d0:	41 2c       	mov	r4, r1
    76d2:	9f cf       	rjmp	.-194    	; 0x7612 <vfprintf+0x10a>
    76d4:	11 11       	cpse	r17, r1
    76d6:	80 52       	subi	r24, 0x20	; 32
    76d8:	b6 01       	movw	r22, r12
    76da:	90 e0       	ldi	r25, 0x00	; 0
    76dc:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    76e0:	8f ef       	ldi	r24, 0xFF	; 255
    76e2:	a8 1a       	sub	r10, r24
    76e4:	b8 0a       	sbc	r11, r24
    76e6:	f5 01       	movw	r30, r10
    76e8:	84 91       	lpm	r24, Z
    76ea:	81 11       	cpse	r24, r1
    76ec:	f3 cf       	rjmp	.-26     	; 0x76d4 <vfprintf+0x1cc>
    76ee:	e1 10       	cpse	r14, r1
    76f0:	81 c2       	rjmp	.+1282   	; 0x7bf4 <vfprintf+0x6ec>
    76f2:	53 01       	movw	r10, r6
    76f4:	f6 01       	movw	r30, r12
    76f6:	93 81       	ldd	r25, Z+3	; 0x03
    76f8:	f1 01       	movw	r30, r2
    76fa:	93 fd       	sbrc	r25, 3
    76fc:	85 91       	lpm	r24, Z+
    76fe:	93 ff       	sbrs	r25, 3
    7700:	81 91       	ld	r24, Z+
    7702:	1f 01       	movw	r2, r30
    7704:	88 23       	and	r24, r24
    7706:	09 f4       	brne	.+2      	; 0x770a <vfprintf+0x202>
    7708:	11 c2       	rjmp	.+1058   	; 0x7b2c <vfprintf+0x624>
    770a:	85 32       	cpi	r24, 0x25	; 37
    770c:	41 f4       	brne	.+16     	; 0x771e <vfprintf+0x216>
    770e:	93 fd       	sbrc	r25, 3
    7710:	85 91       	lpm	r24, Z+
    7712:	93 ff       	sbrs	r25, 3
    7714:	81 91       	ld	r24, Z+
    7716:	1f 01       	movw	r2, r30
    7718:	85 32       	cpi	r24, 0x25	; 37
    771a:	09 f0       	breq	.+2      	; 0x771e <vfprintf+0x216>
    771c:	1c cf       	rjmp	.-456    	; 0x7556 <vfprintf+0x4e>
    771e:	b6 01       	movw	r22, r12
    7720:	90 e0       	ldi	r25, 0x00	; 0
    7722:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7726:	35 01       	movw	r6, r10
    7728:	e4 cf       	rjmp	.-56     	; 0x76f2 <vfprintf+0x1ea>
    772a:	17 ff       	sbrs	r17, 7
    772c:	6f c0       	rjmp	.+222    	; 0x780c <vfprintf+0x304>
    772e:	4a 0c       	add	r4, r10
    7730:	fc 85       	ldd	r31, Y+12	; 0x0c
    7732:	f4 ff       	sbrs	r31, 4
    7734:	04 c0       	rjmp	.+8      	; 0x773e <vfprintf+0x236>
    7736:	8a 81       	ldd	r24, Y+2	; 0x02
    7738:	81 33       	cpi	r24, 0x31	; 49
    773a:	09 f4       	brne	.+2      	; 0x773e <vfprintf+0x236>
    773c:	4a 94       	dec	r4
    773e:	14 14       	cp	r1, r4
    7740:	0c f0       	brlt	.+2      	; 0x7744 <vfprintf+0x23c>
    7742:	86 c0       	rjmp	.+268    	; 0x7850 <vfprintf+0x348>
    7744:	28 e0       	ldi	r18, 0x08	; 8
    7746:	24 15       	cp	r18, r4
    7748:	10 f4       	brcc	.+4      	; 0x774e <vfprintf+0x246>
    774a:	88 e0       	ldi	r24, 0x08	; 8
    774c:	48 2e       	mov	r4, r24
    774e:	85 e0       	ldi	r24, 0x05	; 5
    7750:	90 e0       	ldi	r25, 0x00	; 0
    7752:	17 ff       	sbrs	r17, 7
    7754:	06 c0       	rjmp	.+12     	; 0x7762 <vfprintf+0x25a>
    7756:	c5 01       	movw	r24, r10
    7758:	b7 fe       	sbrs	r11, 7
    775a:	02 c0       	rjmp	.+4      	; 0x7760 <vfprintf+0x258>
    775c:	90 e0       	ldi	r25, 0x00	; 0
    775e:	80 e0       	ldi	r24, 0x00	; 0
    7760:	01 96       	adiw	r24, 0x01	; 1
    7762:	01 11       	cpse	r16, r1
    7764:	01 96       	adiw	r24, 0x01	; 1
    7766:	ff 20       	and	r15, r15
    7768:	31 f0       	breq	.+12     	; 0x7776 <vfprintf+0x26e>
    776a:	2f 2d       	mov	r18, r15
    776c:	30 e0       	ldi	r19, 0x00	; 0
    776e:	2f 5f       	subi	r18, 0xFF	; 255
    7770:	3f 4f       	sbci	r19, 0xFF	; 255
    7772:	82 0f       	add	r24, r18
    7774:	93 1f       	adc	r25, r19
    7776:	58 16       	cp	r5, r24
    7778:	19 06       	cpc	r1, r25
    777a:	19 f0       	breq	.+6      	; 0x7782 <vfprintf+0x27a>
    777c:	14 f0       	brlt	.+4      	; 0x7782 <vfprintf+0x27a>
    777e:	e5 2c       	mov	r14, r5
    7780:	e8 1a       	sub	r14, r24
    7782:	81 2f       	mov	r24, r17
    7784:	89 70       	andi	r24, 0x09	; 9
    7786:	11 f4       	brne	.+4      	; 0x778c <vfprintf+0x284>
    7788:	e1 10       	cpse	r14, r1
    778a:	67 c0       	rjmp	.+206    	; 0x785a <vfprintf+0x352>
    778c:	00 23       	and	r16, r16
    778e:	29 f0       	breq	.+10     	; 0x779a <vfprintf+0x292>
    7790:	b6 01       	movw	r22, r12
    7792:	80 2f       	mov	r24, r16
    7794:	90 e0       	ldi	r25, 0x00	; 0
    7796:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    779a:	13 fd       	sbrc	r17, 3
    779c:	02 c0       	rjmp	.+4      	; 0x77a2 <vfprintf+0x29a>
    779e:	e1 10       	cpse	r14, r1
    77a0:	63 c0       	rjmp	.+198    	; 0x7868 <vfprintf+0x360>
    77a2:	17 ff       	sbrs	r17, 7
    77a4:	7c c0       	rjmp	.+248    	; 0x789e <vfprintf+0x396>
    77a6:	85 01       	movw	r16, r10
    77a8:	b7 fe       	sbrs	r11, 7
    77aa:	02 c0       	rjmp	.+4      	; 0x77b0 <vfprintf+0x2a8>
    77ac:	10 e0       	ldi	r17, 0x00	; 0
    77ae:	00 e0       	ldi	r16, 0x00	; 0
    77b0:	c5 01       	movw	r24, r10
    77b2:	84 19       	sub	r24, r4
    77b4:	91 09       	sbc	r25, r1
    77b6:	2c 01       	movw	r4, r24
    77b8:	6f 2d       	mov	r22, r15
    77ba:	70 e0       	ldi	r23, 0x00	; 0
    77bc:	ee 27       	eor	r30, r30
    77be:	ff 27       	eor	r31, r31
    77c0:	e6 1b       	sub	r30, r22
    77c2:	f7 0b       	sbc	r31, r23
    77c4:	ee 87       	std	Y+14, r30	; 0x0e
    77c6:	ff 87       	std	Y+15, r31	; 0x0f
    77c8:	0f 3f       	cpi	r16, 0xFF	; 255
    77ca:	10 07       	cpc	r17, r16
    77cc:	29 f4       	brne	.+10     	; 0x77d8 <vfprintf+0x2d0>
    77ce:	b6 01       	movw	r22, r12
    77d0:	8e e2       	ldi	r24, 0x2E	; 46
    77d2:	90 e0       	ldi	r25, 0x00	; 0
    77d4:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    77d8:	a0 16       	cp	r10, r16
    77da:	b1 06       	cpc	r11, r17
    77dc:	0c f4       	brge	.+2      	; 0x77e0 <vfprintf+0x2d8>
    77de:	4b c0       	rjmp	.+150    	; 0x7876 <vfprintf+0x36e>
    77e0:	40 16       	cp	r4, r16
    77e2:	51 06       	cpc	r5, r17
    77e4:	0c f0       	brlt	.+2      	; 0x77e8 <vfprintf+0x2e0>
    77e6:	47 c0       	rjmp	.+142    	; 0x7876 <vfprintf+0x36e>
    77e8:	f5 01       	movw	r30, r10
    77ea:	e0 1b       	sub	r30, r16
    77ec:	f1 0b       	sbc	r31, r17
    77ee:	e8 0d       	add	r30, r8
    77f0:	f9 1d       	adc	r31, r9
    77f2:	81 81       	ldd	r24, Z+1	; 0x01
    77f4:	01 50       	subi	r16, 0x01	; 1
    77f6:	11 09       	sbc	r17, r1
    77f8:	2e 85       	ldd	r18, Y+14	; 0x0e
    77fa:	3f 85       	ldd	r19, Y+15	; 0x0f
    77fc:	02 17       	cp	r16, r18
    77fe:	13 07       	cpc	r17, r19
    7800:	e4 f1       	brlt	.+120    	; 0x787a <vfprintf+0x372>
    7802:	b6 01       	movw	r22, r12
    7804:	90 e0       	ldi	r25, 0x00	; 0
    7806:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    780a:	de cf       	rjmp	.-68     	; 0x77c8 <vfprintf+0x2c0>
    780c:	16 fd       	sbrc	r17, 6
    780e:	9f cf       	rjmp	.-194    	; 0x774e <vfprintf+0x246>
    7810:	ef 2d       	mov	r30, r15
    7812:	f0 e0       	ldi	r31, 0x00	; 0
    7814:	ea 15       	cp	r30, r10
    7816:	fb 05       	cpc	r31, r11
    7818:	34 f0       	brlt	.+12     	; 0x7826 <vfprintf+0x31e>
    781a:	3c ef       	ldi	r19, 0xFC	; 252
    781c:	a3 16       	cp	r10, r19
    781e:	3f ef       	ldi	r19, 0xFF	; 255
    7820:	b3 06       	cpc	r11, r19
    7822:	0c f0       	brlt	.+2      	; 0x7826 <vfprintf+0x31e>
    7824:	10 68       	ori	r17, 0x80	; 128
    7826:	32 96       	adiw	r30, 0x02	; 2
    7828:	e8 0d       	add	r30, r8
    782a:	f9 1d       	adc	r31, r9
    782c:	01 c0       	rjmp	.+2      	; 0x7830 <vfprintf+0x328>
    782e:	fa 94       	dec	r15
    7830:	ff 20       	and	r15, r15
    7832:	19 f0       	breq	.+6      	; 0x783a <vfprintf+0x332>
    7834:	82 91       	ld	r24, -Z
    7836:	80 33       	cpi	r24, 0x30	; 48
    7838:	d1 f3       	breq	.-12     	; 0x782e <vfprintf+0x326>
    783a:	17 ff       	sbrs	r17, 7
    783c:	88 cf       	rjmp	.-240    	; 0x774e <vfprintf+0x246>
    783e:	44 24       	eor	r4, r4
    7840:	43 94       	inc	r4
    7842:	4f 0c       	add	r4, r15
    7844:	fa 14       	cp	r15, r10
    7846:	1b 04       	cpc	r1, r11
    7848:	31 f0       	breq	.+12     	; 0x7856 <vfprintf+0x34e>
    784a:	2c f0       	brlt	.+10     	; 0x7856 <vfprintf+0x34e>
    784c:	fa 18       	sub	r15, r10
    784e:	7f cf       	rjmp	.-258    	; 0x774e <vfprintf+0x246>
    7850:	44 24       	eor	r4, r4
    7852:	43 94       	inc	r4
    7854:	7c cf       	rjmp	.-264    	; 0x774e <vfprintf+0x246>
    7856:	f1 2c       	mov	r15, r1
    7858:	7a cf       	rjmp	.-268    	; 0x774e <vfprintf+0x246>
    785a:	b6 01       	movw	r22, r12
    785c:	80 e2       	ldi	r24, 0x20	; 32
    785e:	90 e0       	ldi	r25, 0x00	; 0
    7860:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7864:	ea 94       	dec	r14
    7866:	90 cf       	rjmp	.-224    	; 0x7788 <vfprintf+0x280>
    7868:	b6 01       	movw	r22, r12
    786a:	80 e3       	ldi	r24, 0x30	; 48
    786c:	90 e0       	ldi	r25, 0x00	; 0
    786e:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7872:	ea 94       	dec	r14
    7874:	94 cf       	rjmp	.-216    	; 0x779e <vfprintf+0x296>
    7876:	80 e3       	ldi	r24, 0x30	; 48
    7878:	bd cf       	rjmp	.-134    	; 0x77f4 <vfprintf+0x2ec>
    787a:	a0 16       	cp	r10, r16
    787c:	b1 06       	cpc	r11, r17
    787e:	41 f4       	brne	.+16     	; 0x7890 <vfprintf+0x388>
    7880:	9a 81       	ldd	r25, Y+2	; 0x02
    7882:	96 33       	cpi	r25, 0x36	; 54
    7884:	50 f4       	brcc	.+20     	; 0x789a <vfprintf+0x392>
    7886:	95 33       	cpi	r25, 0x35	; 53
    7888:	19 f4       	brne	.+6      	; 0x7890 <vfprintf+0x388>
    788a:	3c 85       	ldd	r19, Y+12	; 0x0c
    788c:	34 ff       	sbrs	r19, 4
    788e:	05 c0       	rjmp	.+10     	; 0x789a <vfprintf+0x392>
    7890:	b6 01       	movw	r22, r12
    7892:	90 e0       	ldi	r25, 0x00	; 0
    7894:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7898:	2a cf       	rjmp	.-428    	; 0x76ee <vfprintf+0x1e6>
    789a:	81 e3       	ldi	r24, 0x31	; 49
    789c:	f9 cf       	rjmp	.-14     	; 0x7890 <vfprintf+0x388>
    789e:	8a 81       	ldd	r24, Y+2	; 0x02
    78a0:	81 33       	cpi	r24, 0x31	; 49
    78a2:	19 f0       	breq	.+6      	; 0x78aa <vfprintf+0x3a2>
    78a4:	9c 85       	ldd	r25, Y+12	; 0x0c
    78a6:	9f 7e       	andi	r25, 0xEF	; 239
    78a8:	9c 87       	std	Y+12, r25	; 0x0c
    78aa:	b6 01       	movw	r22, r12
    78ac:	90 e0       	ldi	r25, 0x00	; 0
    78ae:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    78b2:	ff 20       	and	r15, r15
    78b4:	a9 f0       	breq	.+42     	; 0x78e0 <vfprintf+0x3d8>
    78b6:	b6 01       	movw	r22, r12
    78b8:	8e e2       	ldi	r24, 0x2E	; 46
    78ba:	90 e0       	ldi	r25, 0x00	; 0
    78bc:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    78c0:	f3 94       	inc	r15
    78c2:	f3 94       	inc	r15
    78c4:	e2 e0       	ldi	r30, 0x02	; 2
    78c6:	01 e0       	ldi	r16, 0x01	; 1
    78c8:	0e 0f       	add	r16, r30
    78ca:	e8 0d       	add	r30, r8
    78cc:	f9 2d       	mov	r31, r9
    78ce:	f1 1d       	adc	r31, r1
    78d0:	80 81       	ld	r24, Z
    78d2:	b6 01       	movw	r22, r12
    78d4:	90 e0       	ldi	r25, 0x00	; 0
    78d6:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    78da:	e0 2f       	mov	r30, r16
    78dc:	0f 11       	cpse	r16, r15
    78de:	f3 cf       	rjmp	.-26     	; 0x78c6 <vfprintf+0x3be>
    78e0:	85 e6       	ldi	r24, 0x65	; 101
    78e2:	90 e0       	ldi	r25, 0x00	; 0
    78e4:	14 ff       	sbrs	r17, 4
    78e6:	02 c0       	rjmp	.+4      	; 0x78ec <vfprintf+0x3e4>
    78e8:	85 e4       	ldi	r24, 0x45	; 69
    78ea:	90 e0       	ldi	r25, 0x00	; 0
    78ec:	b6 01       	movw	r22, r12
    78ee:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    78f2:	b7 fc       	sbrc	r11, 7
    78f4:	06 c0       	rjmp	.+12     	; 0x7902 <vfprintf+0x3fa>
    78f6:	a1 14       	cp	r10, r1
    78f8:	b1 04       	cpc	r11, r1
    78fa:	c1 f4       	brne	.+48     	; 0x792c <vfprintf+0x424>
    78fc:	ec 85       	ldd	r30, Y+12	; 0x0c
    78fe:	e4 ff       	sbrs	r30, 4
    7900:	15 c0       	rjmp	.+42     	; 0x792c <vfprintf+0x424>
    7902:	b1 94       	neg	r11
    7904:	a1 94       	neg	r10
    7906:	b1 08       	sbc	r11, r1
    7908:	8d e2       	ldi	r24, 0x2D	; 45
    790a:	b6 01       	movw	r22, r12
    790c:	90 e0       	ldi	r25, 0x00	; 0
    790e:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7912:	80 e3       	ldi	r24, 0x30	; 48
    7914:	2a e0       	ldi	r18, 0x0A	; 10
    7916:	a2 16       	cp	r10, r18
    7918:	b1 04       	cpc	r11, r1
    791a:	54 f4       	brge	.+20     	; 0x7930 <vfprintf+0x428>
    791c:	b6 01       	movw	r22, r12
    791e:	90 e0       	ldi	r25, 0x00	; 0
    7920:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7924:	b6 01       	movw	r22, r12
    7926:	c5 01       	movw	r24, r10
    7928:	c0 96       	adiw	r24, 0x30	; 48
    792a:	b4 cf       	rjmp	.-152    	; 0x7894 <vfprintf+0x38c>
    792c:	8b e2       	ldi	r24, 0x2B	; 43
    792e:	ed cf       	rjmp	.-38     	; 0x790a <vfprintf+0x402>
    7930:	8f 5f       	subi	r24, 0xFF	; 255
    7932:	fa e0       	ldi	r31, 0x0A	; 10
    7934:	af 1a       	sub	r10, r31
    7936:	b1 08       	sbc	r11, r1
    7938:	ed cf       	rjmp	.-38     	; 0x7914 <vfprintf+0x40c>
    793a:	83 36       	cpi	r24, 0x63	; 99
    793c:	c9 f0       	breq	.+50     	; 0x7970 <vfprintf+0x468>
    793e:	83 37       	cpi	r24, 0x73	; 115
    7940:	71 f1       	breq	.+92     	; 0x799e <vfprintf+0x496>
    7942:	83 35       	cpi	r24, 0x53	; 83
    7944:	09 f0       	breq	.+2      	; 0x7948 <vfprintf+0x440>
    7946:	5b c0       	rjmp	.+182    	; 0x79fe <vfprintf+0x4f6>
    7948:	35 01       	movw	r6, r10
    794a:	f2 e0       	ldi	r31, 0x02	; 2
    794c:	6f 0e       	add	r6, r31
    794e:	71 1c       	adc	r7, r1
    7950:	f5 01       	movw	r30, r10
    7952:	a0 80       	ld	r10, Z
    7954:	b1 80       	ldd	r11, Z+1	; 0x01
    7956:	6f 2d       	mov	r22, r15
    7958:	70 e0       	ldi	r23, 0x00	; 0
    795a:	06 fd       	sbrc	r16, 6
    795c:	02 c0       	rjmp	.+4      	; 0x7962 <vfprintf+0x45a>
    795e:	6f ef       	ldi	r22, 0xFF	; 255
    7960:	7f ef       	ldi	r23, 0xFF	; 255
    7962:	c5 01       	movw	r24, r10
    7964:	0e 94 51 50 	call	0xa0a2	; 0xa0a2 <strnlen_P>
    7968:	8c 87       	std	Y+12, r24	; 0x0c
    796a:	9d 87       	std	Y+13, r25	; 0x0d
    796c:	00 68       	ori	r16, 0x80	; 128
    796e:	0d c0       	rjmp	.+26     	; 0x798a <vfprintf+0x482>
    7970:	35 01       	movw	r6, r10
    7972:	32 e0       	ldi	r19, 0x02	; 2
    7974:	63 0e       	add	r6, r19
    7976:	71 1c       	adc	r7, r1
    7978:	f5 01       	movw	r30, r10
    797a:	80 81       	ld	r24, Z
    797c:	89 83       	std	Y+1, r24	; 0x01
    797e:	21 e0       	ldi	r18, 0x01	; 1
    7980:	30 e0       	ldi	r19, 0x00	; 0
    7982:	2c 87       	std	Y+12, r18	; 0x0c
    7984:	3d 87       	std	Y+13, r19	; 0x0d
    7986:	54 01       	movw	r10, r8
    7988:	0f 77       	andi	r16, 0x7F	; 127
    798a:	03 fd       	sbrc	r16, 3
    798c:	06 c0       	rjmp	.+12     	; 0x799a <vfprintf+0x492>
    798e:	2c 85       	ldd	r18, Y+12	; 0x0c
    7990:	3d 85       	ldd	r19, Y+13	; 0x0d
    7992:	52 16       	cp	r5, r18
    7994:	13 06       	cpc	r1, r19
    7996:	09 f0       	breq	.+2      	; 0x799a <vfprintf+0x492>
    7998:	a8 f4       	brcc	.+42     	; 0x79c4 <vfprintf+0x4bc>
    799a:	e5 2c       	mov	r14, r5
    799c:	2b c0       	rjmp	.+86     	; 0x79f4 <vfprintf+0x4ec>
    799e:	35 01       	movw	r6, r10
    79a0:	32 e0       	ldi	r19, 0x02	; 2
    79a2:	63 0e       	add	r6, r19
    79a4:	71 1c       	adc	r7, r1
    79a6:	f5 01       	movw	r30, r10
    79a8:	a0 80       	ld	r10, Z
    79aa:	b1 80       	ldd	r11, Z+1	; 0x01
    79ac:	6f 2d       	mov	r22, r15
    79ae:	70 e0       	ldi	r23, 0x00	; 0
    79b0:	06 fd       	sbrc	r16, 6
    79b2:	02 c0       	rjmp	.+4      	; 0x79b8 <vfprintf+0x4b0>
    79b4:	6f ef       	ldi	r22, 0xFF	; 255
    79b6:	7f ef       	ldi	r23, 0xFF	; 255
    79b8:	c5 01       	movw	r24, r10
    79ba:	0e 94 5f 50 	call	0xa0be	; 0xa0be <strnlen>
    79be:	8c 87       	std	Y+12, r24	; 0x0c
    79c0:	9d 87       	std	Y+13, r25	; 0x0d
    79c2:	e2 cf       	rjmp	.-60     	; 0x7988 <vfprintf+0x480>
    79c4:	b6 01       	movw	r22, r12
    79c6:	80 e2       	ldi	r24, 0x20	; 32
    79c8:	90 e0       	ldi	r25, 0x00	; 0
    79ca:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    79ce:	5a 94       	dec	r5
    79d0:	de cf       	rjmp	.-68     	; 0x798e <vfprintf+0x486>
    79d2:	f5 01       	movw	r30, r10
    79d4:	07 fd       	sbrc	r16, 7
    79d6:	85 91       	lpm	r24, Z+
    79d8:	07 ff       	sbrs	r16, 7
    79da:	81 91       	ld	r24, Z+
    79dc:	5f 01       	movw	r10, r30
    79de:	b6 01       	movw	r22, r12
    79e0:	90 e0       	ldi	r25, 0x00	; 0
    79e2:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    79e6:	e1 10       	cpse	r14, r1
    79e8:	ea 94       	dec	r14
    79ea:	8c 85       	ldd	r24, Y+12	; 0x0c
    79ec:	9d 85       	ldd	r25, Y+13	; 0x0d
    79ee:	01 97       	sbiw	r24, 0x01	; 1
    79f0:	8c 87       	std	Y+12, r24	; 0x0c
    79f2:	9d 87       	std	Y+13, r25	; 0x0d
    79f4:	ec 85       	ldd	r30, Y+12	; 0x0c
    79f6:	fd 85       	ldd	r31, Y+13	; 0x0d
    79f8:	ef 2b       	or	r30, r31
    79fa:	59 f7       	brne	.-42     	; 0x79d2 <vfprintf+0x4ca>
    79fc:	78 ce       	rjmp	.-784    	; 0x76ee <vfprintf+0x1e6>
    79fe:	84 36       	cpi	r24, 0x64	; 100
    7a00:	19 f0       	breq	.+6      	; 0x7a08 <vfprintf+0x500>
    7a02:	89 36       	cpi	r24, 0x69	; 105
    7a04:	09 f0       	breq	.+2      	; 0x7a08 <vfprintf+0x500>
    7a06:	74 c0       	rjmp	.+232    	; 0x7af0 <vfprintf+0x5e8>
    7a08:	35 01       	movw	r6, r10
    7a0a:	07 ff       	sbrs	r16, 7
    7a0c:	66 c0       	rjmp	.+204    	; 0x7ada <vfprintf+0x5d2>
    7a0e:	f4 e0       	ldi	r31, 0x04	; 4
    7a10:	6f 0e       	add	r6, r31
    7a12:	71 1c       	adc	r7, r1
    7a14:	f5 01       	movw	r30, r10
    7a16:	60 81       	ld	r22, Z
    7a18:	71 81       	ldd	r23, Z+1	; 0x01
    7a1a:	82 81       	ldd	r24, Z+2	; 0x02
    7a1c:	93 81       	ldd	r25, Z+3	; 0x03
    7a1e:	10 2f       	mov	r17, r16
    7a20:	1f 76       	andi	r17, 0x6F	; 111
    7a22:	97 ff       	sbrs	r25, 7
    7a24:	08 c0       	rjmp	.+16     	; 0x7a36 <vfprintf+0x52e>
    7a26:	90 95       	com	r25
    7a28:	80 95       	com	r24
    7a2a:	70 95       	com	r23
    7a2c:	61 95       	neg	r22
    7a2e:	7f 4f       	sbci	r23, 0xFF	; 255
    7a30:	8f 4f       	sbci	r24, 0xFF	; 255
    7a32:	9f 4f       	sbci	r25, 0xFF	; 255
    7a34:	10 68       	ori	r17, 0x80	; 128
    7a36:	2a e0       	ldi	r18, 0x0A	; 10
    7a38:	30 e0       	ldi	r19, 0x00	; 0
    7a3a:	a4 01       	movw	r20, r8
    7a3c:	0e 94 c9 50 	call	0xa192	; 0xa192 <__ultoa_invert>
    7a40:	a8 2e       	mov	r10, r24
    7a42:	a8 18       	sub	r10, r8
    7a44:	ba 2c       	mov	r11, r10
    7a46:	01 2f       	mov	r16, r17
    7a48:	16 ff       	sbrs	r17, 6
    7a4a:	0a c0       	rjmp	.+20     	; 0x7a60 <vfprintf+0x558>
    7a4c:	0e 7f       	andi	r16, 0xFE	; 254
    7a4e:	af 14       	cp	r10, r15
    7a50:	38 f4       	brcc	.+14     	; 0x7a60 <vfprintf+0x558>
    7a52:	14 ff       	sbrs	r17, 4
    7a54:	04 c0       	rjmp	.+8      	; 0x7a5e <vfprintf+0x556>
    7a56:	12 fd       	sbrc	r17, 2
    7a58:	02 c0       	rjmp	.+4      	; 0x7a5e <vfprintf+0x556>
    7a5a:	01 2f       	mov	r16, r17
    7a5c:	0e 7e       	andi	r16, 0xEE	; 238
    7a5e:	bf 2c       	mov	r11, r15
    7a60:	04 ff       	sbrs	r16, 4
    7a62:	a0 c0       	rjmp	.+320    	; 0x7ba4 <vfprintf+0x69c>
    7a64:	fe 01       	movw	r30, r28
    7a66:	ea 0d       	add	r30, r10
    7a68:	f1 1d       	adc	r31, r1
    7a6a:	80 81       	ld	r24, Z
    7a6c:	80 33       	cpi	r24, 0x30	; 48
    7a6e:	09 f0       	breq	.+2      	; 0x7a72 <vfprintf+0x56a>
    7a70:	92 c0       	rjmp	.+292    	; 0x7b96 <vfprintf+0x68e>
    7a72:	09 7e       	andi	r16, 0xE9	; 233
    7a74:	f0 2f       	mov	r31, r16
    7a76:	f8 70       	andi	r31, 0x08	; 8
    7a78:	ef 2e       	mov	r14, r31
    7a7a:	03 fd       	sbrc	r16, 3
    7a7c:	a2 c0       	rjmp	.+324    	; 0x7bc2 <vfprintf+0x6ba>
    7a7e:	00 ff       	sbrs	r16, 0
    7a80:	9c c0       	rjmp	.+312    	; 0x7bba <vfprintf+0x6b2>
    7a82:	fa 2c       	mov	r15, r10
    7a84:	b5 14       	cp	r11, r5
    7a86:	10 f4       	brcc	.+4      	; 0x7a8c <vfprintf+0x584>
    7a88:	f5 0c       	add	r15, r5
    7a8a:	fb 18       	sub	r15, r11
    7a8c:	04 ff       	sbrs	r16, 4
    7a8e:	9f c0       	rjmp	.+318    	; 0x7bce <vfprintf+0x6c6>
    7a90:	b6 01       	movw	r22, r12
    7a92:	80 e3       	ldi	r24, 0x30	; 48
    7a94:	90 e0       	ldi	r25, 0x00	; 0
    7a96:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7a9a:	02 ff       	sbrs	r16, 2
    7a9c:	09 c0       	rjmp	.+18     	; 0x7ab0 <vfprintf+0x5a8>
    7a9e:	88 e7       	ldi	r24, 0x78	; 120
    7aa0:	90 e0       	ldi	r25, 0x00	; 0
    7aa2:	01 ff       	sbrs	r16, 1
    7aa4:	02 c0       	rjmp	.+4      	; 0x7aaa <vfprintf+0x5a2>
    7aa6:	88 e5       	ldi	r24, 0x58	; 88
    7aa8:	90 e0       	ldi	r25, 0x00	; 0
    7aaa:	b6 01       	movw	r22, r12
    7aac:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7ab0:	af 14       	cp	r10, r15
    7ab2:	08 f4       	brcc	.+2      	; 0x7ab6 <vfprintf+0x5ae>
    7ab4:	98 c0       	rjmp	.+304    	; 0x7be6 <vfprintf+0x6de>
    7ab6:	aa 94       	dec	r10
    7ab8:	0a 2d       	mov	r16, r10
    7aba:	10 e0       	ldi	r17, 0x00	; 0
    7abc:	0f 5f       	subi	r16, 0xFF	; 255
    7abe:	1f 4f       	sbci	r17, 0xFF	; 255
    7ac0:	08 0d       	add	r16, r8
    7ac2:	19 1d       	adc	r17, r9
    7ac4:	f8 01       	movw	r30, r16
    7ac6:	82 91       	ld	r24, -Z
    7ac8:	8f 01       	movw	r16, r30
    7aca:	b6 01       	movw	r22, r12
    7acc:	90 e0       	ldi	r25, 0x00	; 0
    7ace:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7ad2:	80 16       	cp	r8, r16
    7ad4:	91 06       	cpc	r9, r17
    7ad6:	b1 f7       	brne	.-20     	; 0x7ac4 <vfprintf+0x5bc>
    7ad8:	0a ce       	rjmp	.-1004   	; 0x76ee <vfprintf+0x1e6>
    7ada:	f2 e0       	ldi	r31, 0x02	; 2
    7adc:	6f 0e       	add	r6, r31
    7ade:	71 1c       	adc	r7, r1
    7ae0:	f5 01       	movw	r30, r10
    7ae2:	60 81       	ld	r22, Z
    7ae4:	71 81       	ldd	r23, Z+1	; 0x01
    7ae6:	07 2e       	mov	r0, r23
    7ae8:	00 0c       	add	r0, r0
    7aea:	88 0b       	sbc	r24, r24
    7aec:	99 0b       	sbc	r25, r25
    7aee:	97 cf       	rjmp	.-210    	; 0x7a1e <vfprintf+0x516>
    7af0:	10 2f       	mov	r17, r16
    7af2:	85 37       	cpi	r24, 0x75	; 117
    7af4:	a9 f4       	brne	.+42     	; 0x7b20 <vfprintf+0x618>
    7af6:	1f 7e       	andi	r17, 0xEF	; 239
    7af8:	2a e0       	ldi	r18, 0x0A	; 10
    7afa:	30 e0       	ldi	r19, 0x00	; 0
    7afc:	35 01       	movw	r6, r10
    7afe:	17 ff       	sbrs	r17, 7
    7b00:	41 c0       	rjmp	.+130    	; 0x7b84 <vfprintf+0x67c>
    7b02:	f4 e0       	ldi	r31, 0x04	; 4
    7b04:	6f 0e       	add	r6, r31
    7b06:	71 1c       	adc	r7, r1
    7b08:	f5 01       	movw	r30, r10
    7b0a:	60 81       	ld	r22, Z
    7b0c:	71 81       	ldd	r23, Z+1	; 0x01
    7b0e:	82 81       	ldd	r24, Z+2	; 0x02
    7b10:	93 81       	ldd	r25, Z+3	; 0x03
    7b12:	a4 01       	movw	r20, r8
    7b14:	0e 94 c9 50 	call	0xa192	; 0xa192 <__ultoa_invert>
    7b18:	a8 2e       	mov	r10, r24
    7b1a:	a8 18       	sub	r10, r8
    7b1c:	1f 77       	andi	r17, 0x7F	; 127
    7b1e:	92 cf       	rjmp	.-220    	; 0x7a44 <vfprintf+0x53c>
    7b20:	19 7f       	andi	r17, 0xF9	; 249
    7b22:	8f 36       	cpi	r24, 0x6F	; 111
    7b24:	61 f1       	breq	.+88     	; 0x7b7e <vfprintf+0x676>
    7b26:	d8 f4       	brcc	.+54     	; 0x7b5e <vfprintf+0x656>
    7b28:	88 35       	cpi	r24, 0x58	; 88
    7b2a:	21 f1       	breq	.+72     	; 0x7b74 <vfprintf+0x66c>
    7b2c:	f6 01       	movw	r30, r12
    7b2e:	86 81       	ldd	r24, Z+6	; 0x06
    7b30:	97 81       	ldd	r25, Z+7	; 0x07
    7b32:	2f 96       	adiw	r28, 0x0f	; 15
    7b34:	cd bf       	out	0x3d, r28	; 61
    7b36:	de bf       	out	0x3e, r29	; 62
    7b38:	df 91       	pop	r29
    7b3a:	cf 91       	pop	r28
    7b3c:	1f 91       	pop	r17
    7b3e:	0f 91       	pop	r16
    7b40:	ff 90       	pop	r15
    7b42:	ef 90       	pop	r14
    7b44:	df 90       	pop	r13
    7b46:	cf 90       	pop	r12
    7b48:	bf 90       	pop	r11
    7b4a:	af 90       	pop	r10
    7b4c:	9f 90       	pop	r9
    7b4e:	8f 90       	pop	r8
    7b50:	7f 90       	pop	r7
    7b52:	6f 90       	pop	r6
    7b54:	5f 90       	pop	r5
    7b56:	4f 90       	pop	r4
    7b58:	3f 90       	pop	r3
    7b5a:	2f 90       	pop	r2
    7b5c:	08 95       	ret
    7b5e:	80 37       	cpi	r24, 0x70	; 112
    7b60:	39 f0       	breq	.+14     	; 0x7b70 <vfprintf+0x668>
    7b62:	88 37       	cpi	r24, 0x78	; 120
    7b64:	19 f7       	brne	.-58     	; 0x7b2c <vfprintf+0x624>
    7b66:	14 fd       	sbrc	r17, 4
    7b68:	14 60       	ori	r17, 0x04	; 4
    7b6a:	20 e1       	ldi	r18, 0x10	; 16
    7b6c:	30 e0       	ldi	r19, 0x00	; 0
    7b6e:	c6 cf       	rjmp	.-116    	; 0x7afc <vfprintf+0x5f4>
    7b70:	10 61       	ori	r17, 0x10	; 16
    7b72:	f9 cf       	rjmp	.-14     	; 0x7b66 <vfprintf+0x65e>
    7b74:	04 fd       	sbrc	r16, 4
    7b76:	16 60       	ori	r17, 0x06	; 6
    7b78:	20 e1       	ldi	r18, 0x10	; 16
    7b7a:	32 e0       	ldi	r19, 0x02	; 2
    7b7c:	bf cf       	rjmp	.-130    	; 0x7afc <vfprintf+0x5f4>
    7b7e:	28 e0       	ldi	r18, 0x08	; 8
    7b80:	30 e0       	ldi	r19, 0x00	; 0
    7b82:	bc cf       	rjmp	.-136    	; 0x7afc <vfprintf+0x5f4>
    7b84:	f2 e0       	ldi	r31, 0x02	; 2
    7b86:	6f 0e       	add	r6, r31
    7b88:	71 1c       	adc	r7, r1
    7b8a:	f5 01       	movw	r30, r10
    7b8c:	60 81       	ld	r22, Z
    7b8e:	71 81       	ldd	r23, Z+1	; 0x01
    7b90:	90 e0       	ldi	r25, 0x00	; 0
    7b92:	80 e0       	ldi	r24, 0x00	; 0
    7b94:	be cf       	rjmp	.-132    	; 0x7b12 <vfprintf+0x60a>
    7b96:	02 fd       	sbrc	r16, 2
    7b98:	02 c0       	rjmp	.+4      	; 0x7b9e <vfprintf+0x696>
    7b9a:	b3 94       	inc	r11
    7b9c:	6b cf       	rjmp	.-298    	; 0x7a74 <vfprintf+0x56c>
    7b9e:	b3 94       	inc	r11
    7ba0:	b3 94       	inc	r11
    7ba2:	68 cf       	rjmp	.-304    	; 0x7a74 <vfprintf+0x56c>
    7ba4:	80 2f       	mov	r24, r16
    7ba6:	86 78       	andi	r24, 0x86	; 134
    7ba8:	09 f4       	brne	.+2      	; 0x7bac <vfprintf+0x6a4>
    7baa:	64 cf       	rjmp	.-312    	; 0x7a74 <vfprintf+0x56c>
    7bac:	f6 cf       	rjmp	.-20     	; 0x7b9a <vfprintf+0x692>
    7bae:	b6 01       	movw	r22, r12
    7bb0:	80 e2       	ldi	r24, 0x20	; 32
    7bb2:	90 e0       	ldi	r25, 0x00	; 0
    7bb4:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7bb8:	b3 94       	inc	r11
    7bba:	b5 14       	cp	r11, r5
    7bbc:	c0 f3       	brcs	.-16     	; 0x7bae <vfprintf+0x6a6>
    7bbe:	e1 2c       	mov	r14, r1
    7bc0:	65 cf       	rjmp	.-310    	; 0x7a8c <vfprintf+0x584>
    7bc2:	e5 2c       	mov	r14, r5
    7bc4:	eb 18       	sub	r14, r11
    7bc6:	b5 14       	cp	r11, r5
    7bc8:	08 f4       	brcc	.+2      	; 0x7bcc <vfprintf+0x6c4>
    7bca:	60 cf       	rjmp	.-320    	; 0x7a8c <vfprintf+0x584>
    7bcc:	f8 cf       	rjmp	.-16     	; 0x7bbe <vfprintf+0x6b6>
    7bce:	80 2f       	mov	r24, r16
    7bd0:	86 78       	andi	r24, 0x86	; 134
    7bd2:	09 f4       	brne	.+2      	; 0x7bd6 <vfprintf+0x6ce>
    7bd4:	6d cf       	rjmp	.-294    	; 0x7ab0 <vfprintf+0x5a8>
    7bd6:	8b e2       	ldi	r24, 0x2B	; 43
    7bd8:	01 ff       	sbrs	r16, 1
    7bda:	80 e2       	ldi	r24, 0x20	; 32
    7bdc:	07 fd       	sbrc	r16, 7
    7bde:	8d e2       	ldi	r24, 0x2D	; 45
    7be0:	b6 01       	movw	r22, r12
    7be2:	90 e0       	ldi	r25, 0x00	; 0
    7be4:	63 cf       	rjmp	.-314    	; 0x7aac <vfprintf+0x5a4>
    7be6:	b6 01       	movw	r22, r12
    7be8:	80 e3       	ldi	r24, 0x30	; 48
    7bea:	90 e0       	ldi	r25, 0x00	; 0
    7bec:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7bf0:	fa 94       	dec	r15
    7bf2:	5e cf       	rjmp	.-324    	; 0x7ab0 <vfprintf+0x5a8>
    7bf4:	b6 01       	movw	r22, r12
    7bf6:	80 e2       	ldi	r24, 0x20	; 32
    7bf8:	90 e0       	ldi	r25, 0x00	; 0
    7bfa:	0e 94 99 50 	call	0xa132	; 0xa132 <fputc>
    7bfe:	ea 94       	dec	r14
    7c00:	76 cd       	rjmp	.-1300   	; 0x76ee <vfprintf+0x1e6>
    7c02:	24 e0       	ldi	r18, 0x04	; 4
    7c04:	e1 2c       	mov	r14, r1
    7c06:	25 15       	cp	r18, r5
    7c08:	08 f0       	brcs	.+2      	; 0x7c0c <vfprintf+0x704>
    7c0a:	39 cd       	rjmp	.-1422   	; 0x767e <vfprintf+0x176>
    7c0c:	84 e0       	ldi	r24, 0x04	; 4
    7c0e:	29 cd       	rjmp	.-1454   	; 0x7662 <vfprintf+0x15a>

00007c10 <global constructors keyed to 65535_0_avr_iot_sample.cpp.o.11057>:
_GLOBAL__I_65535_0_avr_iot_sample.cpp.o.11057():
    7c10:	10 92 d8 6f 	sts	0x6FD8, r1	; 0x806fd8 <Serial3+0x2>
    7c14:	10 92 d9 6f 	sts	0x6FD9, r1	; 0x806fd9 <Serial3+0x3>
    7c18:	88 ee       	ldi	r24, 0xE8	; 232
    7c1a:	93 e0       	ldi	r25, 0x03	; 3
    7c1c:	a0 e0       	ldi	r26, 0x00	; 0
    7c1e:	b0 e0       	ldi	r27, 0x00	; 0
    7c20:	80 93 da 6f 	sts	0x6FDA, r24	; 0x806fda <Serial3+0x4>
    7c24:	90 93 db 6f 	sts	0x6FDB, r25	; 0x806fdb <Serial3+0x5>
    7c28:	a0 93 dc 6f 	sts	0x6FDC, r26	; 0x806fdc <Serial3+0x6>
    7c2c:	b0 93 dd 6f 	sts	0x6FDD, r27	; 0x806fdd <Serial3+0x7>
    7c30:	23 ed       	ldi	r18, 0xD3	; 211
    7c32:	32 e4       	ldi	r19, 0x42	; 66
    7c34:	20 93 d6 6f 	sts	0x6FD6, r18	; 0x806fd6 <Serial3>
    7c38:	30 93 d7 6f 	sts	0x6FD7, r19	; 0x806fd7 <Serial3+0x1>
    7c3c:	20 e6       	ldi	r18, 0x60	; 96
    7c3e:	38 e0       	ldi	r19, 0x08	; 8
    7c40:	20 93 de 6f 	sts	0x6FDE, r18	; 0x806fde <Serial3+0x8>
    7c44:	30 93 df 6f 	sts	0x6FDF, r19	; 0x806fdf <Serial3+0x9>
    7c48:	27 e9       	ldi	r18, 0x97	; 151
    7c4a:	32 e0       	ldi	r19, 0x02	; 2
    7c4c:	20 93 e0 6f 	sts	0x6FE0, r18	; 0x806fe0 <Serial3+0xa>
    7c50:	30 93 e1 6f 	sts	0x6FE1, r19	; 0x806fe1 <Serial3+0xb>
    7c54:	22 e0       	ldi	r18, 0x02	; 2
    7c56:	20 93 e2 6f 	sts	0x6FE2, r18	; 0x806fe2 <Serial3+0xc>
    7c5a:	10 92 e3 6f 	sts	0x6FE3, r1	; 0x806fe3 <Serial3+0xd>
    7c5e:	10 92 e4 6f 	sts	0x6FE4, r1	; 0x806fe4 <Serial3+0xe>
    7c62:	10 92 97 6e 	sts	0x6E97, r1	; 0x806e97 <Wire+0x2>
    7c66:	10 92 98 6e 	sts	0x6E98, r1	; 0x806e98 <Wire+0x3>
    7c6a:	80 93 99 6e 	sts	0x6E99, r24	; 0x806e99 <Wire+0x4>
    7c6e:	90 93 9a 6e 	sts	0x6E9A, r25	; 0x806e9a <Wire+0x5>
    7c72:	a0 93 9b 6e 	sts	0x6E9B, r26	; 0x806e9b <Wire+0x6>
    7c76:	b0 93 9c 6e 	sts	0x6E9C, r27	; 0x806e9c <Wire+0x7>
    7c7a:	25 ee       	ldi	r18, 0xE5	; 229
    7c7c:	32 e4       	ldi	r19, 0x42	; 66
    7c7e:	20 93 95 6e 	sts	0x6E95, r18	; 0x806e95 <Wire>
    7c82:	30 93 96 6e 	sts	0x6E96, r19	; 0x806e96 <Wire+0x1>
    7c86:	40 e0       	ldi	r20, 0x00	; 0
    7c88:	59 e0       	ldi	r21, 0x09	; 9
    7c8a:	40 93 9d 6e 	sts	0x6E9D, r20	; 0x806e9d <Wire+0x8>
    7c8e:	50 93 9e 6e 	sts	0x6E9E, r21	; 0x806e9e <Wire+0x9>
    7c92:	10 92 7e 6d 	sts	0x6D7E, r1	; 0x806d7e <Wire1+0x2>
    7c96:	10 92 7f 6d 	sts	0x6D7F, r1	; 0x806d7f <Wire1+0x3>
    7c9a:	80 93 80 6d 	sts	0x6D80, r24	; 0x806d80 <Wire1+0x4>
    7c9e:	90 93 81 6d 	sts	0x6D81, r25	; 0x806d81 <Wire1+0x5>
    7ca2:	a0 93 82 6d 	sts	0x6D82, r26	; 0x806d82 <Wire1+0x6>
    7ca6:	b0 93 83 6d 	sts	0x6D83, r27	; 0x806d83 <Wire1+0x7>
    7caa:	20 93 7c 6d 	sts	0x6D7C, r18	; 0x806d7c <Wire1>
    7cae:	30 93 7d 6d 	sts	0x6D7D, r19	; 0x806d7d <Wire1+0x1>
    7cb2:	80 e2       	ldi	r24, 0x20	; 32
    7cb4:	99 e0       	ldi	r25, 0x09	; 9
    7cb6:	80 93 84 6d 	sts	0x6D84, r24	; 0x806d84 <Wire1+0x8>
    7cba:	90 93 85 6d 	sts	0x6D85, r25	; 0x806d85 <Wire1+0x9>
    7cbe:	80 91 ae 6f 	lds	r24, 0x6FAE	; 0x806fae <guard variable for SequansControllerClass::instance()::instance>
    7cc2:	81 11       	cpse	r24, r1
    7cc4:	03 c0       	rjmp	.+6      	; 0x7ccc <global constructors keyed to 65535_0_avr_iot_sample.cpp.o.11057+0xbc>
    7cc6:	81 e0       	ldi	r24, 0x01	; 1
    7cc8:	80 93 ae 6f 	sts	0x6FAE, r24	; 0x806fae <guard variable for SequansControllerClass::instance()::instance>
    7ccc:	80 91 b6 6f 	lds	r24, 0x6FB6	; 0x806fb6 <guard variable for SecurityProfileClass::instance()::instance>
    7cd0:	81 11       	cpse	r24, r1
    7cd2:	03 c0       	rjmp	.+6      	; 0x7cda <global constructors keyed to 65535_0_avr_iot_sample.cpp.o.11057+0xca>
    7cd4:	81 e0       	ldi	r24, 0x01	; 1
    7cd6:	80 93 b6 6f 	sts	0x6FB6, r24	; 0x806fb6 <guard variable for SecurityProfileClass::instance()::instance>
    7cda:	80 91 be 6f 	lds	r24, 0x6FBE	; 0x806fbe <guard variable for MqttClientClass::instance()::instance>
    7cde:	81 11       	cpse	r24, r1
    7ce0:	03 c0       	rjmp	.+6      	; 0x7ce8 <global constructors keyed to 65535_0_avr_iot_sample.cpp.o.11057+0xd8>
    7ce2:	81 e0       	ldi	r24, 0x01	; 1
    7ce4:	80 93 be 6f 	sts	0x6FBE, r24	; 0x806fbe <guard variable for MqttClientClass::instance()::instance>
    7ce8:	80 91 c6 6f 	lds	r24, 0x6FC6	; 0x806fc6 <guard variable for LteClass::instance()::instance>
    7cec:	81 11       	cpse	r24, r1
    7cee:	03 c0       	rjmp	.+6      	; 0x7cf6 <global constructors keyed to 65535_0_avr_iot_sample.cpp.o.11057+0xe6>
    7cf0:	81 e0       	ldi	r24, 0x01	; 1
    7cf2:	80 93 c6 6f 	sts	0x6FC6, r24	; 0x806fc6 <guard variable for LteClass::instance()::instance>
    7cf6:	80 91 ce 6f 	lds	r24, 0x6FCE	; 0x806fce <guard variable for LowPowerClass::instance()::instance>
    7cfa:	81 11       	cpse	r24, r1
    7cfc:	03 c0       	rjmp	.+6      	; 0x7d04 <global constructors keyed to 65535_0_avr_iot_sample.cpp.o.11057+0xf4>
    7cfe:	81 e0       	ldi	r24, 0x01	; 1
    7d00:	80 93 ce 6f 	sts	0x6FCE, r24	; 0x806fce <guard variable for LowPowerClass::instance()::instance>
    7d04:	86 ed       	ldi	r24, 0xD6	; 214
    7d06:	9f e6       	ldi	r25, 0x6F	; 111
    7d08:	80 93 69 70 	sts	0x7069, r24	; 0x807069 <Log>
    7d0c:	90 93 6a 70 	sts	0x706A, r25	; 0x80706a <Log+0x1>
    7d10:	83 e0       	ldi	r24, 0x03	; 3
    7d12:	90 e0       	ldi	r25, 0x00	; 0
    7d14:	80 93 6b 70 	sts	0x706B, r24	; 0x80706b <Log+0x2>
    7d18:	90 93 6c 70 	sts	0x706C, r25	; 0x80706c <Log+0x3>
    7d1c:	80 91 6d 70 	lds	r24, 0x706D	; 0x80706d <guard variable for HttpClientClass::instance()::instance>
    7d20:	81 11       	cpse	r24, r1
    7d22:	03 c0       	rjmp	.+6      	; 0x7d2a <global constructors keyed to 65535_0_avr_iot_sample.cpp.o.11057+0x11a>
    7d24:	81 e0       	ldi	r24, 0x01	; 1
    7d26:	80 93 6d 70 	sts	0x706D, r24	; 0x80706d <guard variable for HttpClientClass::instance()::instance>
    7d2a:	80 91 76 70 	lds	r24, 0x7076	; 0x807076 <guard variable for ECC608Class::instance()::instance>
    7d2e:	81 11       	cpse	r24, r1
    7d30:	05 c0       	rjmp	.+10     	; 0x7d3c <global constructors keyed to 65535_0_avr_iot_sample.cpp.o.11057+0x12c>
    7d32:	10 92 75 70 	sts	0x7075, r1	; 0x807075 <ECC608Class::instance()::instance>
    7d36:	81 e0       	ldi	r24, 0x01	; 1
    7d38:	80 93 76 70 	sts	0x7076, r24	; 0x807076 <guard variable for ECC608Class::instance()::instance>
    7d3c:	80 91 75 70 	lds	r24, 0x7075	; 0x807075 <ECC608Class::instance()::instance>
    7d40:	80 93 7e 70 	sts	0x707E, r24	; 0x80707e <ECC608>
    7d44:	08 95       	ret

00007d46 <main>:
main():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:48
 * called first in non-optiboot configurations (neither is needed on Optibooot configurations() *
 * an extra bit of initialization code in .init3 to fix the vectors and still happen if user    *
 * overrides main. In the past there was a USB-related function here, that is removed, as work  *
 * will be needed in any event at the core level if VUSB-based "stuff" arrives, but really I'm  *
 * just waiting for the DU-series now                                                           */
int main() {
    7d46:	cf 93       	push	r28
    7d48:	df 93       	push	r29
    7d4a:	cd b7       	in	r28, 0x3d	; 61
    7d4c:	de b7       	in	r29, 0x3e	; 62
    7d4e:	cb 52       	subi	r28, 0x2B	; 43
    7d50:	d1 40       	sbci	r29, 0x01	; 1
    7d52:	cd bf       	out	0x3d, r28	; 61
    7d54:	de bf       	out	0x3e, r29	; 62
init_clock():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1642
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0B << 2));
    #elif (F_CPU == 28000000)
      /* Overclocked - generally quite reliable at room temperature, but a dumb frequency (see PWM section) */
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x0A << 2));
    #elif (F_CPU == 24000000)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (0x09 << 2));
    7d56:	88 ed       	ldi	r24, 0xD8	; 216
    7d58:	94 e2       	ldi	r25, 0x24	; 36
    7d5a:	84 bf       	out	0x34, r24	; 52
    7d5c:	90 93 68 00 	sts	0x0068, r25	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
init_TCA0():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1912
}

void __attribute__((weak)) init_TCA0() {
  /* TCA0_PINS from pins_arduino.h */
  /* Enable Split Mode to get more PWM pins, since analogWrite() only provides 8-bit PWM anyway*/
  TCA0.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    7d60:	21 e0       	ldi	r18, 0x01	; 1
    7d62:	20 93 03 0a 	sts	0x0A03, r18	; 0x800a03 <__TEXT_REGION_LENGTH__+0x7e0a03>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1917

  // Only 1 WGM so no need to specifically set up.

  /* Period setting, 8-bit register in SPLIT mode */
  TCA0.SPLIT.LPER    = PWM_TIMER_PERIOD;
    7d66:	8e ef       	ldi	r24, 0xFE	; 254
    7d68:	80 93 26 0a 	sts	0x0A26, r24	; 0x800a26 <__TEXT_REGION_LENGTH__+0x7e0a26>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1918
  TCA0.SPLIT.HPER    = PWM_TIMER_PERIOD;
    7d6c:	80 93 27 0a 	sts	0x0A27, r24	; 0x800a27 <__TEXT_REGION_LENGTH__+0x7e0a27>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1945
    TCA0.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA0) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA0 to different divider"
    #endif
    TCA0.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    7d70:	9b e0       	ldi	r25, 0x0B	; 11
    7d72:	90 93 00 0a 	sts	0x0A00, r25	; 0x800a00 <__TEXT_REGION_LENGTH__+0x7e0a00>
init_timers():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1890
uint8_t __PeripheralControl = 0xFF;

void init_timers() {
  init_TCA0();
  #if (defined(TCA1))
    PORTMUX.TCAROUTEA = TCA0_PINS | TCA1_PINS;
    7d76:	32 e0       	ldi	r19, 0x02	; 2
    7d78:	30 93 e6 05 	sts	0x05E6, r19	; 0x8005e6 <__TEXT_REGION_LENGTH__+0x7e05e6>
init_TCA1():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1963

#if defined(TCA1)
void __attribute__((weak)) init_TCA1() {

  /* Enable Split Mode */
  TCA1.SPLIT.CTRLD = TCA_SPLIT_SPLITM_bm;
    7d7c:	20 93 43 0a 	sts	0x0A43, r18	; 0x800a43 <__TEXT_REGION_LENGTH__+0x7e0a43>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1966

  /* Period setting, 8-bit register in SPLIT mode */
  TCA1.SPLIT.LPER    = PWM_TIMER_PERIOD;
    7d80:	80 93 66 0a 	sts	0x0A66, r24	; 0x800a66 <__TEXT_REGION_LENGTH__+0x7e0a66>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1967
  TCA1.SPLIT.HPER    = PWM_TIMER_PERIOD;
    7d84:	80 93 67 0a 	sts	0x0A67, r24	; 0x800a67 <__TEXT_REGION_LENGTH__+0x7e0a67>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1978
    TCA1.SPLIT.CTRLA   = (TCA_SPLIT_CLKSEL_DIV256_gc) | (TCA_SPLIT_ENABLE_bm);
  #elif (F_CPU > 5000000) // use 64 divider unless it's 5 MHz or under
    #if defined(MILLIS_USE_TIMERA1) && (TIME_TRACKING_TIMER_DIVIDER != 64)
      #error "wiring.c and timers.h want to set millis timer TCA1 to different divider"
    #endif
    TCA1.SPLIT.CTRLA   =  (TCA_SPLIT_CLKSEL_DIV64_gc) | (TCA_SPLIT_ENABLE_bm);
    7d88:	90 93 40 0a 	sts	0x0A40, r25	; 0x800a40 <__TEXT_REGION_LENGTH__+0x7e0a40>
init_TCBs():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2000
 * Set up routing (defined in pins_arduino.h)
 * Notice how there's no semicolon until after the preprocessor conditionals.
 * In other words, that's all one line.
 */

  PORTMUX.TCBROUTEA = 0
    7d8c:	90 93 e7 05 	sts	0x05E7, r25	; 0x8005e7 <__TEXT_REGION_LENGTH__+0x7e05e7>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2051
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    7d90:	37 e0       	ldi	r19, 0x07	; 7
    7d92:	30 93 01 0b 	sts	0x0B01, r19	; 0x800b01 <__TEXT_REGION_LENGTH__+0x7e0b01>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2054

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    7d96:	80 93 0c 0b 	sts	0x0B0C, r24	; 0x800b0c <__TEXT_REGION_LENGTH__+0x7e0b0c>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2057
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    7d9a:	10 92 0d 0b 	sts	0x0B0D, r1	; 0x800b0d <__TEXT_REGION_LENGTH__+0x7e0b0d>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2060

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    7d9e:	95 e0       	ldi	r25, 0x05	; 5
    7da0:	90 93 00 0b 	sts	0x0B00, r25	; 0x800b00 <__TEXT_REGION_LENGTH__+0x7e0b00>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2051
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    7da4:	30 93 11 0b 	sts	0x0B11, r19	; 0x800b11 <__TEXT_REGION_LENGTH__+0x7e0b11>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2054

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    7da8:	80 93 1c 0b 	sts	0x0B1C, r24	; 0x800b1c <__TEXT_REGION_LENGTH__+0x7e0b1c>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2057
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    7dac:	10 92 1d 0b 	sts	0x0B1D, r1	; 0x800b1d <__TEXT_REGION_LENGTH__+0x7e0b1d>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2060

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    7db0:	90 93 10 0b 	sts	0x0B10, r25	; 0x800b10 <__TEXT_REGION_LENGTH__+0x7e0b10>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2051
    #elif defined(MILLIS_USE_TIMERB4)
      if(timer_B != (TCB_t *)&TCB4)
    #endif
    {
      // 8 bit PWM mode, but do not enable output yet, will do in analogWrite()
      timer_B->CTRLB = (TCB_CNTMODE_PWM8_gc);
    7db4:	30 93 31 0b 	sts	0x0B31, r19	; 0x800b31 <__TEXT_REGION_LENGTH__+0x7e0b31>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2054

      // Assign 8-bit period
      timer_B->CCMPL = PWM_TIMER_PERIOD; // TOP = 254 see section at start
    7db8:	80 93 3c 0b 	sts	0x0B3C, r24	; 0x800b3c <__TEXT_REGION_LENGTH__+0x7e0b3c>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2057
      // default duty 50% - we have to set something here because of the
      // errata, otherwise CCMP will not get the CCMPL either.
      timer_B->CCMPH = PWM_TIMER_COMPARE;
    7dbc:	10 92 3d 0b 	sts	0x0B3D, r1	; 0x800b3d <__TEXT_REGION_LENGTH__+0x7e0b3d>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2060

      // Use TCA clock (250kHz, +/- 50%) and enable
      timer_B->CTRLA = (TCB_CLKSEL_TCA0_gc) | (TCB_ENABLE_bm);
    7dc0:	90 93 30 0b 	sts	0x0B30, r25	; 0x800b30 <__TEXT_REGION_LENGTH__+0x7e0b30>
init_TCD0():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2104
 * be set in the status register. We skip checking this here because, as we do many places the  *
 * initiialization functions assume that the chip starts from a reset condition.                */

void __attribute__((weak)) init_TCD0() {
  #if defined(USE_TIMERD0_PWM) || defined (MILLIS_USE_TIMERD0)
    TCD0.CMPACLR  = 0x0FFF;
    7dc4:	4f ef       	ldi	r20, 0xFF	; 255
    7dc6:	5f e0       	ldi	r21, 0x0F	; 15
    7dc8:	40 93 aa 0b 	sts	0x0BAA, r20	; 0x800baa <__TEXT_REGION_LENGTH__+0x7e0baa>
    7dcc:	50 93 ab 0b 	sts	0x0BAB, r21	; 0x800bab <__TEXT_REGION_LENGTH__+0x7e0bab>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2108
    // Match with CMPBCLR clears all outputs. For normal PWM this just needs to be higher than
    // it will count to - so set to maximum (other settings used for non-overlapping PWM and
    // other advanced functionality)
    TCD0.CTRLC    = 0x80;                   // WOD outputs PWM B, WOC outputs PWM A
    7dd0:	80 e8       	ldi	r24, 0x80	; 128
    7dd2:	80 93 82 0b 	sts	0x0B82, r24	; 0x800b82 <__TEXT_REGION_LENGTH__+0x7e0b82>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2110
    // That doesn't need to be that way, but I declare that that's all we support through analogWrite()
    TCD0.CTRLB    = TIMERD0_WGMODE_SETTING;
    7dd6:	10 92 81 0b 	sts	0x0B81, r1	; 0x800b81 <__TEXT_REGION_LENGTH__+0x7e0b81>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2113
    // One ramp or dual slope are the only options that are viable to reproduce classic behavior without
    // considerable calculation overhead. We use one-ramp mode
    TCD0.CMPBCLR  = TIMERD0_TOP_SETTING;
    7dda:	4b ef       	ldi	r20, 0xFB	; 251
    7ddc:	53 e0       	ldi	r21, 0x03	; 3
    7dde:	40 93 ae 0b 	sts	0x0BAE, r20	; 0x800bae <__TEXT_REGION_LENGTH__+0x7e0bae>
    7de2:	50 93 af 0b 	sts	0x0BAF, r21	; 0x800baf <__TEXT_REGION_LENGTH__+0x7e0baf>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:2122
    #if defined(TIMERD0_SET_CLOCK)
      _PROTECTED_WRITE(CLKCTRL_OSCHFCTRLA, (TIMERD0_SET_CLOCK));
    #endif


    TCD0.CTRLA    = TIMERD0_CLOCK_SETTING | TCD_ENABLE_bm;
    7de6:	81 e7       	ldi	r24, 0x71	; 113
    7de8:	80 93 80 0b 	sts	0x0B80, r24	; 0x800b80 <__TEXT_REGION_LENGTH__+0x7e0b80>
init_ADC0():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1536
    #elif F_CPU >= 36000000
      ADC0.CTRLC = ADC_PRESC_DIV28_gc; // 1.286 @ 36 MHz
    #elif F_CPU >  28000000
      ADC0.CTRLC = ADC_PRESC_DIV24_gc; // 1.33 @ 32 MHz, 1.
    #elif F_CPU >= 24000000
      ADC0.CTRLC = ADC_PRESC_DIV20_gc; // 1.2 @ 24, 1.25 @ 25, 1.4 @ 28  MHz
    7dec:	90 93 02 06 	sts	0x0602, r25	; 0x800602 <__TEXT_REGION_LENGTH__+0x7e0602>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1548
    #elif F_CPU >= 4000000
      ADC0.CTRLC = ADC_PRESC_DIV4_gc;  // 1 MHz
    #else  // 1 MHz / 2 = 500 kHz - the lowest setting
      ADC0.CTRLC = ADC_PRESC_DIV2_gc;
    #endif
    ADC0.SAMPCTRL = 14; // 16 ADC clock sampling time - should be about the same amount of *time* as originally?
    7df0:	8e e0       	ldi	r24, 0x0E	; 14
    7df2:	80 93 05 06 	sts	0x0605, r24	; 0x800605 <__TEXT_REGION_LENGTH__+0x7e0605>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1550
    // This is WAY conservative! We could drop it down...
    ADC0.CTRLD = ADC_INITDLY_DLY64_gc; // VREF can take 50uS to become ready, and we're running the ADC clock
    7df6:	80 e6       	ldi	r24, 0x60	; 96
    7df8:	80 93 03 06 	sts	0x0603, r24	; 0x800603 <__TEXT_REGION_LENGTH__+0x7e0603>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1553
    // at around 1 MHz, so we want 64 ADC clocks when we start up a new reference so we don't get bad readings at first
    /* Enable ADC */
    ADC0.CTRLA = ADC_ENABLE_bm | ADC_RESSEL_10BIT_gc;
    7dfc:	90 93 00 06 	sts	0x0600, r25	; 0x800600 <__TEXT_REGION_LENGTH__+0x7e0600>
analogReference():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:117


void analogReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.ADC0REF = (VREF.ADC0REF & ~(VREF_REFSEL_gm))|(mode);
    7e00:	80 91 b0 00 	lds	r24, 0x00B0	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
    7e04:	88 7f       	andi	r24, 0xF8	; 248
    7e06:	85 60       	ori	r24, 0x05	; 5
    7e08:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__TEXT_REGION_LENGTH__+0x7e00b0>
DACReference():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_analog.c:124
}

void DACReference(uint8_t mode) {
  check_valid_analog_ref(mode);
  if (mode < 7 && mode !=4) {
    VREF.DAC0REF = (VREF.DAC0REF & ~(VREF_REFSEL_gm))|(mode);
    7e0c:	80 91 b2 00 	lds	r24, 0x00B2	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
    7e10:	88 7f       	andi	r24, 0xF8	; 248
    7e12:	85 60       	ori	r24, 0x05	; 5
    7e14:	80 93 b2 00 	sts	0x00B2, r24	; 0x8000b2 <__TEXT_REGION_LENGTH__+0x7e00b2>
init_millis():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1448
      #endif
      RTC.INTCTRL         = 0x01; // enable overflow interrupt
      RTC.CTRLA           = (RTC_RUNSTDBY_bm|RTC_RTCEN_bm|RTC_PRESCALER_DIV32_gc);//fire it up, prescale by 32.
    */
    #else // It's a type b timer - we have already errored out if that wasn't defined
      _timer->CCMP = TIME_TRACKING_TIMER_PERIOD;
    7e18:	8f ed       	ldi	r24, 0xDF	; 223
    7e1a:	9e e2       	ldi	r25, 0x2E	; 46
    7e1c:	80 93 2c 0b 	sts	0x0B2C, r24	; 0x800b2c <__TEXT_REGION_LENGTH__+0x7e0b2c>
    7e20:	90 93 2d 0b 	sts	0x0B2D, r25	; 0x800b2d <__TEXT_REGION_LENGTH__+0x7e0b2d>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1450
      // Enable timer interrupt, but clear the rest of register
      _timer->INTCTRL = TCB_CAPT_bm;
    7e24:	20 93 25 0b 	sts	0x0B25, r18	; 0x800b25 <__TEXT_REGION_LENGTH__+0x7e0b25>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1452
      // Clear timer mode (since it will have been set as PWM by init())
      _timer->CTRLB = 0;
    7e28:	10 92 21 0b 	sts	0x0B21, r1	; 0x800b21 <__TEXT_REGION_LENGTH__+0x7e0b21>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring.c:1454
      // CLK_PER/1 is 0b00, . CLK_PER/2 is 0b01, so bitwise OR of valid divider with enable works
      _timer->CTRLA = TIME_TRACKING_TIMER_DIVIDER|TCB_ENABLE_bm;  // Keep this last before enabling interrupts to ensure tracking as accurate as possible
    7e2c:	83 e0       	ldi	r24, 0x03	; 3
    7e2e:	80 93 20 0b 	sts	0x0B20, r24	; 0x800b20 <__TEXT_REGION_LENGTH__+0x7e0b20>
main():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/main.cpp:52
  onBeforeInit(); // Emnpty callback called before init but after the .init stuff. First normal code executed
  init(); // Interrupts are turned on just prior to init() returning.
  initVariant();
  if (!onAfterInit()) sei();  // enable interrupts.
    7e32:	78 94       	sei
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:66

    this->setLogLevel(ll);
    return true;
}

void LogClass::begin(const uint32_t baud_rate) { this->uart->begin(baud_rate); }
    7e34:	00 91 69 70 	lds	r16, 0x7069	; 0x807069 <Log>
    7e38:	10 91 6a 70 	lds	r17, 0x706A	; 0x80706a <Log+0x1>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:540
    }

    void HardwareSerial::begin(unsigned long baud, uint16_t options) {
      // Make sure no transmissions are ongoing and USART is disabled in case begin() is called by accident
      // without first calling end()
      if (_state & 1) {
    7e3c:	d8 01       	movw	r26, r16
    7e3e:	1e 96       	adiw	r26, 0x0e	; 14
    7e40:	8c 91       	ld	r24, X
    7e42:	1e 97       	sbiw	r26, 0x0e	; 14
    7e44:	80 ff       	sbrs	r24, 0
    7e46:	1a c0       	rjmp	.+52     	; 0x7e7c <main+0x136>
end():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:684
        return NOT_A_MUX; // At this point, we have checked all group codes for this peripheral. It ain't there. Return NOT_A_MUX.
      }
    }
    void HardwareSerial::end() {
      // wait for transmission of outgoing data
      flush();
    7e48:	ed 91       	ld	r30, X+
    7e4a:	fc 91       	ld	r31, X
    7e4c:	06 80       	ldd	r0, Z+6	; 0x06
    7e4e:	f7 81       	ldd	r31, Z+7	; 0x07
    7e50:	e0 2d       	mov	r30, r0
    7e52:	c8 01       	movw	r24, r16
    7e54:	09 95       	icall
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:687
      // Disable receiver and transmitter as well as the RX complete and the data register empty interrupts.
      // TXCIE only used in half duplex - we can just turn the damned thing off yo!
      volatile USART_t * temp = _hwserial_module; /* compiler does a slightly better job with this. */
    7e56:	d8 01       	movw	r26, r16
    7e58:	18 96       	adiw	r26, 0x08	; 8
    7e5a:	ed 91       	ld	r30, X+
    7e5c:	fc 91       	ld	r31, X
    7e5e:	19 97       	sbiw	r26, 0x09	; 9
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:688
      temp -> CTRLB &= 0; //~(USART_RXEN_bm | USART_TXEN_bm);
    7e60:	86 81       	ldd	r24, Z+6	; 0x06
    7e62:	16 82       	std	Z+6, r1	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:689
      temp -> CTRLA &= 0; //~(USART_RXCIE_bm | USART_DREIE_bm | USART_TXCIE_bm);
    7e64:	85 81       	ldd	r24, Z+5	; 0x05
    7e66:	15 82       	std	Z+5, r1	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:690
      temp -> STATUS =  USART_TXCIF_bm; // want to make sure no chanceofthat firing in error. TXCIE only used in half duplex
    7e68:	80 e4       	ldi	r24, 0x40	; 64
    7e6a:	84 83       	std	Z+4, r24	; 0x04
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:692
      // clear any received data
      _rx_buffer_head = _rx_buffer_tail;
    7e6c:	50 96       	adiw	r26, 0x10	; 16
    7e6e:	8c 91       	ld	r24, X
    7e70:	50 97       	sbiw	r26, 0x10	; 16
    7e72:	1f 96       	adiw	r26, 0x0f	; 15
    7e74:	8c 93       	st	X, r24
    7e76:	1f 97       	sbiw	r26, 0x0f	; 15
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:696

      // Note: Does not change output pins
      // though the datasheetsays turning the TX module sets it to input.
      _state = 0;
    7e78:	1e 96       	adiw	r26, 0x0e	; 14
    7e7a:	1c 92       	st	X, r1
begin():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:579
        setpinmask             |= 0x10;         // this tells _set_pins not to disturb the configuration on the RX pin.
      }
      if (ctrla & USART_RS485_bm) {             // RS485 mode recorded here too... because we need to set
        setpinmask             |= 0x01;         // set pin output if we need to do that. Datasheet isn't clear
      }
      uint8_t oldSREG = SREG;
    7e7c:	6f b7       	in	r22, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:580
      cli();
    7e7e:	f8 94       	cli
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:581
      volatile USART_t* MyUSART = _hwserial_module;
    7e80:	d8 01       	movw	r26, r16
    7e82:	18 96       	adiw	r26, 0x08	; 8
    7e84:	ed 91       	ld	r30, X+
    7e86:	fc 91       	ld	r31, X
    7e88:	19 97       	sbiw	r26, 0x09	; 9
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:582
      (*MyUSART).CTRLB          = 0;            // gotta disable first - some things are enable-locked.
    7e8a:	16 82       	std	Z+6, r1	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:583
      (*MyUSART).CTRLC          = ctrlc;        // No reason not to set first.
    7e8c:	33 e0       	ldi	r19, 0x03	; 3
    7e8e:	37 83       	std	Z+7, r19	; 0x07
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:584
      (*MyUSART).BAUD           = baud_setting; // Wish I could have set it long ago
    7e90:	81 e4       	ldi	r24, 0x41	; 65
    7e92:	93 e0       	ldi	r25, 0x03	; 3
    7e94:	80 87       	std	Z+8, r24	; 0x08
    7e96:	91 87       	std	Z+9, r25	; 0x09
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:590
      if (ctrla & 0x20) {                       // Now we have to do a bit of work
        setpinmask             &= 0x7F;         // Remove the RX pin in this case because we get the input from elsewhere.
        (*MyUSART).EVCTRL       = 1;            // enable event input - not clear from datasheet what's needed to
        (*MyUSART).TXPLCTRL     = 0xFF;         // Disable pulse length encoding.
      } else {
        (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
    7e98:	14 86       	std	Z+12, r1	; 0x0c
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:592
      }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
      (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
    7e9a:	80 e8       	ldi	r24, 0x80	; 128
    7e9c:	85 83       	std	Z+5, r24	; 0x05
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:593
      (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
    7e9e:	80 ec       	ldi	r24, 0xC0	; 192
    7ea0:	86 83       	std	Z+6, r24	; 0x06
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:594
        _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask); // set up the pin(s)
    7ea2:	1d 96       	adiw	r26, 0x0d	; 13
    7ea4:	2c 91       	ld	r18, X
    7ea6:	1d 97       	sbiw	r26, 0x0d	; 13
    7ea8:	1c 96       	adiw	r26, 0x0c	; 12
    7eaa:	7c 91       	ld	r23, X
    7eac:	1c 97       	sbiw	r26, 0x0c	; 12
    7eae:	1a 96       	adiw	r26, 0x0a	; 10
    7eb0:	8d 91       	ld	r24, X+
    7eb2:	9c 91       	ld	r25, X
_set_pins():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:641
    //  1  1  1  0      TX set output, RX not changed. Loopback mode: you can only see what you send since TX is OUTPUT and that's what's connected to RX.
    //  1  1  1  1      TX set input pullup. Half-duplex mode.
    // * indicates that RS485 mode if requested will be enabled, even though it is inappropriate. These configurations are documented unsupported.
    // Static
    void HardwareSerial::_set_pins(uint8_t* mux_table_ptr, uint8_t mux_count, uint8_t mux_setting, uint8_t enmask) {
      uint8_t* mux_row_ptr   = mux_table_ptr + (mux_setting * USART_PINS_WIDTH);
    7eb4:	fc 01       	movw	r30, r24
    7eb6:	23 9f       	mul	r18, r19
    7eb8:	e0 0d       	add	r30, r0
    7eba:	f1 1d       	adc	r31, r1
    7ebc:	11 24       	eor	r1, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:642
      uint16_t mux_row_gc_tx = pgm_read_word_near(mux_row_ptr); // Clever trick for faster PGM reads of consecutive bytes!
    7ebe:	45 91       	lpm	r20, Z+
    7ec0:	54 91       	lpm	r21, Z
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:644
      uint8_t mux_group_code = (uint8_t) (mux_row_gc_tx);       // this is the mux
      if (mux_setting < mux_count) {              // if false, pinmux none was selected, and we skip the pin configuration.
    7ec2:	27 17       	cp	r18, r23
    7ec4:	08 f0       	brcs	.+2      	; 0x7ec8 <main+0x182>
    7ec6:	3e c0       	rjmp	.+124    	; 0x7f44 <main+0x1fe>
_pinMode():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    7ec8:	59 32       	cpi	r21, 0x29	; 41
    7eca:	90 f4       	brcc	.+36     	; 0x7ef0 <main+0x1aa>
check_valid_digital_pin():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/Arduino.h:712
    7ecc:	25 2f       	mov	r18, r21
    7ece:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:79
    7ed0:	f9 01       	movw	r30, r18
    7ed2:	ed 5b       	subi	r30, 0xBD	; 189
    7ed4:	fd 4b       	sbci	r31, 0xBD	; 189
    7ed6:	a0 81       	ld	r26, Z
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    7ed8:	af 3f       	cpi	r26, 0xFF	; 255
    7eda:	51 f0       	breq	.+20     	; 0x7ef0 <main+0x1aa>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    7edc:	24 59       	subi	r18, 0x94	; 148
    7ede:	3d 4b       	sbci	r19, 0xBD	; 189
    7ee0:	f9 01       	movw	r30, r18
    7ee2:	30 81       	ld	r19, Z
    7ee4:	20 e2       	ldi	r18, 0x20	; 32
    7ee6:	32 9f       	mul	r19, r18
    7ee8:	f0 01       	movw	r30, r0
    7eea:	11 24       	eor	r1, r1
    7eec:	fc 5f       	subi	r31, 0xFC	; 252
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:86
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
    7eee:	a1 83       	std	Z+1, r26	; 0x01
_set_pins():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:653
          pinMode(mux_pin_tx, OUTPUT);            // If and only if TX is enabled and open drain isn't should the TX pin be output.
        } else if (enmask & 0x50) {               // if it is enabled but is in open drain mode, or is disabled, but loopback is enabled
          pinMode(mux_pin_tx, INPUT_PULLUP);      // TX should be INPUT_PULLUP.
        }
        if (enmask & 0x80 && !(enmask & 0x10)) {  // Likewise if RX is enabled, unless loopback mode is too
          pinMode(mux_pin_tx + 1, INPUT_PULLUP);  // (in which case we caught it above), it should be pulled up
    7ef0:	21 e0       	ldi	r18, 0x01	; 1
    7ef2:	25 0f       	add	r18, r21
_pinMode():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:79
    }
  #endif
  _pinMode(pin, mode);
}
void _pinMode(uint8_t pin, uint8_t mode) {
  uint8_t bit_mask = digitalPinToBitMask(pin);
    7ef4:	29 32       	cpi	r18, 0x29	; 41
    7ef6:	30 f5       	brcc	.+76     	; 0x7f44 <main+0x1fe>
check_valid_digital_pin():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/Arduino.h:712
    7ef8:	30 e0       	ldi	r19, 0x00	; 0
_pinMode():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:79
    7efa:	f9 01       	movw	r30, r18
    7efc:	ed 5b       	subi	r30, 0xBD	; 189
    7efe:	fd 4b       	sbci	r31, 0xBD	; 189
    7f00:	10 81       	ld	r17, Z
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:80
  if ((bit_mask == NOT_A_PIN) || (mode > INPUT_PULLUP)) {
    7f02:	1f 3f       	cpi	r17, 0xFF	; 255
    7f04:	f9 f0       	breq	.+62     	; 0x7f44 <main+0x1fe>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:83
    return;                             /* ignore invalid pins passed at runtime */
  }
  PORT_t *port = digitalPinToPortStruct(pin);
    7f06:	f9 01       	movw	r30, r18
    7f08:	e4 59       	subi	r30, 0x94	; 148
    7f0a:	fd 4b       	sbci	r31, 0xBD	; 189
    7f0c:	a0 81       	ld	r26, Z
    7f0e:	e0 e2       	ldi	r30, 0x20	; 32
    7f10:	ae 9f       	mul	r26, r30
    7f12:	d0 01       	movw	r26, r0
    7f14:	11 24       	eor	r1, r1
    7f16:	bc 5f       	subi	r27, 0xFC	; 252
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:89
  // if (port == NULL) return;           /* skip this test; if bit_mask isn't NOT_A_PIN, port won't be null - if it is, pins_arduino.h contains errors and we can't expect any digital I/O to work correctly.
  if (mode == OUTPUT) {
    port->DIRSET = bit_mask;            /* Configure direction as output and done*/
  } else {                              /* mode == INPUT or INPUT_PULLUP - more complicated */
                                        /* Calculate where pin control register is */
    uint8_t bit_pos = digitalPinToBitPosition(pin);
    7f18:	2b 56       	subi	r18, 0x6B	; 107
    7f1a:	3d 4b       	sbci	r19, 0xBD	; 189
    7f1c:	f9 01       	movw	r30, r18
    7f1e:	00 81       	ld	r16, Z
main():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:90
    volatile uint8_t *pin_ctrl = getPINnCTRLregister(port, bit_pos);
    7f20:	f0 e0       	ldi	r31, 0x00	; 0
    7f22:	e0 e0       	ldi	r30, 0x00	; 0
_pinMode():
    7f24:	08 30       	cpi	r16, 0x08	; 8
    7f26:	30 f4       	brcc	.+12     	; 0x7f34 <main+0x1ee>
    7f28:	9d 01       	movw	r18, r26
    7f2a:	20 5f       	subi	r18, 0xF0	; 240
    7f2c:	3f 4f       	sbci	r19, 0xFF	; 255
    7f2e:	f9 01       	movw	r30, r18
    7f30:	e0 0f       	add	r30, r16
    7f32:	f1 1d       	adc	r31, r1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:91
    uint8_t status = SREG;              /* Save state */
    7f34:	3f b7       	in	r19, 0x3f	; 63
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:92
    cli();                              /* Interrupts off for PINnCTRL stuff */
    7f36:	f8 94       	cli
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:93
    port->DIRCLR = bit_mask;            /* Configure direction as input */
    7f38:	12 96       	adiw	r26, 0x02	; 2
    7f3a:	1c 93       	st	X, r17
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:95
    if (mode == INPUT_PULLUP) {         /* Configure pull-up resistor */
      *pin_ctrl |= PORT_PULLUPEN_bm;    /* Enable pull-up */
    7f3c:	20 81       	ld	r18, Z
    7f3e:	28 60       	ori	r18, 0x08	; 8
    7f40:	20 83       	st	Z, r18
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:99
    } else {                            /* mode == INPUT (no pullup) */
      *pin_ctrl &= ~(PORT_PULLUPEN_bm); /* Disable pull-up */
    }
    SREG = status;                      /* Restore state */
    7f42:	3f bf       	out	0x3f, r19	; 63
_mux_set():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:601
    }

// Static
    void HardwareSerial::_mux_set(uint8_t* mux_table_ptr, uint8_t mux_count, uint8_t mux_code) {
    #if HWSERIAL_MUX_REG_COUNT > 1  // for big pincount devices that have more then one USART PORTMUX register
      uint8_t* mux_info_ptr = mux_table_ptr + (mux_count * USART_PINS_WIDTH) + 1;
    7f44:	fc 01       	movw	r30, r24
    7f46:	23 e0       	ldi	r18, 0x03	; 3
    7f48:	72 9f       	mul	r23, r18
    7f4a:	e0 0d       	add	r30, r0
    7f4c:	f1 1d       	adc	r31, r1
    7f4e:	11 24       	eor	r1, r1
    7f50:	31 96       	adiw	r30, 0x01	; 1
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:602
      uint16_t mux_options_off_gm = pgm_read_word_near(mux_info_ptr);  /* pointer offset to the second columun
    7f52:	25 91       	lpm	r18, Z+
    7f54:	34 91       	lpm	r19, Z
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:605
      at the end bottom row of the table, with info about the mux options, rather than a specific option
      Low byte is the offset from USARTROUTEA, second byte is the group mask. */
      volatile uint8_t* portmux  = (uint8_t*)(HWSERIAL_MUX_REGISTER_BASE + (uint8_t)mux_options_off_gm); // offset
    7f56:	f9 01       	movw	r30, r18
    7f58:	ff 27       	eor	r31, r31
    7f5a:	ee 51       	subi	r30, 0x1E	; 30
    7f5c:	fa 4f       	sbci	r31, 0xFA	; 250
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:606
      uint8_t temp   = *portmux;
    7f5e:	90 81       	ld	r25, Z
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:607
      temp          &= ~((uint8_t) (mux_options_off_gm >> 8)); // Group Mask
    7f60:	83 2f       	mov	r24, r19
    7f62:	80 95       	com	r24
    7f64:	89 23       	and	r24, r25
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:608
      temp          |= mux_code;
    7f66:	48 2b       	or	r20, r24
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:609
      *portmux       = temp;
    7f68:	40 83       	st	Z, r20
begin():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/UART.cpp:595
        (*MyUSART).EVCTRL       = 0;            // This needs to be turned off when not in use.
      }                                         // finally strip out the SERIAL_EVENT_RX bit which is in the DREIE
      (*MyUSART).CTRLA          = ctrla & 0xDF; // position, which we never set in begin.
      (*MyUSART).CTRLB          = ctrlb;        // Set the all important CTRLB...
        _set_pins(_usart_pins, _mux_count, _pin_set, setpinmask); // set up the pin(s)
      SREG = oldSREG;                             // re-enable interrupts, and we're done.
    7f6a:	6f bf       	out	0x3f, r22	; 63
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:199
}

void demo_setup(void)
{
  Log.begin(115200);
  Log.infof("Starting the Sample Application %s\r\n", APP_VERSION);
    7f6c:	85 e8       	ldi	r24, 0x85	; 133
    7f6e:	92 e5       	ldi	r25, 0x52	; 82
    7f70:	9f 93       	push	r25
    7f72:	8f 93       	push	r24
    7f74:	85 ea       	ldi	r24, 0xA5	; 165
    7f76:	93 e5       	ldi	r25, 0x53	; 83
    7f78:	9f 93       	push	r25
    7f7a:	8f 93       	push	r24
    7f7c:	09 e6       	ldi	r16, 0x69	; 105
    7f7e:	10 e7       	ldi	r17, 0x70	; 112
    7f80:	1f 93       	push	r17
    7f82:	0f 93       	push	r16
    7f84:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:200
  delay(2000);
    7f88:	60 ed       	ldi	r22, 0xD0	; 208
    7f8a:	77 e0       	ldi	r23, 0x07	; 7
    7f8c:	80 e0       	ldi	r24, 0x00	; 0
    7f8e:	90 e0       	ldi	r25, 0x00	; 0
    7f90:	0e 94 98 02 	call	0x530	; 0x530 <delay>
atcab_init():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:135
    7f94:	8e e0       	ldi	r24, 0x0E	; 14
    7f96:	90 e4       	ldi	r25, 0x40	; 64
    7f98:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <atcab_init_ext.constprop.49>
iotc_ecc608_init_provision():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:245
ATCA_STATUS iotc_ecc608_init_provision(void) {
    ATCA_STATUS atca_status;

    // TODO: for some reason ECC608.begin() fails, which is better, sems to fail here
    atca_status = atcab_init(&cfg_atecc608b_i2c);
    if (atca_status != ATCA_SUCCESS) {
    7f9c:	0f 90       	pop	r0
    7f9e:	0f 90       	pop	r0
    7fa0:	0f 90       	pop	r0
    7fa2:	0f 90       	pop	r0
    7fa4:	0f 90       	pop	r0
    7fa6:	0f 90       	pop	r0
    7fa8:	89 2b       	or	r24, r25
    7faa:	69 f0       	breq	.+26     	; 0x7fc6 <main+0x280>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:246
        Log.error("Failed to initialize ECC608!");
    7fac:	8a ec       	ldi	r24, 0xCA	; 202
    7fae:	93 e5       	ldi	r25, 0x53	; 83
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:251
        return atca_status;
    }
    atca_status = load_ecc608_cache();
    if (atca_status != ATCA_SUCCESS) {
        Log.error("failed to load ecc608 cache!");
    7fb0:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:207
  // memory_test();
  // reserve_stack_with_heap_leak(); // we may need to do this early to prevent corruption
  // memory_test();

  if (ATCA_SUCCESS != iotc_ecc608_init_provision()) {
    Log.error("Failed to read provisioning data!");
    7fb4:	84 e9       	ldi	r24, 0x94	; 148
    7fb6:	91 e6       	ldi	r25, 0x61	; 97
    7fb8:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:208
    delay(10000);
    7fbc:	60 e1       	ldi	r22, 0x10	; 16
    7fbe:	77 e2       	ldi	r23, 0x27	; 39
    7fc0:	80 e0       	ldi	r24, 0x00	; 0
    7fc2:	90 e0       	ldi	r25, 0x00	; 0
    7fc4:	2c c2       	rjmp	.+1112   	; 0x841e <__RODATA_PM_OFFSET__+0x41e>
load_ecc608_cache():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:166

static ATCA_STATUS load_ecc608_cache(void) {
    ATCA_STATUS atca_status;
    size_t slot_size;
    // Determine slot size
    atca_status = atcab_get_zone_size(
    7fc6:	80 91 8a 66 	lds	r24, 0x668A	; 0x80668a <_gDevice>
    7fca:	90 91 8b 66 	lds	r25, 0x668B	; 0x80668b <_gDevice+0x1>
calib_get_zone_size():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_basic.c:296
 */
ATCA_STATUS calib_get_zone_size(ATCADevice device, uint8_t zone, uint16_t slot, size_t* size)
{
    ATCA_STATUS status = ATCA_SUCCESS;

    if ((device == NULL) || (size == NULL))
    7fce:	00 97       	sbiw	r24, 0x00	; 0
    7fd0:	a1 f4       	brne	.+40     	; 0x7ffa <main+0x2b4>
load_ecc608_cache():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:172
        ATCA_ZONE_DATA,
        DATA_SLOT_NUM,
        &slot_size
    );
    if (ATCA_SUCCESS != atca_status)  {
        Log.errorf("IOTC_ECC608: Unable to read zone size: %d\r\n", atca_status);
    7fd2:	1f 92       	push	r1
    7fd4:	82 ee       	ldi	r24, 0xE2	; 226
    7fd6:	8f 93       	push	r24
    7fd8:	87 ee       	ldi	r24, 0xE7	; 231
    7fda:	93 e5       	ldi	r25, 0x53	; 83
    7fdc:	9f 93       	push	r25
    7fde:	8f 93       	push	r24
    7fe0:	1f 93       	push	r17
    7fe2:	0f 93       	push	r16
    7fe4:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    7fe8:	0f 90       	pop	r0
    7fea:	0f 90       	pop	r0
    7fec:	0f 90       	pop	r0
    7fee:	0f 90       	pop	r0
    7ff0:	0f 90       	pop	r0
    7ff2:	0f 90       	pop	r0
iotc_ecc608_init_provision():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:251
        Log.error("Failed to initialize ECC608!");
        return atca_status;
    }
    atca_status = load_ecc608_cache();
    if (atca_status != ATCA_SUCCESS) {
        Log.error("failed to load ecc608 cache!");
    7ff4:	87 e7       	ldi	r24, 0x77	; 119
    7ff6:	91 e6       	ldi	r25, 0x61	; 97
    7ff8:	db cf       	rjmp	.-74     	; 0x7fb0 <main+0x26a>
calib_read_bytes_zone_ext():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib\calib/calib_read.c:1086
    }
    else
#endif
    {
#if CALIB_READ_EN
        status = calib_read_bytes_zone(device, zone, slot, offset, data, length);
    7ffa:	20 ea       	ldi	r18, 0xA0	; 160
    7ffc:	e2 2e       	mov	r14, r18
    7ffe:	ff 24       	eor	r15, r15
    8000:	f3 94       	inc	r15
    8002:	04 e5       	ldi	r16, 0x54	; 84
    8004:	14 e6       	ldi	r17, 0x64	; 100
    8006:	30 e0       	ldi	r19, 0x00	; 0
    8008:	20 e0       	ldi	r18, 0x00	; 0
    800a:	48 e0       	ldi	r20, 0x08	; 8
    800c:	50 e0       	ldi	r21, 0x00	; 0
    800e:	62 e0       	ldi	r22, 0x02	; 2
    8010:	0e 94 45 15 	call	0x2a8a	; 0x2a8a <calib_read_bytes_zone>
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:193
        Log.error("IOTC_ECC608: Failed to read provisioning info!");
        return atca_status;
    }

    bool has_iotconnect_data = false;
    DataHeaderUnion* h = ecchdr_next(NULL);
    8014:	04 e5       	ldi	r16, 0x54	; 84
    8016:	14 e6       	ldi	r17, 0x64	; 100
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:192
    if (ATCA_SUCCESS != atca_status) {
        Log.error("IOTC_ECC608: Failed to read provisioning info!");
        return atca_status;
    }

    bool has_iotconnect_data = false;
    8018:	f1 2c       	mov	r15, r1
load_ecc608_cache():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:187
        DATA_SLOT_NUM,
        0,
        (uint8_t*) data_cache,
        slot_size
    );
    if (ATCA_SUCCESS != atca_status) {
    801a:	89 2b       	or	r24, r25
    801c:	39 f0       	breq	.+14     	; 0x802c <__RODATA_PM_OFFSET__+0x2c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:188
        Log.error("IOTC_ECC608: Failed to read provisioning info!");
    801e:	83 e1       	ldi	r24, 0x13	; 19
    8020:	94 e5       	ldi	r25, 0x54	; 84
    8022:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    8026:	e6 cf       	rjmp	.-52     	; 0x7ff4 <main+0x2ae>
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:79
    return (h->header.next - this_header_offset - sizeof(DataHeaderUnion));
}

static DataHeaderUnion* ecchdr_next(DataHeaderUnion* h) {
    if (!h) {
        return (DataHeaderUnion*) data_cache;
    8028:	04 e5       	ldi	r16, 0x54	; 84
    802a:	14 e6       	ldi	r17, 0x64	; 100
load_ecc608_cache():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:194
        return atca_status;
    }

    bool has_iotconnect_data = false;
    DataHeaderUnion* h = ecchdr_next(NULL);
    while(h->header.type != EMPTY) {
    802c:	d8 01       	movw	r26, r16
    802e:	11 96       	adiw	r26, 0x01	; 1
    8030:	2c 91       	ld	r18, X
    8032:	11 97       	sbiw	r26, 0x01	; 1
    8034:	82 2f       	mov	r24, r18
    8036:	8e 7f       	andi	r24, 0xFE	; 254
    8038:	81 f1       	breq	.+96     	; 0x809a <__RODATA_PM_OFFSET__+0x9a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:195
        if (h->header.type == IOTC_ECC608_PROV_VER) {
    803a:	80 31       	cpi	r24, 0x10	; 16
    803c:	c9 f4       	brne	.+50     	; 0x8070 <__RODATA_PM_OFFSET__+0x70>
ecchdr_get_data_size():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:74
static char data_cache[IOTC_DATA_SLOT_SIZE];


static size_t ecchdr_get_data_size(DataHeaderUnion* h) {
    uint16_t this_header_offset = (char*) h - data_cache;
    return (h->header.next - this_header_offset - sizeof(DataHeaderUnion));
    803e:	8c 91       	ld	r24, X
    8040:	92 2f       	mov	r25, r18
    8042:	91 70       	andi	r25, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:73
// NOTE: Not indexed by type. Just an array one per type indexed by the order it is ecountered in the ECC608.
static char data_cache[IOTC_DATA_SLOT_SIZE];


static size_t ecchdr_get_data_size(DataHeaderUnion* h) {
    uint16_t this_header_offset = (char*) h - data_cache;
    8044:	98 01       	movw	r18, r16
    8046:	24 55       	subi	r18, 0x54	; 84
    8048:	34 46       	sbci	r19, 0x64	; 100
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:74
    return (h->header.next - this_header_offset - sizeof(DataHeaderUnion));
    804a:	82 1b       	sub	r24, r18
    804c:	93 0b       	sbc	r25, r19
load_ecc608_cache():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:197
    bool has_iotconnect_data = false;
    DataHeaderUnion* h = ecchdr_next(NULL);
    while(h->header.type != EMPTY) {
        if (h->header.type == IOTC_ECC608_PROV_VER) {
            if (ecchdr_get_data_size(h) != sizeof(IOTC_ECC608_PROV_DATA_VERSION)
                || 0 != strcmp(IOTC_ECC608_PROV_DATA_VERSION, ecchdr_data_ptr(h))
    804e:	07 97       	sbiw	r24, 0x07	; 7
    8050:	49 f4       	brne	.+18     	; 0x8064 <__RODATA_PM_OFFSET__+0x64>
ecchdr_data_ptr():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:85
    }
    return (DataHeaderUnion*) &data_cache[h->header.next];
}

static char* ecchdr_data_ptr(DataHeaderUnion* h) {
    return ((char*)h) + sizeof(DataHeaderUnion);
    8052:	b8 01       	movw	r22, r16
    8054:	6e 5f       	subi	r22, 0xFE	; 254
    8056:	7f 4f       	sbci	r23, 0xFF	; 255
load_ecc608_cache():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:197
    bool has_iotconnect_data = false;
    DataHeaderUnion* h = ecchdr_next(NULL);
    while(h->header.type != EMPTY) {
        if (h->header.type == IOTC_ECC608_PROV_VER) {
            if (ecchdr_get_data_size(h) != sizeof(IOTC_ECC608_PROV_DATA_VERSION)
                || 0 != strcmp(IOTC_ECC608_PROV_DATA_VERSION, ecchdr_data_ptr(h))
    8058:	82 e4       	ldi	r24, 0x42	; 66
    805a:	94 e5       	ldi	r25, 0x54	; 84
    805c:	0e 94 f4 56 	call	0xade8	; 0xade8 <strcmp>
    8060:	89 2b       	or	r24, r25
    8062:	21 f0       	breq	.+8      	; 0x806c <__RODATA_PM_OFFSET__+0x6c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:199
            ) {
                Log.error("IOTC_ECC608: Unexpected iotconnect data version!");
    8064:	87 e4       	ldi	r24, 0x47	; 71
    8066:	94 e5       	ldi	r25, 0x54	; 84
    8068:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:201
            }
            has_iotconnect_data = true; // all or nothing
    806c:	ff 24       	eor	r15, r15
    806e:	f3 94       	inc	r15
ecchdr_next():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:78
    uint16_t this_header_offset = (char*) h - data_cache;
    return (h->header.next - this_header_offset - sizeof(DataHeaderUnion));
}

static DataHeaderUnion* ecchdr_next(DataHeaderUnion* h) {
    if (!h) {
    8070:	01 15       	cp	r16, r1
    8072:	11 05       	cpc	r17, r1
    8074:	c9 f2       	breq	.-78     	; 0x8028 <__RODATA_PM_OFFSET__+0x28>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:81
        return (DataHeaderUnion*) data_cache;
    }
    return (DataHeaderUnion*) &data_cache[h->header.next];
    8076:	f8 01       	movw	r30, r16
    8078:	80 81       	ld	r24, Z
    807a:	21 81       	ldd	r18, Z+1	; 0x01
    807c:	92 2f       	mov	r25, r18
    807e:	91 70       	andi	r25, 0x01	; 1
    8080:	8c 01       	movw	r16, r24
    8082:	0c 5a       	subi	r16, 0xAC	; 172
    8084:	1b 49       	sbci	r17, 0x9B	; 155
load_ecc608_cache():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:204
                Log.error("IOTC_ECC608: Unexpected iotconnect data version!");
            }
            has_iotconnect_data = true; // all or nothing
        }
        h = ecchdr_next(h);
        if ((char*)h > &data_cache[IOTC_DATA_SLOT_SIZE]) {
    8086:	f5 e6       	ldi	r31, 0x65	; 101
    8088:	04 3f       	cpi	r16, 0xF4	; 244
    808a:	1f 07       	cpc	r17, r31
    808c:	79 f2       	breq	.-98     	; 0x802c <__RODATA_PM_OFFSET__+0x2c>
    808e:	70 f2       	brcs	.-100    	; 0x802c <__RODATA_PM_OFFSET__+0x2c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:205
            Log.error("IOTC_ECC608: Could not find empty provisioning data header!"); // ran off past the end of data
    8090:	88 e7       	ldi	r24, 0x78	; 120
    8092:	94 e5       	ldi	r25, 0x54	; 84
    8094:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    8098:	c9 cf       	rjmp	.-110    	; 0x802c <__RODATA_PM_OFFSET__+0x2c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:208
        }
    }
    if (!has_iotconnect_data) {
    809a:	f1 10       	cpse	r15, r1
    809c:	3b c0       	rjmp	.+118    	; 0x8114 <__RODATA_PM_OFFSET__+0x114>
append_iotconnect_blank_records():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:98
    return ecchdr_next(h);
}

// DO NOT call this function if we already have any of these fields
static void append_iotconnect_blank_records(DataHeaderUnion* start) {
    start = append_iotconnect_blank_record(start, IOTC_ECC608_PROV_VER,  IOTC_ECC608_PROV_VER_SIZE);
    809e:	45 e0       	ldi	r20, 0x05	; 5
    80a0:	50 e0       	ldi	r21, 0x00	; 0
    80a2:	68 e0       	ldi	r22, 0x08	; 8
    80a4:	70 e0       	ldi	r23, 0x00	; 0
    80a6:	c8 01       	movw	r24, r16
    80a8:	0e 94 8a 10 	call	0x2114	; 0x2114 <append_iotconnect_blank_record(DataHeaderUnion*, unsigned int, unsigned int)>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:99
    start = append_iotconnect_blank_record(start, IOTC_ECC608_PROV_CPID, IOTC_ECC608_PROV_CPID_SIZE);
    80ac:	42 e4       	ldi	r20, 0x42	; 66
    80ae:	50 e0       	ldi	r21, 0x00	; 0
    80b0:	66 e0       	ldi	r22, 0x06	; 6
    80b2:	70 e0       	ldi	r23, 0x00	; 0
    80b4:	0e 94 8a 10 	call	0x2114	; 0x2114 <append_iotconnect_blank_record(DataHeaderUnion*, unsigned int, unsigned int)>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:100
    start = append_iotconnect_blank_record(start, IOTC_ECC608_PROV_DUID, IOTC_ECC608_PROV_DUID_SIZE);
    80b8:	42 e4       	ldi	r20, 0x42	; 66
    80ba:	50 e0       	ldi	r21, 0x00	; 0
    80bc:	69 e0       	ldi	r22, 0x09	; 9
    80be:	70 e0       	ldi	r23, 0x00	; 0
    80c0:	0e 94 8a 10 	call	0x2114	; 0x2114 <append_iotconnect_blank_record(DataHeaderUnion*, unsigned int, unsigned int)>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:101
    start = append_iotconnect_blank_record(start, IOTC_ECC608_PROV_ENV,  IOTC_ECC608_PROV_ENV_SIZE);
    80c4:	44 e1       	ldi	r20, 0x14	; 20
    80c6:	50 e0       	ldi	r21, 0x00	; 0
    80c8:	67 e0       	ldi	r22, 0x07	; 7
    80ca:	70 e0       	ldi	r23, 0x00	; 0
    80cc:	0e 94 8a 10 	call	0x2114	; 0x2114 <append_iotconnect_blank_record(DataHeaderUnion*, unsigned int, unsigned int)>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:103
    start->header.type = EMPTY;
    start->header.next = 0;
    80d0:	dc 01       	movw	r26, r24
    80d2:	1c 92       	st	X, r1
    80d4:	11 96       	adiw	r26, 0x01	; 1
    80d6:	1c 92       	st	X, r1
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:130
            return ATCA_BAD_PARAM;
    }
}

static ATCA_STATUS iotc_ecc608_set_string_value_internal(ecc_data_types data_type, const char * value) {
    DataHeaderUnion* h = (DataHeaderUnion *) data_cache;
    80d8:	e4 e5       	ldi	r30, 0x54	; 84
    80da:	f4 e6       	ldi	r31, 0x64	; 100
iotc_ecc608_set_string_value_internal():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:131
    while(h->header.type != EMPTY) {
    80dc:	81 81       	ldd	r24, Z+1	; 0x01
    80de:	98 2f       	mov	r25, r24
    80e0:	9e 7f       	andi	r25, 0xFE	; 254
    80e2:	09 f4       	brne	.+2      	; 0x80e6 <__RODATA_PM_OFFSET__+0xe6>
    80e4:	80 c0       	rjmp	.+256    	; 0x81e6 <__RODATA_PM_OFFSET__+0x1e6>
    80e6:	20 81       	ld	r18, Z
    80e8:	38 2f       	mov	r19, r24
    80ea:	31 70       	andi	r19, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:132
        if (h->header.type == data_type) {
    80ec:	86 95       	lsr	r24
    80ee:	88 30       	cpi	r24, 0x08	; 8
    80f0:	09 f0       	breq	.+2      	; 0x80f4 <__RODATA_PM_OFFSET__+0xf4>
    80f2:	75 c0       	rjmp	.+234    	; 0x81de <__RODATA_PM_OFFSET__+0x1de>
ecchdr_get_data_size():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:73
// NOTE: Not indexed by type. Just an array one per type indexed by the order it is ecountered in the ECC608.
static char data_cache[IOTC_DATA_SLOT_SIZE];


static size_t ecchdr_get_data_size(DataHeaderUnion* h) {
    uint16_t this_header_offset = (char*) h - data_cache;
    80f4:	2e 1b       	sub	r18, r30
    80f6:	3f 0b       	sbc	r19, r31
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:74
    return (h->header.next - this_header_offset - sizeof(DataHeaderUnion));
    80f8:	2e 5a       	subi	r18, 0xAE	; 174
    80fa:	3b 49       	sbci	r19, 0x9B	; 155
iotc_ecc608_set_string_value_internal():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:141
                case IOTC_ECC608_PROV_ENV:
                case IOTC_ECC608_PROV_CPID:
                case IOTC_ECC608_PROV_DUID:
                    // iotconnect data re null terminated strings
                    if ((strlen(value) + 1) > size) {
                        Log.error("IOTC_ECC608: String size is larger than reserved size!");
    80fc:	84 eb       	ldi	r24, 0xB4	; 180
    80fe:	94 e5       	ldi	r25, 0x54	; 84
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:140
                case IOTC_ECC608_PROV_VER:
                case IOTC_ECC608_PROV_ENV:
                case IOTC_ECC608_PROV_CPID:
                case IOTC_ECC608_PROV_DUID:
                    // iotconnect data re null terminated strings
                    if ((strlen(value) + 1) > size) {
    8100:	25 30       	cpi	r18, 0x05	; 5
    8102:	31 05       	cpc	r19, r1
    8104:	08 f4       	brcc	.+2      	; 0x8108 <__RODATA_PM_OFFSET__+0x108>
    8106:	71 c0       	rjmp	.+226    	; 0x81ea <__RODATA_PM_OFFSET__+0x1ea>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:144
                        Log.error("IOTC_ECC608: String size is larger than reserved size!");
                        return ATCA_INVALID_LENGTH;
                    }
                    strcpy(ecchdr_data_ptr(h), value);
    8108:	62 e4       	ldi	r22, 0x42	; 66
    810a:	74 e5       	ldi	r23, 0x54	; 84
    810c:	cf 01       	movw	r24, r30
    810e:	02 96       	adiw	r24, 0x02	; 2
    8110:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
iotconnect_sdk_init_and_get_config():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:195
bool iotconnect_sdk_is_connected(void) {
    return iotc_mqtt_client_is_connected();
}

IotConnectClientConfig *iotconnect_sdk_init_and_get_config() {
    memset(&config, 0, sizeof(config));
    8114:	e4 ef       	ldi	r30, 0xF4	; 244
    8116:	f5 e6       	ldi	r31, 0x65	; 101
    8118:	8e e0       	ldi	r24, 0x0E	; 14
    811a:	df 01       	movw	r26, r30
    811c:	1d 92       	st	X+, r1
    811e:	8a 95       	dec	r24
    8120:	e9 f7       	brne	.-6      	; 0x811c <__RODATA_PM_OFFSET__+0x11c>
iotc_ecc608_get_string_value():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:262
ATCA_STATUS iotc_ecc608_get_string_value(ecc_data_types data_type, char ** value) {
    if (data_type == IOTC_ECC608_PROV_VER) {
        *value = NULL;
        Log.warn("IOTC_ECC608: Warning: User code should not be reading IOTC_ECC608_PROV_VER");
    }
    return iotc_ecc608_get_string_value_internal(data_type, value);
    8122:	66 ef       	ldi	r22, 0xF6	; 246
    8124:	75 e6       	ldi	r23, 0x65	; 101
    8126:	86 e0       	ldi	r24, 0x06	; 6
    8128:	90 e0       	ldi	r25, 0x00	; 0
    812a:	0e 94 65 0a 	call	0x14ca	; 0x14ca <iotc_ecc608_get_string_value_internal(ecc_data_types, char**)>
load_provisioned_data():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:143
        return true;
    }
}

static bool load_provisioned_data(IotConnectClientConfig *config) {
  if (ATCA_SUCCESS != iotc_ecc608_get_string_value(IOTC_ECC608_PROV_CPID, &(config->cpid))) {
    812e:	89 2b       	or	r24, r25
    8130:	09 f0       	breq	.+2      	; 0x8134 <__RODATA_PM_OFFSET__+0x134>
    8132:	5e c0       	rjmp	.+188    	; 0x81f0 <__RODATA_PM_OFFSET__+0x1f0>
iotc_ecc608_get_string_value():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:262
    8134:	64 ef       	ldi	r22, 0xF4	; 244
    8136:	75 e6       	ldi	r23, 0x65	; 101
    8138:	87 e0       	ldi	r24, 0x07	; 7
    813a:	90 e0       	ldi	r25, 0x00	; 0
    813c:	0e 94 65 0a 	call	0x14ca	; 0x14ca <iotc_ecc608_get_string_value_internal(ecc_data_types, char**)>
load_provisioned_data():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:146
    return false; // caller will print the error
  }
  if (ATCA_SUCCESS != iotc_ecc608_get_string_value(IOTC_ECC608_PROV_ENV, &(config->env))) {
    8140:	89 2b       	or	r24, r25
    8142:	09 f0       	breq	.+2      	; 0x8146 <__RODATA_PM_OFFSET__+0x146>
    8144:	55 c0       	rjmp	.+170    	; 0x81f0 <__RODATA_PM_OFFSET__+0x1f0>
iotc_ecc608_get_string_value():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:262
    8146:	68 ef       	ldi	r22, 0xF8	; 248
    8148:	75 e6       	ldi	r23, 0x65	; 101
    814a:	89 e0       	ldi	r24, 0x09	; 9
    814c:	90 e0       	ldi	r25, 0x00	; 0
    814e:	0e 94 65 0a 	call	0x14ca	; 0x14ca <iotc_ecc608_get_string_value_internal(ecc_data_types, char**)>
load_provisioned_data():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:149
    return false; // caller will print the error
  }
  if (ATCA_SUCCESS != iotc_ecc608_get_string_value(IOTC_ECC608_PROV_DUID, &(config->duid))) {
    8152:	89 2b       	or	r24, r25
    8154:	09 f0       	breq	.+2      	; 0x8158 <__RODATA_PM_OFFSET__+0x158>
    8156:	4c c0       	rjmp	.+152    	; 0x81f0 <__RODATA_PM_OFFSET__+0x1f0>
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:214
    return; // caller will print the error
  }

  IotConnectClientConfig *config = iotconnect_sdk_init_and_get_config();
  if (!load_provisioned_data(config)
    || !config->cpid || 0 == strlen(config->cpid)
    8158:	00 91 f6 65 	lds	r16, 0x65F6	; 0x8065f6 <config+0x2>
    815c:	10 91 f7 65 	lds	r17, 0x65F7	; 0x8065f7 <config+0x3>
    8160:	01 15       	cp	r16, r1
    8162:	11 05       	cpc	r17, r1
    8164:	09 f4       	brne	.+2      	; 0x8168 <__RODATA_PM_OFFSET__+0x168>
    8166:	44 c0       	rjmp	.+136    	; 0x81f0 <__RODATA_PM_OFFSET__+0x1f0>
    8168:	f8 01       	movw	r30, r16
    816a:	80 81       	ld	r24, Z
    816c:	88 23       	and	r24, r24
    816e:	09 f4       	brne	.+2      	; 0x8172 <__RODATA_PM_OFFSET__+0x172>
    8170:	3f c0       	rjmp	.+126    	; 0x81f0 <__RODATA_PM_OFFSET__+0x1f0>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:215
    || !config->env || 0 == strlen(config->env)
    8172:	e0 91 f4 65 	lds	r30, 0x65F4	; 0x8065f4 <config>
    8176:	f0 91 f5 65 	lds	r31, 0x65F5	; 0x8065f5 <config+0x1>
    817a:	30 97       	sbiw	r30, 0x00	; 0
    817c:	c9 f1       	breq	.+114    	; 0x81f0 <__RODATA_PM_OFFSET__+0x1f0>
    817e:	80 81       	ld	r24, Z
    8180:	88 23       	and	r24, r24
    8182:	b1 f1       	breq	.+108    	; 0x81f0 <__RODATA_PM_OFFSET__+0x1f0>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:221
  ) {
      Log.error("Invalid provisioning data. Please run the avr-iot-provision sketch.");
      return;
  }

  if (!config->duid || 0 == strlen(config->duid)) {
    8184:	e0 91 f8 65 	lds	r30, 0x65F8	; 0x8065f8 <config+0x4>
    8188:	f0 91 f9 65 	lds	r31, 0x65F9	; 0x8065f9 <config+0x5>
    818c:	30 97       	sbiw	r30, 0x00	; 0
    818e:	a9 f5       	brne	.+106    	; 0x81fa <__RODATA_PM_OFFSET__+0x1fa>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:222
    strcpy(aws_id_buff, GENERATED_ID_PREFIX);
    8190:	6b e7       	ldi	r22, 0x7B	; 123
    8192:	75 e5       	ldi	r23, 0x55	; 85
    8194:	83 e0       	ldi	r24, 0x03	; 3
    8196:	96 e6       	ldi	r25, 0x66	; 102
    8198:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
iotc_ecc608_copy_string_value():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:268
}

// size is in/out: in=max / out=actual
ATCA_STATUS iotc_ecc608_copy_string_value(ecc_data_types data_type, char *buffer, size_t buffer_size) {
    DataHeaderUnion* h = (DataHeaderUnion *) data_cache;
    buffer[0] = 0;
    819c:	10 92 07 66 	sts	0x6607, r1	; 0x806607 <aws_id_buff+0x4>
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:267
    return iotc_ecc608_get_string_value_internal(data_type, value);
}

// size is in/out: in=max / out=actual
ATCA_STATUS iotc_ecc608_copy_string_value(ecc_data_types data_type, char *buffer, size_t buffer_size) {
    DataHeaderUnion* h = (DataHeaderUnion *) data_cache;
    81a0:	e4 e5       	ldi	r30, 0x54	; 84
    81a2:	f4 e6       	ldi	r31, 0x64	; 100
iotc_ecc608_copy_string_value():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:269
    buffer[0] = 0;
    while(h->header.type != EMPTY) {
    81a4:	21 81       	ldd	r18, Z+1	; 0x01
    81a6:	82 2f       	mov	r24, r18
    81a8:	8e 7f       	andi	r24, 0xFE	; 254
    81aa:	09 f4       	brne	.+2      	; 0x81ae <__RODATA_PM_OFFSET__+0x1ae>
    81ac:	34 c1       	rjmp	.+616    	; 0x8416 <__RODATA_PM_OFFSET__+0x416>
    81ae:	80 81       	ld	r24, Z
    81b0:	92 2f       	mov	r25, r18
    81b2:	91 70       	andi	r25, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:270
        if (h->header.type == data_type) {
    81b4:	26 95       	lsr	r18
    81b6:	21 30       	cpi	r18, 0x01	; 1
    81b8:	09 f0       	breq	.+2      	; 0x81bc <__RODATA_PM_OFFSET__+0x1bc>
    81ba:	fc c0       	rjmp	.+504    	; 0x83b4 <__RODATA_PM_OFFSET__+0x3b4>
ecchdr_get_data_size():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:73
// NOTE: Not indexed by type. Just an array one per type indexed by the order it is ecountered in the ECC608.
static char data_cache[IOTC_DATA_SLOT_SIZE];


static size_t ecchdr_get_data_size(DataHeaderUnion* h) {
    uint16_t this_header_offset = (char*) h - data_cache;
    81bc:	9f 01       	movw	r18, r30
    81be:	24 55       	subi	r18, 0x54	; 84
    81c0:	34 46       	sbci	r19, 0x64	; 100
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:74
    return (h->header.next - this_header_offset - sizeof(DataHeaderUnion));
    81c2:	82 1b       	sub	r24, r18
    81c4:	93 0b       	sbc	r25, r19
    81c6:	7c 01       	movw	r14, r24
    81c8:	22 e0       	ldi	r18, 0x02	; 2
    81ca:	e2 1a       	sub	r14, r18
    81cc:	f1 08       	sbc	r15, r1
iotc_ecc608_copy_string_value():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:290
                    }
                    strcpy(buffer, value);
                    break;

                default:
                    if(buffer_size < (ecchdr_get_data_size(h) + 1)) {
    81ce:	01 97       	sbiw	r24, 0x01	; 1
    81d0:	8f 37       	cpi	r24, 0x7F	; 127
    81d2:	91 05       	cpc	r25, r1
    81d4:	08 f4       	brcc	.+2      	; 0x81d8 <__RODATA_PM_OFFSET__+0x1d8>
    81d6:	d9 c0       	rjmp	.+434    	; 0x838a <__RODATA_PM_OFFSET__+0x38a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:291
                        Log.error("IOTC_ECC608: No room to copy the full value");
    81d8:	80 e8       	ldi	r24, 0x80	; 128
    81da:	95 e5       	ldi	r25, 0x55	; 85
    81dc:	0b c0       	rjmp	.+22     	; 0x81f4 <__RODATA_PM_OFFSET__+0x1f4>
ecchdr_next():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:81

static DataHeaderUnion* ecchdr_next(DataHeaderUnion* h) {
    if (!h) {
        return (DataHeaderUnion*) data_cache;
    }
    return (DataHeaderUnion*) &data_cache[h->header.next];
    81de:	f9 01       	movw	r30, r18
    81e0:	ec 5a       	subi	r30, 0xAC	; 172
    81e2:	fb 49       	sbci	r31, 0x9B	; 155
    81e4:	7b cf       	rjmp	.-266    	; 0x80dc <__RODATA_PM_OFFSET__+0xdc>
iotc_ecc608_set_string_value_internal():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:158
            }
            return ATCA_SUCCESS;
        }
        h = ecchdr_next(h);
    }
    Log.error("IOTC_ECC608: Data type %d was not found in storage. Unable to write value.!");
    81e6:	8b ee       	ldi	r24, 0xEB	; 235
    81e8:	94 e5       	ldi	r25, 0x54	; 84
    81ea:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    81ee:	92 cf       	rjmp	.-220    	; 0x8114 <__RODATA_PM_OFFSET__+0x114>
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:217
  IotConnectClientConfig *config = iotconnect_sdk_init_and_get_config();
  if (!load_provisioned_data(config)
    || !config->cpid || 0 == strlen(config->cpid)
    || !config->env || 0 == strlen(config->env)
  ) {
      Log.error("Invalid provisioning data. Please run the avr-iot-provision sketch.");
    81f0:	87 e3       	ldi	r24, 0x37	; 55
    81f2:	95 e5       	ldi	r25, 0x55	; 85
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:262
        iotconnect_sdk_loop();
        delay(100);
      }
    }
  } else {
    Log.error("Encountered an error while initializing the SDK!");
    81f4:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
    81f8:	0e c1       	rjmp	.+540    	; 0x8416 <__RODATA_PM_OFFSET__+0x416>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:221
  ) {
      Log.error("Invalid provisioning data. Please run the avr-iot-provision sketch.");
      return;
  }

  if (!config->duid || 0 == strlen(config->duid)) {
    81fa:	80 81       	ld	r24, Z
    81fc:	88 23       	and	r24, r24
    81fe:	41 f2       	breq	.-112    	; 0x8190 <__RODATA_PM_OFFSET__+0x190>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:234
    aws_id_buff[DUID_WEB_UI_MAX_LEN] = 0;

    config->duid = aws_id_buff;
  }

  Log.infof("CPID: %s\r\n", config->cpid);
    8200:	1f 93       	push	r17
    8202:	0f 93       	push	r16
    8204:	8c ea       	ldi	r24, 0xAC	; 172
    8206:	95 e5       	ldi	r25, 0x55	; 85
    8208:	9f 93       	push	r25
    820a:	8f 93       	push	r24
    820c:	09 e6       	ldi	r16, 0x69	; 105
    820e:	10 e7       	ldi	r17, 0x70	; 112
    8210:	1f 93       	push	r17
    8212:	0f 93       	push	r16
    8214:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:235
  Log.infof("ENV : %s\r\n", config->env);
    8218:	80 91 f5 65 	lds	r24, 0x65F5	; 0x8065f5 <config+0x1>
    821c:	8f 93       	push	r24
    821e:	80 91 f4 65 	lds	r24, 0x65F4	; 0x8065f4 <config>
    8222:	8f 93       	push	r24
    8224:	87 eb       	ldi	r24, 0xB7	; 183
    8226:	95 e5       	ldi	r25, 0x55	; 85
    8228:	9f 93       	push	r25
    822a:	8f 93       	push	r24
    822c:	1f 93       	push	r17
    822e:	0f 93       	push	r16
    8230:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:236
  Log.infof("DUID: %s\r\n", config->duid);
    8234:	80 91 f9 65 	lds	r24, 0x65F9	; 0x8065f9 <config+0x5>
    8238:	8f 93       	push	r24
    823a:	80 91 f8 65 	lds	r24, 0x65F8	; 0x8065f8 <config+0x4>
    823e:	8f 93       	push	r24
    8240:	82 ec       	ldi	r24, 0xC2	; 194
    8242:	95 e5       	ldi	r25, 0x55	; 85
    8244:	9f 93       	push	r25
    8246:	8f 93       	push	r24
    8248:	1f 93       	push	r17
    824a:	0f 93       	push	r16
    824c:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
__base_ctor ():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:5
#include "timeout_timer.h"

#include <Arduino.h>

TimeoutTimer::TimeoutTimer(const uint32_t ms) : interval_ms(ms) {
    8250:	2e 01       	movw	r4, r28
    8252:	34 ef       	ldi	r19, 0xF4	; 244
    8254:	43 1a       	sub	r4, r19
    8256:	3e ef       	ldi	r19, 0xFE	; 254
    8258:	53 0a       	sbc	r5, r19
    825a:	80 ec       	ldi	r24, 0xC0	; 192
    825c:	97 e2       	ldi	r25, 0x27	; 39
    825e:	a9 e0       	ldi	r26, 0x09	; 9
    8260:	b0 e0       	ldi	r27, 0x00	; 0
    8262:	f2 01       	movw	r30, r4
    8264:	80 83       	st	Z, r24
    8266:	91 83       	std	Z+1, r25	; 0x01
    8268:	a2 83       	std	Z+2, r26	; 0x02
    826a:	b3 83       	std	Z+3, r27	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:6
    start_ms = millis();
    826c:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
    8270:	d2 01       	movw	r26, r4
    8272:	14 96       	adiw	r26, 0x04	; 4
    8274:	6d 93       	st	X+, r22
    8276:	7d 93       	st	X+, r23
    8278:	8d 93       	st	X+, r24
    827a:	9c 93       	st	X, r25
    827c:	17 97       	sbiw	r26, 0x07	; 7
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:109

    const TimeoutTimer timeout_timer(timeout_ms);

    // If low power is utilized, sequans controller will already been
    // initialized, so don't reset it by calling begin again
    if (!SequansController.isInitialized()) {
    827e:	ed b7       	in	r30, 0x3d	; 61
    8280:	fe b7       	in	r31, 0x3e	; 62
    8282:	72 96       	adiw	r30, 0x12	; 18
    8284:	ed bf       	out	0x3d, r30	; 61
    8286:	fe bf       	out	0x3e, r31	; 62
    8288:	80 91 91 66 	lds	r24, 0x6691	; 0x806691 <initialized>
    828c:	81 11       	cpse	r24, r1
    828e:	02 c0       	rjmp	.+4      	; 0x8294 <__RODATA_PM_OFFSET__+0x294>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:110
        SequansController.begin();
    8290:	0e 94 fd 27 	call	0x4ffa	; 0x4ffa <SequansControllerClass::begin() [clone .constprop.87]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:114
    }

    // Disconnect before configuration if already connected
    SequansController.writeCommand(AT_DISCONNECT);
    8294:	50 e0       	ldi	r21, 0x00	; 0
    8296:	40 e0       	ldi	r20, 0x00	; 0
    8298:	70 e0       	ldi	r23, 0x00	; 0
    829a:	60 e0       	ldi	r22, 0x00	; 0
    829c:	84 ef       	ldi	r24, 0xF4	; 244
    829e:	9f e4       	ldi	r25, 0x4F	; 79
    82a0:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
_delay_ms():
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:187
    82a4:	ff ef       	ldi	r31, 0xFF	; 255
    82a6:	22 e5       	ldi	r18, 0x52	; 82
    82a8:	37 e0       	ldi	r19, 0x07	; 7
    82aa:	f1 50       	subi	r31, 0x01	; 1
    82ac:	20 40       	sbci	r18, 0x00	; 0
    82ae:	30 40       	sbci	r19, 0x00	; 0
    82b0:	e1 f7       	brne	.-8      	; 0x82aa <__RODATA_PM_OFFSET__+0x2aa>
    82b2:	00 c0       	rjmp	.+0      	; 0x82b4 <__RODATA_PM_OFFSET__+0x2b4>
    82b4:	00 00       	nop
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:117

    _delay_ms(100);
    SequansController.clearReceiveBuffer();
    82b6:	0e 94 82 07 	call	0xf04	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:119

    SequansController.registerCallback(TIMEZONE_CALLBACK, timezoneCallback);
    82ba:	41 e0       	ldi	r20, 0x01	; 1
    82bc:	6a ec       	ldi	r22, 0xCA	; 202
    82be:	72 e0       	ldi	r23, 0x02	; 2
    82c0:	8f ee       	ldi	r24, 0xEF	; 239
    82c2:	9f e4       	ldi	r25, 0x4F	; 79
    82c4:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:121

    SequansController.writeCommand(AT_ENABLE_TIME_ZONE_UPDATE);
    82c8:	50 e0       	ldi	r21, 0x00	; 0
    82ca:	40 e0       	ldi	r20, 0x00	; 0
    82cc:	70 e0       	ldi	r23, 0x00	; 0
    82ce:	60 e0       	ldi	r22, 0x00	; 0
    82d0:	8d ec       	ldi	r24, 0xCD	; 205
    82d2:	95 e5       	ldi	r25, 0x55	; 85
    82d4:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:122
    SequansController.writeCommand(AT_ENABLE_TIME_ZONE_REPORTING);
    82d8:	50 e0       	ldi	r21, 0x00	; 0
    82da:	40 e0       	ldi	r20, 0x00	; 0
    82dc:	70 e0       	ldi	r23, 0x00	; 0
    82de:	60 e0       	ldi	r22, 0x00	; 0
    82e0:	87 ed       	ldi	r24, 0xD7	; 215
    82e2:	95 e5       	ldi	r25, 0x55	; 85
    82e4:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:123
    SequansController.writeCommand(AT_ENABLE_CEREG_URC);
    82e8:	50 e0       	ldi	r21, 0x00	; 0
    82ea:	40 e0       	ldi	r20, 0x00	; 0
    82ec:	70 e0       	ldi	r23, 0x00	; 0
    82ee:	60 e0       	ldi	r22, 0x00	; 0
    82f0:	81 ee       	ldi	r24, 0xE1	; 225
    82f2:	95 e5       	ldi	r25, 0x55	; 85
    82f4:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:124
    SequansController.writeCommand(AT_CONNECT);
    82f8:	50 e0       	ldi	r21, 0x00	; 0
    82fa:	40 e0       	ldi	r20, 0x00	; 0
    82fc:	70 e0       	ldi	r23, 0x00	; 0
    82fe:	60 e0       	ldi	r22, 0x00	; 0
    8300:	8c ee       	ldi	r24, 0xEC	; 236
    8302:	95 e5       	ldi	r25, 0x55	; 85
    8304:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:126

    char response_buffer[64] = "";
    8308:	fe 01       	movw	r30, r28
    830a:	e4 56       	subi	r30, 0x64	; 100
    830c:	ff 4f       	sbci	r31, 0xFF	; 255
    830e:	11 92       	st	Z+, r1
    8310:	11 92       	st	Z+, r1
    8312:	8e e3       	ldi	r24, 0x3E	; 62
    8314:	df 01       	movw	r26, r30
    8316:	1d 92       	st	X+, r1
    8318:	8a 95       	dec	r24
    831a:	e9 f7       	brne	.-6      	; 0x8316 <__RODATA_PM_OFFSET__+0x316>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:127
    char value_buffer[32]    = "";
    831c:	5e 01       	movw	r10, r28
    831e:	bc ed       	ldi	r27, 0xDC	; 220
    8320:	ab 0e       	add	r10, r27
    8322:	b1 1c       	adc	r11, r1
    8324:	f5 01       	movw	r30, r10
    8326:	11 92       	st	Z+, r1
    8328:	11 92       	st	Z+, r1
    832a:	8e e1       	ldi	r24, 0x1E	; 30
    832c:	df 01       	movw	r26, r30
    832e:	1d 92       	st	X+, r1
    8330:	8a 95       	dec	r24
    8332:	e9 f7       	brne	.-6      	; 0x832e <__RODATA_PM_OFFSET__+0x32e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:130

    // Wait for CEREG URC before checking SIM
    SequansController.waitForURC(CEREG_CALLBACK);
    8334:	00 e2       	ldi	r16, 0x20	; 32
    8336:	c0 2e       	mov	r12, r16
    8338:	8e e4       	ldi	r24, 0x4E	; 78
    833a:	d8 2e       	mov	r13, r24
    833c:	e1 2c       	mov	r14, r1
    833e:	f1 2c       	mov	r15, r1
    8340:	00 e0       	ldi	r16, 0x00	; 0
    8342:	10 e0       	ldi	r17, 0x00	; 0
    8344:	20 e0       	ldi	r18, 0x00	; 0
    8346:	30 e0       	ldi	r19, 0x00	; 0
    8348:	40 e8       	ldi	r20, 0x80	; 128
    834a:	51 e0       	ldi	r21, 0x01	; 1
    834c:	70 e0       	ldi	r23, 0x00	; 0
    834e:	60 e0       	ldi	r22, 0x00	; 0
    8350:	8e ef       	ldi	r24, 0xFE	; 254
    8352:	9f e4       	ldi	r25, 0x4F	; 79
    8354:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:131
    SequansController.registerCallback(CEREG_CALLBACK, connectionStatus, false);
    8358:	40 e0       	ldi	r20, 0x00	; 0
    835a:	6f e4       	ldi	r22, 0x4F	; 79
    835c:	77 e2       	ldi	r23, 0x27	; 39
    835e:	8e ef       	ldi	r24, 0xFE	; 254
    8360:	9f e4       	ldi	r25, 0x4F	; 79
    8362:	0e 94 b8 0d 	call	0x1b70	; 0x1b70 <SequansControllerClass::registerCallback(char const*, void (*)(char*), bool) [clone .constprop.122]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:135

    // We check that the SIM card is inserted and ready. Note that we can only
    // do this and get a meaningful response in CFUN=1 or CFUN=4.
    if (SequansController.writeCommand(AT_CHECK_SIM,
    8366:	40 e4       	ldi	r20, 0x40	; 64
    8368:	50 e0       	ldi	r21, 0x00	; 0
    836a:	be 01       	movw	r22, r28
    836c:	64 56       	subi	r22, 0x64	; 100
    836e:	7f 4f       	sbci	r23, 0xFF	; 255
    8370:	86 ef       	ldi	r24, 0xF6	; 246
    8372:	95 e5       	ldi	r25, 0x55	; 85
    8374:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    8378:	01 97       	sbiw	r24, 0x01	; 1
    837a:	01 f1       	breq	.+64     	; 0x83bc <__RODATA_PM_OFFSET__+0x3bc>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:139
                                       response_buffer,
                                       sizeof(response_buffer)) !=
        ResponseResult::OK) {
        Log.error("Checking SIM card failed, is it inserted?");
    837c:	8f ef       	ldi	r24, 0xFF	; 255
    837e:	95 e5       	ldi	r25, 0x55	; 85
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:209
    if (!SequansController.extractValueFromCommandResponse(
            response_buffer,
            0,
            value_buffer,
            sizeof(value_buffer))) {
        Log.error("Failed to retrieve time from modem");
    8380:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:252
                // NTP sync, so return if that is the case
                if (!isConnected()) {
                    Log.warn(
                        "Got disconnected from network whilst doing NTP sync");
                    SequansController.unregisterCallback(TIMEZONE_CALLBACK);
                    Lte.end();
    8384:	0e 94 bc 27 	call	0x4f78	; 0x4f78 <LteClass::end() [clone .constprop.95]>
    8388:	46 c0       	rjmp	.+140    	; 0x8416 <__RODATA_PM_OFFSET__+0x416>
ecchdr_data_ptr():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:85
    }
    return (DataHeaderUnion*) &data_cache[h->header.next];
}

static char* ecchdr_data_ptr(DataHeaderUnion* h) {
    return ((char*)h) + sizeof(DataHeaderUnion);
    838a:	bf 01       	movw	r22, r30
    838c:	6e 5f       	subi	r22, 0xFE	; 254
    838e:	7f 4f       	sbci	r23, 0xFF	; 255
iotc_ecc608_copy_string_value():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:295
                    if(buffer_size < (ecchdr_get_data_size(h) + 1)) {
                        Log.error("IOTC_ECC608: No room to copy the full value");
                        return ATCA_INVALID_SIZE;
                    }
                    size_t data_size = ecchdr_get_data_size(h);
                    memcpy(buffer, ecchdr_data_ptr(h), data_size);
    8390:	a7 01       	movw	r20, r14
    8392:	87 e0       	ldi	r24, 0x07	; 7
    8394:	96 e6       	ldi	r25, 0x66	; 102
    8396:	0e 94 ce 56 	call	0xad9c	; 0xad9c <memcpy>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:296
                    buffer[data_size] = 0;
    839a:	f7 01       	movw	r30, r14
    839c:	e9 5f       	subi	r30, 0xF9	; 249
    839e:	f9 49       	sbci	r31, 0x99	; 153
    83a0:	10 82       	st	Z, r1
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:229
    size_t buffer_size = AWS_ID_BUFF_SIZE - strlen(GENERATED_ID_PREFIX);
    if (ATCA_SUCCESS != iotc_ecc608_copy_string_value(AWS_THINGNAME, bufer_location, buffer_size)) {
      return; // caller will print the error
    }
    // terminate for max length
    aws_id_buff[DUID_WEB_UI_MAX_LEN] = 0;
    83a2:	10 92 22 66 	sts	0x6622, r1	; 0x806622 <aws_id_buff+0x1f>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:231

    config->duid = aws_id_buff;
    83a6:	83 e0       	ldi	r24, 0x03	; 3
    83a8:	96 e6       	ldi	r25, 0x66	; 102
    83aa:	80 93 f8 65 	sts	0x65F8, r24	; 0x8065f8 <config+0x4>
    83ae:	90 93 f9 65 	sts	0x65F9, r25	; 0x8065f9 <config+0x5>
    83b2:	26 cf       	rjmp	.-436    	; 0x8200 <__RODATA_PM_OFFSET__+0x200>
ecchdr_next():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_ecc608.cpp:81

static DataHeaderUnion* ecchdr_next(DataHeaderUnion* h) {
    if (!h) {
        return (DataHeaderUnion*) data_cache;
    }
    return (DataHeaderUnion*) &data_cache[h->header.next];
    83b4:	fc 01       	movw	r30, r24
    83b6:	ec 5a       	subi	r30, 0xAC	; 172
    83b8:	fb 49       	sbci	r31, 0x9B	; 155
    83ba:	f4 ce       	rjmp	.-536    	; 0x81a4 <__RODATA_PM_OFFSET__+0x1a4>
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:145
        Lte.end();

        return false;
    }

    if (!SequansController.extractValueFromCommandResponse(
    83bc:	0a e3       	ldi	r16, 0x3A	; 58
    83be:	20 e2       	ldi	r18, 0x20	; 32
    83c0:	30 e0       	ldi	r19, 0x00	; 0
    83c2:	a5 01       	movw	r20, r10
    83c4:	60 e0       	ldi	r22, 0x00	; 0
    83c6:	ce 01       	movw	r24, r28
    83c8:	84 56       	subi	r24, 0x64	; 100
    83ca:	9f 4f       	sbci	r25, 0xFF	; 255
    83cc:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    83d0:	81 11       	cpse	r24, r1
    83d2:	03 c0       	rjmp	.+6      	; 0x83da <__RODATA_PM_OFFSET__+0x3da>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:150
            response_buffer,
            0,
            value_buffer,
            sizeof(value_buffer))) {
        Log.error("Failed to retrieve SIM status");
    83d4:	89 e2       	ldi	r24, 0x29	; 41
    83d6:	96 e5       	ldi	r25, 0x56	; 86
    83d8:	d3 cf       	rjmp	.-90     	; 0x8380 <__RODATA_PM_OFFSET__+0x380>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:156
        Lte.end();

        return false;
    }

    if (strncmp(value_buffer, "READY", 5) != 0) {
    83da:	45 e0       	ldi	r20, 0x05	; 5
    83dc:	50 e0       	ldi	r21, 0x00	; 0
    83de:	67 e4       	ldi	r22, 0x47	; 71
    83e0:	76 e5       	ldi	r23, 0x56	; 86
    83e2:	c5 01       	movw	r24, r10
    83e4:	0e 94 0d 57 	call	0xae1a	; 0xae1a <strncmp>
    83e8:	3c 01       	movw	r6, r24
    83ea:	89 2b       	or	r24, r25
    83ec:	d9 f0       	breq	.+54     	; 0x8424 <__RODATA_PM_OFFSET__+0x424>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:157
        Log.errorf("SIM card is not ready, status: %s", value_buffer);
    83ee:	bf 92       	push	r11
    83f0:	af 92       	push	r10
    83f2:	8d e4       	ldi	r24, 0x4D	; 77
    83f4:	96 e5       	ldi	r25, 0x56	; 86
    83f6:	9f 93       	push	r25
    83f8:	8f 93       	push	r24
    83fa:	89 e6       	ldi	r24, 0x69	; 105
    83fc:	90 e7       	ldi	r25, 0x70	; 112
    83fe:	9f 93       	push	r25
    8400:	8f 93       	push	r24
    8402:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:158
        Lte.end();
    8406:	0e 94 bc 27 	call	0x4f78	; 0x4f78 <LteClass::end() [clone .constprop.95]>
    840a:	0f 90       	pop	r0
    840c:	0f 90       	pop	r0
    840e:	0f 90       	pop	r0
    8410:	0f 90       	pop	r0
    8412:	0f 90       	pop	r0
    8414:	0f 90       	pop	r0
demo_loop():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:273
  printf("Done.\n");
}

void demo_loop() {
  // In order to simplify this demo we are doing everything in setup() and controlling our own loop
  delay(1000);
    8416:	68 ee       	ldi	r22, 0xE8	; 232
    8418:	73 e0       	ldi	r23, 0x03	; 3
    841a:	80 e0       	ldi	r24, 0x00	; 0
    841c:	90 e0       	ldi	r25, 0x00	; 0
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:208
  // reserve_stack_with_heap_leak(); // we may need to do this early to prevent corruption
  // memory_test();

  if (ATCA_SUCCESS != iotc_ecc608_init_provision()) {
    Log.error("Failed to read provisioning data!");
    delay(10000);
    841e:	0e 94 98 02 	call	0x530	; 0x530 <delay>
    8422:	f9 cf       	rjmp	.-14     	; 0x8416 <__RODATA_PM_OFFSET__+0x416>
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:164

        return false;
    }

    if (print_messages) {
        Log.infof("Connecting to operator");
    8424:	8f e6       	ldi	r24, 0x6F	; 111
    8426:	96 e5       	ldi	r25, 0x56	; 86
    8428:	9f 93       	push	r25
    842a:	8f 93       	push	r24
    842c:	89 e6       	ldi	r24, 0x69	; 105
    842e:	90 e7       	ldi	r25, 0x70	; 112
    8430:	9f 93       	push	r25
    8432:	8f 93       	push	r24
    8434:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
    8438:	0f 90       	pop	r0
    843a:	0f 90       	pop	r0
    843c:	0f 90       	pop	r0
    843e:	0f 90       	pop	r0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:172
    while (!isConnected() && !timeout_timer.hasTimedOut()) {
        LedCtrl.toggle(Led::CELL, true);
        _delay_ms(500);

        if (print_messages) {
            Log.rawf(".");
    8440:	16 eb       	ldi	r17, 0xB6	; 182
    8442:	e1 2e       	mov	r14, r17
    8444:	17 e5       	ldi	r17, 0x57	; 87
    8446:	f1 2e       	mov	r15, r17
    8448:	09 e6       	ldi	r16, 0x69	; 105
    844a:	10 e7       	ldi	r17, 0x70	; 112
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:357

void LteClass::onDisconnect(void (*disconnect_callback)(void)) {
    disconnected_callback = disconnect_callback;
}

bool LteClass::isConnected(void) { return is_connected; }
    844c:	80 91 8d 66 	lds	r24, 0x668D	; 0x80668d <is_connected>
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:167

    if (print_messages) {
        Log.infof("Connecting to operator");
    }

    while (!isConnected() && !timeout_timer.hasTimedOut()) {
    8450:	81 11       	cpse	r24, r1
    8452:	1f c0       	rjmp	.+62     	; 0x8492 <__RODATA_PM_OFFSET__+0x492>
    8454:	c2 01       	movw	r24, r4
    8456:	0e 94 2a 07 	call	0xe54	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    845a:	81 11       	cpse	r24, r1
    845c:	1a c0       	rjmp	.+52     	; 0x8492 <__RODATA_PM_OFFSET__+0x492>
digitalRead():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore/wiring_digital.c:340

  /* Get port and check valid port */
  PORT_t *port = digitalPinToPortStruct(pin);

  /* Read pin value from PORTx.IN register */
  if (port->IN & bit_mask) {
    845e:	60 91 08 04 	lds	r22, 0x0408	; 0x800408 <__TEXT_REGION_LENGTH__+0x7e0408>
toggle():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/led_ctrl.cpp:94
void LedCtrlClass::toggle(Led led, bool is_from_system_event) {
    if (is_from_system_event && manual_control_enabled)
        return;

    const uint8_t led_pin = getLedPin(led);
    digitalWrite(led_pin, !digitalRead(led_pin));
    8462:	60 95       	com	r22
    8464:	61 70       	andi	r22, 0x01	; 1
    8466:	0e 94 53 22 	call	0x44a6	; 0x44a6 <digitalWrite>
_delay_ms():
c:\users\bobm\appdata\local\arduino15\packages\dxcore\tools\avr-gcc\7.3.0-atmel3.6.1-azduino6\avr\include\util/delay.h:187
    846a:	bf ef       	ldi	r27, 0xFF	; 255
    846c:	ee e9       	ldi	r30, 0x9E	; 158
    846e:	f4 e2       	ldi	r31, 0x24	; 36
    8470:	b1 50       	subi	r27, 0x01	; 1
    8472:	e0 40       	sbci	r30, 0x00	; 0
    8474:	f0 40       	sbci	r31, 0x00	; 0
    8476:	e1 f7       	brne	.-8      	; 0x8470 <__RODATA_PM_OFFSET__+0x470>
    8478:	00 c0       	rjmp	.+0      	; 0x847a <__RODATA_PM_OFFSET__+0x47a>
    847a:	00 00       	nop
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:172
        LedCtrl.toggle(Led::CELL, true);
        _delay_ms(500);

        if (print_messages) {
            Log.rawf(".");
    847c:	ff 92       	push	r15
    847e:	ef 92       	push	r14
    8480:	1f 93       	push	r17
    8482:	0f 93       	push	r16
    8484:	0e 94 ba 0a 	call	0x1574	; 0x1574 <LogClass::rawf(char const*, ...) [clone .constprop.102]>
    8488:	0f 90       	pop	r0
    848a:	0f 90       	pop	r0
    848c:	0f 90       	pop	r0
    848e:	0f 90       	pop	r0
    8490:	dd cf       	rjmp	.-70     	; 0x844c <__RODATA_PM_OFFSET__+0x44c>
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:357

void LteClass::onDisconnect(void (*disconnect_callback)(void)) {
    disconnected_callback = disconnect_callback;
}

bool LteClass::isConnected(void) { return is_connected; }
    8492:	80 91 8d 66 	lds	r24, 0x668D	; 0x80668d <is_connected>
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:176
        if (print_messages) {
            Log.rawf(".");
        }
    }

    if (!isConnected()) {
    8496:	81 11       	cpse	r24, r1
    8498:	28 c0       	rjmp	.+80     	; 0x84ea <__RODATA_PM_OFFSET__+0x4ea>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:177
        Log.rawf(" Was not able to connect to the network within the timeout "
    849a:	1f 92       	push	r1
    849c:	89 e0       	ldi	r24, 0x09	; 9
    849e:	8f 93       	push	r24
    84a0:	87 e2       	ldi	r24, 0x27	; 39
    84a2:	8f 93       	push	r24
    84a4:	80 ec       	ldi	r24, 0xC0	; 192
    84a6:	8f 93       	push	r24
    84a8:	86 e8       	ldi	r24, 0x86	; 134
    84aa:	96 e5       	ldi	r25, 0x56	; 86
    84ac:	9f 93       	push	r25
    84ae:	8f 93       	push	r24
    84b0:	89 e6       	ldi	r24, 0x69	; 105
    84b2:	90 e7       	ldi	r25, 0x70	; 112
    84b4:	9f 93       	push	r25
    84b6:	8f 93       	push	r24
    84b8:	0e 94 ba 0a 	call	0x1574	; 0x1574 <LogClass::rawf(char const*, ...) [clone .constprop.102]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:182
                 "of %d ms. Consider increasing the timeout or checking your "
                 "cellular coverage.\r\n",
                 timeout_ms);

        SequansController.unregisterCallback(CEREG_CALLBACK);
    84bc:	8e ef       	ldi	r24, 0xFE	; 254
    84be:	9f e4       	ldi	r25, 0x4F	; 79
    84c0:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:183
        SequansController.unregisterCallback(TIMEZONE_CALLBACK);
    84c4:	8f ee       	ldi	r24, 0xEF	; 239
    84c6:	9f e4       	ldi	r25, 0x4F	; 79
    84c8:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:184
        SequansController.writeCommand(AT_DISCONNECT);
    84cc:	50 e0       	ldi	r21, 0x00	; 0
    84ce:	40 e0       	ldi	r20, 0x00	; 0
    84d0:	70 e0       	ldi	r23, 0x00	; 0
    84d2:	60 e0       	ldi	r22, 0x00	; 0
    84d4:	84 ef       	ldi	r24, 0xF4	; 244
    84d6:	9f e4       	ldi	r25, 0x4F	; 79
    84d8:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    84dc:	2d b7       	in	r18, 0x3d	; 61
    84de:	3e b7       	in	r19, 0x3e	; 62
    84e0:	28 5f       	subi	r18, 0xF8	; 248
    84e2:	3f 4f       	sbci	r19, 0xFF	; 255
    84e4:	2d bf       	out	0x3d, r18	; 61
    84e6:	3e bf       	out	0x3e, r19	; 62
    84e8:	96 cf       	rjmp	.-212    	; 0x8416 <__RODATA_PM_OFFSET__+0x416>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:190

        return false;
    }

    if (print_messages) {
        Log.rawf(" OK!\r\n");
    84ea:	81 e1       	ldi	r24, 0x11	; 17
    84ec:	97 e5       	ldi	r25, 0x57	; 87
    84ee:	9f 93       	push	r25
    84f0:	8f 93       	push	r24
    84f2:	89 e6       	ldi	r24, 0x69	; 105
    84f4:	90 e7       	ldi	r25, 0x70	; 112
    84f6:	9f 93       	push	r25
    84f8:	8f 93       	push	r24
    84fa:	0e 94 ba 0a 	call	0x1574	; 0x1574 <LogClass::rawf(char const*, ...) [clone .constprop.102]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:193
    }

    if (SequansController.writeCommand(AT_GET_CLOCK,
    84fe:	40 e4       	ldi	r20, 0x40	; 64
    8500:	50 e0       	ldi	r21, 0x00	; 0
    8502:	be 01       	movw	r22, r28
    8504:	64 56       	subi	r22, 0x64	; 100
    8506:	7f 4f       	sbci	r23, 0xFF	; 255
    8508:	88 e1       	ldi	r24, 0x18	; 24
    850a:	97 e5       	ldi	r25, 0x57	; 87
    850c:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    8510:	0f 90       	pop	r0
    8512:	0f 90       	pop	r0
    8514:	0f 90       	pop	r0
    8516:	0f 90       	pop	r0
    8518:	01 97       	sbiw	r24, 0x01	; 1
    851a:	19 f0       	breq	.+6      	; 0x8522 <__RODATA_PM_OFFSET__+0x522>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:198
                                       response_buffer,
                                       sizeof(response_buffer)) !=
        ResponseResult::OK) {

        Log.error("Command for retrieving modem time failed");
    851c:	81 e2       	ldi	r24, 0x21	; 33
    851e:	97 e5       	ldi	r25, 0x57	; 87
    8520:	2f cf       	rjmp	.-418    	; 0x8380 <__RODATA_PM_OFFSET__+0x380>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:204
        Lte.end();

        return false;
    }

    if (!SequansController.extractValueFromCommandResponse(
    8522:	0a e3       	ldi	r16, 0x3A	; 58
    8524:	20 e2       	ldi	r18, 0x20	; 32
    8526:	30 e0       	ldi	r19, 0x00	; 0
    8528:	a5 01       	movw	r20, r10
    852a:	60 e0       	ldi	r22, 0x00	; 0
    852c:	ce 01       	movw	r24, r28
    852e:	84 56       	subi	r24, 0x64	; 100
    8530:	9f 4f       	sbci	r25, 0xFF	; 255
    8532:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    8536:	81 11       	cpse	r24, r1
    8538:	03 c0       	rjmp	.+6      	; 0x8540 <__RODATA_PM_OFFSET__+0x540>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:209
            response_buffer,
            0,
            value_buffer,
            sizeof(value_buffer))) {
        Log.error("Failed to retrieve time from modem");
    853a:	8a e4       	ldi	r24, 0x4A	; 74
    853c:	97 e5       	ldi	r25, 0x57	; 87
    853e:	20 cf       	rjmp	.-448    	; 0x8380 <__RODATA_PM_OFFSET__+0x380>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:215
        Lte.end();

        return false;
    }

    char year[3]  = "";
    8540:	c4 5e       	subi	r28, 0xE4	; 228
    8542:	de 4f       	sbci	r29, 0xFE	; 254
    8544:	18 82       	st	Y, r1
    8546:	cc 51       	subi	r28, 0x1C	; 28
    8548:	d1 40       	sbci	r29, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:216
    char month[3] = "";
    854a:	c7 5e       	subi	r28, 0xE7	; 231
    854c:	de 4f       	sbci	r29, 0xFE	; 254
    854e:	18 82       	st	Y, r1
    8550:	c9 51       	subi	r28, 0x19	; 25
    8552:	d1 40       	sbci	r29, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:217
    char day[3]   = "";
    8554:	ca 5e       	subi	r28, 0xEA	; 234
    8556:	de 4f       	sbci	r29, 0xFE	; 254
    8558:	18 82       	st	Y, r1
    855a:	c6 51       	subi	r28, 0x16	; 22
    855c:	d1 40       	sbci	r29, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:218
    memcpy(year, &value_buffer[0] + 1, 2);
    855e:	d5 01       	movw	r26, r10
    8560:	11 96       	adiw	r26, 0x01	; 1
    8562:	8d 91       	ld	r24, X+
    8564:	9c 91       	ld	r25, X
    8566:	12 97       	sbiw	r26, 0x02	; 2
    8568:	c6 5e       	subi	r28, 0xE6	; 230
    856a:	de 4f       	sbci	r29, 0xFE	; 254
    856c:	88 83       	st	Y, r24
    856e:	99 83       	std	Y+1, r25	; 0x01
    8570:	ca 51       	subi	r28, 0x1A	; 26
    8572:	d1 40       	sbci	r29, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:219
    memcpy(month, &value_buffer[0] + 4, 2);
    8574:	14 96       	adiw	r26, 0x04	; 4
    8576:	8d 91       	ld	r24, X+
    8578:	9c 91       	ld	r25, X
    857a:	15 97       	sbiw	r26, 0x05	; 5
    857c:	c9 5e       	subi	r28, 0xE9	; 233
    857e:	de 4f       	sbci	r29, 0xFE	; 254
    8580:	88 83       	st	Y, r24
    8582:	99 83       	std	Y+1, r25	; 0x01
    8584:	c7 51       	subi	r28, 0x17	; 23
    8586:	d1 40       	sbci	r29, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:220
    memcpy(day, &value_buffer[0] + 7, 2);
    8588:	17 96       	adiw	r26, 0x07	; 7
    858a:	8d 91       	ld	r24, X+
    858c:	9c 91       	ld	r25, X
    858e:	cc 5e       	subi	r28, 0xEC	; 236
    8590:	de 4f       	sbci	r29, 0xFE	; 254
    8592:	88 83       	st	Y, r24
    8594:	99 83       	std	Y+1, r25	; 0x01
    8596:	c4 51       	subi	r28, 0x14	; 20
    8598:	d1 40       	sbci	r29, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:223

    // We check the date and whether it is unix epoch start or not
    if (atoi(year) == 70 && atoi(month) == 1 && atoi(day) == 1) {
    859a:	ce 01       	movw	r24, r28
    859c:	86 5e       	subi	r24, 0xE6	; 230
    859e:	9e 4f       	sbci	r25, 0xFE	; 254
    85a0:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
    85a4:	86 34       	cpi	r24, 0x46	; 70
    85a6:	91 05       	cpc	r25, r1
    85a8:	09 f0       	breq	.+2      	; 0x85ac <__RODATA_PM_OFFSET__+0x5ac>
    85aa:	96 c0       	rjmp	.+300    	; 0x86d8 <__RODATA_PM_OFFSET__+0x6d8>
    85ac:	ce 01       	movw	r24, r28
    85ae:	89 5e       	subi	r24, 0xE9	; 233
    85b0:	9e 4f       	sbci	r25, 0xFE	; 254
    85b2:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
    85b6:	01 97       	sbiw	r24, 0x01	; 1
    85b8:	09 f0       	breq	.+2      	; 0x85bc <__RODATA_PM_OFFSET__+0x5bc>
    85ba:	8e c0       	rjmp	.+284    	; 0x86d8 <__RODATA_PM_OFFSET__+0x6d8>
    85bc:	ce 01       	movw	r24, r28
    85be:	8c 5e       	subi	r24, 0xEC	; 236
    85c0:	9e 4f       	sbci	r25, 0xFE	; 254
    85c2:	0e 94 3c 4f 	call	0x9e78	; 0x9e78 <atoi>
    85c6:	01 97       	sbiw	r24, 0x01	; 1
    85c8:	09 f0       	breq	.+2      	; 0x85cc <__RODATA_PM_OFFSET__+0x5cc>
    85ca:	86 c0       	rjmp	.+268    	; 0x86d8 <__RODATA_PM_OFFSET__+0x6d8>
__base_ctor ():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:5
#include "timeout_timer.h"

#include <Arduino.h>

TimeoutTimer::TimeoutTimer(const uint32_t ms) : interval_ms(ms) {
    85cc:	80 e1       	ldi	r24, 0x10	; 16
    85ce:	97 e2       	ldi	r25, 0x27	; 39
    85d0:	a0 e0       	ldi	r26, 0x00	; 0
    85d2:	b0 e0       	ldi	r27, 0x00	; 0
    85d4:	cc 5f       	subi	r28, 0xFC	; 252
    85d6:	de 4f       	sbci	r29, 0xFE	; 254
    85d8:	88 83       	st	Y, r24
    85da:	99 83       	std	Y+1, r25	; 0x01
    85dc:	aa 83       	std	Y+2, r26	; 0x02
    85de:	bb 83       	std	Y+3, r27	; 0x03
    85e0:	c4 50       	subi	r28, 0x04	; 4
    85e2:	d1 40       	sbci	r29, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:6
    start_ms = millis();
    85e4:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
    85e8:	c8 5f       	subi	r28, 0xF8	; 248
    85ea:	de 4f       	sbci	r29, 0xFE	; 254
    85ec:	68 83       	st	Y, r22
    85ee:	79 83       	std	Y+1, r23	; 0x01
    85f0:	8a 83       	std	Y+2, r24	; 0x02
    85f2:	9b 83       	std	Y+3, r25	; 0x03
    85f4:	c8 50       	subi	r28, 0x08	; 8
    85f6:	d1 40       	sbci	r29, 0x01	; 1
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:229

        // Not valid time, have to do sync. First we wait some to see if we get
        // the timezone URC
        const TimeoutTimer timezone_timer(TIMEZONE_WAIT_MS);

        while (!timezone_timer.hasTimedOut() && !got_timezone) {}
    85f8:	ce 01       	movw	r24, r28
    85fa:	8c 5f       	subi	r24, 0xFC	; 252
    85fc:	9e 4f       	sbci	r25, 0xFE	; 254
    85fe:	0e 94 2a 07 	call	0xe54	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    8602:	81 11       	cpse	r24, r1
    8604:	04 c0       	rjmp	.+8      	; 0x860e <__RODATA_PM_OFFSET__+0x60e>
    8606:	80 91 8c 66 	lds	r24, 0x668C	; 0x80668c <got_timezone>
    860a:	88 23       	and	r24, r24
    860c:	a9 f3       	breq	.-22     	; 0x85f8 <__RODATA_PM_OFFSET__+0x5f8>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:231

        if (!got_timezone) {
    860e:	80 91 8c 66 	lds	r24, 0x668C	; 0x80668c <got_timezone>
    8612:	81 11       	cpse	r24, r1
    8614:	61 c0       	rjmp	.+194    	; 0x86d8 <__RODATA_PM_OFFSET__+0x6d8>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:235

            // Do manual sync with NTP server
            if (print_messages) {
                Log.info("Did not get time from operator, doing NTP sync. "
    8616:	8d e6       	ldi	r24, 0x6D	; 109
    8618:	97 e5       	ldi	r25, 0x57	; 87
    861a:	0e 94 29 0a 	call	0x1452	; 0x1452 <LogClass::info(char const*) [clone .constprop.93]>
__base_ctor ():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:5
#include "timeout_timer.h"

#include <Arduino.h>

TimeoutTimer::TimeoutTimer(const uint32_t ms) : interval_ms(ms) {
    861e:	80 ec       	ldi	r24, 0xC0	; 192
    8620:	97 e2       	ldi	r25, 0x27	; 39
    8622:	a9 e0       	ldi	r26, 0x09	; 9
    8624:	b0 e0       	ldi	r27, 0x00	; 0
    8626:	c4 50       	subi	r28, 0x04	; 4
    8628:	df 4f       	sbci	r29, 0xFF	; 255
    862a:	88 83       	st	Y, r24
    862c:	99 83       	std	Y+1, r25	; 0x01
    862e:	aa 83       	std	Y+2, r26	; 0x02
    8630:	bb 83       	std	Y+3, r27	; 0x03
    8632:	cc 5f       	subi	r28, 0xFC	; 252
    8634:	d0 40       	sbci	r29, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/timeout_timer.cpp:6
    start_ms = millis();
    8636:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
    863a:	c0 50       	subi	r28, 0x00	; 0
    863c:	df 4f       	sbci	r29, 0xFF	; 255
    863e:	68 83       	st	Y, r22
    8640:	79 83       	std	Y+1, r23	; 0x01
    8642:	8a 83       	std	Y+2, r24	; 0x02
    8644:	9b 83       	std	Y+3, r25	; 0x03
    8646:	c0 50       	subi	r28, 0x00	; 0
    8648:	d1 40       	sbci	r29, 0x01	; 1
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:261
                if (SequansController.writeCommand(AT_SYNC_NTP) !=
                    ResponseResult::OK) {
                    continue;
                }

                char buffer[64] = "";
    864a:	be e3       	ldi	r27, 0x3E	; 62
    864c:	3b 2e       	mov	r3, r27
    864e:	4e 01       	movw	r8, r28
    8650:	b3 e0       	ldi	r27, 0x03	; 3
    8652:	8b 0e       	add	r8, r27
    8654:	91 1c       	adc	r9, r1
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:244
            // Will break from this when we get the NTP sync

            const TimeoutTimer ntp_sync_timer(timeout_ms);
            bool got_ntp_sync = false;

            while (!ntp_sync_timer.hasTimedOut() && !got_ntp_sync) {
    8656:	ce 01       	movw	r24, r28
    8658:	84 50       	subi	r24, 0x04	; 4
    865a:	9f 4f       	sbci	r25, 0xFF	; 255
    865c:	0e 94 2a 07 	call	0xe54	; 0xe54 <TimeoutTimer::hasTimedOut() const>
    8660:	81 11       	cpse	r24, r1
    8662:	6c c0       	rjmp	.+216    	; 0x873c <__RODATA_PM_OFFSET__+0x73c>
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:357

void LteClass::onDisconnect(void (*disconnect_callback)(void)) {
    disconnected_callback = disconnect_callback;
}

bool LteClass::isConnected(void) { return is_connected; }
    8664:	80 91 8d 66 	lds	r24, 0x668D	; 0x80668d <is_connected>
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:248

            while (!ntp_sync_timer.hasTimedOut() && !got_ntp_sync) {

                // We might be disconnected from the network whilst doing the
                // NTP sync, so return if that is the case
                if (!isConnected()) {
    8668:	81 11       	cpse	r24, r1
    866a:	09 c0       	rjmp	.+18     	; 0x867e <__RODATA_PM_OFFSET__+0x67e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:249
                    Log.warn(
    866c:	88 eb       	ldi	r24, 0xB8	; 184
    866e:	97 e5       	ldi	r25, 0x57	; 87
    8670:	0e 94 9c 0a 	call	0x1538	; 0x1538 <LogClass::warn(char const*) [clone .constprop.124]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:251
                        "Got disconnected from network whilst doing NTP sync");
                    SequansController.unregisterCallback(TIMEZONE_CALLBACK);
    8674:	8f ee       	ldi	r24, 0xEF	; 239
    8676:	9f e4       	ldi	r25, 0x4F	; 79
    8678:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
    867c:	83 ce       	rjmp	.-762    	; 0x8384 <__RODATA_PM_OFFSET__+0x384>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:256
                    Lte.end();
                    return false;
                }

                if (SequansController.writeCommand(AT_SYNC_NTP) !=
    867e:	50 e0       	ldi	r21, 0x00	; 0
    8680:	40 e0       	ldi	r20, 0x00	; 0
    8682:	70 e0       	ldi	r23, 0x00	; 0
    8684:	60 e0       	ldi	r22, 0x00	; 0
    8686:	8c ee       	ldi	r24, 0xEC	; 236
    8688:	97 e5       	ldi	r25, 0x57	; 87
    868a:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
    868e:	01 97       	sbiw	r24, 0x01	; 1
    8690:	11 f7       	brne	.-60     	; 0x8656 <__RODATA_PM_OFFSET__+0x656>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:261
                    ResponseResult::OK) {
                    continue;
                }

                char buffer[64] = "";
    8692:	19 82       	std	Y+1, r1	; 0x01
    8694:	1a 82       	std	Y+2, r1	; 0x02
    8696:	f4 01       	movw	r30, r8
    8698:	23 2d       	mov	r18, r3
    869a:	11 92       	st	Z+, r1
    869c:	2a 95       	dec	r18
    869e:	e9 f7       	brne	.-6      	; 0x869a <__RODATA_PM_OFFSET__+0x69a>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:263

                if (!SequansController.waitForURC(NTP_CALLBACK,
    86a0:	f0 e2       	ldi	r31, 0x20	; 32
    86a2:	cf 2e       	mov	r12, r31
    86a4:	ae e4       	ldi	r26, 0x4E	; 78
    86a6:	da 2e       	mov	r13, r26
    86a8:	e1 2c       	mov	r14, r1
    86aa:	f1 2c       	mov	r15, r1
    86ac:	00 e0       	ldi	r16, 0x00	; 0
    86ae:	10 e0       	ldi	r17, 0x00	; 0
    86b0:	20 e0       	ldi	r18, 0x00	; 0
    86b2:	30 e0       	ldi	r19, 0x00	; 0
    86b4:	40 e4       	ldi	r20, 0x40	; 64
    86b6:	50 e0       	ldi	r21, 0x00	; 0
    86b8:	be 01       	movw	r22, r28
    86ba:	6f 5f       	subi	r22, 0xFF	; 255
    86bc:	7f 4f       	sbci	r23, 0xFF	; 255
    86be:	8a e2       	ldi	r24, 0x2A	; 42
    86c0:	98 e5       	ldi	r25, 0x58	; 88
    86c2:	0e 94 24 0f 	call	0x1e48	; 0x1e48 <SequansControllerClass::waitForURC(char const*, char*, unsigned int, unsigned long long) [clone .constprop.121]>
    86c6:	88 23       	and	r24, r24
    86c8:	31 f2       	breq	.-116    	; 0x8656 <__RODATA_PM_OFFSET__+0x656>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:270
                                                  sizeof(buffer))) {
                    // Time wait for the NTP URC timed out, retry
                    continue;
                }

                if (buffer[NTP_STATUS_INDEX] == NTP_OK) {
    86ca:	8a 81       	ldd	r24, Y+2	; 0x02
    86cc:	80 33       	cpi	r24, 0x30	; 48
    86ce:	19 f6       	brne	.-122    	; 0x8656 <__RODATA_PM_OFFSET__+0x656>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:271
                    Log.info("Got NTP sync!");
    86d0:	81 e3       	ldi	r24, 0x31	; 49
    86d2:	98 e5       	ldi	r25, 0x58	; 88
    86d4:	0e 94 29 0a 	call	0x1452	; 0x1452 <LogClass::info(char const*) [clone .constprop.93]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:288
                return false;
            }
        }
    }

    SequansController.unregisterCallback(TIMEZONE_CALLBACK);
    86d8:	8f ee       	ldi	r24, 0xEF	; 239
    86da:	9f e4       	ldi	r25, 0x4F	; 79
    86dc:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:241
  Log.infof("DUID: %s\r\n", config->duid);

  if (!connect_lte()) {
      return;
  }
  connecteded_to_network = true;
    86e0:	81 e0       	ldi	r24, 0x01	; 1
    86e2:	80 93 02 66 	sts	0x6602, r24	; 0x806602 <connecteded_to_network>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:243

  config->ota_cb = on_ota;
    86e6:	8a ed       	ldi	r24, 0xDA	; 218
    86e8:	9b e2       	ldi	r25, 0x2B	; 43
    86ea:	80 93 fa 65 	sts	0x65FA, r24	; 0x8065fa <config+0x6>
    86ee:	90 93 fb 65 	sts	0x65FB, r25	; 0x8065fb <config+0x7>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:244
  config->status_cb = on_connection_status;
    86f2:	8e e8       	ldi	r24, 0x8E	; 142
    86f4:	9a e0       	ldi	r25, 0x0A	; 10
    86f6:	80 93 00 66 	sts	0x6600, r24	; 0x806600 <config+0xc>
    86fa:	90 93 01 66 	sts	0x6601, r25	; 0x806601 <config+0xd>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:245
  config->cmd_cb = on_command;
    86fe:	88 ec       	ldi	r24, 0xC8	; 200
    8700:	99 e2       	ldi	r25, 0x29	; 41
    8702:	80 93 fc 65 	sts	0x65FC, r24	; 0x8065fc <config+0x8>
    8706:	90 93 fd 65 	sts	0x65FD, r25	; 0x8065fd <config+0x9>
iotconnect_sdk_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:232
}

///////////////////////////////////////////////////////////////////////////////////
// this the Initialization os IoTConnect SDK
bool iotconnect_sdk_init(void) {
    if (!config.cpid || !config.env || !config.duid) {
    870a:	80 91 f6 65 	lds	r24, 0x65F6	; 0x8065f6 <config+0x2>
    870e:	90 91 f7 65 	lds	r25, 0x65F7	; 0x8065f7 <config+0x3>
    8712:	89 2b       	or	r24, r25
    8714:	61 f0       	breq	.+24     	; 0x872e <__RODATA_PM_OFFSET__+0x72e>
    8716:	80 91 f4 65 	lds	r24, 0x65F4	; 0x8065f4 <config>
    871a:	90 91 f5 65 	lds	r25, 0x65F5	; 0x8065f5 <config+0x1>
    871e:	89 2b       	or	r24, r25
    8720:	31 f0       	breq	.+12     	; 0x872e <__RODATA_PM_OFFSET__+0x72e>
    8722:	80 91 f8 65 	lds	r24, 0x65F8	; 0x8065f8 <config+0x4>
    8726:	90 91 f9 65 	lds	r25, 0x65F9	; 0x8065f9 <config+0x5>
    872a:	89 2b       	or	r24, r25
    872c:	21 f5       	brne	.+72     	; 0x8776 <__RODATA_PM_OFFSET__+0x776>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:233
        Log.error("CPID, Environment and DUID are required for iotconnect_sdk_init()");
    872e:	8c e9       	ldi	r24, 0x9C	; 156
    8730:	98 e5       	ldi	r25, 0x58	; 88
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:279
    }

    mqtt_config.status_cb = config.status_cb;
    mqtt_config.c2d_msg_cb = on_mqtt_c2d_message;
    if (!iotc_mqtt_client_init(&mqtt_config)) {
        Log.error("Failed to connect!");
    8732:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:262
        iotconnect_sdk_loop();
        delay(100);
      }
    }
  } else {
    Log.error("Encountered an error while initializing the SDK!");
    8736:	80 e4       	ldi	r24, 0x40	; 64
    8738:	91 e6       	ldi	r25, 0x61	; 97
    873a:	5c cd       	rjmp	.-1352   	; 0x81f4 <__RODATA_PM_OFFSET__+0x1f4>
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:278
                    break;
                }
            }

            if (!got_ntp_sync) {
                Log.warnf("Did not get NTP sync within timeout of %lu ms. "
    873c:	1f 92       	push	r1
    873e:	89 e0       	ldi	r24, 0x09	; 9
    8740:	8f 93       	push	r24
    8742:	87 e2       	ldi	r24, 0x27	; 39
    8744:	8f 93       	push	r24
    8746:	80 ec       	ldi	r24, 0xC0	; 192
    8748:	8f 93       	push	r24
    874a:	8f e3       	ldi	r24, 0x3F	; 63
    874c:	98 e5       	ldi	r25, 0x58	; 88
    874e:	9f 93       	push	r25
    8750:	8f 93       	push	r24
    8752:	89 e6       	ldi	r24, 0x69	; 105
    8754:	90 e7       	ldi	r25, 0x70	; 112
    8756:	9f 93       	push	r25
    8758:	8f 93       	push	r24
    875a:	0e 94 ba 0b 	call	0x1774	; 0x1774 <LogClass::warnf(char const*, ...) [clone .constprop.94]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:281
                          "Consider increasing timeout for Lte.begin()\r\n",
                          timeout_ms);
                SequansController.unregisterCallback(TIMEZONE_CALLBACK);
    875e:	8f ee       	ldi	r24, 0xEF	; 239
    8760:	9f e4       	ldi	r25, 0x4F	; 79
    8762:	0e 94 5e 0d 	call	0x1abc	; 0x1abc <SequansControllerClass::unregisterCallback(char const*) [clone .constprop.123]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:282
                Lte.end();
    8766:	0e 94 bc 27 	call	0x4f78	; 0x4f78 <LteClass::end() [clone .constprop.95]>
    876a:	8d b7       	in	r24, 0x3d	; 61
    876c:	9e b7       	in	r25, 0x3e	; 62
    876e:	08 96       	adiw	r24, 0x08	; 8
    8770:	8d bf       	out	0x3d, r24	; 61
    8772:	9e bf       	out	0x3e, r25	; 62
    8774:	50 ce       	rjmp	.-864    	; 0x8416 <__RODATA_PM_OFFSET__+0x416>
iotconnect_sdk_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:236
bool iotconnect_sdk_init(void) {
    if (!config.cpid || !config.env || !config.duid) {
        Log.error("CPID, Environment and DUID are required for iotconnect_sdk_init()");
        return false;
    }
    if (mqtt_config.sr) {
    8776:	80 91 4e 64 	lds	r24, 0x644E	; 0x80644e <mqtt_config>
    877a:	90 91 4f 64 	lds	r25, 0x644F	; 0x80644f <mqtt_config+0x1>
    877e:	00 97       	sbiw	r24, 0x00	; 0
    8780:	31 f0       	breq	.+12     	; 0x878e <__RODATA_PM_OFFSET__+0x78e>
iotcl_discovery_free_sync_response():
    8782:	0e 94 5e 09 	call	0x12bc	; 0x12bc <iotcl_discovery_free_sync_response.part.1>
iotconnect_sdk_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:238
        iotcl_discovery_free_sync_response(mqtt_config.sr);
        mqtt_config.sr = NULL;
    8786:	10 92 4e 64 	sts	0x644E, r1	; 0x80644e <mqtt_config>
    878a:	10 92 4f 64 	sts	0x644F, r1	; 0x80644f <mqtt_config+0x1>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:240
    }
    IotclDiscoveryResponse *discovery_response = run_http_discovery(config.cpid, config.env);
    878e:	90 91 f4 65 	lds	r25, 0x65F4	; 0x8065f4 <config>
    8792:	c8 5d       	subi	r28, 0xD8	; 216
    8794:	de 4f       	sbci	r29, 0xFE	; 254
    8796:	98 83       	st	Y, r25
    8798:	c8 52       	subi	r28, 0x28	; 40
    879a:	d1 40       	sbci	r29, 0x01	; 1
    879c:	a0 91 f5 65 	lds	r26, 0x65F5	; 0x8065f5 <config+0x1>
    87a0:	c7 5d       	subi	r28, 0xD7	; 215
    87a2:	de 4f       	sbci	r29, 0xFE	; 254
    87a4:	a8 83       	st	Y, r26
    87a6:	c9 52       	subi	r28, 0x29	; 41
    87a8:	d1 40       	sbci	r29, 0x01	; 1
    87aa:	10 91 f6 65 	lds	r17, 0x65F6	; 0x8065f6 <config+0x2>
    87ae:	00 91 f7 65 	lds	r16, 0x65F7	; 0x8065f7 <config+0x3>
run_http_discovery():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:76

static IotclDiscoveryResponse *run_http_discovery(const char *cpid, const char *env) {
    char *json_start = NULL;
    IotclDiscoveryResponse *ret = NULL;
    char *path_buff = (char *) malloc(sizeof(HTTP_DISCOVERY_PATH_FORMAT) +
                            strlen(cpid) +
    87b2:	a1 2f       	mov	r26, r17
    87b4:	b0 2f       	mov	r27, r16
    87b6:	fd 01       	movw	r30, r26
    87b8:	01 90       	ld	r0, Z+
    87ba:	00 20       	and	r0, r0
    87bc:	e9 f7       	brne	.-6      	; 0x87b8 <__RODATA_PM_OFFSET__+0x7b8>
    87be:	31 97       	sbiw	r30, 0x01	; 1
    87c0:	ea 1b       	sub	r30, r26
    87c2:	fb 0b       	sbc	r31, r27
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:77
                            strlen(env)/* %s x 2 */
    87c4:	89 2f       	mov	r24, r25
    87c6:	c7 5d       	subi	r28, 0xD7	; 215
    87c8:	de 4f       	sbci	r29, 0xFE	; 254
    87ca:	98 81       	ld	r25, Y
    87cc:	c9 52       	subi	r28, 0x29	; 41
    87ce:	d1 40       	sbci	r29, 0x01	; 1
    87d0:	dc 01       	movw	r26, r24
    87d2:	0d 90       	ld	r0, X+
    87d4:	00 20       	and	r0, r0
    87d6:	e9 f7       	brne	.-6      	; 0x87d2 <__RODATA_PM_OFFSET__+0x7d2>
    87d8:	11 97       	sbiw	r26, 0x01	; 1
    87da:	9d 01       	movw	r18, r26
    87dc:	28 1b       	sub	r18, r24
    87de:	39 0b       	sbc	r19, r25
    87e0:	c9 01       	movw	r24, r18
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:76

static IotclDiscoveryResponse *run_http_discovery(const char *cpid, const char *env) {
    char *json_start = NULL;
    IotclDiscoveryResponse *ret = NULL;
    char *path_buff = (char *) malloc(sizeof(HTTP_DISCOVERY_PATH_FORMAT) +
                            strlen(cpid) +
    87e2:	8e 0f       	add	r24, r30
    87e4:	9f 1f       	adc	r25, r31
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:78
                            strlen(env)/* %s x 2 */
    );
    87e6:	89 96       	adiw	r24, 0x29	; 41
    87e8:	0e 94 b8 54 	call	0xa970	; 0xa970 <malloc>
    87ec:	7c 01       	movw	r14, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:80

    sprintf(path_buff, HTTP_DISCOVERY_PATH_FORMAT, cpid, env);
    87ee:	c7 5d       	subi	r28, 0xD7	; 215
    87f0:	de 4f       	sbci	r29, 0xFE	; 254
    87f2:	38 81       	ld	r19, Y
    87f4:	c9 52       	subi	r28, 0x29	; 41
    87f6:	d1 40       	sbci	r29, 0x01	; 1
    87f8:	3f 93       	push	r19
    87fa:	c8 5d       	subi	r28, 0xD8	; 216
    87fc:	de 4f       	sbci	r29, 0xFE	; 254
    87fe:	88 81       	ld	r24, Y
    8800:	c8 52       	subi	r28, 0x28	; 40
    8802:	d1 40       	sbci	r29, 0x01	; 1
    8804:	8f 93       	push	r24
    8806:	0f 93       	push	r16
    8808:	1f 93       	push	r17
    880a:	8e ed       	ldi	r24, 0xDE	; 222
    880c:	98 e5       	ldi	r25, 0x58	; 88
    880e:	9f 93       	push	r25
    8810:	8f 93       	push	r24
    8812:	ff 92       	push	r15
    8814:	ef 92       	push	r14
    8816:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:82

    IotConnectHttpResponse response = {0};
    881a:	19 82       	std	Y+1, r1	; 0x01
    881c:	1a 82       	std	Y+2, r1	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:84

    iotconnect_https_request(
    881e:	30 e0       	ldi	r19, 0x00	; 0
    8820:	20 e0       	ldi	r18, 0x00	; 0
    8822:	a7 01       	movw	r20, r14
    8824:	67 e0       	ldi	r22, 0x07	; 7
    8826:	79 e5       	ldi	r23, 0x59	; 89
    8828:	de 01       	movw	r26, r28
    882a:	11 96       	adiw	r26, 0x01	; 1
    882c:	6d 01       	movw	r12, r26
    882e:	cd 01       	movw	r24, r26
    8830:	0e 94 9a 23 	call	0x4734	; 0x4734 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:91
        IOTCONNECT_DISCOVERY_HOSTNAME,
        path_buff,
        NULL
    );

    free(path_buff);
    8834:	c7 01       	movw	r24, r14
    8836:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:93

    if (NULL == response.data) {
    883a:	e9 80       	ldd	r14, Y+1	; 0x01
    883c:	fa 80       	ldd	r15, Y+2	; 0x02
    883e:	ed b7       	in	r30, 0x3d	; 61
    8840:	fe b7       	in	r31, 0x3e	; 62
    8842:	38 96       	adiw	r30, 0x08	; 8
    8844:	ed bf       	out	0x3d, r30	; 61
    8846:	fe bf       	out	0x3e, r31	; 62
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:94
        dump_response("Unable to parse HTTP response,", &response);
    8848:	b6 01       	movw	r22, r12
    884a:	8f e1       	ldi	r24, 0x1F	; 31
    884c:	99 e5       	ldi	r25, 0x59	; 89
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:93
        NULL
    );

    free(path_buff);

    if (NULL == response.data) {
    884e:	e1 14       	cp	r14, r1
    8850:	f1 04       	cpc	r15, r1
    8852:	59 f0       	breq	.+22     	; 0x886a <__RODATA_PM_OFFSET__+0x86a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:97
        dump_response("Unable to parse HTTP response,", &response);
        goto cleanup;
    }
    json_start = strstr(response.data, "{");
    8854:	6b e7       	ldi	r22, 0x7B	; 123
    8856:	70 e0       	ldi	r23, 0x00	; 0
    8858:	c7 01       	movw	r24, r14
    885a:	0e 94 e9 56 	call	0xadd2	; 0xadd2 <strchr>
    885e:	8c 01       	movw	r16, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:98
    if (NULL == json_start) {
    8860:	00 97       	sbiw	r24, 0x00	; 0
    8862:	41 f4       	brne	.+16     	; 0x8874 <__RODATA_PM_OFFSET__+0x874>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:99
        dump_response("No json response from server.", &response);
    8864:	b6 01       	movw	r22, r12
    8866:	8e e3       	ldi	r24, 0x3E	; 62
    8868:	99 e5       	ldi	r25, 0x59	; 89
    886a:	0e 94 8a 0c 	call	0x1914	; 0x1914 <dump_response(char const*, IotConnectHttpResponse*)>
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:106
    }
    if (json_start != response.data) {
        dump_response("WARN: Expected JSON to start immediately in the returned data.", &response);
    }

    ret = iotcl_discovery_parse_discovery_response(json_start);
    886e:	10 e0       	ldi	r17, 0x00	; 0
    8870:	00 e0       	ldi	r16, 0x00	; 0
    8872:	b2 c0       	rjmp	.+356    	; 0x89d8 <__RODATA_PM_OFFSET__+0x9d8>
run_http_discovery():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:102
    json_start = strstr(response.data, "{");
    if (NULL == json_start) {
        dump_response("No json response from server.", &response);
        goto cleanup;
    }
    if (json_start != response.data) {
    8874:	e8 16       	cp	r14, r24
    8876:	f9 06       	cpc	r15, r25
    8878:	29 f0       	breq	.+10     	; 0x8884 <__RODATA_PM_OFFSET__+0x884>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:103
        dump_response("WARN: Expected JSON to start immediately in the returned data.", &response);
    887a:	b6 01       	movw	r22, r12
    887c:	8c e5       	ldi	r24, 0x5C	; 92
    887e:	99 e5       	ldi	r25, 0x59	; 89
    8880:	0e 94 8a 0c 	call	0x1914	; 0x1914 <dump_response(char const*, IotConnectHttpResponse*)>
iotcl_discovery_parse_discovery_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:59

    return (response->host && response->path);
}

IotclDiscoveryResponse *iotcl_discovery_parse_discovery_response(const char *response_data) {
    cJSON *json_root = cJSON_Parse(response_data);
    8884:	c8 01       	movw	r24, r16
    8886:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <cJSON_Parse>
    888a:	7c 01       	movw	r14, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:60
    if (!json_root) {
    888c:	00 97       	sbiw	r24, 0x00	; 0
    888e:	51 f0       	breq	.+20     	; 0x88a4 <__RODATA_PM_OFFSET__+0x8a4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:64
        return NULL;
    }

    cJSON *base_url_cjson = cJSON_GetObjectItem(json_root, "baseUrl");
    8890:	6b e9       	ldi	r22, 0x9B	; 155
    8892:	79 e5       	ldi	r23, 0x59	; 89
    8894:	0e 94 b2 2a 	call	0x5564	; 0x5564 <cJSON_GetObjectItem>
    8898:	4c 01       	movw	r8, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:65
    if (!base_url_cjson) {
    889a:	89 2b       	or	r24, r25
    889c:	01 f5       	brne	.+64     	; 0x88de <__RODATA_PM_OFFSET__+0x8de>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:66
        cJSON_Delete(json_root);
    889e:	c7 01       	movw	r24, r14
    88a0:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
run_http_discovery():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:108
    }

    ret = iotcl_discovery_parse_discovery_response(json_start);
    if (!ret) {
        Log.errorf("Error: Unable to get discovery response for environment \"%s\"."
    88a4:	c7 5d       	subi	r28, 0xD7	; 215
    88a6:	de 4f       	sbci	r29, 0xFE	; 254
    88a8:	b8 81       	ld	r27, Y
    88aa:	c9 52       	subi	r28, 0x29	; 41
    88ac:	d1 40       	sbci	r29, 0x01	; 1
    88ae:	bf 93       	push	r27
    88b0:	c8 5d       	subi	r28, 0xD8	; 216
    88b2:	de 4f       	sbci	r29, 0xFE	; 254
    88b4:	e8 81       	ld	r30, Y
    88b6:	c8 52       	subi	r28, 0x28	; 40
    88b8:	d1 40       	sbci	r29, 0x01	; 1
    88ba:	ef 93       	push	r30
    88bc:	83 ea       	ldi	r24, 0xA3	; 163
    88be:	99 e5       	ldi	r25, 0x59	; 89
    88c0:	9f 93       	push	r25
    88c2:	8f 93       	push	r24
    88c4:	89 e6       	ldi	r24, 0x69	; 105
    88c6:	90 e7       	ldi	r25, 0x70	; 112
    88c8:	9f 93       	push	r25
    88ca:	8f 93       	push	r24
    88cc:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    88d0:	0f 90       	pop	r0
    88d2:	0f 90       	pop	r0
    88d4:	0f 90       	pop	r0
    88d6:	0f 90       	pop	r0
    88d8:	0f 90       	pop	r0
    88da:	0f 90       	pop	r0
    88dc:	c8 cf       	rjmp	.-112    	; 0x886e <__RODATA_PM_OFFSET__+0x86e>
iotcl_discovery_parse_discovery_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:70
        return NULL;
    }

    IotclDiscoveryResponse *response = (IotclDiscoveryResponse *) calloc(1, sizeof(IotclDiscoveryResponse));
    88de:	66 e0       	ldi	r22, 0x06	; 6
    88e0:	70 e0       	ldi	r23, 0x00	; 0
    88e2:	81 e0       	ldi	r24, 0x01	; 1
    88e4:	90 e0       	ldi	r25, 0x00	; 0
    88e6:	0e 94 9e 54 	call	0xa93c	; 0xa93c <calloc>
    88ea:	8c 01       	movw	r16, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:71
    if (!response) {
    88ec:	89 2b       	or	r24, r25
    88ee:	09 f4       	brne	.+2      	; 0x88f2 <__RODATA_PM_OFFSET__+0x8f2>
    88f0:	ef c0       	rjmp	.+478    	; 0x8ad0 <__RODATA_PM_OFFSET__+0xad0>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:76
        goto cleanup;
    }

    { // separate the declaration into a block to allow jump without warnings
        char *jsonBaseUrl = base_url_cjson->valuestring;
    88f2:	d4 01       	movw	r26, r8
    88f4:	18 96       	adiw	r26, 0x08	; 8
    88f6:	8d 91       	ld	r24, X+
    88f8:	9c 91       	ld	r25, X
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:77
        if (!jsonBaseUrl) {
    88fa:	00 97       	sbiw	r24, 0x00	; 0
    88fc:	09 f4       	brne	.+2      	; 0x8900 <__RODATA_PM_OFFSET__+0x900>
    88fe:	e8 c0       	rjmp	.+464    	; 0x8ad0 <__RODATA_PM_OFFSET__+0xad0>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:81
            goto cleanup;
        }

        response->url = iotcl_strdup(jsonBaseUrl);
    8900:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <iotcl_strdup>
    8904:	f8 01       	movw	r30, r16
    8906:	80 83       	st	Z, r24
    8908:	91 83       	std	Z+1, r25	; 0x01
split_url():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:29
    }
    return iotcl_strdup(str_value);
}

static bool split_url(IotclDiscoveryResponse *response) {
    size_t base_url_len = strlen(response->url);
    890a:	fc 01       	movw	r30, r24
    890c:	01 90       	ld	r0, Z+
    890e:	00 20       	and	r0, r0
    8910:	e9 f7       	brne	.-6      	; 0x890c <__RODATA_PM_OFFSET__+0x90c>
    8912:	31 97       	sbiw	r30, 0x01	; 1
    8914:	1f 01       	movw	r2, r30
    8916:	28 1a       	sub	r2, r24
    8918:	39 0a       	sbc	r3, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:33


    // mutable version that will allow us to modify the url string
    char *base_url_copy = iotcl_strdup(response->url);
    891a:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <iotcl_strdup>
    891e:	4c 01       	movw	r8, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:34
    if (!base_url_copy) {
    8920:	00 97       	sbiw	r24, 0x00	; 0
    8922:	09 f4       	brne	.+2      	; 0x8926 <__RODATA_PM_OFFSET__+0x926>
    8924:	d5 c0       	rjmp	.+426    	; 0x8ad0 <__RODATA_PM_OFFSET__+0xad0>
    8926:	ac 01       	movw	r20, r24
    8928:	42 0d       	add	r20, r2
    892a:	53 1d       	adc	r21, r3
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:37
        return false;
    }
    int num_found = 0;
    892c:	30 e0       	ldi	r19, 0x00	; 0
    892e:	20 e0       	ldi	r18, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:38
    char *host = NULL;
    8930:	c6 5d       	subi	r28, 0xD6	; 214
    8932:	de 4f       	sbci	r29, 0xFE	; 254
    8934:	18 82       	st	Y, r1
    8936:	ca 52       	subi	r28, 0x2A	; 42
    8938:	d1 40       	sbci	r29, 0x01	; 1
    893a:	c5 5d       	subi	r28, 0xD5	; 213
    893c:	de 4f       	sbci	r29, 0xFE	; 254
    893e:	18 82       	st	Y, r1
    8940:	cb 52       	subi	r28, 0x2B	; 43
    8942:	d1 40       	sbci	r29, 0x01	; 1
split_url():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:39
    for (size_t i = 0; i < base_url_len; i++) {
    8944:	48 17       	cp	r20, r24
    8946:	59 07       	cpc	r21, r25
    8948:	09 f1       	breq	.+66     	; 0x898c <__RODATA_PM_OFFSET__+0x98c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:40
        if (base_url_copy[i] == '/') {
    894a:	1c 01       	movw	r2, r24
    894c:	01 96       	adiw	r24, 0x01	; 1
    894e:	d1 01       	movw	r26, r2
    8950:	6c 91       	ld	r22, X
    8952:	6f 32       	cpi	r22, 0x2F	; 47
    8954:	b9 f7       	brne	.-18     	; 0x8944 <__RODATA_PM_OFFSET__+0x944>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:41
            num_found++;
    8956:	2f 5f       	subi	r18, 0xFF	; 255
    8958:	3f 4f       	sbci	r19, 0xFF	; 255
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:42
            if (num_found == 2) {
    895a:	22 30       	cpi	r18, 0x02	; 2
    895c:	31 05       	cpc	r19, r1
    895e:	59 f4       	brne	.+22     	; 0x8976 <__RODATA_PM_OFFSET__+0x976>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:43
                host = &base_url_copy[i + 1];
    8960:	c6 5d       	subi	r28, 0xD6	; 214
    8962:	de 4f       	sbci	r29, 0xFE	; 254
    8964:	88 83       	st	Y, r24
    8966:	ca 52       	subi	r28, 0x2A	; 42
    8968:	d1 40       	sbci	r29, 0x01	; 1
    896a:	c5 5d       	subi	r28, 0xD5	; 213
    896c:	de 4f       	sbci	r29, 0xFE	; 254
    896e:	98 83       	st	Y, r25
    8970:	cb 52       	subi	r28, 0x2B	; 43
    8972:	d1 40       	sbci	r29, 0x01	; 1
    8974:	e7 cf       	rjmp	.-50     	; 0x8944 <__RODATA_PM_OFFSET__+0x944>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:45
                // host will be terminated below
            } else if (num_found == 3) {
    8976:	23 30       	cpi	r18, 0x03	; 3
    8978:	31 05       	cpc	r19, r1
    897a:	21 f7       	brne	.-56     	; 0x8944 <__RODATA_PM_OFFSET__+0x944>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:46
                response->path = iotcl_strdup(&base_url_copy[i]); // first make a copy
    897c:	c1 01       	movw	r24, r2
    897e:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <iotcl_strdup>
    8982:	f8 01       	movw	r30, r16
    8984:	84 83       	std	Z+4, r24	; 0x04
    8986:	95 83       	std	Z+5, r25	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:47
                base_url_copy[i] = 0; // then terminate host so that it can be duped below
    8988:	d1 01       	movw	r26, r2
    898a:	1c 92       	st	X, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:52
                break;
            }
        }
    }
    response->host = iotcl_strdup(host);
    898c:	c6 5d       	subi	r28, 0xD6	; 214
    898e:	de 4f       	sbci	r29, 0xFE	; 254
    8990:	88 81       	ld	r24, Y
    8992:	ca 52       	subi	r28, 0x2A	; 42
    8994:	d1 40       	sbci	r29, 0x01	; 1
    8996:	c5 5d       	subi	r28, 0xD5	; 213
    8998:	de 4f       	sbci	r29, 0xFE	; 254
    899a:	98 81       	ld	r25, Y
    899c:	cb 52       	subi	r28, 0x2B	; 43
    899e:	d1 40       	sbci	r29, 0x01	; 1
    89a0:	0e 94 ef 0f 	call	0x1fde	; 0x1fde <iotcl_strdup>
    89a4:	f8 01       	movw	r30, r16
    89a6:	82 83       	std	Z+2, r24	; 0x02
    89a8:	93 83       	std	Z+3, r25	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:53
    free(base_url_copy);
    89aa:	c4 01       	movw	r24, r8
    89ac:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:55

    return (response->host && response->path);
    89b0:	d8 01       	movw	r26, r16
    89b2:	12 96       	adiw	r26, 0x02	; 2
    89b4:	8d 91       	ld	r24, X+
    89b6:	9c 91       	ld	r25, X
    89b8:	13 97       	sbiw	r26, 0x03	; 3
    89ba:	89 2b       	or	r24, r25
    89bc:	41 f0       	breq	.+16     	; 0x89ce <__RODATA_PM_OFFSET__+0x9ce>
    89be:	91 e0       	ldi	r25, 0x01	; 1
    89c0:	14 96       	adiw	r26, 0x04	; 4
    89c2:	2d 91       	ld	r18, X+
    89c4:	3c 91       	ld	r19, X
    89c6:	23 2b       	or	r18, r19
    89c8:	09 f4       	brne	.+2      	; 0x89cc <__RODATA_PM_OFFSET__+0x9cc>
    89ca:	90 e0       	ldi	r25, 0x00	; 0
main():
    89cc:	69 2e       	mov	r6, r25
iotcl_discovery_parse_discovery_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:82
        if (!jsonBaseUrl) {
            goto cleanup;
        }

        response->url = iotcl_strdup(jsonBaseUrl);
        if (split_url(response)) {
    89ce:	60 fe       	sbrs	r6, 0
    89d0:	7f c0       	rjmp	.+254    	; 0x8ad0 <__RODATA_PM_OFFSET__+0xad0>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:83
            cJSON_Delete(json_root);
    89d2:	c7 01       	movw	r24, r14
    89d4:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
iotconnect_free_https_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:68
}


void iotconnect_free_https_response(IotConnectHttpResponse *response) {
    if (response->data) {
    89d8:	89 81       	ldd	r24, Y+1	; 0x01
    89da:	9a 81       	ldd	r25, Y+2	; 0x02
    89dc:	00 97       	sbiw	r24, 0x00	; 0
    89de:	11 f0       	breq	.+4      	; 0x89e4 <__RODATA_PM_OFFSET__+0x9e4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:69
        free(response->data);
    89e0:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
iotconnect_sdk_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:241
    if (mqtt_config.sr) {
        iotcl_discovery_free_sync_response(mqtt_config.sr);
        mqtt_config.sr = NULL;
    }
    IotclDiscoveryResponse *discovery_response = run_http_discovery(config.cpid, config.env);
    IotclSyncResponse *sr = run_http_sync(discovery_response, config.cpid, config.duid);
    89e4:	70 90 f8 65 	lds	r7, 0x65F8	; 0x8065f8 <config+0x4>
    89e8:	60 90 f9 65 	lds	r6, 0x65F9	; 0x8065f9 <config+0x5>
    89ec:	90 90 f6 65 	lds	r9, 0x65F6	; 0x8065f6 <config+0x2>
    89f0:	80 90 f7 65 	lds	r8, 0x65F7	; 0x8065f7 <config+0x3>
run_http_sync():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:123
}

static IotclSyncResponse *run_http_sync(IotclDiscoveryResponse* dr, const char *cpid, const char *uniqueid) {
    char *json_start = NULL;
    IotclSyncResponse *ret = NULL;
    char *post_data = (char *)malloc(IOTCONNECT_DISCOVERY_PROTOCOL_POST_DATA_MAX_LEN + 1);
    89f4:	89 e0       	ldi	r24, 0x09	; 9
    89f6:	91 e0       	ldi	r25, 0x01	; 1
    89f8:	0e 94 b8 54 	call	0xa970	; 0xa970 <malloc>
    89fc:	7c 01       	movw	r14, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:125

    if (!post_data) {
    89fe:	89 2b       	or	r24, r25
    8a00:	09 f0       	breq	.+2      	; 0x8a04 <__RODATA_PM_OFFSET__+0xa04>
    8a02:	6d c0       	rjmp	.+218    	; 0x8ade <__RODATA_PM_OFFSET__+0xade>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:126
        Log.error("run_http_sync: Out of memory!");
    8a04:	86 e1       	ldi	r24, 0x16	; 22
    8a06:	9a e5       	ldi	r25, 0x5A	; 90
    8a08:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:127
        return NULL;
    8a0c:	f1 2c       	mov	r15, r1
    8a0e:	e1 2c       	mov	r14, r1
iotconnect_sdk_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:242
        iotcl_discovery_free_sync_response(mqtt_config.sr);
        mqtt_config.sr = NULL;
    }
    IotclDiscoveryResponse *discovery_response = run_http_discovery(config.cpid, config.env);
    IotclSyncResponse *sr = run_http_sync(discovery_response, config.cpid, config.duid);
    iotcl_discovery_free_discovery_response(discovery_response); // we no longer need it
    8a10:	c8 01       	movw	r24, r16
    8a12:	0e 94 8a 09 	call	0x1314	; 0x1314 <iotcl_discovery_free_discovery_response>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:243
    if (NULL == sr) {
    8a16:	e1 14       	cp	r14, r1
    8a18:	f1 04       	cpc	r15, r1
    8a1a:	09 f4       	brne	.+2      	; 0x8a1e <__RODATA_PM_OFFSET__+0xa1e>
    8a1c:	8c ce       	rjmp	.-744    	; 0x8736 <__RODATA_PM_OFFSET__+0x736>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:247
        // Sync_call will print the error
        return false;
    }
    mqtt_config.sr = sr;
    8a1e:	e0 92 4e 64 	sts	0x644E, r14	; 0x80644e <mqtt_config>
    8a22:	f0 92 4f 64 	sts	0x644F, r15	; 0x80644f <mqtt_config+0x1>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:248
    lib_config.device.env = config.env;
    8a26:	80 91 f4 65 	lds	r24, 0x65F4	; 0x8065f4 <config>
    8a2a:	90 91 f5 65 	lds	r25, 0x65F5	; 0x8065f5 <config+0x1>
    8a2e:	80 93 42 64 	sts	0x6442, r24	; 0x806442 <lib_config+0x4>
    8a32:	90 93 43 64 	sts	0x6443, r25	; 0x806443 <lib_config+0x5>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:249
    lib_config.device.cpid = config.cpid;
    8a36:	80 91 f6 65 	lds	r24, 0x65F6	; 0x8065f6 <config+0x2>
    8a3a:	90 91 f7 65 	lds	r25, 0x65F7	; 0x8065f7 <config+0x3>
    8a3e:	80 93 40 64 	sts	0x6440, r24	; 0x806440 <lib_config+0x2>
    8a42:	90 93 41 64 	sts	0x6441, r25	; 0x806441 <lib_config+0x3>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:250
    lib_config.device.duid = config.duid;
    8a46:	80 91 f8 65 	lds	r24, 0x65F8	; 0x8065f8 <config+0x4>
    8a4a:	90 91 f9 65 	lds	r25, 0x65F9	; 0x8065f9 <config+0x5>
    8a4e:	80 93 3e 64 	sts	0x643E, r24	; 0x80643e <lib_config>
    8a52:	90 93 3f 64 	sts	0x643F, r25	; 0x80643f <lib_config+0x1>
iotc_get_time_modem():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:126
}

time_t iotc_get_time_modem(void) {
    // If low power is utilized, sequans controller will already been
    // initialized, so don't reset it by calling begin again
    if (!SequansController.isInitialized()) {
    8a56:	80 91 91 66 	lds	r24, 0x6691	; 0x806691 <initialized>
    8a5a:	81 11       	cpse	r24, r1
    8a5c:	02 c0       	rjmp	.+4      	; 0x8a62 <__RODATA_PM_OFFSET__+0xa62>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:127
        SequansController.begin();
    8a5e:	0e 94 fd 27 	call	0x4ffa	; 0x4ffa <SequansControllerClass::begin() [clone .constprop.87]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:130
    }

    char response_buffer[64] = "";
    8a62:	19 82       	std	Y+1, r1	; 0x01
    8a64:	1a 82       	std	Y+2, r1	; 0x02
    8a66:	fe 01       	movw	r30, r28
    8a68:	33 96       	adiw	r30, 0x03	; 3
    8a6a:	8e e3       	ldi	r24, 0x3E	; 62
    8a6c:	df 01       	movw	r26, r30
    8a6e:	1d 92       	st	X+, r1
    8a70:	8a 95       	dec	r24
    8a72:	e9 f7       	brne	.-6      	; 0x8a6e <__RODATA_PM_OFFSET__+0xa6e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:131
    char value_buffer[32] = "";
    8a74:	e7 56       	subi	r30, 0x67	; 103
    8a76:	ff 4f       	sbci	r31, 0xFF	; 255
    8a78:	11 92       	st	Z+, r1
    8a7a:	11 92       	st	Z+, r1
    8a7c:	8e e1       	ldi	r24, 0x1E	; 30
    8a7e:	df 01       	movw	r26, r30
    8a80:	1d 92       	st	X+, r1
    8a82:	8a 95       	dec	r24
    8a84:	e9 f7       	brne	.-6      	; 0x8a80 <__RODATA_PM_OFFSET__+0xa80>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:133

    ResponseResult res = SequansController.writeCommand( "AT+CCLK?", response_buffer, sizeof(response_buffer));
    8a86:	40 e4       	ldi	r20, 0x40	; 64
    8a88:	50 e0       	ldi	r21, 0x00	; 0
    8a8a:	b6 01       	movw	r22, r12
    8a8c:	88 e1       	ldi	r24, 0x18	; 24
    8a8e:	97 e5       	ldi	r25, 0x57	; 87
    8a90:	0e 94 17 18 	call	0x302e	; 0x302e <SequansControllerClass::writeCommand(char const*, char*, unsigned int) [clone .constprop.98]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:134
    if (res != ResponseResult::OK) {
    8a94:	01 97       	sbiw	r24, 0x01	; 1
    8a96:	09 f4       	brne	.+2      	; 0x8a9a <__RODATA_PM_OFFSET__+0xa9a>
    8a98:	e7 c1       	rjmp	.+974    	; 0x8e68 <__RODATA_PM_OFFSET__+0xe68>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:135
        Log.error("Failed to retrieve successful response time from the modem");
    8a9a:	8c e5       	ldi	r24, 0x5C	; 92
    8a9c:	9d e5       	ldi	r25, 0x5D	; 93
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:144
    if (!SequansController.extractValueFromCommandResponse(
        response_buffer,
        0,
        value_buffer,
        sizeof(value_buffer))) {
            Log.error("Failed to retrieve time from the modem");
    8a9e:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
iotconnect_sdk_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:254

    iotc_get_time_modem();

    if (!config.env || !config.cpid || !config.duid) {
    8aa2:	80 91 f4 65 	lds	r24, 0x65F4	; 0x8065f4 <config>
    8aa6:	90 91 f5 65 	lds	r25, 0x65F5	; 0x8065f5 <config+0x1>
    8aaa:	89 2b       	or	r24, r25
    8aac:	71 f0       	breq	.+28     	; 0x8aca <__RODATA_PM_OFFSET__+0xaca>
    8aae:	60 91 f6 65 	lds	r22, 0x65F6	; 0x8065f6 <config+0x2>
    8ab2:	70 91 f7 65 	lds	r23, 0x65F7	; 0x8065f7 <config+0x3>
    8ab6:	61 15       	cp	r22, r1
    8ab8:	71 05       	cpc	r23, r1
    8aba:	39 f0       	breq	.+14     	; 0x8aca <__RODATA_PM_OFFSET__+0xaca>
    8abc:	80 91 f8 65 	lds	r24, 0x65F8	; 0x8065f8 <config+0x4>
    8ac0:	90 91 f9 65 	lds	r25, 0x65F9	; 0x8065f9 <config+0x5>
    8ac4:	89 2b       	or	r24, r25
    8ac6:	09 f0       	breq	.+2      	; 0x8aca <__RODATA_PM_OFFSET__+0xaca>
    8ac8:	1c c3       	rjmp	.+1592   	; 0x9102 <__RODATA_PM_OFFSET__+0x1102>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:255
        Log.error("Error: Device configuration is invalid. Configuration values for env, cpid and duid are required.");
    8aca:	82 e3       	ldi	r24, 0x32	; 50
    8acc:	9e e5       	ldi	r25, 0x5E	; 94
    8ace:	31 ce       	rjmp	.-926    	; 0x8732 <__RODATA_PM_OFFSET__+0x732>
iotcl_discovery_parse_discovery_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:90
        } // else cleanup and return null

    }

    cleanup:
    cJSON_Delete(json_root);
    8ad0:	c7 01       	movw	r24, r14
    8ad2:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:91
    iotcl_discovery_free_discovery_response(response);
    8ad6:	c8 01       	movw	r24, r16
    8ad8:	0e 94 8a 09 	call	0x1314	; 0x1314 <iotcl_discovery_free_discovery_response>
    8adc:	e3 ce       	rjmp	.-570    	; 0x88a4 <__RODATA_PM_OFFSET__+0x8a4>
run_http_sync():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:130
    if (!post_data) {
        Log.error("run_http_sync: Out of memory!");
        return NULL;
    }

    snprintf(post_data,
    8ade:	6f 92       	push	r6
    8ae0:	7f 92       	push	r7
    8ae2:	8f 92       	push	r8
    8ae4:	9f 92       	push	r9
    8ae6:	84 e3       	ldi	r24, 0x34	; 52
    8ae8:	9a e5       	ldi	r25, 0x5A	; 90
    8aea:	9f 93       	push	r25
    8aec:	8f 93       	push	r24
    8aee:	81 e0       	ldi	r24, 0x01	; 1
    8af0:	8f 93       	push	r24
    8af2:	88 e0       	ldi	r24, 0x08	; 8
    8af4:	8f 93       	push	r24
    8af6:	ff 92       	push	r15
    8af8:	ef 92       	push	r14
    8afa:	0e 94 83 57 	call	0xaf06	; 0xaf06 <snprintf>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:137
             IOTCONNECT_DISCOVERY_PROTOCOL_POST_DATA_TEMPLATE,
             cpid,
             uniqueid
    );

    char * path = (char *) malloc(strlen(dr->path) + 5 /* "sync?" */ + 1/* null*/);
    8afe:	d8 01       	movw	r26, r16
    8b00:	14 96       	adiw	r26, 0x04	; 4
    8b02:	6d 90       	ld	r6, X+
    8b04:	7c 90       	ld	r7, X
    8b06:	f3 01       	movw	r30, r6
    8b08:	01 90       	ld	r0, Z+
    8b0a:	00 20       	and	r0, r0
    8b0c:	e9 f7       	brne	.-6      	; 0x8b08 <__RODATA_PM_OFFSET__+0xb08>
    8b0e:	cf 01       	movw	r24, r30
    8b10:	86 19       	sub	r24, r6
    8b12:	97 09       	sbc	r25, r7
    8b14:	05 96       	adiw	r24, 0x05	; 5
    8b16:	0e 94 b8 54 	call	0xa970	; 0xa970 <malloc>
    8b1a:	4c 01       	movw	r8, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:138
    strcpy(path, dr->path);
    8b1c:	b3 01       	movw	r22, r6
    8b1e:	0e 94 fd 56 	call	0xadfa	; 0xadfa <strcpy>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:139
    strcat(path, "sync?");
    8b22:	6d eb       	ldi	r22, 0xBD	; 189
    8b24:	7a e5       	ldi	r23, 0x5A	; 90
    8b26:	c4 01       	movw	r24, r8
    8b28:	0e 94 de 56 	call	0xadbc	; 0xadbc <strcat>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:140
    IotConnectHttpResponse response = {0};
    8b2c:	19 82       	std	Y+1, r1	; 0x01
    8b2e:	1a 82       	std	Y+2, r1	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:141
    iotconnect_https_request(
    8b30:	d8 01       	movw	r26, r16
    8b32:	12 96       	adiw	r26, 0x02	; 2
    8b34:	6d 91       	ld	r22, X+
    8b36:	7c 91       	ld	r23, X
    8b38:	97 01       	movw	r18, r14
    8b3a:	a4 01       	movw	r20, r8
    8b3c:	c6 01       	movw	r24, r12
    8b3e:	0e 94 9a 23 	call	0x4734	; 0x4734 <iotconnect_https_request(IotConnectHttpResponse*, char const*, char const*, char const*) [clone .constprop.67]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:148
        dr->host,
        path,
        post_data
    );

    free(path);
    8b42:	c4 01       	movw	r24, r8
    8b44:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:149
    free(post_data);
    8b48:	c7 01       	movw	r24, r14
    8b4a:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:151

    if (NULL == response.data) {
    8b4e:	e9 80       	ldd	r14, Y+1	; 0x01
    8b50:	fa 80       	ldd	r15, Y+2	; 0x02
    8b52:	ed b7       	in	r30, 0x3d	; 61
    8b54:	fe b7       	in	r31, 0x3e	; 62
    8b56:	3a 96       	adiw	r30, 0x0a	; 10
    8b58:	ed bf       	out	0x3d, r30	; 61
    8b5a:	fe bf       	out	0x3e, r31	; 62
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:152
        dump_response("Unable to parse HTTP response.", &response);
    8b5c:	b6 01       	movw	r22, r12
    8b5e:	83 ec       	ldi	r24, 0xC3	; 195
    8b60:	9a e5       	ldi	r25, 0x5A	; 90
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:151
    );

    free(path);
    free(post_data);

    if (NULL == response.data) {
    8b62:	e1 14       	cp	r14, r1
    8b64:	f1 04       	cpc	r15, r1
    8b66:	59 f0       	breq	.+22     	; 0x8b7e <__RODATA_PM_OFFSET__+0xb7e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:155
        dump_response("Unable to parse HTTP response.", &response);
        goto cleanup;
    }
    json_start = strstr(response.data, "{");
    8b68:	6b e7       	ldi	r22, 0x7B	; 123
    8b6a:	70 e0       	ldi	r23, 0x00	; 0
    8b6c:	c7 01       	movw	r24, r14
    8b6e:	0e 94 e9 56 	call	0xadd2	; 0xadd2 <strchr>
    8b72:	4c 01       	movw	r8, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:156
    if (NULL == json_start) {
    8b74:	00 97       	sbiw	r24, 0x00	; 0
    8b76:	41 f4       	brne	.+16     	; 0x8b88 <__RODATA_PM_OFFSET__+0xb88>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:157
        dump_response("No json response from server.", &response);
    8b78:	b6 01       	movw	r22, r12
    8b7a:	8e e3       	ldi	r24, 0x3E	; 62
    8b7c:	99 e5       	ldi	r25, 0x59	; 89
    8b7e:	0e 94 8a 0c 	call	0x1914	; 0x1914 <dump_response(char const*, IotConnectHttpResponse*)>
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:168

    ret = iotcl_discovery_parse_sync_response(json_start);
    if (!ret || ret->ds != IOTCL_SR_OK) {
        report_sync_error(ret, response.data);
        iotcl_discovery_free_sync_response(ret);
        ret = NULL;
    8b82:	f1 2c       	mov	r15, r1
    8b84:	e1 2c       	mov	r14, r1
    8b86:	31 c1       	rjmp	.+610    	; 0x8dea <__RODATA_PM_OFFSET__+0xdea>
run_http_sync():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:160
    json_start = strstr(response.data, "{");
    if (NULL == json_start) {
        dump_response("No json response from server.", &response);
        goto cleanup;
    }
    if (json_start != response.data) {
    8b88:	e8 16       	cp	r14, r24
    8b8a:	f9 06       	cpc	r15, r25
    8b8c:	29 f0       	breq	.+10     	; 0x8b98 <__RODATA_PM_OFFSET__+0xb98>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:161
        dump_response("WARN: Expected JSON to start immediately in the returned data.", &response);
    8b8e:	b6 01       	movw	r22, r12
    8b90:	8c e5       	ldi	r24, 0x5C	; 92
    8b92:	99 e5       	ldi	r25, 0x59	; 89
    8b94:	0e 94 8a 0c 	call	0x1914	; 0x1914 <dump_response(char const*, IotConnectHttpResponse*)>
iotcl_discovery_parse_sync_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:106
    }
}

IotclSyncResponse *iotcl_discovery_parse_sync_response(const char *response_data) {
    cJSON *tmp_value = NULL;
    IotclSyncResponse *response = (IotclSyncResponse *) calloc(1, sizeof(IotclSyncResponse));
    8b98:	6a e1       	ldi	r22, 0x1A	; 26
    8b9a:	70 e0       	ldi	r23, 0x00	; 0
    8b9c:	81 e0       	ldi	r24, 0x01	; 1
    8b9e:	90 e0       	ldi	r25, 0x00	; 0
    8ba0:	0e 94 9e 54 	call	0xa93c	; 0xa93c <calloc>
    8ba4:	7c 01       	movw	r14, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:107
    if (NULL == response) {
    8ba6:	89 2b       	or	r24, r25
    8ba8:	09 f4       	brne	.+2      	; 0x8bac <__RODATA_PM_OFFSET__+0xbac>
    8baa:	1b c1       	rjmp	.+566    	; 0x8de2 <__RODATA_PM_OFFSET__+0xde2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:111
        return NULL;
    }

    cJSON *sync_json_root = cJSON_Parse(response_data);
    8bac:	c4 01       	movw	r24, r8
    8bae:	0e 94 8d 2f 	call	0x5f1a	; 0x5f1a <cJSON_Parse>
    8bb2:	3c 01       	movw	r6, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:112
    if (!sync_json_root) {
    8bb4:	00 97       	sbiw	r24, 0x00	; 0
    8bb6:	09 f0       	breq	.+2      	; 0x8bba <__RODATA_PM_OFFSET__+0xbba>
    8bb8:	2c c0       	rjmp	.+88     	; 0x8c12 <__RODATA_PM_OFFSET__+0xc12>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:113
        response->ds = IOTCL_SR_PARSING_ERROR;
    8bba:	86 e1       	ldi	r24, 0x16	; 22
    8bbc:	90 e0       	ldi	r25, 0x00	; 0
    8bbe:	d7 01       	movw	r26, r14
    8bc0:	8d 93       	st	X+, r24
    8bc2:	9c 93       	st	X, r25
run_http_sync():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:165
    }

    ret = iotcl_discovery_parse_sync_response(json_start);
    if (!ret || ret->ds != IOTCL_SR_OK) {
    8bc4:	d7 01       	movw	r26, r14
    8bc6:	ed 91       	ld	r30, X+
    8bc8:	fc 91       	ld	r31, X
    8bca:	89 80       	ldd	r8, Y+1	; 0x01
    8bcc:	9a 80       	ldd	r9, Y+2	; 0x02
    8bce:	30 97       	sbiw	r30, 0x00	; 0
    8bd0:	09 f4       	brne	.+2      	; 0x8bd4 <__RODATA_PM_OFFSET__+0xbd4>
    8bd2:	0b c1       	rjmp	.+534    	; 0x8dea <__RODATA_PM_OFFSET__+0xdea>
report_sync_error():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:37
static void report_sync_error(IotclSyncResponse *response, const char *sync_response_str) {
    if (NULL == response) {
        Log.error("Failed to obtain sync response");
        return;
    }
    switch (response->ds) {
    8bd4:	31 97       	sbiw	r30, 0x01	; 1
    8bd6:	e6 31       	cpi	r30, 0x16	; 22
    8bd8:	f1 05       	cpc	r31, r1
    8bda:	08 f0       	brcs	.+2      	; 0x8bde <__RODATA_PM_OFFSET__+0xbde>
    8bdc:	40 c1       	rjmp	.+640    	; 0x8e5e <__RODATA_PM_OFFSET__+0xe5e>
    8bde:	ed 50       	subi	r30, 0x0D	; 13
    8be0:	fa 4b       	sbci	r31, 0xBA	; 186
    8be2:	0c 94 95 54 	jmp	0xa92a	; 0xa92a <__tablejump2__>
    8be6:	fd 46       	sbci	r31, 0x6D	; 109
    8be8:	17 47       	sbci	r17, 0x77	; 119
    8bea:	1a 47       	sbci	r17, 0x7A	; 122
    8bec:	1d 47       	sbci	r17, 0x7D	; 125
    8bee:	20 47       	sbci	r18, 0x70	; 112
    8bf0:	23 47       	sbci	r18, 0x73	; 115
    8bf2:	2f 47       	sbci	r18, 0x7F	; 127
    8bf4:	2f 47       	sbci	r18, 0x7F	; 127
    8bf6:	2f 47       	sbci	r18, 0x7F	; 127
    8bf8:	2f 47       	sbci	r18, 0x7F	; 127
    8bfa:	2f 47       	sbci	r18, 0x7F	; 127
    8bfc:	2f 47       	sbci	r18, 0x7F	; 127
    8bfe:	2f 47       	sbci	r18, 0x7F	; 127
    8c00:	2f 47       	sbci	r18, 0x7F	; 127
    8c02:	2f 47       	sbci	r18, 0x7F	; 127
    8c04:	2f 47       	sbci	r18, 0x7F	; 127
    8c06:	2f 47       	sbci	r18, 0x7F	; 127
    8c08:	2f 47       	sbci	r18, 0x7F	; 127
    8c0a:	2f 47       	sbci	r18, 0x7F	; 127
    8c0c:	26 47       	sbci	r18, 0x76	; 118
    8c0e:	29 47       	sbci	r18, 0x79	; 121
    8c10:	2c 47       	sbci	r18, 0x7C	; 124
iotcl_discovery_parse_sync_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:116
        return response;
    }
    cJSON *sync_res_json = cJSON_GetObjectItemCaseSensitive(sync_json_root, "d");
    8c12:	65 e8       	ldi	r22, 0x85	; 133
    8c14:	76 e4       	ldi	r23, 0x46	; 70
    8c16:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
    8c1a:	4c 01       	movw	r8, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:117
    if (!sync_res_json) {
    8c1c:	00 97       	sbiw	r24, 0x00	; 0
    8c1e:	49 f4       	brne	.+18     	; 0x8c32 <__RODATA_PM_OFFSET__+0xc32>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:118
        cJSON_Delete(sync_json_root);
    8c20:	c3 01       	movw	r24, r6
    8c22:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:119
        response->ds = IOTCL_SR_PARSING_ERROR;
    8c26:	86 e1       	ldi	r24, 0x16	; 22
    8c28:	90 e0       	ldi	r25, 0x00	; 0
    8c2a:	f7 01       	movw	r30, r14
    8c2c:	80 83       	st	Z, r24
    8c2e:	91 83       	std	Z+1, r25	; 0x01
    8c30:	c9 cf       	rjmp	.-110    	; 0x8bc4 <__RODATA_PM_OFFSET__+0xbc4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:122
        return response;
    }
    tmp_value = cJSON_GetObjectItem(sync_res_json, "ds");
    8c32:	62 ee       	ldi	r22, 0xE2	; 226
    8c34:	7a e5       	ldi	r23, 0x5A	; 90
    8c36:	0e 94 b2 2a 	call	0x5564	; 0x5564 <cJSON_GetObjectItem>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:123
    if (!tmp_value) {
    8c3a:	00 97       	sbiw	r24, 0x00	; 0
    8c3c:	09 f0       	breq	.+2      	; 0x8c40 <__RODATA_PM_OFFSET__+0xc40>
    8c3e:	ab c0       	rjmp	.+342    	; 0x8d96 <__RODATA_PM_OFFSET__+0xd96>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:124
        response->ds = IOTCL_SR_PARSING_ERROR;
    8c40:	86 e1       	ldi	r24, 0x16	; 22
    8c42:	90 e0       	ldi	r25, 0x00	; 0
    8c44:	d7 01       	movw	r26, r14
    8c46:	8d 93       	st	X+, r24
    8c48:	9c 93       	st	X, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:128
    } else {
        response->ds = cJSON_GetNumberValue(tmp_value);
    }
    if (response->ds == IOTCL_SR_OK) {
    8c4a:	f7 01       	movw	r30, r14
    8c4c:	80 81       	ld	r24, Z
    8c4e:	91 81       	ldd	r25, Z+1	; 0x01
    8c50:	00 97       	sbiw	r24, 0x00	; 0
    8c52:	09 f0       	breq	.+2      	; 0x8c56 <__RODATA_PM_OFFSET__+0xc56>
    8c54:	bb c0       	rjmp	.+374    	; 0x8dcc <__RODATA_PM_OFFSET__+0xdcc>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:129
        response->cpid = safe_get_string_and_strdup(sync_res_json, "cpId");
    8c56:	62 e7       	ldi	r22, 0x72	; 114
    8c58:	78 e4       	ldi	r23, 0x48	; 72
    8c5a:	c4 01       	movw	r24, r8
    8c5c:	0e 94 ca 2b 	call	0x5794	; 0x5794 <safe_get_string_and_strdup>
    8c60:	d7 01       	movw	r26, r14
    8c62:	12 96       	adiw	r26, 0x02	; 2
    8c64:	8d 93       	st	X+, r24
    8c66:	9c 93       	st	X, r25
    8c68:	13 97       	sbiw	r26, 0x03	; 3
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:130
        response->dtg = safe_get_string_and_strdup(sync_res_json, "dtg");
    8c6a:	65 ee       	ldi	r22, 0xE5	; 229
    8c6c:	7a e5       	ldi	r23, 0x5A	; 90
    8c6e:	c4 01       	movw	r24, r8
    8c70:	0e 94 ca 2b 	call	0x5794	; 0x5794 <safe_get_string_and_strdup>
    8c74:	f7 01       	movw	r30, r14
    8c76:	84 83       	std	Z+4, r24	; 0x04
    8c78:	95 83       	std	Z+5, r25	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:131
        tmp_value = cJSON_GetObjectItem(sync_res_json, "ee");
    8c7a:	69 ee       	ldi	r22, 0xE9	; 233
    8c7c:	7a e5       	ldi	r23, 0x5A	; 90
    8c7e:	c4 01       	movw	r24, r8
    8c80:	0e 94 b2 2a 	call	0x5564	; 0x5564 <cJSON_GetObjectItem>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:132
        if (!tmp_value) {
    8c84:	89 2b       	or	r24, r25
    8c86:	39 f4       	brne	.+14     	; 0x8c96 <__RODATA_PM_OFFSET__+0xc96>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:133
            response->ee = -1;
    8c88:	8f ef       	ldi	r24, 0xFF	; 255
    8c8a:	9f ef       	ldi	r25, 0xFF	; 255
    8c8c:	d7 01       	movw	r26, r14
    8c8e:	16 96       	adiw	r26, 0x06	; 6
    8c90:	8d 93       	st	X+, r24
    8c92:	9c 93       	st	X, r25
    8c94:	17 97       	sbiw	r26, 0x07	; 7
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:135
        }
        tmp_value = cJSON_GetObjectItem(sync_res_json, "rc");
    8c96:	6c ee       	ldi	r22, 0xEC	; 236
    8c98:	7a e5       	ldi	r23, 0x5A	; 90
    8c9a:	c4 01       	movw	r24, r8
    8c9c:	0e 94 b2 2a 	call	0x5564	; 0x5564 <cJSON_GetObjectItem>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:136
        if (!tmp_value) {
    8ca0:	89 2b       	or	r24, r25
    8ca2:	29 f4       	brne	.+10     	; 0x8cae <__RODATA_PM_OFFSET__+0xcae>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:137
            response->rc = -1;
    8ca4:	8f ef       	ldi	r24, 0xFF	; 255
    8ca6:	9f ef       	ldi	r25, 0xFF	; 255
    8ca8:	f7 01       	movw	r30, r14
    8caa:	80 87       	std	Z+8, r24	; 0x08
    8cac:	91 87       	std	Z+9, r25	; 0x09
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:139
        }
        tmp_value = cJSON_GetObjectItem(sync_res_json, "at");
    8cae:	6f ee       	ldi	r22, 0xEF	; 239
    8cb0:	7a e5       	ldi	r23, 0x5A	; 90
    8cb2:	c4 01       	movw	r24, r8
    8cb4:	0e 94 b2 2a 	call	0x5564	; 0x5564 <cJSON_GetObjectItem>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:140
        if (!tmp_value) {
    8cb8:	89 2b       	or	r24, r25
    8cba:	39 f4       	brne	.+14     	; 0x8cca <__RODATA_PM_OFFSET__+0xcca>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:141
            response->at = -1;
    8cbc:	8f ef       	ldi	r24, 0xFF	; 255
    8cbe:	9f ef       	ldi	r25, 0xFF	; 255
    8cc0:	d7 01       	movw	r26, r14
    8cc2:	1a 96       	adiw	r26, 0x0a	; 10
    8cc4:	8d 93       	st	X+, r24
    8cc6:	9c 93       	st	X, r25
    8cc8:	1b 97       	sbiw	r26, 0x0b	; 11
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:143
        }
        cJSON *p = cJSON_GetObjectItemCaseSensitive(sync_res_json, "p");
    8cca:	62 e6       	ldi	r22, 0x62	; 98
    8ccc:	72 e5       	ldi	r23, 0x52	; 82
    8cce:	c4 01       	movw	r24, r8
    8cd0:	0e 94 74 1e 	call	0x3ce8	; 0x3ce8 <cJSON_GetObjectItemCaseSensitive>
    8cd4:	4c 01       	movw	r8, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:144
        if (p) {
    8cd6:	00 97       	sbiw	r24, 0x00	; 0
    8cd8:	09 f4       	brne	.+2      	; 0x8cdc <__RODATA_PM_OFFSET__+0xcdc>
    8cda:	6f c0       	rjmp	.+222    	; 0x8dba <__RODATA_PM_OFFSET__+0xdba>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:145
            response->broker.name = safe_get_string_and_strdup(p, "n");
    8cdc:	69 ea       	ldi	r22, 0xA9	; 169
    8cde:	70 e6       	ldi	r23, 0x60	; 96
    8ce0:	0e 94 ca 2b 	call	0x5794	; 0x5794 <safe_get_string_and_strdup>
    8ce4:	f7 01       	movw	r30, r14
    8ce6:	86 87       	std	Z+14, r24	; 0x0e
    8ce8:	97 87       	std	Z+15, r25	; 0x0f
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:146
            response->broker.client_id = safe_get_string_and_strdup(p, "id");
    8cea:	63 e7       	ldi	r22, 0x73	; 115
    8cec:	73 e5       	ldi	r23, 0x53	; 83
    8cee:	c4 01       	movw	r24, r8
    8cf0:	0e 94 ca 2b 	call	0x5794	; 0x5794 <safe_get_string_and_strdup>
    8cf4:	d7 01       	movw	r26, r14
    8cf6:	1c 96       	adiw	r26, 0x0c	; 12
    8cf8:	8d 93       	st	X+, r24
    8cfa:	9c 93       	st	X, r25
    8cfc:	1d 97       	sbiw	r26, 0x0d	; 13
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:147
            response->broker.host = safe_get_string_and_strdup(p, "h");
    8cfe:	62 ef       	ldi	r22, 0xF2	; 242
    8d00:	7a e5       	ldi	r23, 0x5A	; 90
    8d02:	c4 01       	movw	r24, r8
    8d04:	0e 94 ca 2b 	call	0x5794	; 0x5794 <safe_get_string_and_strdup>
    8d08:	f7 01       	movw	r30, r14
    8d0a:	80 8b       	std	Z+16, r24	; 0x10
    8d0c:	91 8b       	std	Z+17, r25	; 0x11
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:148
            response->broker.user_name = safe_get_string_and_strdup(p, "un");
    8d0e:	64 ef       	ldi	r22, 0xF4	; 244
    8d10:	7a e5       	ldi	r23, 0x5A	; 90
    8d12:	c4 01       	movw	r24, r8
    8d14:	0e 94 ca 2b 	call	0x5794	; 0x5794 <safe_get_string_and_strdup>
    8d18:	d7 01       	movw	r26, r14
    8d1a:	52 96       	adiw	r26, 0x12	; 18
    8d1c:	8d 93       	st	X+, r24
    8d1e:	9c 93       	st	X, r25
    8d20:	53 97       	sbiw	r26, 0x13	; 19
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:149
            response->broker.pass = safe_get_string_and_strdup(p, "pwd");
    8d22:	67 ef       	ldi	r22, 0xF7	; 247
    8d24:	7a e5       	ldi	r23, 0x5A	; 90
    8d26:	c4 01       	movw	r24, r8
    8d28:	0e 94 ca 2b 	call	0x5794	; 0x5794 <safe_get_string_and_strdup>
    8d2c:	f7 01       	movw	r30, r14
    8d2e:	84 8b       	std	Z+20, r24	; 0x14
    8d30:	95 8b       	std	Z+21, r25	; 0x15
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:150
            response->broker.sub_topic = safe_get_string_and_strdup(p, "sub");
    8d32:	6b ef       	ldi	r22, 0xFB	; 251
    8d34:	7a e5       	ldi	r23, 0x5A	; 90
    8d36:	c4 01       	movw	r24, r8
    8d38:	0e 94 ca 2b 	call	0x5794	; 0x5794 <safe_get_string_and_strdup>
    8d3c:	d7 01       	movw	r26, r14
    8d3e:	58 96       	adiw	r26, 0x18	; 24
    8d40:	8d 93       	st	X+, r24
    8d42:	9c 93       	st	X, r25
    8d44:	59 97       	sbiw	r26, 0x19	; 25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:151
            response->broker.pub_topic = safe_get_string_and_strdup(p, "pub");
    8d46:	6f ef       	ldi	r22, 0xFF	; 255
    8d48:	7a e5       	ldi	r23, 0x5A	; 90
    8d4a:	c4 01       	movw	r24, r8
    8d4c:	0e 94 ca 2b 	call	0x5794	; 0x5794 <safe_get_string_and_strdup>
    8d50:	f7 01       	movw	r30, r14
    8d52:	86 8b       	std	Z+22, r24	; 0x16
    8d54:	97 8b       	std	Z+23, r25	; 0x17
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:152
            if (
    8d56:	22 81       	ldd	r18, Z+2	; 0x02
    8d58:	33 81       	ldd	r19, Z+3	; 0x03
    8d5a:	23 2b       	or	r18, r19
    8d5c:	b1 f0       	breq	.+44     	; 0x8d8a <__RODATA_PM_OFFSET__+0xd8a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:153
                    !response->cpid ||
    8d5e:	24 81       	ldd	r18, Z+4	; 0x04
    8d60:	35 81       	ldd	r19, Z+5	; 0x05
    8d62:	23 2b       	or	r18, r19
    8d64:	91 f0       	breq	.+36     	; 0x8d8a <__RODATA_PM_OFFSET__+0xd8a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:154
                    !response->dtg ||
    8d66:	20 89       	ldd	r18, Z+16	; 0x10
    8d68:	31 89       	ldd	r19, Z+17	; 0x11
    8d6a:	23 2b       	or	r18, r19
    8d6c:	71 f0       	breq	.+28     	; 0x8d8a <__RODATA_PM_OFFSET__+0xd8a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:155
                    !response->broker.host ||
    8d6e:	24 85       	ldd	r18, Z+12	; 0x0c
    8d70:	35 85       	ldd	r19, Z+13	; 0x0d
    8d72:	23 2b       	or	r18, r19
    8d74:	51 f0       	breq	.+20     	; 0x8d8a <__RODATA_PM_OFFSET__+0xd8a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:156
                    !response->broker.client_id ||
    8d76:	22 89       	ldd	r18, Z+18	; 0x12
    8d78:	33 89       	ldd	r19, Z+19	; 0x13
    8d7a:	23 2b       	or	r18, r19
    8d7c:	31 f0       	breq	.+12     	; 0x8d8a <__RODATA_PM_OFFSET__+0xd8a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:157
                    !response->broker.user_name ||
    8d7e:	20 8d       	ldd	r18, Z+24	; 0x18
    8d80:	31 8d       	ldd	r19, Z+25	; 0x19
    8d82:	23 2b       	or	r18, r19
    8d84:	11 f0       	breq	.+4      	; 0x8d8a <__RODATA_PM_OFFSET__+0xd8a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:159
                    // !response->broker.pass || << password may actually be null or empty
                    !response->broker.sub_topic ||
    8d86:	89 2b       	or	r24, r25
    8d88:	e9 f4       	brne	.+58     	; 0x8dc4 <__RODATA_PM_OFFSET__+0xdc4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:163
                    !response->broker.pub_topic
                    ) {
                // Assume parsing eror, but it could alo be (unlikely) allocation error
                response->ds = IOTCL_SR_PARSING_ERROR;
    8d8a:	86 e1       	ldi	r24, 0x16	; 22
    8d8c:	90 e0       	ldi	r25, 0x00	; 0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:180
            case IOTCL_SR_DEVICE_MOVED:
            case IOTCL_SR_CPID_NOT_FOUND:
                // all fall through
                break;
            default:
                response->ds = IOTCL_SR_UNKNOWN_DEVICE_STATUS;
    8d8e:	d7 01       	movw	r26, r14
    8d90:	8d 93       	st	X+, r24
    8d92:	9c 93       	st	X, r25
    8d94:	17 c0       	rjmp	.+46     	; 0x8dc4 <__RODATA_PM_OFFSET__+0xdc4>
cJSON_IsNumber():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:2934
    if (item == NULL)
    {
        return false;
    }

    return (item->type & 0xFF) == cJSON_Number;
    8d96:	fc 01       	movw	r30, r24
    8d98:	26 81       	ldd	r18, Z+6	; 0x06
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:113

CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item) 
{
    if (!cJSON_IsNumber(item)) 
    {
        return (double) NAN;
    8d9a:	60 e0       	ldi	r22, 0x00	; 0
    8d9c:	70 e0       	ldi	r23, 0x00	; 0
    8d9e:	80 ec       	ldi	r24, 0xC0	; 192
    8da0:	9f e7       	ldi	r25, 0x7F	; 127
cJSON_GetNumberValue():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:111
    return item->valuestring;
}

CJSON_PUBLIC(double) cJSON_GetNumberValue(const cJSON * const item) 
{
    if (!cJSON_IsNumber(item)) 
    8da2:	28 30       	cpi	r18, 0x08	; 8
    8da4:	21 f4       	brne	.+8      	; 0x8dae <__RODATA_PM_OFFSET__+0xdae>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:116
    {
        return (double) NAN;
    }

    return item->valuedouble;
    8da6:	64 85       	ldd	r22, Z+12	; 0x0c
    8da8:	75 85       	ldd	r23, Z+13	; 0x0d
    8daa:	86 85       	ldd	r24, Z+14	; 0x0e
    8dac:	97 85       	ldd	r25, Z+15	; 0x0f
iotcl_discovery_parse_sync_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:126
    }
    tmp_value = cJSON_GetObjectItem(sync_res_json, "ds");
    if (!tmp_value) {
        response->ds = IOTCL_SR_PARSING_ERROR;
    } else {
        response->ds = cJSON_GetNumberValue(tmp_value);
    8dae:	0e 94 ae 53 	call	0xa75c	; 0xa75c <__fixunssfsi>
    8db2:	d7 01       	movw	r26, r14
    8db4:	6d 93       	st	X+, r22
    8db6:	7c 93       	st	X, r23
    8db8:	48 cf       	rjmp	.-368    	; 0x8c4a <__RODATA_PM_OFFSET__+0xc4a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:166
                    ) {
                // Assume parsing eror, but it could alo be (unlikely) allocation error
                response->ds = IOTCL_SR_PARSING_ERROR;
            }
        } else {
            response->ds = IOTCL_SR_PARSING_ERROR;
    8dba:	86 e1       	ldi	r24, 0x16	; 22
    8dbc:	90 e0       	ldi	r25, 0x00	; 0
    8dbe:	f7 01       	movw	r30, r14
    8dc0:	80 83       	st	Z, r24
    8dc2:	91 83       	std	Z+1, r25	; 0x01
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:185
                response->ds = IOTCL_SR_UNKNOWN_DEVICE_STATUS;
                break;
        }
    }
    // we have duplicated strings, so we can now free the result
    cJSON_Delete(sync_json_root);
    8dc4:	c3 01       	movw	r24, r6
    8dc6:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
    8dca:	fc ce       	rjmp	.-520    	; 0x8bc4 <__RODATA_PM_OFFSET__+0xbc4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:169
            }
        } else {
            response->ds = IOTCL_SR_PARSING_ERROR;
        }
    } else {
        switch (response->ds) {
    8dcc:	81 30       	cpi	r24, 0x01	; 1
    8dce:	91 05       	cpc	r25, r1
    8dd0:	28 f0       	brcs	.+10     	; 0x8ddc <__RODATA_PM_OFFSET__+0xddc>
    8dd2:	87 30       	cpi	r24, 0x07	; 7
    8dd4:	91 05       	cpc	r25, r1
    8dd6:	b0 f3       	brcs	.-20     	; 0x8dc4 <__RODATA_PM_OFFSET__+0xdc4>
    8dd8:	44 97       	sbiw	r24, 0x14	; 20
    8dda:	a1 f3       	breq	.-24     	; 0x8dc4 <__RODATA_PM_OFFSET__+0xdc4>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_discovery.c:180
            case IOTCL_SR_DEVICE_MOVED:
            case IOTCL_SR_CPID_NOT_FOUND:
                // all fall through
                break;
            default:
                response->ds = IOTCL_SR_UNKNOWN_DEVICE_STATUS;
    8ddc:	84 e1       	ldi	r24, 0x14	; 20
    8dde:	90 e0       	ldi	r25, 0x00	; 0
    8de0:	d6 cf       	rjmp	.-84     	; 0x8d8e <__RODATA_PM_OFFSET__+0xd8e>
report_sync_error():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:34
    }
}

static void report_sync_error(IotclSyncResponse *response, const char *sync_response_str) {
    if (NULL == response) {
        Log.error("Failed to obtain sync response");
    8de2:	83 e0       	ldi	r24, 0x03	; 3
    8de4:	9b e5       	ldi	r25, 0x5B	; 91
    8de6:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
iotconnect_free_https_response():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:68
    return 0;
}


void iotconnect_free_https_response(IotConnectHttpResponse *response) {
    if (response->data) {
    8dea:	89 81       	ldd	r24, Y+1	; 0x01
    8dec:	9a 81       	ldd	r25, Y+2	; 0x02
    8dee:	00 97       	sbiw	r24, 0x00	; 0
    8df0:	09 f4       	brne	.+2      	; 0x8df4 <__RODATA_PM_OFFSET__+0xdf4>
    8df2:	0e ce       	rjmp	.-996    	; 0x8a10 <__RODATA_PM_OFFSET__+0xa10>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_http_request.cpp:69
        free(response->data);
    8df4:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    8df8:	0b ce       	rjmp	.-1002   	; 0x8a10 <__RODATA_PM_OFFSET__+0xa10>
report_sync_error():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:39
        return;
    }
    switch (response->ds) {
        case IOTCL_SR_DEVICE_NOT_REGISTERED:
            Log.error("IOTC_SyncResponse error: Not registered");
    8dfa:	82 e2       	ldi	r24, 0x22	; 34
    8dfc:	9b e5       	ldi	r25, 0x5B	; 91
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:42
            break;
        case IOTCL_SR_AUTO_REGISTER:
            Log.error("IOTC_SyncResponse error: Auto Register");
    8dfe:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:69
            break;
        default:
            Log.warn("WARN: report_sync_error called, but no error returned?");
            break;
    }
    Log.errorf("Raw server response was:\r\n--------------\r\n%s\r\n--------------\r\n", sync_response_str);
    8e02:	9f 92       	push	r9
    8e04:	8f 92       	push	r8
    8e06:	8d e1       	ldi	r24, 0x1D	; 29
    8e08:	9d e5       	ldi	r25, 0x5D	; 93
    8e0a:	9f 93       	push	r25
    8e0c:	8f 93       	push	r24
    8e0e:	89 e6       	ldi	r24, 0x69	; 105
    8e10:	90 e7       	ldi	r25, 0x70	; 112
    8e12:	9f 93       	push	r25
    8e14:	8f 93       	push	r24
    8e16:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
iotcl_discovery_free_sync_response():
    8e1a:	c7 01       	movw	r24, r14
    8e1c:	0e 94 5e 09 	call	0x12bc	; 0x12bc <iotcl_discovery_free_sync_response.part.1>
    8e20:	0f 90       	pop	r0
    8e22:	0f 90       	pop	r0
    8e24:	0f 90       	pop	r0
    8e26:	0f 90       	pop	r0
    8e28:	0f 90       	pop	r0
    8e2a:	0f 90       	pop	r0
    8e2c:	aa ce       	rjmp	.-684    	; 0x8b82 <__RODATA_PM_OFFSET__+0xb82>
report_sync_error():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:42
    switch (response->ds) {
        case IOTCL_SR_DEVICE_NOT_REGISTERED:
            Log.error("IOTC_SyncResponse error: Not registered");
            break;
        case IOTCL_SR_AUTO_REGISTER:
            Log.error("IOTC_SyncResponse error: Auto Register");
    8e2e:	8a e4       	ldi	r24, 0x4A	; 74
    8e30:	9b e5       	ldi	r25, 0x5B	; 91
    8e32:	e5 cf       	rjmp	.-54     	; 0x8dfe <__RODATA_PM_OFFSET__+0xdfe>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:45
            break;
        case IOTCL_SR_DEVICE_NOT_FOUND:
            Log.error("IOTC_SyncResponse error: Device not found");
    8e34:	81 e7       	ldi	r24, 0x71	; 113
    8e36:	9b e5       	ldi	r25, 0x5B	; 91
    8e38:	e2 cf       	rjmp	.-60     	; 0x8dfe <__RODATA_PM_OFFSET__+0xdfe>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:48
            break;
        case IOTCL_SR_DEVICE_INACTIVE:
            Log.error("IOTC_SyncResponse error: Device inactive");
    8e3a:	8b e9       	ldi	r24, 0x9B	; 155
    8e3c:	9b e5       	ldi	r25, 0x5B	; 91
    8e3e:	df cf       	rjmp	.-66     	; 0x8dfe <__RODATA_PM_OFFSET__+0xdfe>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:51
            break;
        case IOTCL_SR_DEVICE_MOVED:
            Log.error("IOTC_SyncResponse error: Device moved");
    8e40:	84 ec       	ldi	r24, 0xC4	; 196
    8e42:	9b e5       	ldi	r25, 0x5B	; 91
    8e44:	dc cf       	rjmp	.-72     	; 0x8dfe <__RODATA_PM_OFFSET__+0xdfe>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:54
            break;
        case IOTCL_SR_CPID_NOT_FOUND:
            Log.error("IOTC_SyncResponse error: CPID not found");
    8e46:	8a ee       	ldi	r24, 0xEA	; 234
    8e48:	9b e5       	ldi	r25, 0x5B	; 91
    8e4a:	d9 cf       	rjmp	.-78     	; 0x8dfe <__RODATA_PM_OFFSET__+0xdfe>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:57
            break;
        case IOTCL_SR_UNKNOWN_DEVICE_STATUS:
            Log.error("IOTC_SyncResponse error: Unknown device status error from server");
    8e4c:	82 e1       	ldi	r24, 0x12	; 18
    8e4e:	9c e5       	ldi	r25, 0x5C	; 92
    8e50:	d6 cf       	rjmp	.-84     	; 0x8dfe <__RODATA_PM_OFFSET__+0xdfe>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:60
            break;
        case IOTCL_SR_ALLOCATION_ERROR:
            Log.error("IOTC_SyncResponse internal error: Allocation Error");
    8e52:	83 e5       	ldi	r24, 0x53	; 83
    8e54:	9c e5       	ldi	r25, 0x5C	; 92
    8e56:	d3 cf       	rjmp	.-90     	; 0x8dfe <__RODATA_PM_OFFSET__+0xdfe>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:63
            break;
        case IOTCL_SR_PARSING_ERROR:
            Log.error("IOTC_SyncResponse internal error: Parsing error. Please check parameters passed to the request.");
    8e58:	86 e8       	ldi	r24, 0x86	; 134
    8e5a:	9c e5       	ldi	r25, 0x5C	; 92
    8e5c:	d0 cf       	rjmp	.-96     	; 0x8dfe <__RODATA_PM_OFFSET__+0xdfe>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:66
            break;
        default:
            Log.warn("WARN: report_sync_error called, but no error returned?");
    8e5e:	86 ee       	ldi	r24, 0xE6	; 230
    8e60:	9c e5       	ldi	r25, 0x5C	; 92
    8e62:	0e 94 9c 0a 	call	0x1538	; 0x1538 <LogClass::warn(char const*) [clone .constprop.124]>
    8e66:	cd cf       	rjmp	.-102    	; 0x8e02 <__RODATA_PM_OFFSET__+0xe02>
iotc_get_time_modem():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:139
    if (res != ResponseResult::OK) {
        Log.error("Failed to retrieve successful response time from the modem");
        return 0;
    }

    if (!SequansController.extractValueFromCommandResponse(
    8e68:	0a e3       	ldi	r16, 0x3A	; 58
    8e6a:	20 e2       	ldi	r18, 0x20	; 32
    8e6c:	30 e0       	ldi	r19, 0x00	; 0
    8e6e:	ae 01       	movw	r20, r28
    8e70:	44 56       	subi	r20, 0x64	; 100
    8e72:	5f 4f       	sbci	r21, 0xFF	; 255
    8e74:	60 e0       	ldi	r22, 0x00	; 0
    8e76:	c6 01       	movw	r24, r12
    8e78:	0e 94 c5 0c 	call	0x198a	; 0x198a <SequansControllerClass::extractValueFromCommandResponse(char*, unsigned char, char*, unsigned int, char) [clone .constprop.126]>
    8e7c:	81 11       	cpse	r24, r1
    8e7e:	03 c0       	rjmp	.+6      	; 0x8e86 <__RODATA_PM_OFFSET__+0xe86>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:144
        response_buffer,
        0,
        value_buffer,
        sizeof(value_buffer))) {
            Log.error("Failed to retrieve time from the modem");
    8e80:	87 e9       	ldi	r24, 0x97	; 151
    8e82:	9d e5       	ldi	r25, 0x5D	; 93
    8e84:	0c ce       	rjmp	.-1000   	; 0x8a9e <__RODATA_PM_OFFSET__+0xa9e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:147
            return 0;
    }
    Log.debugf("Time AT response: >>%s<<\r\n", response_buffer);
    8e86:	df 92       	push	r13
    8e88:	cf 92       	push	r12
    8e8a:	8e eb       	ldi	r24, 0xBE	; 190
    8e8c:	9d e5       	ldi	r25, 0x5D	; 93
    8e8e:	9f 93       	push	r25
    8e90:	8f 93       	push	r24
    8e92:	09 e6       	ldi	r16, 0x69	; 105
    8e94:	10 e7       	ldi	r17, 0x70	; 112
    8e96:	1f 93       	push	r17
    8e98:	0f 93       	push	r16
    8e9a:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <LogClass::debugf(char const*, ...) [clone .constprop.118]>
cclk_response_to_time_t():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:93
static time_t cclk_response_to_time_t(const char* time_str)
{
    time_t now_time_t;
    int hh, mm, ss, yy, mon, day, tzo;
    char tz_sign;
    struct tm now_tm = {0};
    8e9e:	8c e0       	ldi	r24, 0x0C	; 12
    8ea0:	f5 01       	movw	r30, r10
    8ea2:	11 92       	st	Z+, r1
    8ea4:	8a 95       	dec	r24
    8ea6:	e9 f7       	brne	.-6      	; 0x8ea2 <__RODATA_PM_OFFSET__+0xea2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:95

    int num = sscanf(time_str, "\r\n+CCLK: \"%d/%d/%d,%d:%d:%d%c%d\"\r\n", &yy, &mon, &day, &hh, &mm, &ss, &tz_sign, &tzo);
    8ea8:	9e 01       	movw	r18, r28
    8eaa:	24 50       	subi	r18, 0x04	; 4
    8eac:	3f 4f       	sbci	r19, 0xFF	; 255
    8eae:	c0 5e       	subi	r28, 0xE0	; 224
    8eb0:	de 4f       	sbci	r29, 0xFE	; 254
    8eb2:	28 83       	st	Y, r18
    8eb4:	39 83       	std	Y+1, r19	; 0x01
    8eb6:	c0 52       	subi	r28, 0x20	; 32
    8eb8:	d1 40       	sbci	r29, 0x01	; 1
    8eba:	3f 93       	push	r19
    8ebc:	2f 93       	push	r18
    8ebe:	ce 01       	movw	r24, r28
    8ec0:	81 5e       	subi	r24, 0xE1	; 225
    8ec2:	9e 4f       	sbci	r25, 0xFE	; 254
    8ec4:	ce 5d       	subi	r28, 0xDE	; 222
    8ec6:	de 4f       	sbci	r29, 0xFE	; 254
    8ec8:	88 83       	st	Y, r24
    8eca:	99 83       	std	Y+1, r25	; 0x01
    8ecc:	c2 52       	subi	r28, 0x22	; 34
    8ece:	d1 40       	sbci	r29, 0x01	; 1
    8ed0:	9f 93       	push	r25
    8ed2:	8f 93       	push	r24
    8ed4:	4e 01       	movw	r8, r28
    8ed6:	99 ee       	ldi	r25, 0xE9	; 233
    8ed8:	89 1a       	sub	r8, r25
    8eda:	9e ef       	ldi	r25, 0xFE	; 254
    8edc:	99 0a       	sbc	r9, r25
    8ede:	9f 92       	push	r9
    8ee0:	8f 92       	push	r8
    8ee2:	3e 01       	movw	r6, r28
    8ee4:	a6 ee       	ldi	r26, 0xE6	; 230
    8ee6:	6a 1a       	sub	r6, r26
    8ee8:	ae ef       	ldi	r26, 0xFE	; 254
    8eea:	7a 0a       	sbc	r7, r26
    8eec:	7f 92       	push	r7
    8eee:	6f 92       	push	r6
    8ef0:	1e 01       	movw	r2, r28
    8ef2:	b3 ee       	ldi	r27, 0xE3	; 227
    8ef4:	2b 1a       	sub	r2, r27
    8ef6:	be ef       	ldi	r27, 0xFE	; 254
    8ef8:	3b 0a       	sbc	r3, r27
    8efa:	3f 92       	push	r3
    8efc:	2f 92       	push	r2
    8efe:	fe 01       	movw	r30, r28
    8f00:	ec 5f       	subi	r30, 0xFC	; 252
    8f02:	fe 4f       	sbci	r31, 0xFE	; 254
    8f04:	cc 5d       	subi	r28, 0xDC	; 220
    8f06:	de 4f       	sbci	r29, 0xFE	; 254
    8f08:	e8 83       	st	Y, r30
    8f0a:	f9 83       	std	Y+1, r31	; 0x01
    8f0c:	c4 52       	subi	r28, 0x24	; 36
    8f0e:	d1 40       	sbci	r29, 0x01	; 1
    8f10:	ff 93       	push	r31
    8f12:	ef 93       	push	r30
    8f14:	5f 92       	push	r5
    8f16:	4f 92       	push	r4
    8f18:	28 5e       	subi	r18, 0xE8	; 232
    8f1a:	3f 4f       	sbci	r19, 0xFF	; 255
    8f1c:	ca 5d       	subi	r28, 0xDA	; 218
    8f1e:	de 4f       	sbci	r29, 0xFE	; 254
    8f20:	28 83       	st	Y, r18
    8f22:	39 83       	std	Y+1, r19	; 0x01
    8f24:	c6 52       	subi	r28, 0x26	; 38
    8f26:	d1 40       	sbci	r29, 0x01	; 1
    8f28:	3f 93       	push	r19
    8f2a:	2f 93       	push	r18
    8f2c:	89 ed       	ldi	r24, 0xD9	; 217
    8f2e:	9d e5       	ldi	r25, 0x5D	; 93
    8f30:	9f 93       	push	r25
    8f32:	8f 93       	push	r24
    8f34:	df 92       	push	r13
    8f36:	cf 92       	push	r12
    8f38:	0e 94 e4 57 	call	0xafc8	; 0xafc8 <sscanf>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:96
    if (num != 8)  { // need to match 8 items &yy, &mon, &day etc.
    8f3c:	ad b7       	in	r26, 0x3d	; 61
    8f3e:	be b7       	in	r27, 0x3e	; 62
    8f40:	5a 96       	adiw	r26, 0x1a	; 26
    8f42:	ad bf       	out	0x3d, r26	; 61
    8f44:	be bf       	out	0x3e, r27	; 62
    8f46:	08 97       	sbiw	r24, 0x08	; 8
    8f48:	89 f0       	breq	.+34     	; 0x8f6c <__RODATA_PM_OFFSET__+0xf6c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:97
        Log.errorf("Unable to parse modem time %s", time_str);
    8f4a:	df 92       	push	r13
    8f4c:	cf 92       	push	r12
    8f4e:	8c ef       	ldi	r24, 0xFC	; 252
    8f50:	9d e5       	ldi	r25, 0x5D	; 93
    8f52:	9f 93       	push	r25
    8f54:	8f 93       	push	r24
    8f56:	1f 93       	push	r17
    8f58:	0f 93       	push	r16
    8f5a:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    8f5e:	0f 90       	pop	r0
    8f60:	0f 90       	pop	r0
    8f62:	0f 90       	pop	r0
    8f64:	0f 90       	pop	r0
    8f66:	0f 90       	pop	r0
    8f68:	0f 90       	pop	r0
    8f6a:	9b cd       	rjmp	.-1226   	; 0x8aa2 <__RODATA_PM_OFFSET__+0xaa2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:101
        return 0;
    }

    if (70 == yy) {
    8f6c:	cc 5e       	subi	r28, 0xEC	; 236
    8f6e:	de 4f       	sbci	r29, 0xFE	; 254
    8f70:	88 81       	ld	r24, Y
    8f72:	99 81       	ldd	r25, Y+1	; 0x01
    8f74:	c4 51       	subi	r28, 0x14	; 20
    8f76:	d1 40       	sbci	r29, 0x01	; 1
    8f78:	86 34       	cpi	r24, 0x46	; 70
    8f7a:	91 05       	cpc	r25, r1
    8f7c:	29 f4       	brne	.+10     	; 0x8f88 <__RODATA_PM_OFFSET__+0xf88>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:102
        Log.warn("Modem time is not ready");
    8f7e:	8a e1       	ldi	r24, 0x1A	; 26
    8f80:	9e e5       	ldi	r25, 0x5E	; 94
    8f82:	0e 94 9c 0a 	call	0x1538	; 0x1538 <LogClass::warn(char const*) [clone .constprop.124]>
    8f86:	8d cd       	rjmp	.-1254   	; 0x8aa2 <__RODATA_PM_OFFSET__+0xaa2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:105
        return 0; // I guess this could be 1970. Modem seems to report "70/01/01,00:02:21+00" when offline
    }
    now_tm.tm_isdst = -1;
    8f88:	2f ef       	ldi	r18, 0xFF	; 255
    8f8a:	3f ef       	ldi	r19, 0xFF	; 255
    8f8c:	f5 01       	movw	r30, r10
    8f8e:	22 87       	std	Z+10, r18	; 0x0a
    8f90:	33 87       	std	Z+11, r19	; 0x0b
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:106
    now_tm.tm_hour = hh;
    8f92:	d1 01       	movw	r26, r2
    8f94:	2c 91       	ld	r18, X
    8f96:	22 83       	std	Z+2, r18	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:107
    now_tm.tm_min = mm;
    8f98:	f3 01       	movw	r30, r6
    8f9a:	20 81       	ld	r18, Z
    8f9c:	d5 01       	movw	r26, r10
    8f9e:	11 96       	adiw	r26, 0x01	; 1
    8fa0:	2c 93       	st	X, r18
    8fa2:	11 97       	sbiw	r26, 0x01	; 1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:108
    now_tm.tm_sec = ss;
    8fa4:	f4 01       	movw	r30, r8
    8fa6:	20 81       	ld	r18, Z
    8fa8:	2c 93       	st	X, r18
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:109
    now_tm.tm_year = 2000 + yy - 1900;
    8faa:	8c 59       	subi	r24, 0x9C	; 156
    8fac:	9f 4f       	sbci	r25, 0xFF	; 255
    8fae:	16 96       	adiw	r26, 0x06	; 6
    8fb0:	8d 93       	st	X+, r24
    8fb2:	9c 93       	st	X, r25
    8fb4:	17 97       	sbiw	r26, 0x07	; 7
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:110
    now_tm.tm_mon = mon - 1;
    8fb6:	d2 01       	movw	r26, r4
    8fb8:	8c 91       	ld	r24, X
    8fba:	81 50       	subi	r24, 0x01	; 1
    8fbc:	f5 01       	movw	r30, r10
    8fbe:	85 83       	std	Z+5, r24	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:111
    now_tm.tm_mday = day;
    8fc0:	cc 5f       	subi	r28, 0xFC	; 252
    8fc2:	de 4f       	sbci	r29, 0xFE	; 254
    8fc4:	88 81       	ld	r24, Y
    8fc6:	c4 50       	subi	r28, 0x04	; 4
    8fc8:	d1 40       	sbci	r29, 0x01	; 1
    8fca:	83 83       	std	Z+3, r24	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:112
    now_time_t = mktime(&now_tm);
    8fcc:	c5 01       	movw	r24, r10
    8fce:	0e 94 c6 34 	call	0x698c	; 0x698c <mktime>
    8fd2:	5b 01       	movw	r10, r22
    8fd4:	6c 01       	movw	r12, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:114

    Log.infof("+CCLK: \"%d/%d/%d,%d:%d:%d%c%d\"\r\n", yy, mon, day, hh, mm, ss, tz_sign, tzo);
    8fd6:	c3 50       	subi	r28, 0x03	; 3
    8fd8:	df 4f       	sbci	r29, 0xFF	; 255
    8fda:	88 81       	ld	r24, Y
    8fdc:	cd 5f       	subi	r28, 0xFD	; 253
    8fde:	d0 40       	sbci	r29, 0x00	; 0
    8fe0:	8f 93       	push	r24
    8fe2:	c4 50       	subi	r28, 0x04	; 4
    8fe4:	df 4f       	sbci	r29, 0xFF	; 255
    8fe6:	88 81       	ld	r24, Y
    8fe8:	cc 5f       	subi	r28, 0xFC	; 252
    8fea:	d0 40       	sbci	r29, 0x00	; 0
    8fec:	8f 93       	push	r24
    8fee:	c1 5e       	subi	r28, 0xE1	; 225
    8ff0:	de 4f       	sbci	r29, 0xFE	; 254
    8ff2:	88 81       	ld	r24, Y
    8ff4:	cf 51       	subi	r28, 0x1F	; 31
    8ff6:	d1 40       	sbci	r29, 0x01	; 1
    8ff8:	28 2f       	mov	r18, r24
    8ffa:	08 2e       	mov	r0, r24
    8ffc:	00 0c       	add	r0, r0
    8ffe:	33 0b       	sbc	r19, r19
    9000:	3f 93       	push	r19
    9002:	8f 93       	push	r24
    9004:	d4 01       	movw	r26, r8
    9006:	11 96       	adiw	r26, 0x01	; 1
    9008:	8c 91       	ld	r24, X
    900a:	11 97       	sbiw	r26, 0x01	; 1
    900c:	8f 93       	push	r24
    900e:	8c 91       	ld	r24, X
    9010:	8f 93       	push	r24
    9012:	f3 01       	movw	r30, r6
    9014:	81 81       	ldd	r24, Z+1	; 0x01
    9016:	8f 93       	push	r24
    9018:	80 81       	ld	r24, Z
    901a:	8f 93       	push	r24
    901c:	d1 01       	movw	r26, r2
    901e:	11 96       	adiw	r26, 0x01	; 1
    9020:	8c 91       	ld	r24, X
    9022:	11 97       	sbiw	r26, 0x01	; 1
    9024:	8f 93       	push	r24
    9026:	8c 91       	ld	r24, X
    9028:	8f 93       	push	r24
    902a:	cb 5f       	subi	r28, 0xFB	; 251
    902c:	de 4f       	sbci	r29, 0xFE	; 254
    902e:	88 81       	ld	r24, Y
    9030:	c5 50       	subi	r28, 0x05	; 5
    9032:	d1 40       	sbci	r29, 0x01	; 1
    9034:	8f 93       	push	r24
    9036:	cc 5f       	subi	r28, 0xFC	; 252
    9038:	de 4f       	sbci	r29, 0xFE	; 254
    903a:	88 81       	ld	r24, Y
    903c:	c4 50       	subi	r28, 0x04	; 4
    903e:	d1 40       	sbci	r29, 0x01	; 1
    9040:	8f 93       	push	r24
    9042:	f2 01       	movw	r30, r4
    9044:	81 81       	ldd	r24, Z+1	; 0x01
    9046:	8f 93       	push	r24
    9048:	80 81       	ld	r24, Z
    904a:	8f 93       	push	r24
    904c:	cb 5e       	subi	r28, 0xEB	; 235
    904e:	de 4f       	sbci	r29, 0xFE	; 254
    9050:	88 81       	ld	r24, Y
    9052:	c5 51       	subi	r28, 0x15	; 21
    9054:	d1 40       	sbci	r29, 0x01	; 1
    9056:	8f 93       	push	r24
    9058:	cc 5e       	subi	r28, 0xEC	; 236
    905a:	de 4f       	sbci	r29, 0xFE	; 254
    905c:	88 81       	ld	r24, Y
    905e:	c4 51       	subi	r28, 0x14	; 20
    9060:	d1 40       	sbci	r29, 0x01	; 1
    9062:	8f 93       	push	r24
    9064:	8b ed       	ldi	r24, 0xDB	; 219
    9066:	9d e5       	ldi	r25, 0x5D	; 93
    9068:	9f 93       	push	r25
    906a:	8f 93       	push	r24
    906c:	1f 93       	push	r17
    906e:	0f 93       	push	r16
    9070:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:118

    // tz offset is quarter of an hour from gmt. 15 minutes have 900 seconds
    // To get GMT time, we need to subtract (not add) the signed offset
    int sign = tz_sign == '-' ? -1 : 1;
    9074:	2d b7       	in	r18, 0x3d	; 61
    9076:	3e b7       	in	r19, 0x3e	; 62
    9078:	2c 5e       	subi	r18, 0xEC	; 236
    907a:	3f 4f       	sbci	r19, 0xFF	; 255
    907c:	2d bf       	out	0x3d, r18	; 61
    907e:	3e bf       	out	0x3e, r19	; 62
    9080:	c1 5e       	subi	r28, 0xE1	; 225
    9082:	de 4f       	sbci	r29, 0xFE	; 254
    9084:	88 81       	ld	r24, Y
    9086:	cf 51       	subi	r28, 0x1F	; 31
    9088:	d1 40       	sbci	r29, 0x01	; 1
    908a:	8d 32       	cpi	r24, 0x2D	; 45
    908c:	b9 f5       	brne	.+110    	; 0x90fc <__RODATA_PM_OFFSET__+0x10fc>
main():
    908e:	8f ef       	ldi	r24, 0xFF	; 255
    9090:	9f ef       	ldi	r25, 0xFF	; 255
cclk_response_to_time_t():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:119
    now_time_t -= sign * 900 * tzo;
    9092:	24 e8       	ldi	r18, 0x84	; 132
    9094:	33 e0       	ldi	r19, 0x03	; 3
    9096:	82 9f       	mul	r24, r18
    9098:	a0 01       	movw	r20, r0
    909a:	83 9f       	mul	r24, r19
    909c:	50 0d       	add	r21, r0
    909e:	92 9f       	mul	r25, r18
    90a0:	50 0d       	add	r21, r0
    90a2:	11 24       	eor	r1, r1
    90a4:	c4 50       	subi	r28, 0x04	; 4
    90a6:	df 4f       	sbci	r29, 0xFF	; 255
    90a8:	28 81       	ld	r18, Y
    90aa:	39 81       	ldd	r19, Y+1	; 0x01
    90ac:	cc 5f       	subi	r28, 0xFC	; 252
    90ae:	d0 40       	sbci	r29, 0x00	; 0
    90b0:	42 9f       	mul	r20, r18
    90b2:	c0 01       	movw	r24, r0
    90b4:	43 9f       	mul	r20, r19
    90b6:	90 0d       	add	r25, r0
    90b8:	52 9f       	mul	r21, r18
    90ba:	90 0d       	add	r25, r0
    90bc:	11 24       	eor	r1, r1
    90be:	09 2e       	mov	r0, r25
    90c0:	00 0c       	add	r0, r0
    90c2:	aa 0b       	sbc	r26, r26
    90c4:	bb 0b       	sbc	r27, r27
    90c6:	a8 1a       	sub	r10, r24
    90c8:	b9 0a       	sbc	r11, r25
    90ca:	ca 0a       	sbc	r12, r26
    90cc:	db 0a       	sbc	r13, r27
iotc_get_time_modem():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:150
            return 0;
    }
    Log.debugf("Time AT response: >>%s<<\r\n", response_buffer);

    time_t now = cclk_response_to_time_t(response_buffer);
    if (0 == now) {
    90ce:	09 f4       	brne	.+2      	; 0x90d2 <__RODATA_PM_OFFSET__+0x10d2>
    90d0:	e8 cc       	rjmp	.-1584   	; 0x8aa2 <__RODATA_PM_OFFSET__+0xaa2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:154
        return 0; // the called function will report the error
    }

    rtc_start = now - (time_t)(millis()/1000);
    90d2:	0e 94 bb 02 	call	0x576	; 0x576 <millis>
    90d6:	28 ee       	ldi	r18, 0xE8	; 232
    90d8:	33 e0       	ldi	r19, 0x03	; 3
    90da:	40 e0       	ldi	r20, 0x00	; 0
    90dc:	50 e0       	ldi	r21, 0x00	; 0
    90de:	0e 94 79 52 	call	0xa4f2	; 0xa4f2 <__udivmodsi4>
    90e2:	a2 1a       	sub	r10, r18
    90e4:	b3 0a       	sbc	r11, r19
    90e6:	c4 0a       	sbc	r12, r20
    90e8:	d5 0a       	sbc	r13, r21
    90ea:	a0 92 92 66 	sts	0x6692, r10	; 0x806692 <rtc_start>
    90ee:	b0 92 93 66 	sts	0x6693, r11	; 0x806693 <rtc_start+0x1>
    90f2:	c0 92 94 66 	sts	0x6694, r12	; 0x806694 <rtc_start+0x2>
    90f6:	d0 92 95 66 	sts	0x6695, r13	; 0x806695 <rtc_start+0x3>
    90fa:	d3 cc       	rjmp	.-1626   	; 0x8aa2 <__RODATA_PM_OFFSET__+0xaa2>
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_time.cpp:118

    Log.infof("+CCLK: \"%d/%d/%d,%d:%d:%d%c%d\"\r\n", yy, mon, day, hh, mm, ss, tz_sign, tzo);

    // tz offset is quarter of an hour from gmt. 15 minutes have 900 seconds
    // To get GMT time, we need to subtract (not add) the signed offset
    int sign = tz_sign == '-' ? -1 : 1;
    90fc:	81 e0       	ldi	r24, 0x01	; 1
    90fe:	90 e0       	ldi	r25, 0x00	; 0
    9100:	c8 cf       	rjmp	.-112    	; 0x9092 <__RODATA_PM_OFFSET__+0x1092>
iotconnect_sdk_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:259
    if (!config.env || !config.cpid || !config.duid) {
        Log.error("Error: Device configuration is invalid. Configuration values for env, cpid and duid are required.");
        return false;
    }

    lib_config.event_functions.ota_cb = config.ota_cb;
    9102:	80 91 fa 65 	lds	r24, 0x65FA	; 0x8065fa <config+0x6>
    9106:	90 91 fb 65 	lds	r25, 0x65FB	; 0x8065fb <config+0x7>
    910a:	80 93 46 64 	sts	0x6446, r24	; 0x806446 <lib_config+0x8>
    910e:	90 93 47 64 	sts	0x6447, r25	; 0x806447 <lib_config+0x9>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:260
    lib_config.event_functions.cmd_cb = config.cmd_cb;
    9112:	80 91 fc 65 	lds	r24, 0x65FC	; 0x8065fc <config+0x8>
    9116:	90 91 fd 65 	lds	r25, 0x65FD	; 0x8065fd <config+0x9>
    911a:	80 93 48 64 	sts	0x6448, r24	; 0x806448 <lib_config+0xa>
    911e:	90 93 49 64 	sts	0x6449, r25	; 0x806449 <lib_config+0xb>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:261
    lib_config.event_functions.msg_cb = on_message_intercept;
    9122:	8d e6       	ldi	r24, 0x6D	; 109
    9124:	93 e2       	ldi	r25, 0x23	; 35
    9126:	80 93 4a 64 	sts	0x644A, r24	; 0x80644a <lib_config+0xc>
    912a:	90 93 4b 64 	sts	0x644B, r25	; 0x80644b <lib_config+0xd>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:263

    lib_config.telemetry.dtg = sr->dtg;
    912e:	d7 01       	movw	r26, r14
    9130:	14 96       	adiw	r26, 0x04	; 4
    9132:	8d 91       	ld	r24, X+
    9134:	9c 91       	ld	r25, X
    9136:	80 93 44 64 	sts	0x6444, r24	; 0x806444 <lib_config+0x6>
    913a:	90 93 45 64 	sts	0x6445, r25	; 0x806445 <lib_config+0x7>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:266

    char cpid_buff[5];
    strncpy(cpid_buff, config.cpid, 4);
    913e:	44 e0       	ldi	r20, 0x04	; 4
    9140:	50 e0       	ldi	r21, 0x00	; 0
    9142:	8e 01       	movw	r16, r28
    9144:	0f 5f       	subi	r16, 0xFF	; 255
    9146:	1f 4f       	sbci	r17, 0xFF	; 255
    9148:	c8 01       	movw	r24, r16
    914a:	0e 94 1b 57 	call	0xae36	; 0xae36 <strncpy>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:267
    cpid_buff[4] = 0;
    914e:	1d 82       	std	Y+5, r1	; 0x05
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:268
    Log.infof("CPID: %s***\r\n", cpid_buff);
    9150:	1f 93       	push	r17
    9152:	0f 93       	push	r16
    9154:	84 e9       	ldi	r24, 0x94	; 148
    9156:	9e e5       	ldi	r25, 0x5E	; 94
    9158:	9f 93       	push	r25
    915a:	8f 93       	push	r24
    915c:	e9 e6       	ldi	r30, 0x69	; 105
    915e:	ee 2e       	mov	r14, r30
    9160:	e0 e7       	ldi	r30, 0x70	; 112
    9162:	fe 2e       	mov	r15, r30
    9164:	ff 92       	push	r15
    9166:	ef 92       	push	r14
    9168:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:269
    Log.infof("ENV:  %s\r\n", config.env);
    916c:	80 91 f5 65 	lds	r24, 0x65F5	; 0x8065f5 <config+0x1>
    9170:	8f 93       	push	r24
    9172:	80 91 f4 65 	lds	r24, 0x65F4	; 0x8065f4 <config>
    9176:	8f 93       	push	r24
    9178:	82 ea       	ldi	r24, 0xA2	; 162
    917a:	9e e5       	ldi	r25, 0x5E	; 94
    917c:	9f 93       	push	r25
    917e:	8f 93       	push	r24
    9180:	ff 92       	push	r15
    9182:	ef 92       	push	r14
    9184:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
iotcl_deinit():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:51
    }
    return &config;
}

void iotcl_deinit(void) {
    config_is_valid = false;
    9188:	10 92 3d 64 	sts	0x643D, r1	; 0x80643d <config_is_valid>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:53

    memset(&config, 0, sizeof(config));
    918c:	ed e2       	ldi	r30, 0x2D	; 45
    918e:	f4 e6       	ldi	r31, 0x64	; 100
    9190:	80 e1       	ldi	r24, 0x10	; 16
    9192:	df 01       	movw	r26, r30
    9194:	1d 92       	st	X+, r1
    9196:	8a 95       	dec	r24
    9198:	e9 f7       	brne	.-6      	; 0x9194 <__RODATA_PM_OFFSET__+0x1194>
iotcl_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:20
static bool config_is_valid = false;

bool iotcl_init(IotclConfig *c) {
    iotcl_deinit();
    if (
            !c || !c->device.env || !c->device.cpid || !c->device.duid ||
    919a:	e0 91 42 64 	lds	r30, 0x6442	; 0x806442 <lib_config+0x4>
    919e:	f0 91 43 64 	lds	r31, 0x6443	; 0x806443 <lib_config+0x5>
    91a2:	2d b7       	in	r18, 0x3d	; 61
    91a4:	3e b7       	in	r19, 0x3e	; 62
    91a6:	24 5f       	subi	r18, 0xF4	; 244
    91a8:	3f 4f       	sbci	r19, 0xFF	; 255
    91aa:	2d bf       	out	0x3d, r18	; 61
    91ac:	3e bf       	out	0x3e, r19	; 62
    91ae:	30 97       	sbiw	r30, 0x00	; 0
    91b0:	09 f4       	brne	.+2      	; 0x91b4 <__RODATA_PM_OFFSET__+0x11b4>
    91b2:	5b c0       	rjmp	.+182    	; 0x926a <__RODATA_PM_OFFSET__+0x126a>
    91b4:	a0 91 40 64 	lds	r26, 0x6440	; 0x806440 <lib_config+0x2>
    91b8:	b0 91 41 64 	lds	r27, 0x6441	; 0x806441 <lib_config+0x3>
    91bc:	10 97       	sbiw	r26, 0x00	; 0
    91be:	09 f4       	brne	.+2      	; 0x91c2 <__RODATA_PM_OFFSET__+0x11c2>
    91c0:	54 c0       	rjmp	.+168    	; 0x926a <__RODATA_PM_OFFSET__+0x126a>
    91c2:	80 91 3e 64 	lds	r24, 0x643E	; 0x80643e <lib_config>
    91c6:	90 91 3f 64 	lds	r25, 0x643F	; 0x80643f <lib_config+0x1>
    91ca:	00 97       	sbiw	r24, 0x00	; 0
    91cc:	09 f4       	brne	.+2      	; 0x91d0 <__RODATA_PM_OFFSET__+0x11d0>
    91ce:	4d c0       	rjmp	.+154    	; 0x926a <__RODATA_PM_OFFSET__+0x126a>
    91d0:	20 81       	ld	r18, Z
    91d2:	22 23       	and	r18, r18
    91d4:	09 f4       	brne	.+2      	; 0x91d8 <__RODATA_PM_OFFSET__+0x11d8>
    91d6:	49 c0       	rjmp	.+146    	; 0x926a <__RODATA_PM_OFFSET__+0x126a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:21
            0 == strlen(c->device.env) || 0 == strlen(c->device.cpid) || 0 == strlen(c->device.duid)
    91d8:	2c 91       	ld	r18, X
    91da:	22 23       	and	r18, r18
    91dc:	09 f4       	brne	.+2      	; 0x91e0 <__RODATA_PM_OFFSET__+0x11e0>
    91de:	45 c0       	rjmp	.+138    	; 0x926a <__RODATA_PM_OFFSET__+0x126a>
    91e0:	fc 01       	movw	r30, r24
    91e2:	20 81       	ld	r18, Z
    91e4:	22 23       	and	r18, r18
    91e6:	09 f4       	brne	.+2      	; 0x91ea <__RODATA_PM_OFFSET__+0x11ea>
    91e8:	40 c0       	rjmp	.+128    	; 0x926a <__RODATA_PM_OFFSET__+0x126a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:26
            ) {
        IOTCL_LOG ("IotConnectLib_Configure: configuration parameters missing" IOTCL_NL);
        return false;
    }
    if (strlen(c->device.cpid) + 1 /* dash, separator */  + strlen(c->device.duid) > MAX_DEVICE_COMBINED_NAME) {
    91ea:	fd 01       	movw	r30, r26
    91ec:	01 90       	ld	r0, Z+
    91ee:	00 20       	and	r0, r0
    91f0:	e9 f7       	brne	.-6      	; 0x91ec <__RODATA_PM_OFFSET__+0x11ec>
    91f2:	9f 01       	movw	r18, r30
    91f4:	fc 01       	movw	r30, r24
    91f6:	01 90       	ld	r0, Z+
    91f8:	00 20       	and	r0, r0
    91fa:	e9 f7       	brne	.-6      	; 0x91f6 <__RODATA_PM_OFFSET__+0x11f6>
    91fc:	31 97       	sbiw	r30, 0x01	; 1
    91fe:	e8 1b       	sub	r30, r24
    9200:	f9 0b       	sbc	r31, r25
    9202:	ea 1b       	sub	r30, r26
    9204:	fb 0b       	sbc	r31, r27
    9206:	e2 0f       	add	r30, r18
    9208:	f3 1f       	adc	r31, r19
    920a:	e1 38       	cpi	r30, 0x81	; 129
    920c:	f1 05       	cpc	r31, r1
    920e:	68 f5       	brcc	.+90     	; 0x926a <__RODATA_PM_OFFSET__+0x126a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:30
        IOTCL_LOG ("IotConnectLib_Configure: combined name (cpid + uuid) exceeded maximum value" IOTCL_NL);
        return false;
    }
    memcpy(&config, c, sizeof(config));
    9210:	80 e1       	ldi	r24, 0x10	; 16
    9212:	ee e3       	ldi	r30, 0x3E	; 62
    9214:	f4 e6       	ldi	r31, 0x64	; 100
    9216:	ad e2       	ldi	r26, 0x2D	; 45
    9218:	b4 e6       	ldi	r27, 0x64	; 100
    921a:	01 90       	ld	r0, Z+
    921c:	0d 92       	st	X+, r0
    921e:	8a 95       	dec	r24
    9220:	e1 f7       	brne	.-8      	; 0x921a <__RODATA_PM_OFFSET__+0x121a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:38
        // allocation failure
        IOTCL_LOG ("IotConnectLib_Configure: malloc failure" IOTCL_NL);
        iotcl_deinit();
        return false;
    }
    config_is_valid = true;
    9222:	81 e0       	ldi	r24, 0x01	; 1
    9224:	80 93 3d 64 	sts	0x643D, r24	; 0x80643d <config_is_valid>
iotconnect_sdk_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:276
    if (!iotcl_init(&lib_config)) {
        Log.error("Error: Failed to initialize the IoTConnect Lib");
        return false;
    }

    mqtt_config.status_cb = config.status_cb;
    9228:	20 91 00 66 	lds	r18, 0x6600	; 0x806600 <config+0xc>
    922c:	30 91 01 66 	lds	r19, 0x6601	; 0x806601 <config+0xd>
    9230:	20 93 52 64 	sts	0x6452, r18	; 0x806452 <mqtt_config+0x4>
    9234:	30 93 53 64 	sts	0x6453, r19	; 0x806453 <mqtt_config+0x5>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:277
    mqtt_config.c2d_msg_cb = on_mqtt_c2d_message;
    9238:	26 ef       	ldi	r18, 0xF6	; 246
    923a:	3f e2       	ldi	r19, 0x2F	; 47
    923c:	20 93 50 64 	sts	0x6450, r18	; 0x806450 <mqtt_config+0x2>
    9240:	30 93 51 64 	sts	0x6451, r19	; 0x806451 <mqtt_config+0x3>
iotc_mqtt_client_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:71
        c->status_cb(IOTC_CS_MQTT_DISCONNECTED);
    }
}

bool iotc_mqtt_client_init(IotConnectMqttClientConfig *config) {
    disconnect_received = false;
    9244:	10 92 2c 64 	sts	0x642C, r1	; 0x80642c <disconnect_received>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:72
    c = config;
    9248:	2e e4       	ldi	r18, 0x4E	; 78
    924a:	34 e6       	ldi	r19, 0x64	; 100
    924c:	20 93 2a 64 	sts	0x642A, r18	; 0x80642a <c>
    9250:	30 93 2b 64 	sts	0x642B, r19	; 0x80642b <c+0x1>
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:357

void LteClass::onDisconnect(void (*disconnect_callback)(void)) {
    disconnected_callback = disconnect_callback;
}

bool LteClass::isConnected(void) { return is_connected; }
    9254:	90 91 8d 66 	lds	r25, 0x668D	; 0x80668d <is_connected>
iotc_mqtt_client_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:77
    if (!c) {
        Log.error("iotc_mqtt_client_init() called with invalid arguments");
    }

    if (!Lte.isConnected()) {
    9258:	91 11       	cpse	r25, r1
    925a:	0a c0       	rjmp	.+20     	; 0x9270 <__RODATA_PM_OFFSET__+0x1270>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:78
        Log.error("LTE must be up and running before initializing MQTT");
    925c:	8c ed       	ldi	r24, 0xDC	; 220
    925e:	9e e5       	ldi	r25, 0x5E	; 94
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:85
    }

    // Initialize the ECC
    ATCA_STATUS status = ECC608.begin();
    if (status != ATCACERT_E_SUCCESS) {
        Log.error("Could not initialize ECC hardware");
    9260:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
iotconnect_sdk_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:279
    if (!iotc_mqtt_client_init(&mqtt_config)) {
        Log.error("Failed to connect!");
    9264:	80 e9       	ldi	r24, 0x90	; 144
    9266:	90 e6       	ldi	r25, 0x60	; 96
    9268:	64 ca       	rjmp	.-2872   	; 0x8732 <__RODATA_PM_OFFSET__+0x732>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:272
    cpid_buff[4] = 0;
    Log.infof("CPID: %s***\r\n", cpid_buff);
    Log.infof("ENV:  %s\r\n", config.env);

    if (!iotcl_init(&lib_config)) {
        Log.error("Error: Failed to initialize the IoTConnect Lib");
    926a:	8d ea       	ldi	r24, 0xAD	; 173
    926c:	9e e5       	ldi	r25, 0x5E	; 94
    926e:	61 ca       	rjmp	.-2878   	; 0x8732 <__RODATA_PM_OFFSET__+0x732>
begin():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/ecc608.cpp:35
};

ECC608Class ECC608 = ECC608Class::instance();

ATCA_STATUS ECC608Class::begin() {
    if (initialized) {
    9270:	90 91 7e 70 	lds	r25, 0x707E	; 0x80707e <ECC608>
    9274:	91 11       	cpse	r25, r1
    9276:	0b c0       	rjmp	.+22     	; 0x928e <__RODATA_PM_OFFSET__+0x128e>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/ecc608.cpp:38
        return ATCA_SUCCESS;
    } else {
        initialized = true;
    9278:	80 93 7e 70 	sts	0x707E, r24	; 0x80707e <ECC608>
atcab_init():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src\cryptoauthlib\lib/atca_basic.c:135
    927c:	89 ed       	ldi	r24, 0xD9	; 217
    927e:	91 e4       	ldi	r25, 0x41	; 65
    9280:	0e 94 9b 16 	call	0x2d36	; 0x2d36 <atcab_init_ext.constprop.49>
iotc_mqtt_client_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:84
        return false;
    }

    // Initialize the ECC
    ATCA_STATUS status = ECC608.begin();
    if (status != ATCACERT_E_SUCCESS) {
    9284:	89 2b       	or	r24, r25
    9286:	19 f0       	breq	.+6      	; 0x928e <__RODATA_PM_OFFSET__+0x128e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:85
        Log.error("Could not initialize ECC hardware");
    9288:	82 e4       	ldi	r24, 0x42	; 66
    928a:	99 e4       	ldi	r25, 0x49	; 73
    928c:	e9 cf       	rjmp	.-46     	; 0x9260 <__RODATA_PM_OFFSET__+0x1260>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:92
    }

    Log.infof("Attempting to connect to MQTT host:%s, client id:%s, username: %s\r\n",
        c->sr->broker.host,
        c->sr->broker.client_id,
        c->sr->broker.user_name
    928e:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    9292:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    9296:	01 90       	ld	r0, Z+
    9298:	f0 81       	ld	r31, Z
    929a:	e0 2d       	mov	r30, r0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:89
    if (status != ATCACERT_E_SUCCESS) {
        Log.error("Could not initialize ECC hardware");
        return false;
    }

    Log.infof("Attempting to connect to MQTT host:%s, client id:%s, username: %s\r\n",
    929c:	83 89       	ldd	r24, Z+19	; 0x13
    929e:	8f 93       	push	r24
    92a0:	82 89       	ldd	r24, Z+18	; 0x12
    92a2:	8f 93       	push	r24
    92a4:	85 85       	ldd	r24, Z+13	; 0x0d
    92a6:	8f 93       	push	r24
    92a8:	84 85       	ldd	r24, Z+12	; 0x0c
    92aa:	8f 93       	push	r24
    92ac:	81 89       	ldd	r24, Z+17	; 0x11
    92ae:	8f 93       	push	r24
    92b0:	80 89       	ldd	r24, Z+16	; 0x10
    92b2:	8f 93       	push	r24
    92b4:	80 e1       	ldi	r24, 0x10	; 16
    92b6:	9f e5       	ldi	r25, 0x5F	; 95
    92b8:	9f 93       	push	r25
    92ba:	8f 93       	push	r24
    92bc:	79 e6       	ldi	r23, 0x69	; 105
    92be:	e7 2e       	mov	r14, r23
    92c0:	70 e7       	ldi	r23, 0x70	; 112
    92c2:	f7 2e       	mov	r15, r23
    92c4:	ff 92       	push	r15
    92c6:	ef 92       	push	r14
    92c8:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:101
        c->sr->broker.host,
        MQTT_SECURE_PORT,
        true,
        60,
        true,
        c->sr->broker.user_name,
    92cc:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    92d0:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    92d4:	01 90       	ld	r0, Z+
    92d6:	f0 81       	ld	r31, Z
    92d8:	e0 2d       	mov	r30, r0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:95
        c->sr->broker.host,
        c->sr->broker.client_id,
        c->sr->broker.user_name
    );

    if(!MqttClient.begin(c->sr->broker.client_id,
    92da:	42 89       	ldd	r20, Z+18	; 0x12
    92dc:	53 89       	ldd	r21, Z+19	; 0x13
    92de:	60 89       	ldd	r22, Z+16	; 0x10
    92e0:	71 89       	ldd	r23, Z+17	; 0x11
    92e2:	84 85       	ldd	r24, Z+12	; 0x0c
    92e4:	95 85       	ldd	r25, Z+13	; 0x0d
    92e6:	0e 94 aa 1f 	call	0x3f54	; 0x3f54 <MqttClientClass::begin(char const*, char const*, unsigned int, bool, unsigned int, bool, char const*, char const*) [clone .constprop.45]>
    92ea:	2d b7       	in	r18, 0x3d	; 61
    92ec:	3e b7       	in	r19, 0x3e	; 62
    92ee:	26 5f       	subi	r18, 0xF6	; 246
    92f0:	3f 4f       	sbci	r19, 0xFF	; 255
    92f2:	2d bf       	out	0x3d, r18	; 61
    92f4:	3e bf       	out	0x3e, r19	; 62
    92f6:	81 11       	cpse	r24, r1
    92f8:	21 c0       	rjmp	.+66     	; 0x933c <__RODATA_PM_OFFSET__+0x133c>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:106
        c->sr->broker.user_name,
        "")) {
            Log.errorf("Failed to connect to MQTT using host:%s, client id:%s, username: %s\r\n",
                c->sr->broker.host,
                c->sr->broker.client_id,
                c->sr->broker.user_name
    92fa:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    92fe:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    9302:	01 90       	ld	r0, Z+
    9304:	f0 81       	ld	r31, Z
    9306:	e0 2d       	mov	r30, r0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:103
        true,
        60,
        true,
        c->sr->broker.user_name,
        "")) {
            Log.errorf("Failed to connect to MQTT using host:%s, client id:%s, username: %s\r\n",
    9308:	83 89       	ldd	r24, Z+19	; 0x13
    930a:	8f 93       	push	r24
    930c:	82 89       	ldd	r24, Z+18	; 0x12
    930e:	8f 93       	push	r24
    9310:	85 85       	ldd	r24, Z+13	; 0x0d
    9312:	8f 93       	push	r24
    9314:	84 85       	ldd	r24, Z+12	; 0x0c
    9316:	8f 93       	push	r24
    9318:	81 89       	ldd	r24, Z+17	; 0x11
    931a:	8f 93       	push	r24
    931c:	80 89       	ldd	r24, Z+16	; 0x10
    931e:	8f 93       	push	r24
    9320:	84 e5       	ldi	r24, 0x54	; 84
    9322:	9f e5       	ldi	r25, 0x5F	; 95
    9324:	9f 93       	push	r25
    9326:	8f 93       	push	r24
    9328:	ff 92       	push	r15
    932a:	ef 92       	push	r14
    932c:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    9330:	8d b7       	in	r24, 0x3d	; 61
    9332:	9e b7       	in	r25, 0x3e	; 62
    9334:	0a 96       	adiw	r24, 0x0a	; 10
    9336:	8d bf       	out	0x3d, r24	; 61
    9338:	9e bf       	out	0x3e, r25	; 62
    933a:	94 cf       	rjmp	.-216    	; 0x9264 <__RODATA_PM_OFFSET__+0x1264>
onConnectionStatusChange():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:562
}

void MqttClientClass::onConnectionStatusChange(void (*connected)(void),
                                               void (*disconnected)(void)) {
    if (connected != NULL) {
        connected_callback = connected;
    933c:	8e ec       	ldi	r24, 0xCE	; 206
    933e:	92 e0       	ldi	r25, 0x02	; 2
    9340:	80 93 28 64 	sts	0x6428, r24	; 0x806428 <connected_callback>
    9344:	90 93 29 64 	sts	0x6429, r25	; 0x806429 <connected_callback+0x1>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:566
    }

    if (disconnected != NULL) {
        disconnected_callback = disconnected;
    9348:	8b ed       	ldi	r24, 0xDB	; 219
    934a:	92 e0       	ldi	r25, 0x02	; 2
    934c:	80 93 8e 66 	sts	0x668E, r24	; 0x80668e <_ZL21disconnected_callback.lto_priv.138>
    9350:	90 93 8f 66 	sts	0x668F, r25	; 0x80668f <_ZL21disconnected_callback.lto_priv.138+0x1>
    9354:	49 e7       	ldi	r20, 0x79	; 121
    9356:	e4 2e       	mov	r14, r20
    9358:	f1 2c       	mov	r15, r1
iotc_mqtt_client_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:134
                c->sr->broker.client_id,
                c->sr->broker.user_name
            );
            return false;
        }
        Log.rawf(".");
    935a:	56 eb       	ldi	r21, 0xB6	; 182
    935c:	a5 2e       	mov	r10, r21
    935e:	57 e5       	ldi	r21, 0x57	; 87
    9360:	b5 2e       	mov	r11, r21
    9362:	69 e6       	ldi	r22, 0x69	; 105
    9364:	c6 2e       	mov	r12, r22
    9366:	60 e7       	ldi	r22, 0x70	; 112
    9368:	d6 2e       	mov	r13, r22
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:570
    }
}

bool MqttClientClass::isConnected(void) { return connected_to_broker; }
    936a:	80 91 90 66 	lds	r24, 0x6690	; 0x806690 <connected_to_broker>
iotc_mqtt_client_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:114
    }

    MqttClient.onConnectionStatusChange(on_mqtt_connected, on_mqtt_disconnected);

    int tires_num_500ms = 120; // 60 seconds
    while (!MqttClient.isConnected()) {
    936e:	81 11       	cpse	r24, r1
    9370:	73 c0       	rjmp	.+230    	; 0x9458 <__RODATA_PM_OFFSET__+0x1458>
    9372:	91 e0       	ldi	r25, 0x01	; 1
    9374:	e9 1a       	sub	r14, r25
    9376:	f1 08       	sbc	r15, r1
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:116
        tires_num_500ms--;
        if (tires_num_500ms < 0) {
    9378:	b9 f5       	brne	.+110    	; 0x93e8 <__RODATA_PM_OFFSET__+0x13e8>
print():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/log.cpp:30
    ((class Print*)(fdev_get_udata(fp)))->write((uint8_t)c);
    return 0;
}

void LogClass::print(const char* str, const char level[]) {
    this->uart->printf("%s%s\r\n", level, str);
    937a:	82 ef       	ldi	r24, 0xF2	; 242
    937c:	91 e6       	ldi	r25, 0x61	; 97
    937e:	9f 93       	push	r25
    9380:	8f 93       	push	r24
    9382:	9f 93       	push	r25
    9384:	8f 93       	push	r24
    9386:	8e e6       	ldi	r24, 0x6E	; 110
    9388:	9f e4       	ldi	r25, 0x4F	; 79
    938a:	9f 93       	push	r25
    938c:	8f 93       	push	r24
    938e:	09 e6       	ldi	r16, 0x69	; 105
    9390:	10 e7       	ldi	r17, 0x70	; 112
    9392:	80 91 6a 70 	lds	r24, 0x706A	; 0x80706a <Log+0x1>
    9396:	8f 93       	push	r24
    9398:	80 91 69 70 	lds	r24, 0x7069	; 0x807069 <Log>
    939c:	8f 93       	push	r24
    939e:	0e 94 07 0a 	call	0x140e	; 0x140e <Print::printf(char const*, ...) [clone .constprop.129]>
iotc_mqtt_client_init():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:121
            Log.raw(""); // start in a new line
            Log.errorf("Timed out while attempting to connect to MQTT using host:%s, client id:%s, username: %s\r\n",
                c->sr->broker.host,
                c->sr->broker.client_id,
                c->sr->broker.user_name
    93a2:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    93a6:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    93aa:	01 90       	ld	r0, Z+
    93ac:	f0 81       	ld	r31, Z
    93ae:	e0 2d       	mov	r30, r0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:118
    int tires_num_500ms = 120; // 60 seconds
    while (!MqttClient.isConnected()) {
        tires_num_500ms--;
        if (tires_num_500ms < 0) {
            Log.raw(""); // start in a new line
            Log.errorf("Timed out while attempting to connect to MQTT using host:%s, client id:%s, username: %s\r\n",
    93b0:	83 89       	ldd	r24, Z+19	; 0x13
    93b2:	8f 93       	push	r24
    93b4:	82 89       	ldd	r24, Z+18	; 0x12
    93b6:	8f 93       	push	r24
    93b8:	85 85       	ldd	r24, Z+13	; 0x0d
    93ba:	8f 93       	push	r24
    93bc:	84 85       	ldd	r24, Z+12	; 0x0c
    93be:	8f 93       	push	r24
    93c0:	81 89       	ldd	r24, Z+17	; 0x11
    93c2:	8f 93       	push	r24
    93c4:	80 89       	ldd	r24, Z+16	; 0x10
    93c6:	8f 93       	push	r24
    93c8:	8a e9       	ldi	r24, 0x9A	; 154
    93ca:	9f e5       	ldi	r25, 0x5F	; 95
    93cc:	9f 93       	push	r25
    93ce:	8f 93       	push	r24
    93d0:	1f 93       	push	r17
    93d2:	0f 93       	push	r16
    93d4:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:123
                c->sr->broker.host,
                c->sr->broker.client_id,
                c->sr->broker.user_name
            );
            MqttClient.end();
    93d8:	0e 94 3b 23 	call	0x4676	; 0x4676 <MqttClientClass::end() [clone .constprop.97]>
    93dc:	ad b7       	in	r26, 0x3d	; 61
    93de:	be b7       	in	r27, 0x3e	; 62
    93e0:	52 96       	adiw	r26, 0x12	; 18
    93e2:	ad bf       	out	0x3d, r26	; 61
    93e4:	be bf       	out	0x3e, r27	; 62
    93e6:	3e cf       	rjmp	.-388    	; 0x9264 <__RODATA_PM_OFFSET__+0x1264>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:126
            return false;
        }
        if (disconnect_received) {
    93e8:	80 91 2c 64 	lds	r24, 0x642C	; 0x80642c <disconnect_received>
    93ec:	88 23       	and	r24, r24
    93ee:	19 f1       	breq	.+70     	; 0x9436 <__RODATA_PM_OFFSET__+0x1436>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:130
            Log.errorf("Received a disconnect while attempting to connect to MQTT using host:%s, client id:%s, username: %s\r\n",
                c->sr->broker.host,
                c->sr->broker.client_id,
                c->sr->broker.user_name
    93f0:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    93f4:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    93f8:	01 90       	ld	r0, Z+
    93fa:	f0 81       	ld	r31, Z
    93fc:	e0 2d       	mov	r30, r0
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:127
            );
            MqttClient.end();
            return false;
        }
        if (disconnect_received) {
            Log.errorf("Received a disconnect while attempting to connect to MQTT using host:%s, client id:%s, username: %s\r\n",
    93fe:	83 89       	ldd	r24, Z+19	; 0x13
    9400:	8f 93       	push	r24
    9402:	82 89       	ldd	r24, Z+18	; 0x12
    9404:	8f 93       	push	r24
    9406:	85 85       	ldd	r24, Z+13	; 0x0d
    9408:	8f 93       	push	r24
    940a:	84 85       	ldd	r24, Z+12	; 0x0c
    940c:	8f 93       	push	r24
    940e:	81 89       	ldd	r24, Z+17	; 0x11
    9410:	8f 93       	push	r24
    9412:	80 89       	ldd	r24, Z+16	; 0x10
    9414:	8f 93       	push	r24
    9416:	84 ef       	ldi	r24, 0xF4	; 244
    9418:	9f e5       	ldi	r25, 0x5F	; 95
    941a:	9f 93       	push	r25
    941c:	8f 93       	push	r24
    941e:	89 e6       	ldi	r24, 0x69	; 105
    9420:	90 e7       	ldi	r25, 0x70	; 112
    9422:	9f 93       	push	r25
    9424:	8f 93       	push	r24
    9426:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    942a:	ed b7       	in	r30, 0x3d	; 61
    942c:	fe b7       	in	r31, 0x3e	; 62
    942e:	3a 96       	adiw	r30, 0x0a	; 10
    9430:	ed bf       	out	0x3d, r30	; 61
    9432:	fe bf       	out	0x3e, r31	; 62
    9434:	17 cf       	rjmp	.-466    	; 0x9264 <__RODATA_PM_OFFSET__+0x1264>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:134
                c->sr->broker.client_id,
                c->sr->broker.user_name
            );
            return false;
        }
        Log.rawf(".");
    9436:	bf 92       	push	r11
    9438:	af 92       	push	r10
    943a:	df 92       	push	r13
    943c:	cf 92       	push	r12
    943e:	0e 94 ba 0a 	call	0x1574	; 0x1574 <LogClass::rawf(char const*, ...) [clone .constprop.102]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:135
        delay(500);
    9442:	64 ef       	ldi	r22, 0xF4	; 244
    9444:	71 e0       	ldi	r23, 0x01	; 1
    9446:	80 e0       	ldi	r24, 0x00	; 0
    9448:	90 e0       	ldi	r25, 0x00	; 0
    944a:	0e 94 98 02 	call	0x530	; 0x530 <delay>
    944e:	0f 90       	pop	r0
    9450:	0f 90       	pop	r0
    9452:	0f 90       	pop	r0
    9454:	0f 90       	pop	r0
    9456:	89 cf       	rjmp	.-238    	; 0x936a <__RODATA_PM_OFFSET__+0x136a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:137
    }
    if(!MqttClient.subscribe(c->sr->broker.sub_topic)) {
    9458:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    945c:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    9460:	01 90       	ld	r0, Z+
    9462:	f0 81       	ld	r31, Z
    9464:	e0 2d       	mov	r30, r0
    9466:	80 8d       	ldd	r24, Z+24	; 0x18
    9468:	91 8d       	ldd	r25, Z+25	; 0x19
    946a:	0e 94 c5 1d 	call	0x3b8a	; 0x3b8a <MqttClientClass::subscribe(char const*, MqttQoS) [clone .constprop.41]>
    946e:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    9472:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    9476:	81 11       	cpse	r24, r1
    9478:	18 c0       	rjmp	.+48     	; 0x94aa <__RODATA_PM_OFFSET__+0x14aa>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:138
        Log.errorf("ERROR: Unable to subscribe for C2D messages topic %s!", c->sr->broker.sub_topic);
    947a:	01 90       	ld	r0, Z+
    947c:	f0 81       	ld	r31, Z
    947e:	e0 2d       	mov	r30, r0
    9480:	81 8d       	ldd	r24, Z+25	; 0x19
    9482:	8f 93       	push	r24
    9484:	80 8d       	ldd	r24, Z+24	; 0x18
    9486:	8f 93       	push	r24
    9488:	8a e5       	ldi	r24, 0x5A	; 90
    948a:	90 e6       	ldi	r25, 0x60	; 96
    948c:	9f 93       	push	r25
    948e:	8f 93       	push	r24
    9490:	89 e6       	ldi	r24, 0x69	; 105
    9492:	90 e7       	ldi	r25, 0x70	; 112
    9494:	9f 93       	push	r25
    9496:	8f 93       	push	r24
    9498:	0e 94 de 0a 	call	0x15bc	; 0x15bc <LogClass::errorf(char const*, ...) [clone .constprop.133]>
    949c:	0f 90       	pop	r0
    949e:	0f 90       	pop	r0
    94a0:	0f 90       	pop	r0
    94a2:	0f 90       	pop	r0
    94a4:	0f 90       	pop	r0
    94a6:	0f 90       	pop	r0
    94a8:	dd ce       	rjmp	.-582    	; 0x9264 <__RODATA_PM_OFFSET__+0x1264>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:143
        return false;
    }


    if (c->status_cb) {
    94aa:	04 80       	ldd	r0, Z+4	; 0x04
    94ac:	f5 81       	ldd	r31, Z+5	; 0x05
    94ae:	e0 2d       	mov	r30, r0
    94b0:	30 97       	sbiw	r30, 0x00	; 0
    94b2:	19 f0       	breq	.+6      	; 0x94ba <__RODATA_PM_OFFSET__+0x14ba>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:144
        c->status_cb(IOTC_CS_MQTT_CONNECTED);
    94b4:	81 e0       	ldi	r24, 0x01	; 1
    94b6:	90 e0       	ldi	r25, 0x00	; 0
    94b8:	09 95       	icall
onDisconnect():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/lte.cpp:354

    return String(buffer);
}

void LteClass::onDisconnect(void (*disconnect_callback)(void)) {
    disconnected_callback = disconnect_callback;
    94ba:	87 ec       	ldi	r24, 0xC7	; 199
    94bc:	92 e0       	ldi	r25, 0x02	; 2
    94be:	80 93 26 64 	sts	0x6426, r24	; 0x806426 <_ZL21disconnected_callback.lto_priv.137>
    94c2:	90 93 27 64 	sts	0x6427, r25	; 0x806427 <_ZL21disconnected_callback.lto_priv.137+0x1>
    94c6:	94 e1       	ldi	r25, 0x14	; 20
    94c8:	c9 2e       	mov	r12, r25
    94ca:	d1 2c       	mov	r13, r1
publish_telemetry():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:123
    iotcl_telemetry_set_string(msg, "version", APP_VERSION);
    iotcl_telemetry_set_number(msg, "random", rand() % 100);

    const char *str = iotcl_create_serialized_string(msg, false);
    iotcl_telemetry_destroy(msg);
    Log.infof("Sending: %s\r\n", str);
    94cc:	29 e6       	ldi	r18, 0x69	; 105
    94ce:	e2 2e       	mov	r14, r18
    94d0:	20 e7       	ldi	r18, 0x70	; 112
    94d2:	f2 2e       	mov	r15, r18
readMessage():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:757

    SequansController.clearReceiveBuffer();

    // We determine all message IDs lower than 0 as just no message ID passed
    if (message_id < 0) {
        char command[MQTT_RECEIVE_LENGTH] = "";
    94d4:	9e 01       	movw	r18, r28
    94d6:	2d 5f       	subi	r18, 0xFD	; 253
    94d8:	3f 4f       	sbci	r19, 0xFF	; 255
    94da:	c0 5e       	subi	r28, 0xE0	; 224
    94dc:	de 4f       	sbci	r29, 0xFE	; 254
    94de:	28 83       	st	Y, r18
    94e0:	39 83       	std	Y+1, r19	; 0x01
    94e2:	c0 52       	subi	r28, 0x20	; 32
    94e4:	d1 40       	sbci	r29, 0x01	; 1
iotc_mqtt_client_loop():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:50
    String message = MqttClient.readMessage(c->sr->broker.sub_topic);
    // Read message will return an empty string if there were no new
    // messages, so anything other than that means that there was a new
    // message
    if (message != "") {
        Log.infof("Got new message: %s", message.c_str());
    94e6:	3c e2       	ldi	r19, 0x2C	; 44
    94e8:	23 2e       	mov	r2, r19
    94ea:	31 e6       	ldi	r19, 0x61	; 97
    94ec:	33 2e       	mov	r3, r19
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:250
  config->cmd_cb = on_command;

  if (iotconnect_sdk_init()) {
    Lte.onDisconnect(on_lte_disconnect);
    for (int i = 0; i < 20; i++) {
      if (!connecteded_to_network || !iotconnect_sdk_is_connected()) {
    94ee:	80 91 02 66 	lds	r24, 0x6602	; 0x806602 <connecteded_to_network>
    94f2:	88 23       	and	r24, r24
    94f4:	09 f4       	brne	.+2      	; 0x94f8 <__RODATA_PM_OFFSET__+0x14f8>
    94f6:	3e c1       	rjmp	.+636    	; 0x9774 <__RODATA_PM_OFFSET__+0x1774>
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:570
    if (disconnected != NULL) {
        disconnected_callback = disconnected;
    }
}

bool MqttClientClass::isConnected(void) { return connected_to_broker; }
    94f8:	80 91 90 66 	lds	r24, 0x6690	; 0x806690 <connected_to_broker>
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:250
    94fc:	88 23       	and	r24, r24
    94fe:	09 f4       	brne	.+2      	; 0x9502 <__RODATA_PM_OFFSET__+0x1502>
    9500:	39 c1       	rjmp	.+626    	; 0x9774 <__RODATA_PM_OFFSET__+0x1774>
iotcl_get_config():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_lib.c:44
    return true;
}


IotclConfig *iotcl_get_config(void) {
    if (!config_is_valid) {
    9502:	80 91 3d 64 	lds	r24, 0x643D	; 0x80643d <config_is_valid>
    9506:	81 11       	cpse	r24, r1
    9508:	03 c0       	rjmp	.+6      	; 0x9510 <__RODATA_PM_OFFSET__+0x1510>
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:142
    cleanup_value:
    cJSON_free(msg->root_value);

    cleanup:
    cJSON_free(msg);
    return NULL;
    950a:	b1 2c       	mov	r11, r1
    950c:	a1 2c       	mov	r10, r1
    950e:	75 c0       	rjmp	.+234    	; 0x95fa <__RODATA_PM_OFFSET__+0x15fa>
iotcl_telemetry_create():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:109

IotclMessageHandle iotcl_telemetry_create(void) {
    cJSON *sdk_array = NULL;
    IotclConfig *config = iotcl_get_config();
    if (!config) return NULL;
    if (!config->telemetry.dtg) return NULL;
    9510:	80 91 33 64 	lds	r24, 0x6433	; 0x806433 <config+0x6>
    9514:	90 91 34 64 	lds	r25, 0x6434	; 0x806434 <config+0x7>
    9518:	89 2b       	or	r24, r25
    951a:	b9 f3       	breq	.-18     	; 0x950a <__RODATA_PM_OFFSET__+0x150a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:110
    struct IotclMessageHandleTag *msg =
    951c:	61 e0       	ldi	r22, 0x01	; 1
    951e:	70 e0       	ldi	r23, 0x00	; 0
    9520:	86 e0       	ldi	r24, 0x06	; 6
    9522:	90 e0       	ldi	r25, 0x00	; 0
    9524:	0e 94 9e 54 	call	0xa93c	; 0xa93c <calloc>
    9528:	5c 01       	movw	r10, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:113
            (struct IotclMessageHandleTag *) calloc(sizeof(struct IotclMessageHandleTag), 1);

    if (!msg) return NULL;
    952a:	89 2b       	or	r24, r25
    952c:	71 f3       	breq	.-36     	; 0x950a <__RODATA_PM_OFFSET__+0x150a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:115

    msg->root_value = cJSON_CreateObject();
    952e:	0e 94 de 10 	call	0x21bc	; 0x21bc <cJSON_CreateObject>
    9532:	d5 01       	movw	r26, r10
    9534:	8d 93       	st	X+, r24
    9536:	9c 93       	st	X, r25
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:117

    if (!msg->root_value) goto cleanup;
    9538:	00 97       	sbiw	r24, 0x00	; 0
    953a:	e9 f1       	breq	.+122    	; 0x95b6 <__RODATA_PM_OFFSET__+0x15b6>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:119

    if (!cJSON_AddStringToObject(msg->root_value, "cpid", config->device.cpid)) goto cleanup_value;
    953c:	40 91 2f 64 	lds	r20, 0x642F	; 0x80642f <config+0x2>
    9540:	50 91 30 64 	lds	r21, 0x6430	; 0x806430 <config+0x3>
    9544:	61 e7       	ldi	r22, 0x71	; 113
    9546:	73 e5       	ldi	r23, 0x53	; 83
    9548:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    954c:	89 2b       	or	r24, r25
    954e:	71 f1       	breq	.+92     	; 0x95ac <__RODATA_PM_OFFSET__+0x15ac>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:120
    if (!cJSON_AddStringToObject(msg->root_value, "dtg", config->telemetry.dtg)) goto cleanup_value;
    9550:	40 91 33 64 	lds	r20, 0x6433	; 0x806433 <config+0x6>
    9554:	50 91 34 64 	lds	r21, 0x6434	; 0x806434 <config+0x7>
    9558:	65 ee       	ldi	r22, 0xE5	; 229
    955a:	7a e5       	ldi	r23, 0x5A	; 90
    955c:	f5 01       	movw	r30, r10
    955e:	80 81       	ld	r24, Z
    9560:	91 81       	ldd	r25, Z+1	; 0x01
    9562:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    9566:	89 2b       	or	r24, r25
    9568:	09 f1       	breq	.+66     	; 0x95ac <__RODATA_PM_OFFSET__+0x15ac>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:121
    if (!cJSON_AddNumberToObject(msg->root_value, "mt", 0)) goto cleanup_value; // telemetry message type (zero)
    956a:	20 e0       	ldi	r18, 0x00	; 0
    956c:	30 e0       	ldi	r19, 0x00	; 0
    956e:	a9 01       	movw	r20, r18
    9570:	66 e6       	ldi	r22, 0x66	; 102
    9572:	78 e4       	ldi	r23, 0x48	; 72
    9574:	d5 01       	movw	r26, r10
    9576:	8d 91       	ld	r24, X+
    9578:	9c 91       	ld	r25, X
    957a:	0e 94 3f 11 	call	0x227e	; 0x227e <cJSON_AddNumberToObject>
    957e:	89 2b       	or	r24, r25
    9580:	a9 f0       	breq	.+42     	; 0x95ac <__RODATA_PM_OFFSET__+0x15ac>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:122
    sdk_array = cJSON_AddObjectToObject(msg->root_value, "sdk");
    9582:	67 e7       	ldi	r22, 0x77	; 119
    9584:	78 e4       	ldi	r23, 0x48	; 72
    9586:	f5 01       	movw	r30, r10
    9588:	80 81       	ld	r24, Z
    958a:	91 81       	ldd	r25, Z+1	; 0x01
    958c:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <cJSON_AddObjectToObject>
    9590:	4c 01       	movw	r8, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:123
    if (!sdk_array) goto cleanup_value;
    9592:	00 97       	sbiw	r24, 0x00	; 0
    9594:	59 f0       	breq	.+22     	; 0x95ac <__RODATA_PM_OFFSET__+0x15ac>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:124
    if (!cJSON_AddStringToObject(sdk_array, "l", CONFIG_IOTCONNECT_SDK_NAME)) goto cleanup_array;
    9596:	4b e7       	ldi	r20, 0x7B	; 123
    9598:	58 e4       	ldi	r21, 0x48	; 72
    959a:	6f e1       	ldi	r22, 0x1F	; 31
    959c:	77 e4       	ldi	r23, 0x47	; 71
    959e:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    95a2:	89 2b       	or	r24, r25
    95a4:	61 f4       	brne	.+24     	; 0x95be <__RODATA_PM_OFFSET__+0x15be>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:135
    if (!msg->telemetry_data_array) goto cleanup_array;

    return msg;

    cleanup_array:
    cJSON_free(sdk_array);
    95a6:	c4 01       	movw	r24, r8
    95a8:	0e 94 1b 05 	call	0xa36	; 0xa36 <cJSON_free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:138

    cleanup_value:
    cJSON_free(msg->root_value);
    95ac:	d5 01       	movw	r26, r10
    95ae:	8d 91       	ld	r24, X+
    95b0:	9c 91       	ld	r25, X
    95b2:	0e 94 1b 05 	call	0xa36	; 0xa36 <cJSON_free>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:141

    cleanup:
    cJSON_free(msg);
    95b6:	c5 01       	movw	r24, r10
    95b8:	0e 94 1b 05 	call	0xa36	; 0xa36 <cJSON_free>
    95bc:	a6 cf       	rjmp	.-180    	; 0x950a <__RODATA_PM_OFFSET__+0x150a>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:125
    if (!cJSON_AddStringToObject(msg->root_value, "dtg", config->telemetry.dtg)) goto cleanup_value;
    if (!cJSON_AddNumberToObject(msg->root_value, "mt", 0)) goto cleanup_value; // telemetry message type (zero)
    sdk_array = cJSON_AddObjectToObject(msg->root_value, "sdk");
    if (!sdk_array) goto cleanup_value;
    if (!cJSON_AddStringToObject(sdk_array, "l", CONFIG_IOTCONNECT_SDK_NAME)) goto cleanup_array;
    if (!cJSON_AddStringToObject(sdk_array, "v", CONFIG_IOTCONNECT_SDK_VERSION)) goto cleanup_array;
    95be:	4f e7       	ldi	r20, 0x7F	; 127
    95c0:	58 e4       	ldi	r21, 0x48	; 72
    95c2:	63 e8       	ldi	r22, 0x83	; 131
    95c4:	78 e4       	ldi	r23, 0x48	; 72
    95c6:	c4 01       	movw	r24, r8
    95c8:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    95cc:	89 2b       	or	r24, r25
    95ce:	59 f3       	breq	.-42     	; 0x95a6 <__RODATA_PM_OFFSET__+0x15a6>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:126
    if (!cJSON_AddStringToObject(sdk_array, "e", config->device.env)) goto cleanup_array;
    95d0:	40 91 31 64 	lds	r20, 0x6431	; 0x806431 <config+0x4>
    95d4:	50 91 32 64 	lds	r21, 0x6432	; 0x806432 <config+0x5>
    95d8:	6a ee       	ldi	r22, 0xEA	; 234
    95da:	7a e5       	ldi	r23, 0x5A	; 90
    95dc:	c4 01       	movw	r24, r8
    95de:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    95e2:	89 2b       	or	r24, r25
    95e4:	01 f3       	breq	.-64     	; 0x95a6 <__RODATA_PM_OFFSET__+0x15a6>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:128

    msg->telemetry_data_array = cJSON_AddArrayToObject(msg->root_value, "d");
    95e6:	d5 01       	movw	r26, r10
    95e8:	8d 91       	ld	r24, X+
    95ea:	9c 91       	ld	r25, X
    95ec:	0e 94 bb 10 	call	0x2176	; 0x2176 <cJSON_AddArrayToObject.constprop.82>
    95f0:	f5 01       	movw	r30, r10
    95f2:	82 83       	std	Z+2, r24	; 0x02
    95f4:	93 83       	std	Z+3, r25	; 0x03
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:130

    if (!msg->telemetry_data_array) goto cleanup_array;
    95f6:	89 2b       	or	r24, r25
    95f8:	b1 f2       	breq	.-84     	; 0x95a6 <__RODATA_PM_OFFSET__+0x15a6>
iotcl_iso_timestamp_now():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:23
    95fa:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <to_iso_timestamp.constprop.106>
publish_telemetry():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:117
static void publish_telemetry() {
    IotclMessageHandle msg = iotcl_telemetry_create();

    // Optional. The first time you create a data point, the current timestamp will be automatically added
    // TelemetryAddWith* calls are only required if sending multiple data points in one packet.
    iotcl_telemetry_add_with_iso_time(msg, iotcl_iso_timestamp_now());
    95fe:	bc 01       	movw	r22, r24
    9600:	c5 01       	movw	r24, r10
    9602:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <iotcl_telemetry_add_with_iso_time>
iotcl_telemetry_set_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:213
    free(leaf_name);
    return false;
}

bool iotcl_telemetry_set_string(IotclMessageHandle message, const char *path, const char *value) {
    if (!message) return false;
    9606:	a1 14       	cp	r10, r1
    9608:	b1 04       	cpc	r11, r1
    960a:	29 f1       	breq	.+74     	; 0x9656 <__RODATA_PM_OFFSET__+0x1656>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:214
    if (NULL == message->current_telemetry_object) {
    960c:	f5 01       	movw	r30, r10
    960e:	84 81       	ldd	r24, Z+4	; 0x04
    9610:	95 81       	ldd	r25, Z+5	; 0x05
    9612:	89 2b       	or	r24, r25
    9614:	31 f4       	brne	.+12     	; 0x9622 <__RODATA_PM_OFFSET__+0x1622>
iotcl_iso_timestamp_now():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:23
    9616:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <to_iso_timestamp.constprop.106>
iotcl_telemetry_set_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:215
        iotcl_telemetry_add_with_iso_time(message, iotcl_iso_timestamp_now());
    961a:	bc 01       	movw	r22, r24
    961c:	c5 01       	movw	r24, r10
    961e:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <iotcl_telemetry_add_with_iso_time>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:217
    }
    char *leaf_name = NULL;
    9622:	19 82       	std	Y+1, r1	; 0x01
    9624:	1a 82       	std	Y+2, r1	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:218
    cJSON *const target = json_object_dotset_locate(message->current_telemetry_object, &leaf_name, path);
    9626:	43 ea       	ldi	r20, 0xA3	; 163
    9628:	50 e6       	ldi	r21, 0x60	; 96
    962a:	b8 01       	movw	r22, r16
    962c:	d5 01       	movw	r26, r10
    962e:	14 96       	adiw	r26, 0x04	; 4
    9630:	8d 91       	ld	r24, X+
    9632:	9c 91       	ld	r25, X
    9634:	0e 94 72 2b 	call	0x56e4	; 0x56e4 <json_object_dotset_locate.constprop.84>
    9638:	4c 01       	movw	r8, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:219
    if (!target) goto cleanup; // out of memory
    963a:	00 97       	sbiw	r24, 0x00	; 0
    963c:	41 f0       	breq	.+16     	; 0x964e <__RODATA_PM_OFFSET__+0x164e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:221

    if (!cJSON_AddStringToObject(target, leaf_name, value)) goto cleanup_tgt;
    963e:	69 81       	ldd	r22, Y+1	; 0x01
    9640:	7a 81       	ldd	r23, Y+2	; 0x02
    9642:	45 e8       	ldi	r20, 0x85	; 133
    9644:	52 e5       	ldi	r21, 0x52	; 82
    9646:	0e 94 08 11 	call	0x2210	; 0x2210 <cJSON_AddStringToObject>
    964a:	89 2b       	or	r24, r25
    964c:	69 f1       	breq	.+90     	; 0x96a8 <__RODATA_PM_OFFSET__+0x16a8>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:229

    cleanup_tgt:
    cJSON_free(target);

    cleanup:
    free(leaf_name);
    964e:	89 81       	ldd	r24, Y+1	; 0x01
    9650:	9a 81       	ldd	r25, Y+2	; 0x02
    9652:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
publish_telemetry():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:119
    iotcl_telemetry_set_string(msg, "version", APP_VERSION);
    iotcl_telemetry_set_number(msg, "random", rand() % 100);
    9656:	82 d1       	rcall	.+772    	; 0x995c <rand>
    9658:	64 e6       	ldi	r22, 0x64	; 100
    965a:	70 e0       	ldi	r23, 0x00	; 0
    965c:	37 d7       	rcall	.+3694   	; 0xa4cc <__divmodhi4>
    965e:	bc 01       	movw	r22, r24
    9660:	99 0f       	add	r25, r25
    9662:	88 0b       	sbc	r24, r24
    9664:	99 0b       	sbc	r25, r25
    9666:	f9 d5       	rcall	.+3058   	; 0xa25a <__floatsisf>
    9668:	2b 01       	movw	r4, r22
    966a:	3c 01       	movw	r6, r24
main():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:255
    free(leaf_name);
    return false;
}

const char *iotcl_create_serialized_string(IotclMessageHandle message, bool pretty) {
    if (!message) return NULL;
    966c:	91 2c       	mov	r9, r1
    966e:	81 2c       	mov	r8, r1
iotcl_telemetry_set_number():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:171
    }
    return true;
}

bool iotcl_telemetry_set_number(IotclMessageHandle message, const char *path, double value) {
    if (!message) return false;
    9670:	a1 14       	cp	r10, r1
    9672:	b1 04       	cpc	r11, r1
    9674:	09 f4       	brne	.+2      	; 0x9678 <__RODATA_PM_OFFSET__+0x1678>
    9676:	43 c0       	rjmp	.+134    	; 0x96fe <__RODATA_PM_OFFSET__+0x16fe>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:172
    if (NULL == message->current_telemetry_object) {
    9678:	f5 01       	movw	r30, r10
    967a:	84 81       	ldd	r24, Z+4	; 0x04
    967c:	95 81       	ldd	r25, Z+5	; 0x05
    967e:	89 2b       	or	r24, r25
    9680:	b9 f0       	breq	.+46     	; 0x96b0 <__RODATA_PM_OFFSET__+0x16b0>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:175
        if (!iotcl_telemetry_add_with_iso_time(message, iotcl_iso_timestamp_now())) return false;
    }
    char *leaf_name = NULL;
    9682:	19 82       	std	Y+1, r1	; 0x01
    9684:	1a 82       	std	Y+2, r1	; 0x02
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:176
    cJSON *target = json_object_dotset_locate(message->current_telemetry_object, &leaf_name, path);
    9686:	4b ea       	ldi	r20, 0xAB	; 171
    9688:	50 e6       	ldi	r21, 0x60	; 96
    968a:	b8 01       	movw	r22, r16
    968c:	d5 01       	movw	r26, r10
    968e:	14 96       	adiw	r26, 0x04	; 4
    9690:	8d 91       	ld	r24, X+
    9692:	9c 91       	ld	r25, X
    9694:	0e 94 72 2b 	call	0x56e4	; 0x56e4 <json_object_dotset_locate.constprop.84>
    9698:	4c 01       	movw	r8, r24
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:177
    if (!target) goto cleanup; // out of memory
    969a:	00 97       	sbiw	r24, 0x00	; 0
    969c:	c9 f4       	brne	.+50     	; 0x96d0 <__RODATA_PM_OFFSET__+0x16d0>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:187

    cleanup_tgt:
    cJSON_free(target);

    cleanup:
    free(leaf_name);
    969e:	89 81       	ldd	r24, Y+1	; 0x01
    96a0:	9a 81       	ldd	r25, Y+2	; 0x02
    96a2:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    96a6:	0c c0       	rjmp	.+24     	; 0x96c0 <__RODATA_PM_OFFSET__+0x16c0>
iotcl_telemetry_set_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:226
    if (!cJSON_AddStringToObject(target, leaf_name, value)) goto cleanup_tgt;
    free(leaf_name);
    return true;

    cleanup_tgt:
    cJSON_free(target);
    96a8:	c4 01       	movw	r24, r8
    96aa:	0e 94 1b 05 	call	0xa36	; 0xa36 <cJSON_free>
    96ae:	cf cf       	rjmp	.-98     	; 0x964e <__RODATA_PM_OFFSET__+0x164e>
iotcl_iso_timestamp_now():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_common.c:23
    96b0:	0e 94 3d 17 	call	0x2e7a	; 0x2e7a <to_iso_timestamp.constprop.106>
iotcl_telemetry_set_number():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:173
}

bool iotcl_telemetry_set_number(IotclMessageHandle message, const char *path, double value) {
    if (!message) return false;
    if (NULL == message->current_telemetry_object) {
        if (!iotcl_telemetry_add_with_iso_time(message, iotcl_iso_timestamp_now())) return false;
    96b4:	bc 01       	movw	r22, r24
    96b6:	c5 01       	movw	r24, r10
    96b8:	0e 94 f8 2a 	call	0x55f0	; 0x55f0 <iotcl_telemetry_add_with_iso_time>
    96bc:	81 11       	cpse	r24, r1
    96be:	e1 cf       	rjmp	.-62     	; 0x9682 <__RODATA_PM_OFFSET__+0x1682>
iotcl_create_serialized_string():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:256
    return false;
}

const char *iotcl_create_serialized_string(IotclMessageHandle message, bool pretty) {
    if (!message) return NULL;
    if (!message->root_value) return NULL;
    96c0:	f5 01       	movw	r30, r10
    96c2:	80 81       	ld	r24, Z
    96c4:	91 81       	ldd	r25, Z+1	; 0x01
    96c6:	00 97       	sbiw	r24, 0x00	; 0
    96c8:	79 f4       	brne	.+30     	; 0x96e8 <__RODATA_PM_OFFSET__+0x16e8>
main():
    96ca:	91 2c       	mov	r9, r1
    96cc:	81 2c       	mov	r8, r1
    96ce:	12 c0       	rjmp	.+36     	; 0x96f4 <__RODATA_PM_OFFSET__+0x16f4>
iotcl_telemetry_set_number():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:179
    }
    char *leaf_name = NULL;
    cJSON *target = json_object_dotset_locate(message->current_telemetry_object, &leaf_name, path);
    if (!target) goto cleanup; // out of memory

    if (!cJSON_AddNumberToObject(target, leaf_name, value)) goto cleanup_tgt;
    96d0:	69 81       	ldd	r22, Y+1	; 0x01
    96d2:	7a 81       	ldd	r23, Y+2	; 0x02
    96d4:	a3 01       	movw	r20, r6
    96d6:	92 01       	movw	r18, r4
    96d8:	0e 94 3f 11 	call	0x227e	; 0x227e <cJSON_AddNumberToObject>
    96dc:	89 2b       	or	r24, r25
    96de:	f9 f6       	brne	.-66     	; 0x969e <__RODATA_PM_OFFSET__+0x169e>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:184
    free(leaf_name);
    return true;

    cleanup_tgt:
    cJSON_free(target);
    96e0:	c4 01       	movw	r24, r8
    96e2:	0e 94 1b 05 	call	0xa36	; 0xa36 <cJSON_free>
    96e6:	db cf       	rjmp	.-74     	; 0x969e <__RODATA_PM_OFFSET__+0x169e>
cJSON_PrintUnformatted():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/cJSON.c:1255
    return (char*)print(item, true, &global_hooks);
}

CJSON_PUBLIC(char *) cJSON_PrintUnformatted(const cJSON *item)
{
    return (char*)print(item, false, &global_hooks);
    96e8:	70 e0       	ldi	r23, 0x00	; 0
    96ea:	60 e0       	ldi	r22, 0x00	; 0
    96ec:	0e 94 39 1d 	call	0x3a72	; 0x3a72 <print.constprop.111>
    96f0:	98 2e       	mov	r9, r24
    96f2:	89 2e       	mov	r8, r25
iotcl_telemetry_destroy():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:270
    cJSON_free((char *) serialized_string);
}

void iotcl_telemetry_destroy(IotclMessageHandle message) {
    if (message) {
        cJSON_Delete(message->root_value);
    96f4:	d5 01       	movw	r26, r10
    96f6:	8d 91       	ld	r24, X+
    96f8:	9c 91       	ld	r25, X
    96fa:	0e 94 f1 06 	call	0xde2	; 0xde2 <cJSON_Delete>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:272
    }
    free(message);
    96fe:	c5 01       	movw	r24, r10
    9700:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
publish_telemetry():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:123

    const char *str = iotcl_create_serialized_string(msg, false);
    iotcl_telemetry_destroy(msg);
    Log.infof("Sending: %s\r\n", str);
    9704:	8f 92       	push	r8
    9706:	9f 92       	push	r9
    9708:	e2 eb       	ldi	r30, 0xB2	; 178
    970a:	f0 e6       	ldi	r31, 0x60	; 96
    970c:	ff 93       	push	r31
    970e:	ef 93       	push	r30
    9710:	ff 92       	push	r15
    9712:	ef 92       	push	r14
    9714:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
iotconnect_sdk_send_packet():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/IoTConnectSDK.cpp:222
        config.msg_cb(data, type);
    }
}

bool iotconnect_sdk_send_packet(const char *data) {
    return iotc_mqtt_client_send_message(data);
    9718:	89 2d       	mov	r24, r9
    971a:	98 2d       	mov	r25, r8
    971c:	0e 94 75 28 	call	0x50ea	; 0x50ea <iotc_mqtt_client_send_message(char const*)>
iotcl_destroy_serialized():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotconnect_telemetry.c:265
        return cJSON_PrintUnformatted(message->root_value);
    }
}

void iotcl_destroy_serialized(const char *serialized_string) {
    cJSON_free((char *) serialized_string);
    9720:	89 2d       	mov	r24, r9
    9722:	98 2d       	mov	r25, r8
    9724:	0e 94 1b 05 	call	0xa36	; 0xa36 <cJSON_free>
    9728:	0f 90       	pop	r0
    972a:	0f 90       	pop	r0
    972c:	0f 90       	pop	r0
    972e:	0f 90       	pop	r0
    9730:	0f 90       	pop	r0
    9732:	0f 90       	pop	r0
    9734:	82 e3       	ldi	r24, 0x32	; 50
    9736:	a8 2e       	mov	r10, r24
    9738:	b1 2c       	mov	r11, r1
iotc_mqtt_client_loop():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:35
bool iotc_mqtt_client_send_message(const char *message) {
    return MqttClient.publish(c->sr->broker.pub_topic, message);
}

void iotc_mqtt_client_loop() {
    if (!c || !c->sr) {
    973a:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    973e:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    9742:	30 97       	sbiw	r30, 0x00	; 0
    9744:	21 f0       	breq	.+8      	; 0x974e <__RODATA_PM_OFFSET__+0x174e>
    9746:	a0 81       	ld	r26, Z
    9748:	b1 81       	ldd	r27, Z+1	; 0x01
    974a:	10 97       	sbiw	r26, 0x00	; 0
    974c:	e9 f4       	brne	.+58     	; 0x9788 <__RODATA_PM_OFFSET__+0x1788>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:36
        Log.error("iotc_mqtt_client_loop(): Client not initialized!");
    974e:	80 ec       	ldi	r24, 0xC0	; 192
    9750:	90 e6       	ldi	r25, 0x60	; 96
    9752:	0e 94 47 0a 	call	0x148e	; 0x148e <LogClass::error(char const*) [clone .constprop.127]>
demo_setup():
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:258
      }
      publish_telemetry(); // publish as soon as we detect that button stat changed
      // pause 5 second and "loop" frequently to read incoming mesages
      for (int j = 0; j < 50; j++) {
        iotconnect_sdk_loop();
        delay(100);
    9756:	64 e6       	ldi	r22, 0x64	; 100
    9758:	70 e0       	ldi	r23, 0x00	; 0
    975a:	80 e0       	ldi	r24, 0x00	; 0
    975c:	90 e0       	ldi	r25, 0x00	; 0
    975e:	0e 94 98 02 	call	0x530	; 0x530 <delay>
    9762:	91 e0       	ldi	r25, 0x01	; 1
    9764:	a9 1a       	sub	r10, r25
    9766:	b1 08       	sbc	r11, r1
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:256
        // not connected, but mqtt should try to reconnect
        break;
      }
      publish_telemetry(); // publish as soon as we detect that button stat changed
      // pause 5 second and "loop" frequently to read incoming mesages
      for (int j = 0; j < 50; j++) {
    9768:	41 f7       	brne	.-48     	; 0x973a <__RODATA_PM_OFFSET__+0x173a>
    976a:	a1 e0       	ldi	r26, 0x01	; 1
    976c:	ca 1a       	sub	r12, r26
    976e:	d1 08       	sbc	r13, r1
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:249
  config->status_cb = on_connection_status;
  config->cmd_cb = on_command;

  if (iotconnect_sdk_init()) {
    Lte.onDisconnect(on_lte_disconnect);
    for (int i = 0; i < 20; i++) {
    9770:	09 f0       	breq	.+2      	; 0x9774 <__RODATA_PM_OFFSET__+0x1774>
    9772:	bd ce       	rjmp	.-646    	; 0x94ee <__RODATA_PM_OFFSET__+0x14ee>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:266
  } else {
    Log.error("Encountered an error while initializing the SDK!");
    return;
  }

  iotconnect_sdk_disconnect();
    9774:	0e 94 64 23 	call	0x46c8	; 0x46c8 <iotconnect_sdk_disconnect()>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:267
  Lte.end();    
    9778:	0e 94 bc 27 	call	0x4f78	; 0x4f78 <LteClass::end() [clone .constprop.95]>
C:\Users\bobm\active_projects\IoT-Cell-mini\Avnet\avr_iot_sample/avr-iot-sample.cpp:268
  printf("Done.\n");
    977c:	81 e7       	ldi	r24, 0x71	; 113
    977e:	91 e6       	ldi	r25, 0x61	; 97
    9780:	0e 94 58 57 	call	0xaeb0	; 0xaeb0 <puts>
    9784:	0c 94 0b 42 	jmp	0x8416	; 0x8416 <__RODATA_PM_OFFSET__+0x416>
isConnected():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:570
    9788:	80 91 90 66 	lds	r24, 0x6690	; 0x806690 <connected_to_broker>
iotc_mqtt_client_loop():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:39
        return;
    }
    if (!MqttClient.isConnected()) {
    978c:	81 11       	cpse	r24, r1
    978e:	09 c0       	rjmp	.+18     	; 0x97a2 <__RODATA_PM_OFFSET__+0x17a2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:40
        if (c->status_cb) {
    9790:	04 80       	ldd	r0, Z+4	; 0x04
    9792:	f5 81       	ldd	r31, Z+5	; 0x05
    9794:	e0 2d       	mov	r30, r0
    9796:	30 97       	sbiw	r30, 0x00	; 0
    9798:	21 f0       	breq	.+8      	; 0x97a2 <__RODATA_PM_OFFSET__+0x17a2>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:41
            c->status_cb(IOTC_CS_MQTT_DISCONNECTED);
    979a:	82 e0       	ldi	r24, 0x02	; 2
    979c:	90 e0       	ldi	r25, 0x00	; 0
    979e:	09 95       	icall
    97a0:	da cf       	rjmp	.-76     	; 0x9756 <__RODATA_PM_OFFSET__+0x1756>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:45
            return;
        }
    }
    String message = MqttClient.readMessage(c->sr->broker.sub_topic);
    97a2:	58 96       	adiw	r26, 0x18	; 24
    97a4:	4c 90       	ld	r4, X
    97a6:	58 97       	sbiw	r26, 0x18	; 24
    97a8:	59 96       	adiw	r26, 0x19	; 25
    97aa:	5c 90       	ld	r5, X
readMessage():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:800
    char buffer[size + 16];
    if (!readMessage(topic, buffer, sizeof(buffer))) {
        return "";
    }

    return buffer;
    97ac:	6d b6       	in	r6, 0x3d	; 61
    97ae:	7e b6       	in	r7, 0x3e	; 62
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:793

    return (response == ResponseResult::OK);
}

String MqttClientClass::readMessage(const char* topic, const uint16_t size) {
    Log.debugf("Reading message on topic %s\r\n", topic);
    97b0:	5f 92       	push	r5
    97b2:	4f 92       	push	r4
    97b4:	81 ef       	ldi	r24, 0xF1	; 241
    97b6:	90 e6       	ldi	r25, 0x60	; 96
    97b8:	9f 93       	push	r25
    97ba:	8f 93       	push	r24
    97bc:	ff 92       	push	r15
    97be:	ef 92       	push	r14
    97c0:	0e 94 52 0b 	call	0x16a4	; 0x16a4 <LogClass::debugf(char const*, ...) [clone .constprop.118]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:795
    // Add bytes for termination of AT command when reading
    char buffer[size + 16];
    97c4:	0f 90       	pop	r0
    97c6:	0f 90       	pop	r0
    97c8:	0f 90       	pop	r0
    97ca:	0f 90       	pop	r0
    97cc:	0f 90       	pop	r0
    97ce:	0f 90       	pop	r0
    97d0:	ed b7       	in	r30, 0x3d	; 61
    97d2:	fe b7       	in	r31, 0x3e	; 62
    97d4:	e0 51       	subi	r30, 0x10	; 16
    97d6:	f1 40       	sbci	r31, 0x01	; 1
    97d8:	ed bf       	out	0x3d, r30	; 61
    97da:	fe bf       	out	0x3e, r31	; 62
    97dc:	2d b7       	in	r18, 0x3d	; 61
    97de:	3e b7       	in	r19, 0x3e	; 62
    97e0:	2f 5f       	subi	r18, 0xFF	; 255
    97e2:	3f 4f       	sbci	r19, 0xFF	; 255
    97e4:	49 01       	movw	r8, r18
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:753
    // We don't use writeCommand here as the AT receive command for MQTT
    // will return a carraige return and a line feed before the content, so
    // we write the bytes and manually clear these character before the
    // payload

    SequansController.clearReceiveBuffer();
    97e6:	0e 94 82 07 	call	0xf04	; 0xf04 <SequansControllerClass::clearReceiveBuffer() [clone .constprop.125]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:757

    // We determine all message IDs lower than 0 as just no message ID passed
    if (message_id < 0) {
        char command[MQTT_RECEIVE_LENGTH] = "";
    97ea:	19 82       	std	Y+1, r1	; 0x01
    97ec:	1a 82       	std	Y+2, r1	; 0x02
    97ee:	c0 5e       	subi	r28, 0xE0	; 224
    97f0:	de 4f       	sbci	r29, 0xFE	; 254
    97f2:	a8 81       	ld	r26, Y
    97f4:	b9 81       	ldd	r27, Y+1	; 0x01
    97f6:	c0 52       	subi	r28, 0x20	; 32
    97f8:	d1 40       	sbci	r29, 0x01	; 1
    97fa:	e9 e9       	ldi	r30, 0x99	; 153
    97fc:	1d 92       	st	X+, r1
    97fe:	ea 95       	dec	r30
    9800:	e9 f7       	brne	.-6      	; 0x97fc <__RODATA_PM_OFFSET__+0x17fc>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:758
        sprintf(command, MQTT_RECEIVE, topic);
    9802:	5f 92       	push	r5
    9804:	4f 92       	push	r4
    9806:	2f e0       	ldi	r18, 0x0F	; 15
    9808:	31 e6       	ldi	r19, 0x61	; 97
    980a:	3f 93       	push	r19
    980c:	2f 93       	push	r18
    980e:	1f 93       	push	r17
    9810:	0f 93       	push	r16
    9812:	0e 94 ba 57 	call	0xaf74	; 0xaf74 <sprintf>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:760

        SequansController.writeBytes((uint8_t*)&command[0],
    9816:	f8 01       	movw	r30, r16
    9818:	01 90       	ld	r0, Z+
    981a:	00 20       	and	r0, r0
    981c:	e9 f7       	brne	.-6      	; 0x9818 <__RODATA_PM_OFFSET__+0x1818>
    981e:	31 97       	sbiw	r30, 0x01	; 1
    9820:	bf 01       	movw	r22, r30
    9822:	60 1b       	sub	r22, r16
    9824:	71 0b       	sbc	r23, r17
    9826:	41 e0       	ldi	r20, 0x01	; 1
    9828:	c8 01       	movw	r24, r16
    982a:	0e 94 b6 0e 	call	0x1d6c	; 0x1d6c <SequansControllerClass::writeBytes(unsigned char const*, unsigned int, bool) [clone .constprop.119]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:778
                                     strlen(command),
                                     true);
    }

    // First two bytes are \r\n for the MQTT message response, so we flush those
    if (!SequansController.waitForByte('\r', 100)) {
    982e:	44 e6       	ldi	r20, 0x64	; 100
    9830:	50 e0       	ldi	r21, 0x00	; 0
    9832:	60 e0       	ldi	r22, 0x00	; 0
    9834:	70 e0       	ldi	r23, 0x00	; 0
    9836:	8d e0       	ldi	r24, 0x0D	; 13
    9838:	0e 94 b9 07 	call	0xf72	; 0xf72 <SequansControllerClass::waitForByte(unsigned char, unsigned long) [clone .constprop.116]>
    983c:	0f 90       	pop	r0
    983e:	0f 90       	pop	r0
    9840:	0f 90       	pop	r0
    9842:	0f 90       	pop	r0
    9844:	0f 90       	pop	r0
    9846:	0f 90       	pop	r0
    9848:	81 11       	cpse	r24, r1
    984a:	2f c0       	rjmp	.+94     	; 0x98aa <__RODATA_PM_OFFSET__+0x18aa>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:797
String MqttClientClass::readMessage(const char* topic, const uint16_t size) {
    Log.debugf("Reading message on topic %s\r\n", topic);
    // Add bytes for termination of AT command when reading
    char buffer[size + 16];
    if (!readMessage(topic, buffer, sizeof(buffer))) {
        return "";
    984c:	62 ef       	ldi	r22, 0xF2	; 242
    984e:	71 e6       	ldi	r23, 0x61	; 97
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:800
    }

    return buffer;
    9850:	c8 01       	movw	r24, r16
    9852:	0e 94 be 09 	call	0x137c	; 0x137c <String::String(char const*)>
    9856:	6d be       	out	0x3d, r6	; 61
    9858:	7e be       	out	0x3e, r7	; 62
equals():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:464
unsigned char String::equals(const String &s2) const {
  return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const {
  if (len == 0) {
    985a:	8d 81       	ldd	r24, Y+5	; 0x05
    985c:	9e 81       	ldd	r25, Y+6	; 0x06
    985e:	89 2b       	or	r24, r25
    9860:	f9 f0       	breq	.+62     	; 0x98a0 <__RODATA_PM_OFFSET__+0x18a0>
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:470
    return (cstr == NULL || *cstr == 0);
  }
  if (cstr == NULL) {
    return buffer[0] == 0;
  }
  return strcmp(buffer, cstr) == 0;
    9862:	e9 81       	ldd	r30, Y+1	; 0x01
    9864:	fa 81       	ldd	r31, Y+2	; 0x02
iotc_mqtt_client_loop():
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:49
    // Read message will return an empty string if there were no new
    // messages, so anything other than that means that there was a new
    // message
    if (message != "") {
    9866:	80 81       	ld	r24, Z
    9868:	88 23       	and	r24, r24
    986a:	d1 f0       	breq	.+52     	; 0x98a0 <__RODATA_PM_OFFSET__+0x18a0>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:50
        Log.infof("Got new message: %s", message.c_str());
    986c:	ff 93       	push	r31
    986e:	ef 93       	push	r30
    9870:	3f 92       	push	r3
    9872:	2f 92       	push	r2
    9874:	ff 92       	push	r15
    9876:	ef 92       	push	r14
    9878:	0e 94 22 0c 	call	0x1844	; 0x1844 <LogClass::infof(char const*, ...) [clone .constprop.90]>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:51
        if (c->c2d_msg_cb) {
    987c:	e0 91 2a 64 	lds	r30, 0x642A	; 0x80642a <c>
    9880:	f0 91 2b 64 	lds	r31, 0x642B	; 0x80642b <c+0x1>
    9884:	02 80       	ldd	r0, Z+2	; 0x02
    9886:	f3 81       	ldd	r31, Z+3	; 0x03
    9888:	e0 2d       	mov	r30, r0
    988a:	0f 90       	pop	r0
    988c:	0f 90       	pop	r0
    988e:	0f 90       	pop	r0
    9890:	0f 90       	pop	r0
    9892:	0f 90       	pop	r0
    9894:	0f 90       	pop	r0
    9896:	30 97       	sbiw	r30, 0x00	; 0
    9898:	19 f0       	breq	.+6      	; 0x98a0 <__RODATA_PM_OFFSET__+0x18a0>
c:\Users\bobm\Documents\Arduino\libraries\iotconnect-mchp-avr-sdk\src/iotc_mqtt_client.cpp:53
            const char* c_str = message.c_str();
            c->c2d_msg_cb(c_str);
    989a:	89 81       	ldd	r24, Y+1	; 0x01
    989c:	9a 81       	ldd	r25, Y+2	; 0x02
    989e:	09 95       	icall
__base_dtor ():
C:\Users\bobm\AppData\Local\Arduino15\packages\DxCore\hardware\megaavr\1.5.6\cores\dxcore\api/String.cpp:114
  char buf[33];
  *this = dtostrf(value, (decimalPlaces + 2), decimalPlaces, buf);
}

String::~String() {
  free(buffer);
    98a0:	89 81       	ldd	r24, Y+1	; 0x01
    98a2:	9a 81       	ldd	r25, Y+2	; 0x02
    98a4:	0e 94 54 55 	call	0xaaa8	; 0xaaa8 <free>
    98a8:	56 cf       	rjmp	.-340    	; 0x9756 <__RODATA_PM_OFFSET__+0x1756>
readMessage():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:781

    // First two bytes are \r\n for the MQTT message response, so we flush those
    if (!SequansController.waitForByte('\r', 100)) {
        return false;
    }
    if (!SequansController.waitForByte('\n', 100)) {
    98aa:	44 e6       	ldi	r20, 0x64	; 100
    98ac:	50 e0       	ldi	r21, 0x00	; 0
    98ae:	60 e0       	ldi	r22, 0x00	; 0
    98b0:	70 e0       	ldi	r23, 0x00	; 0
    98b2:	8a e0       	ldi	r24, 0x0A	; 10
    98b4:	0e 94 b9 07 	call	0xf72	; 0xf72 <SequansControllerClass::waitForByte(unsigned char, unsigned long) [clone .constprop.116]>
    98b8:	88 23       	and	r24, r24
    98ba:	41 f2       	breq	.-112    	; 0x984c <__RODATA_PM_OFFSET__+0x184c>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:787
        return false;
    }

    // Then we can read the response into the buffer
    const ResponseResult response = SequansController.readResponse(buffer,
                                                                   buffer_size);
    98bc:	60 e1       	ldi	r22, 0x10	; 16
    98be:	71 e0       	ldi	r23, 0x01	; 1
    98c0:	c4 01       	movw	r24, r8
    98c2:	0e 94 70 17 	call	0x2ee0	; 0x2ee0 <SequansControllerClass::readResponse(char*, unsigned int) [clone .constprop.99]>
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:796

String MqttClientClass::readMessage(const char* topic, const uint16_t size) {
    Log.debugf("Reading message on topic %s\r\n", topic);
    // Add bytes for termination of AT command when reading
    char buffer[size + 16];
    if (!readMessage(topic, buffer, sizeof(buffer))) {
    98c6:	01 97       	sbiw	r24, 0x01	; 1
    98c8:	09 f6       	brne	.-126    	; 0x984c <__RODATA_PM_OFFSET__+0x184c>
    98ca:	b4 01       	movw	r22, r8
    98cc:	c1 cf       	rjmp	.-126    	; 0x9850 <__RODATA_PM_OFFSET__+0x1850>

000098ce <do_rand>:
do_rand():
    98ce:	8f 92       	push	r8
    98d0:	9f 92       	push	r9
    98d2:	af 92       	push	r10
    98d4:	bf 92       	push	r11
    98d6:	cf 92       	push	r12
    98d8:	df 92       	push	r13
    98da:	ef 92       	push	r14
    98dc:	ff 92       	push	r15
    98de:	cf 93       	push	r28
    98e0:	df 93       	push	r29
    98e2:	ec 01       	movw	r28, r24
    98e4:	68 81       	ld	r22, Y
    98e6:	79 81       	ldd	r23, Y+1	; 0x01
    98e8:	8a 81       	ldd	r24, Y+2	; 0x02
    98ea:	9b 81       	ldd	r25, Y+3	; 0x03
    98ec:	61 15       	cp	r22, r1
    98ee:	71 05       	cpc	r23, r1
    98f0:	81 05       	cpc	r24, r1
    98f2:	91 05       	cpc	r25, r1
    98f4:	21 f4       	brne	.+8      	; 0x98fe <do_rand+0x30>
    98f6:	64 e2       	ldi	r22, 0x24	; 36
    98f8:	79 ed       	ldi	r23, 0xD9	; 217
    98fa:	8b e5       	ldi	r24, 0x5B	; 91
    98fc:	97 e0       	ldi	r25, 0x07	; 7
    98fe:	2d e1       	ldi	r18, 0x1D	; 29
    9900:	33 ef       	ldi	r19, 0xF3	; 243
    9902:	41 e0       	ldi	r20, 0x01	; 1
    9904:	50 e0       	ldi	r21, 0x00	; 0
    9906:	17 d6       	rcall	.+3118   	; 0xa536 <__divmodsi4>
    9908:	49 01       	movw	r8, r18
    990a:	5a 01       	movw	r10, r20
    990c:	9b 01       	movw	r18, r22
    990e:	ac 01       	movw	r20, r24
    9910:	a7 ea       	ldi	r26, 0xA7	; 167
    9912:	b1 e4       	ldi	r27, 0x41	; 65
    9914:	32 d6       	rcall	.+3172   	; 0xa57a <__muluhisi3>
    9916:	6b 01       	movw	r12, r22
    9918:	7c 01       	movw	r14, r24
    991a:	ac ee       	ldi	r26, 0xEC	; 236
    991c:	b4 ef       	ldi	r27, 0xF4	; 244
    991e:	a5 01       	movw	r20, r10
    9920:	94 01       	movw	r18, r8
    9922:	37 d6       	rcall	.+3182   	; 0xa592 <__mulohisi3>
    9924:	dc 01       	movw	r26, r24
    9926:	cb 01       	movw	r24, r22
    9928:	8c 0d       	add	r24, r12
    992a:	9d 1d       	adc	r25, r13
    992c:	ae 1d       	adc	r26, r14
    992e:	bf 1d       	adc	r27, r15
    9930:	b7 ff       	sbrs	r27, 7
    9932:	03 c0       	rjmp	.+6      	; 0x993a <do_rand+0x6c>
    9934:	01 97       	sbiw	r24, 0x01	; 1
    9936:	a1 09       	sbc	r26, r1
    9938:	b0 48       	sbci	r27, 0x80	; 128
    993a:	88 83       	st	Y, r24
    993c:	99 83       	std	Y+1, r25	; 0x01
    993e:	aa 83       	std	Y+2, r26	; 0x02
    9940:	bb 83       	std	Y+3, r27	; 0x03
    9942:	9f 77       	andi	r25, 0x7F	; 127
    9944:	df 91       	pop	r29
    9946:	cf 91       	pop	r28
    9948:	ff 90       	pop	r15
    994a:	ef 90       	pop	r14
    994c:	df 90       	pop	r13
    994e:	cf 90       	pop	r12
    9950:	bf 90       	pop	r11
    9952:	af 90       	pop	r10
    9954:	9f 90       	pop	r9
    9956:	8f 90       	pop	r8
    9958:	08 95       	ret

0000995a <rand_r>:
rand_r():
    995a:	b9 cf       	rjmp	.-142    	; 0x98ce <do_rand>

0000995c <rand>:
rand():
    995c:	88 e0       	ldi	r24, 0x08	; 8
    995e:	92 e4       	ldi	r25, 0x42	; 66
    9960:	b6 cf       	rjmp	.-148    	; 0x98ce <do_rand>

00009962 <srand>:
srand():
    9962:	b0 e0       	ldi	r27, 0x00	; 0
    9964:	a0 e0       	ldi	r26, 0x00	; 0
    9966:	80 93 08 42 	sts	0x4208, r24	; 0x804208 <next>
    996a:	90 93 09 42 	sts	0x4209, r25	; 0x804209 <next+0x1>
    996e:	a0 93 0a 42 	sts	0x420A, r26	; 0x80420a <next+0x2>
    9972:	b0 93 0b 42 	sts	0x420B, r27	; 0x80420b <next+0x3>
    9976:	08 95       	ret

00009978 <strtod>:
strtod():
    9978:	8f 92       	push	r8
    997a:	9f 92       	push	r9
    997c:	af 92       	push	r10
    997e:	bf 92       	push	r11
    9980:	cf 92       	push	r12
    9982:	df 92       	push	r13
    9984:	ef 92       	push	r14
    9986:	ff 92       	push	r15
    9988:	0f 93       	push	r16
    998a:	1f 93       	push	r17
    998c:	cf 93       	push	r28
    998e:	df 93       	push	r29
    9990:	5c 01       	movw	r10, r24
    9992:	7b 01       	movw	r14, r22
    9994:	61 15       	cp	r22, r1
    9996:	71 05       	cpc	r23, r1
    9998:	19 f0       	breq	.+6      	; 0x99a0 <strtod+0x28>
    999a:	db 01       	movw	r26, r22
    999c:	8d 93       	st	X+, r24
    999e:	9c 93       	st	X, r25
    99a0:	85 01       	movw	r16, r10
    99a2:	0f 5f       	subi	r16, 0xFF	; 255
    99a4:	1f 4f       	sbci	r17, 0xFF	; 255
    99a6:	f5 01       	movw	r30, r10
    99a8:	d0 81       	ld	r29, Z
    99aa:	8d 2f       	mov	r24, r29
    99ac:	90 e0       	ldi	r25, 0x00	; 0
    99ae:	59 d3       	rcall	.+1714   	; 0xa062 <isspace>
    99b0:	6c 01       	movw	r12, r24
    99b2:	89 2b       	or	r24, r25
    99b4:	a9 f5       	brne	.+106    	; 0x9a20 <strtod+0xa8>
    99b6:	dd 32       	cpi	r29, 0x2D	; 45
    99b8:	a9 f5       	brne	.+106    	; 0x9a24 <strtod+0xac>
    99ba:	0f 5f       	subi	r16, 0xFF	; 255
    99bc:	1f 4f       	sbci	r17, 0xFF	; 255
    99be:	d5 01       	movw	r26, r10
    99c0:	11 96       	adiw	r26, 0x01	; 1
    99c2:	dc 91       	ld	r29, X
    99c4:	c1 e0       	ldi	r28, 0x01	; 1
    99c6:	58 01       	movw	r10, r16
    99c8:	f1 e0       	ldi	r31, 0x01	; 1
    99ca:	af 1a       	sub	r10, r31
    99cc:	b1 08       	sbc	r11, r1
    99ce:	43 e0       	ldi	r20, 0x03	; 3
    99d0:	50 e0       	ldi	r21, 0x00	; 0
    99d2:	6e e5       	ldi	r22, 0x5E	; 94
    99d4:	71 e0       	ldi	r23, 0x01	; 1
    99d6:	c5 01       	movw	r24, r10
    99d8:	4c d3       	rcall	.+1688   	; 0xa072 <strncasecmp_P>
    99da:	89 2b       	or	r24, r25
    99dc:	61 f5       	brne	.+88     	; 0x9a36 <strtod+0xbe>
    99de:	68 01       	movw	r12, r16
    99e0:	82 e0       	ldi	r24, 0x02	; 2
    99e2:	c8 0e       	add	r12, r24
    99e4:	d1 1c       	adc	r13, r1
    99e6:	45 e0       	ldi	r20, 0x05	; 5
    99e8:	50 e0       	ldi	r21, 0x00	; 0
    99ea:	69 e5       	ldi	r22, 0x59	; 89
    99ec:	71 e0       	ldi	r23, 0x01	; 1
    99ee:	c6 01       	movw	r24, r12
    99f0:	40 d3       	rcall	.+1664   	; 0xa072 <strncasecmp_P>
    99f2:	89 2b       	or	r24, r25
    99f4:	21 f4       	brne	.+8      	; 0x99fe <strtod+0x86>
    99f6:	68 01       	movw	r12, r16
    99f8:	97 e0       	ldi	r25, 0x07	; 7
    99fa:	c9 0e       	add	r12, r25
    99fc:	d1 1c       	adc	r13, r1
    99fe:	e1 14       	cp	r14, r1
    9a00:	f1 04       	cpc	r15, r1
    9a02:	19 f0       	breq	.+6      	; 0x9a0a <strtod+0x92>
    9a04:	d7 01       	movw	r26, r14
    9a06:	cd 92       	st	X+, r12
    9a08:	dc 92       	st	X, r13
    9a0a:	60 e0       	ldi	r22, 0x00	; 0
    9a0c:	70 e0       	ldi	r23, 0x00	; 0
    9a0e:	80 e8       	ldi	r24, 0x80	; 128
    9a10:	9f ef       	ldi	r25, 0xFF	; 255
    9a12:	c1 11       	cpse	r28, r1
    9a14:	f9 c0       	rjmp	.+498    	; 0x9c08 <strtod+0x290>
    9a16:	60 e0       	ldi	r22, 0x00	; 0
    9a18:	70 e0       	ldi	r23, 0x00	; 0
    9a1a:	80 e8       	ldi	r24, 0x80	; 128
    9a1c:	9f e7       	ldi	r25, 0x7F	; 127
    9a1e:	f4 c0       	rjmp	.+488    	; 0x9c08 <strtod+0x290>
    9a20:	58 01       	movw	r10, r16
    9a22:	be cf       	rjmp	.-132    	; 0x99a0 <strtod+0x28>
    9a24:	db 32       	cpi	r29, 0x2B	; 43
    9a26:	29 f4       	brne	.+10     	; 0x9a32 <strtod+0xba>
    9a28:	85 01       	movw	r16, r10
    9a2a:	0e 5f       	subi	r16, 0xFE	; 254
    9a2c:	1f 4f       	sbci	r17, 0xFF	; 255
    9a2e:	f5 01       	movw	r30, r10
    9a30:	d1 81       	ldd	r29, Z+1	; 0x01
    9a32:	c0 e0       	ldi	r28, 0x00	; 0
    9a34:	c8 cf       	rjmp	.-112    	; 0x99c6 <strtod+0x4e>
    9a36:	43 e0       	ldi	r20, 0x03	; 3
    9a38:	50 e0       	ldi	r21, 0x00	; 0
    9a3a:	66 e5       	ldi	r22, 0x56	; 86
    9a3c:	71 e0       	ldi	r23, 0x01	; 1
    9a3e:	c5 01       	movw	r24, r10
    9a40:	18 d3       	rcall	.+1584   	; 0xa072 <strncasecmp_P>
    9a42:	89 2b       	or	r24, r25
    9a44:	e9 f0       	breq	.+58     	; 0x9a80 <strtod+0x108>
    9a46:	f8 01       	movw	r30, r16
    9a48:	10 e0       	ldi	r17, 0x00	; 0
    9a4a:	00 e0       	ldi	r16, 0x00	; 0
    9a4c:	20 e0       	ldi	r18, 0x00	; 0
    9a4e:	30 e0       	ldi	r19, 0x00	; 0
    9a50:	a9 01       	movw	r20, r18
    9a52:	5f 01       	movw	r10, r30
    9a54:	b0 ed       	ldi	r27, 0xD0	; 208
    9a56:	8b 2e       	mov	r8, r27
    9a58:	8d 0e       	add	r8, r29
    9a5a:	89 e0       	ldi	r24, 0x09	; 9
    9a5c:	88 15       	cp	r24, r8
    9a5e:	c0 f1       	brcs	.+112    	; 0x9ad0 <strtod+0x158>
    9a60:	9c 2e       	mov	r9, r28
    9a62:	68 94       	set
    9a64:	91 f8       	bld	r9, 1
    9a66:	8c 2f       	mov	r24, r28
    9a68:	88 70       	andi	r24, 0x08	; 8
    9a6a:	c2 ff       	sbrs	r28, 2
    9a6c:	16 c0       	rjmp	.+44     	; 0x9a9a <strtod+0x122>
    9a6e:	81 11       	cpse	r24, r1
    9a70:	02 c0       	rjmp	.+4      	; 0x9a76 <strtod+0xfe>
    9a72:	0f 5f       	subi	r16, 0xFF	; 255
    9a74:	1f 4f       	sbci	r17, 0xFF	; 255
    9a76:	31 96       	adiw	r30, 0x01	; 1
    9a78:	d5 01       	movw	r26, r10
    9a7a:	dc 91       	ld	r29, X
    9a7c:	c9 2d       	mov	r28, r9
    9a7e:	e9 cf       	rjmp	.-46     	; 0x9a52 <strtod+0xda>
    9a80:	e1 14       	cp	r14, r1
    9a82:	f1 04       	cpc	r15, r1
    9a84:	29 f0       	breq	.+10     	; 0x9a90 <strtod+0x118>
    9a86:	0e 5f       	subi	r16, 0xFE	; 254
    9a88:	1f 4f       	sbci	r17, 0xFF	; 255
    9a8a:	f7 01       	movw	r30, r14
    9a8c:	00 83       	st	Z, r16
    9a8e:	11 83       	std	Z+1, r17	; 0x01
    9a90:	60 e0       	ldi	r22, 0x00	; 0
    9a92:	70 e0       	ldi	r23, 0x00	; 0
    9a94:	80 ec       	ldi	r24, 0xC0	; 192
    9a96:	9f e7       	ldi	r25, 0x7F	; 127
    9a98:	b7 c0       	rjmp	.+366    	; 0x9c08 <strtod+0x290>
    9a9a:	88 23       	and	r24, r24
    9a9c:	11 f0       	breq	.+4      	; 0x9aa2 <strtod+0x12a>
    9a9e:	01 50       	subi	r16, 0x01	; 1
    9aa0:	11 09       	sbc	r17, r1
    9aa2:	a5 e0       	ldi	r26, 0x05	; 5
    9aa4:	b0 e0       	ldi	r27, 0x00	; 0
    9aa6:	69 d5       	rcall	.+2770   	; 0xa57a <__muluhisi3>
    9aa8:	9b 01       	movw	r18, r22
    9aaa:	ac 01       	movw	r20, r24
    9aac:	22 0f       	add	r18, r18
    9aae:	33 1f       	adc	r19, r19
    9ab0:	44 1f       	adc	r20, r20
    9ab2:	55 1f       	adc	r21, r21
    9ab4:	28 0d       	add	r18, r8
    9ab6:	31 1d       	adc	r19, r1
    9ab8:	41 1d       	adc	r20, r1
    9aba:	51 1d       	adc	r21, r1
    9abc:	28 39       	cpi	r18, 0x98	; 152
    9abe:	99 e9       	ldi	r25, 0x99	; 153
    9ac0:	39 07       	cpc	r19, r25
    9ac2:	49 07       	cpc	r20, r25
    9ac4:	99 e1       	ldi	r25, 0x19	; 25
    9ac6:	59 07       	cpc	r21, r25
    9ac8:	b0 f2       	brcs	.-84     	; 0x9a76 <strtod+0xfe>
    9aca:	c6 60       	ori	r28, 0x06	; 6
    9acc:	9c 2e       	mov	r9, r28
    9ace:	d3 cf       	rjmp	.-90     	; 0x9a76 <strtod+0xfe>
    9ad0:	ae ef       	ldi	r26, 0xFE	; 254
    9ad2:	8a 12       	cpse	r8, r26
    9ad4:	06 c0       	rjmp	.+12     	; 0x9ae2 <strtod+0x16a>
    9ad6:	c3 fd       	sbrc	r28, 3
    9ad8:	3c c0       	rjmp	.+120    	; 0x9b52 <strtod+0x1da>
    9ada:	9c 2e       	mov	r9, r28
    9adc:	68 94       	set
    9ade:	93 f8       	bld	r9, 3
    9ae0:	ca cf       	rjmp	.-108    	; 0x9a76 <strtod+0xfe>
    9ae2:	df 7d       	andi	r29, 0xDF	; 223
    9ae4:	d5 34       	cpi	r29, 0x45	; 69
    9ae6:	a9 f5       	brne	.+106    	; 0x9b52 <strtod+0x1da>
    9ae8:	80 81       	ld	r24, Z
    9aea:	8d 32       	cpi	r24, 0x2D	; 45
    9aec:	39 f4       	brne	.+14     	; 0x9afc <strtod+0x184>
    9aee:	c0 61       	ori	r28, 0x10	; 16
    9af0:	df 01       	movw	r26, r30
    9af2:	12 96       	adiw	r26, 0x02	; 2
    9af4:	81 81       	ldd	r24, Z+1	; 0x01
    9af6:	62 e0       	ldi	r22, 0x02	; 2
    9af8:	70 e0       	ldi	r23, 0x00	; 0
    9afa:	06 c0       	rjmp	.+12     	; 0x9b08 <strtod+0x190>
    9afc:	df 01       	movw	r26, r30
    9afe:	8b 32       	cpi	r24, 0x2B	; 43
    9b00:	c1 f3       	breq	.-16     	; 0x9af2 <strtod+0x17a>
    9b02:	11 96       	adiw	r26, 0x01	; 1
    9b04:	61 e0       	ldi	r22, 0x01	; 1
    9b06:	70 e0       	ldi	r23, 0x00	; 0
    9b08:	80 53       	subi	r24, 0x30	; 48
    9b0a:	5d 01       	movw	r10, r26
    9b0c:	a6 1a       	sub	r10, r22
    9b0e:	b7 0a       	sbc	r11, r23
    9b10:	8a 30       	cpi	r24, 0x0A	; 10
    9b12:	f8 f4       	brcc	.+62     	; 0x9b52 <strtod+0x1da>
    9b14:	e0 e8       	ldi	r30, 0x80	; 128
    9b16:	ce 16       	cp	r12, r30
    9b18:	ec e0       	ldi	r30, 0x0C	; 12
    9b1a:	de 06       	cpc	r13, r30
    9b1c:	5c f4       	brge	.+22     	; 0x9b34 <strtod+0x1bc>
    9b1e:	b6 01       	movw	r22, r12
    9b20:	66 0f       	add	r22, r22
    9b22:	77 1f       	adc	r23, r23
    9b24:	66 0f       	add	r22, r22
    9b26:	77 1f       	adc	r23, r23
    9b28:	c6 0e       	add	r12, r22
    9b2a:	d7 1e       	adc	r13, r23
    9b2c:	cc 0c       	add	r12, r12
    9b2e:	dd 1c       	adc	r13, r13
    9b30:	c8 0e       	add	r12, r24
    9b32:	d1 1c       	adc	r13, r1
    9b34:	5d 01       	movw	r10, r26
    9b36:	ff ef       	ldi	r31, 0xFF	; 255
    9b38:	af 1a       	sub	r10, r31
    9b3a:	bf 0a       	sbc	r11, r31
    9b3c:	8c 91       	ld	r24, X
    9b3e:	80 53       	subi	r24, 0x30	; 48
    9b40:	8a 30       	cpi	r24, 0x0A	; 10
    9b42:	98 f1       	brcs	.+102    	; 0x9baa <strtod+0x232>
    9b44:	c4 ff       	sbrs	r28, 4
    9b46:	03 c0       	rjmp	.+6      	; 0x9b4e <strtod+0x1d6>
    9b48:	d1 94       	neg	r13
    9b4a:	c1 94       	neg	r12
    9b4c:	d1 08       	sbc	r13, r1
    9b4e:	0c 0d       	add	r16, r12
    9b50:	1d 1d       	adc	r17, r13
    9b52:	c1 ff       	sbrs	r28, 1
    9b54:	09 c0       	rjmp	.+18     	; 0x9b68 <strtod+0x1f0>
    9b56:	e1 14       	cp	r14, r1
    9b58:	f1 04       	cpc	r15, r1
    9b5a:	31 f0       	breq	.+12     	; 0x9b68 <strtod+0x1f0>
    9b5c:	81 e0       	ldi	r24, 0x01	; 1
    9b5e:	a8 1a       	sub	r10, r24
    9b60:	b1 08       	sbc	r11, r1
    9b62:	d7 01       	movw	r26, r14
    9b64:	ad 92       	st	X+, r10
    9b66:	bc 92       	st	X, r11
    9b68:	ca 01       	movw	r24, r20
    9b6a:	b9 01       	movw	r22, r18
    9b6c:	74 d3       	rcall	.+1768   	; 0xa256 <__floatunsisf>
    9b6e:	c3 70       	andi	r28, 0x03	; 3
    9b70:	c3 30       	cpi	r28, 0x03	; 3
    9b72:	09 f4       	brne	.+2      	; 0x9b76 <strtod+0x1fe>
    9b74:	90 58       	subi	r25, 0x80	; 128
    9b76:	4b 01       	movw	r8, r22
    9b78:	5c 01       	movw	r10, r24
    9b7a:	20 e0       	ldi	r18, 0x00	; 0
    9b7c:	30 e0       	ldi	r19, 0x00	; 0
    9b7e:	a9 01       	movw	r20, r18
    9b80:	66 d3       	rcall	.+1740   	; 0xa24e <__cmpsf2>
    9b82:	88 23       	and	r24, r24
    9b84:	09 f4       	brne	.+2      	; 0x9b88 <strtod+0x210>
    9b86:	3e c0       	rjmp	.+124    	; 0x9c04 <strtod+0x28c>
    9b88:	cd e8       	ldi	r28, 0x8D	; 141
    9b8a:	d1 e0       	ldi	r29, 0x01	; 1
    9b8c:	17 ff       	sbrs	r17, 7
    9b8e:	05 c0       	rjmp	.+10     	; 0x9b9a <strtod+0x222>
    9b90:	11 95       	neg	r17
    9b92:	01 95       	neg	r16
    9b94:	11 09       	sbc	r17, r1
    9b96:	c5 e7       	ldi	r28, 0x75	; 117
    9b98:	d1 e0       	ldi	r29, 0x01	; 1
    9b9a:	6e 01       	movw	r12, r28
    9b9c:	b8 e1       	ldi	r27, 0x18	; 24
    9b9e:	cb 1a       	sub	r12, r27
    9ba0:	d1 08       	sbc	r13, r1
    9ba2:	80 e2       	ldi	r24, 0x20	; 32
    9ba4:	e8 2e       	mov	r14, r24
    9ba6:	f1 2c       	mov	r15, r1
    9ba8:	0e c0       	rjmp	.+28     	; 0x9bc6 <strtod+0x24e>
    9baa:	d5 01       	movw	r26, r10
    9bac:	b3 cf       	rjmp	.-154    	; 0x9b14 <strtod+0x19c>
    9bae:	fe 01       	movw	r30, r28
    9bb0:	25 91       	lpm	r18, Z+
    9bb2:	35 91       	lpm	r19, Z+
    9bb4:	45 91       	lpm	r20, Z+
    9bb6:	54 91       	lpm	r21, Z
    9bb8:	0e 19       	sub	r16, r14
    9bba:	1f 09       	sbc	r17, r15
    9bbc:	c5 01       	movw	r24, r10
    9bbe:	b4 01       	movw	r22, r8
    9bc0:	ab d3       	rcall	.+1878   	; 0xa318 <__mulsf3>
    9bc2:	4b 01       	movw	r8, r22
    9bc4:	5c 01       	movw	r10, r24
    9bc6:	d5 01       	movw	r26, r10
    9bc8:	c4 01       	movw	r24, r8
    9bca:	0e 15       	cp	r16, r14
    9bcc:	1f 05       	cpc	r17, r15
    9bce:	7c f7       	brge	.-34     	; 0x9bae <strtod+0x236>
    9bd0:	24 97       	sbiw	r28, 0x04	; 4
    9bd2:	f5 94       	asr	r15
    9bd4:	e7 94       	ror	r14
    9bd6:	cc 16       	cp	r12, r28
    9bd8:	dd 06       	cpc	r13, r29
    9bda:	a9 f7       	brne	.-22     	; 0x9bc6 <strtod+0x24e>
    9bdc:	8a 2f       	mov	r24, r26
    9bde:	88 0f       	add	r24, r24
    9be0:	8b 2f       	mov	r24, r27
    9be2:	88 1f       	adc	r24, r24
    9be4:	8f 3f       	cpi	r24, 0xFF	; 255
    9be6:	41 f0       	breq	.+16     	; 0x9bf8 <strtod+0x280>
    9be8:	20 e0       	ldi	r18, 0x00	; 0
    9bea:	30 e0       	ldi	r19, 0x00	; 0
    9bec:	a9 01       	movw	r20, r18
    9bee:	c5 01       	movw	r24, r10
    9bf0:	b4 01       	movw	r22, r8
    9bf2:	2d d3       	rcall	.+1626   	; 0xa24e <__cmpsf2>
    9bf4:	81 11       	cpse	r24, r1
    9bf6:	06 c0       	rjmp	.+12     	; 0x9c04 <strtod+0x28c>
    9bf8:	82 e2       	ldi	r24, 0x22	; 34
    9bfa:	90 e0       	ldi	r25, 0x00	; 0
    9bfc:	80 93 97 70 	sts	0x7097, r24	; 0x807097 <errno>
    9c00:	90 93 98 70 	sts	0x7098, r25	; 0x807098 <errno+0x1>
    9c04:	c5 01       	movw	r24, r10
    9c06:	b4 01       	movw	r22, r8
    9c08:	df 91       	pop	r29
    9c0a:	cf 91       	pop	r28
    9c0c:	1f 91       	pop	r17
    9c0e:	0f 91       	pop	r16
    9c10:	ff 90       	pop	r15
    9c12:	ef 90       	pop	r14
    9c14:	df 90       	pop	r13
    9c16:	cf 90       	pop	r12
    9c18:	bf 90       	pop	r11
    9c1a:	af 90       	pop	r10
    9c1c:	9f 90       	pop	r9
    9c1e:	8f 90       	pop	r8
    9c20:	08 95       	ret

00009c22 <strtol>:
strtol():
    9c22:	3f 92       	push	r3
    9c24:	4f 92       	push	r4
    9c26:	5f 92       	push	r5
    9c28:	6f 92       	push	r6
    9c2a:	7f 92       	push	r7
    9c2c:	8f 92       	push	r8
    9c2e:	9f 92       	push	r9
    9c30:	af 92       	push	r10
    9c32:	bf 92       	push	r11
    9c34:	cf 92       	push	r12
    9c36:	df 92       	push	r13
    9c38:	ef 92       	push	r14
    9c3a:	ff 92       	push	r15
    9c3c:	0f 93       	push	r16
    9c3e:	1f 93       	push	r17
    9c40:	cf 93       	push	r28
    9c42:	df 93       	push	r29
    9c44:	5c 01       	movw	r10, r24
    9c46:	6b 01       	movw	r12, r22
    9c48:	7a 01       	movw	r14, r20
    9c4a:	61 15       	cp	r22, r1
    9c4c:	71 05       	cpc	r23, r1
    9c4e:	19 f0       	breq	.+6      	; 0x9c56 <strtol+0x34>
    9c50:	fb 01       	movw	r30, r22
    9c52:	80 83       	st	Z, r24
    9c54:	91 83       	std	Z+1, r25	; 0x01
    9c56:	e1 14       	cp	r14, r1
    9c58:	f1 04       	cpc	r15, r1
    9c5a:	51 f0       	breq	.+20     	; 0x9c70 <strtol+0x4e>
    9c5c:	c7 01       	movw	r24, r14
    9c5e:	02 97       	sbiw	r24, 0x02	; 2
    9c60:	83 97       	sbiw	r24, 0x23	; 35
    9c62:	30 f0       	brcs	.+12     	; 0x9c70 <strtol+0x4e>
    9c64:	40 e0       	ldi	r20, 0x00	; 0
    9c66:	30 e0       	ldi	r19, 0x00	; 0
    9c68:	20 e0       	ldi	r18, 0x00	; 0
    9c6a:	90 e0       	ldi	r25, 0x00	; 0
    9c6c:	6a c0       	rjmp	.+212    	; 0x9d42 <strtol+0x120>
    9c6e:	5e 01       	movw	r10, r28
    9c70:	e5 01       	movw	r28, r10
    9c72:	21 96       	adiw	r28, 0x01	; 1
    9c74:	f5 01       	movw	r30, r10
    9c76:	10 81       	ld	r17, Z
    9c78:	81 2f       	mov	r24, r17
    9c7a:	90 e0       	ldi	r25, 0x00	; 0
    9c7c:	f2 d1       	rcall	.+996    	; 0xa062 <isspace>
    9c7e:	89 2b       	or	r24, r25
    9c80:	b1 f7       	brne	.-20     	; 0x9c6e <strtol+0x4c>
    9c82:	1d 32       	cpi	r17, 0x2D	; 45
    9c84:	01 f5       	brne	.+64     	; 0x9cc6 <strtol+0xa4>
    9c86:	21 96       	adiw	r28, 0x01	; 1
    9c88:	f5 01       	movw	r30, r10
    9c8a:	11 81       	ldd	r17, Z+1	; 0x01
    9c8c:	01 e0       	ldi	r16, 0x01	; 1
    9c8e:	e1 14       	cp	r14, r1
    9c90:	f1 04       	cpc	r15, r1
    9c92:	09 f4       	brne	.+2      	; 0x9c96 <strtol+0x74>
    9c94:	e4 c0       	rjmp	.+456    	; 0x9e5e <strtol+0x23c>
    9c96:	f0 e1       	ldi	r31, 0x10	; 16
    9c98:	ef 16       	cp	r14, r31
    9c9a:	f1 04       	cpc	r15, r1
    9c9c:	09 f0       	breq	.+2      	; 0x9ca0 <strtol+0x7e>
    9c9e:	88 c0       	rjmp	.+272    	; 0x9db0 <strtol+0x18e>
    9ca0:	10 33       	cpi	r17, 0x30	; 48
    9ca2:	59 f4       	brne	.+22     	; 0x9cba <strtol+0x98>
    9ca4:	88 81       	ld	r24, Y
    9ca6:	8f 7d       	andi	r24, 0xDF	; 223
    9ca8:	88 35       	cpi	r24, 0x58	; 88
    9caa:	09 f0       	breq	.+2      	; 0x9cae <strtol+0x8c>
    9cac:	7c c0       	rjmp	.+248    	; 0x9da6 <strtol+0x184>
    9cae:	19 81       	ldd	r17, Y+1	; 0x01
    9cb0:	22 96       	adiw	r28, 0x02	; 2
    9cb2:	02 60       	ori	r16, 0x02	; 2
    9cb4:	f0 e1       	ldi	r31, 0x10	; 16
    9cb6:	ef 2e       	mov	r14, r31
    9cb8:	f1 2c       	mov	r15, r1
    9cba:	81 2c       	mov	r8, r1
    9cbc:	91 2c       	mov	r9, r1
    9cbe:	a1 2c       	mov	r10, r1
    9cc0:	88 e0       	ldi	r24, 0x08	; 8
    9cc2:	b8 2e       	mov	r11, r24
    9cc4:	91 c0       	rjmp	.+290    	; 0x9de8 <strtol+0x1c6>
    9cc6:	1b 32       	cpi	r17, 0x2B	; 43
    9cc8:	21 f4       	brne	.+8      	; 0x9cd2 <strtol+0xb0>
    9cca:	e5 01       	movw	r28, r10
    9ccc:	22 96       	adiw	r28, 0x02	; 2
    9cce:	f5 01       	movw	r30, r10
    9cd0:	11 81       	ldd	r17, Z+1	; 0x01
    9cd2:	00 e0       	ldi	r16, 0x00	; 0
    9cd4:	dc cf       	rjmp	.-72     	; 0x9c8e <strtol+0x6c>
    9cd6:	ea e0       	ldi	r30, 0x0A	; 10
    9cd8:	ee 16       	cp	r14, r30
    9cda:	f1 04       	cpc	r15, r1
    9cdc:	09 f4       	brne	.+2      	; 0x9ce0 <strtol+0xbe>
    9cde:	c5 c0       	rjmp	.+394    	; 0x9e6a <strtol+0x248>
    9ce0:	f0 e1       	ldi	r31, 0x10	; 16
    9ce2:	ef 16       	cp	r14, r31
    9ce4:	f1 04       	cpc	r15, r1
    9ce6:	09 f0       	breq	.+2      	; 0x9cea <strtol+0xc8>
    9ce8:	73 c0       	rjmp	.+230    	; 0x9dd0 <strtol+0x1ae>
    9cea:	e7 cf       	rjmp	.-50     	; 0x9cba <strtol+0x98>
    9cec:	78 e0       	ldi	r23, 0x08	; 8
    9cee:	e7 2e       	mov	r14, r23
    9cf0:	f1 2c       	mov	r15, r1
    9cf2:	81 2c       	mov	r8, r1
    9cf4:	91 2c       	mov	r9, r1
    9cf6:	a1 2c       	mov	r10, r1
    9cf8:	60 e1       	ldi	r22, 0x10	; 16
    9cfa:	b6 2e       	mov	r11, r22
    9cfc:	75 c0       	rjmp	.+234    	; 0x9de8 <strtol+0x1c6>
    9cfe:	21 e0       	ldi	r18, 0x01	; 1
    9d00:	ab c0       	rjmp	.+342    	; 0x9e58 <strtol+0x236>
    9d02:	30 2f       	mov	r19, r16
    9d04:	31 70       	andi	r19, 0x01	; 1
    9d06:	c1 14       	cp	r12, r1
    9d08:	d1 04       	cpc	r13, r1
    9d0a:	31 f0       	breq	.+12     	; 0x9d18 <strtol+0xf6>
    9d0c:	22 23       	and	r18, r18
    9d0e:	71 f1       	breq	.+92     	; 0x9d6c <strtol+0x14a>
    9d10:	21 97       	sbiw	r28, 0x01	; 1
    9d12:	f6 01       	movw	r30, r12
    9d14:	c0 83       	st	Z, r28
    9d16:	d1 83       	std	Z+1, r29	; 0x01
    9d18:	27 ff       	sbrs	r18, 7
    9d1a:	2e c0       	rjmp	.+92     	; 0x9d78 <strtol+0x156>
    9d1c:	60 e0       	ldi	r22, 0x00	; 0
    9d1e:	70 e0       	ldi	r23, 0x00	; 0
    9d20:	80 e0       	ldi	r24, 0x00	; 0
    9d22:	90 e8       	ldi	r25, 0x80	; 128
    9d24:	31 11       	cpse	r19, r1
    9d26:	04 c0       	rjmp	.+8      	; 0x9d30 <strtol+0x10e>
    9d28:	6f ef       	ldi	r22, 0xFF	; 255
    9d2a:	7f ef       	ldi	r23, 0xFF	; 255
    9d2c:	8f ef       	ldi	r24, 0xFF	; 255
    9d2e:	9f e7       	ldi	r25, 0x7F	; 127
    9d30:	22 e2       	ldi	r18, 0x22	; 34
    9d32:	30 e0       	ldi	r19, 0x00	; 0
    9d34:	20 93 97 70 	sts	0x7097, r18	; 0x807097 <errno>
    9d38:	30 93 98 70 	sts	0x7098, r19	; 0x807098 <errno+0x1>
    9d3c:	46 2f       	mov	r20, r22
    9d3e:	37 2f       	mov	r19, r23
    9d40:	28 2f       	mov	r18, r24
    9d42:	64 2f       	mov	r22, r20
    9d44:	73 2f       	mov	r23, r19
    9d46:	82 2f       	mov	r24, r18
    9d48:	df 91       	pop	r29
    9d4a:	cf 91       	pop	r28
    9d4c:	1f 91       	pop	r17
    9d4e:	0f 91       	pop	r16
    9d50:	ff 90       	pop	r15
    9d52:	ef 90       	pop	r14
    9d54:	df 90       	pop	r13
    9d56:	cf 90       	pop	r12
    9d58:	bf 90       	pop	r11
    9d5a:	af 90       	pop	r10
    9d5c:	9f 90       	pop	r9
    9d5e:	8f 90       	pop	r8
    9d60:	7f 90       	pop	r7
    9d62:	6f 90       	pop	r6
    9d64:	5f 90       	pop	r5
    9d66:	4f 90       	pop	r4
    9d68:	3f 90       	pop	r3
    9d6a:	08 95       	ret
    9d6c:	01 ff       	sbrs	r16, 1
    9d6e:	04 c0       	rjmp	.+8      	; 0x9d78 <strtol+0x156>
    9d70:	22 97       	sbiw	r28, 0x02	; 2
    9d72:	f6 01       	movw	r30, r12
    9d74:	c0 83       	st	Z, r28
    9d76:	d1 83       	std	Z+1, r29	; 0x01
    9d78:	33 23       	and	r19, r19
    9d7a:	41 f0       	breq	.+16     	; 0x9d8c <strtol+0x16a>
    9d7c:	90 95       	com	r25
    9d7e:	80 95       	com	r24
    9d80:	70 95       	com	r23
    9d82:	61 95       	neg	r22
    9d84:	7f 4f       	sbci	r23, 0xFF	; 255
    9d86:	8f 4f       	sbci	r24, 0xFF	; 255
    9d88:	9f 4f       	sbci	r25, 0xFF	; 255
    9d8a:	d8 cf       	rjmp	.-80     	; 0x9d3c <strtol+0x11a>
    9d8c:	97 ff       	sbrs	r25, 7
    9d8e:	d6 cf       	rjmp	.-84     	; 0x9d3c <strtol+0x11a>
    9d90:	82 e2       	ldi	r24, 0x22	; 34
    9d92:	90 e0       	ldi	r25, 0x00	; 0
    9d94:	80 93 97 70 	sts	0x7097, r24	; 0x807097 <errno>
    9d98:	90 93 98 70 	sts	0x7098, r25	; 0x807098 <errno+0x1>
    9d9c:	6f ef       	ldi	r22, 0xFF	; 255
    9d9e:	7f ef       	ldi	r23, 0xFF	; 255
    9da0:	8f ef       	ldi	r24, 0xFF	; 255
    9da2:	9f e7       	ldi	r25, 0x7F	; 127
    9da4:	cb cf       	rjmp	.-106    	; 0x9d3c <strtol+0x11a>
    9da6:	10 e3       	ldi	r17, 0x30	; 48
    9da8:	e1 14       	cp	r14, r1
    9daa:	f1 04       	cpc	r15, r1
    9dac:	09 f4       	brne	.+2      	; 0x9db0 <strtol+0x18e>
    9dae:	9e cf       	rjmp	.-196    	; 0x9cec <strtol+0xca>
    9db0:	28 e0       	ldi	r18, 0x08	; 8
    9db2:	e2 16       	cp	r14, r18
    9db4:	f1 04       	cpc	r15, r1
    9db6:	09 f4       	brne	.+2      	; 0x9dba <strtol+0x198>
    9db8:	9c cf       	rjmp	.-200    	; 0x9cf2 <strtol+0xd0>
    9dba:	0c f0       	brlt	.+2      	; 0x9dbe <strtol+0x19c>
    9dbc:	8c cf       	rjmp	.-232    	; 0x9cd6 <strtol+0xb4>
    9dbe:	81 2c       	mov	r8, r1
    9dc0:	91 2c       	mov	r9, r1
    9dc2:	a1 2c       	mov	r10, r1
    9dc4:	e0 e4       	ldi	r30, 0x40	; 64
    9dc6:	be 2e       	mov	r11, r30
    9dc8:	82 e0       	ldi	r24, 0x02	; 2
    9dca:	e8 16       	cp	r14, r24
    9dcc:	f1 04       	cpc	r15, r1
    9dce:	61 f0       	breq	.+24     	; 0x9de8 <strtol+0x1c6>
    9dd0:	60 e0       	ldi	r22, 0x00	; 0
    9dd2:	70 e0       	ldi	r23, 0x00	; 0
    9dd4:	80 e0       	ldi	r24, 0x00	; 0
    9dd6:	90 e8       	ldi	r25, 0x80	; 128
    9dd8:	97 01       	movw	r18, r14
    9dda:	0f 2c       	mov	r0, r15
    9ddc:	00 0c       	add	r0, r0
    9dde:	44 0b       	sbc	r20, r20
    9de0:	55 0b       	sbc	r21, r21
    9de2:	87 d3       	rcall	.+1806   	; 0xa4f2 <__udivmodsi4>
    9de4:	49 01       	movw	r8, r18
    9de6:	5a 01       	movw	r10, r20
    9de8:	20 e0       	ldi	r18, 0x00	; 0
    9dea:	60 e0       	ldi	r22, 0x00	; 0
    9dec:	70 e0       	ldi	r23, 0x00	; 0
    9dee:	cb 01       	movw	r24, r22
    9df0:	27 01       	movw	r4, r14
    9df2:	0f 2c       	mov	r0, r15
    9df4:	00 0c       	add	r0, r0
    9df6:	66 08       	sbc	r6, r6
    9df8:	77 08       	sbc	r7, r7
    9dfa:	fe 01       	movw	r30, r28
    9dfc:	50 ed       	ldi	r21, 0xD0	; 208
    9dfe:	35 2e       	mov	r3, r21
    9e00:	31 0e       	add	r3, r17
    9e02:	39 e0       	ldi	r19, 0x09	; 9
    9e04:	33 15       	cp	r19, r3
    9e06:	70 f4       	brcc	.+28     	; 0x9e24 <strtol+0x202>
    9e08:	3f eb       	ldi	r19, 0xBF	; 191
    9e0a:	31 0f       	add	r19, r17
    9e0c:	49 ec       	ldi	r20, 0xC9	; 201
    9e0e:	34 2e       	mov	r3, r20
    9e10:	3a 31       	cpi	r19, 0x1A	; 26
    9e12:	38 f0       	brcs	.+14     	; 0x9e22 <strtol+0x200>
    9e14:	3f e9       	ldi	r19, 0x9F	; 159
    9e16:	31 0f       	add	r19, r17
    9e18:	3a 31       	cpi	r19, 0x1A	; 26
    9e1a:	08 f0       	brcs	.+2      	; 0x9e1e <strtol+0x1fc>
    9e1c:	72 cf       	rjmp	.-284    	; 0x9d02 <strtol+0xe0>
    9e1e:	39 ea       	ldi	r19, 0xA9	; 169
    9e20:	33 2e       	mov	r3, r19
    9e22:	31 0e       	add	r3, r17
    9e24:	3e 14       	cp	r3, r14
    9e26:	1f 04       	cpc	r1, r15
    9e28:	0c f0       	brlt	.+2      	; 0x9e2c <strtol+0x20a>
    9e2a:	6b cf       	rjmp	.-298    	; 0x9d02 <strtol+0xe0>
    9e2c:	27 fd       	sbrc	r18, 7
    9e2e:	14 c0       	rjmp	.+40     	; 0x9e58 <strtol+0x236>
    9e30:	86 16       	cp	r8, r22
    9e32:	97 06       	cpc	r9, r23
    9e34:	a8 06       	cpc	r10, r24
    9e36:	b9 06       	cpc	r11, r25
    9e38:	70 f0       	brcs	.+28     	; 0x9e56 <strtol+0x234>
    9e3a:	a3 01       	movw	r20, r6
    9e3c:	92 01       	movw	r18, r4
    9e3e:	23 d3       	rcall	.+1606   	; 0xa486 <__mulsi3>
    9e40:	63 0d       	add	r22, r3
    9e42:	71 1d       	adc	r23, r1
    9e44:	81 1d       	adc	r24, r1
    9e46:	91 1d       	adc	r25, r1
    9e48:	61 30       	cpi	r22, 0x01	; 1
    9e4a:	71 05       	cpc	r23, r1
    9e4c:	81 05       	cpc	r24, r1
    9e4e:	20 e8       	ldi	r18, 0x80	; 128
    9e50:	92 07       	cpc	r25, r18
    9e52:	08 f4       	brcc	.+2      	; 0x9e56 <strtol+0x234>
    9e54:	54 cf       	rjmp	.-344    	; 0x9cfe <strtol+0xdc>
    9e56:	2f ef       	ldi	r18, 0xFF	; 255
    9e58:	21 96       	adiw	r28, 0x01	; 1
    9e5a:	10 81       	ld	r17, Z
    9e5c:	ce cf       	rjmp	.-100    	; 0x9dfa <strtol+0x1d8>
    9e5e:	10 33       	cpi	r17, 0x30	; 48
    9e60:	09 f4       	brne	.+2      	; 0x9e64 <strtol+0x242>
    9e62:	20 cf       	rjmp	.-448    	; 0x9ca4 <strtol+0x82>
    9e64:	2a e0       	ldi	r18, 0x0A	; 10
    9e66:	e2 2e       	mov	r14, r18
    9e68:	f1 2c       	mov	r15, r1
    9e6a:	9c ec       	ldi	r25, 0xCC	; 204
    9e6c:	89 2e       	mov	r8, r25
    9e6e:	98 2c       	mov	r9, r8
    9e70:	a8 2c       	mov	r10, r8
    9e72:	9c e0       	ldi	r25, 0x0C	; 12
    9e74:	b9 2e       	mov	r11, r25
    9e76:	b8 cf       	rjmp	.-144    	; 0x9de8 <strtol+0x1c6>

00009e78 <atoi>:
atoi():
    9e78:	fc 01       	movw	r30, r24
    9e7a:	88 27       	eor	r24, r24
    9e7c:	99 27       	eor	r25, r25
    9e7e:	e8 94       	clt
    9e80:	21 91       	ld	r18, Z+
    9e82:	20 32       	cpi	r18, 0x20	; 32
    9e84:	e9 f3       	breq	.-6      	; 0x9e80 <atoi+0x8>
    9e86:	29 30       	cpi	r18, 0x09	; 9
    9e88:	10 f0       	brcs	.+4      	; 0x9e8e <atoi+0x16>
    9e8a:	2e 30       	cpi	r18, 0x0E	; 14
    9e8c:	c8 f3       	brcs	.-14     	; 0x9e80 <atoi+0x8>
    9e8e:	2b 32       	cpi	r18, 0x2B	; 43
    9e90:	39 f0       	breq	.+14     	; 0x9ea0 <atoi+0x28>
    9e92:	2d 32       	cpi	r18, 0x2D	; 45
    9e94:	31 f4       	brne	.+12     	; 0x9ea2 <atoi+0x2a>
    9e96:	68 94       	set
    9e98:	03 c0       	rjmp	.+6      	; 0x9ea0 <atoi+0x28>
    9e9a:	43 d1       	rcall	.+646    	; 0xa122 <__mulhi_const_10>
    9e9c:	82 0f       	add	r24, r18
    9e9e:	91 1d       	adc	r25, r1
    9ea0:	21 91       	ld	r18, Z+
    9ea2:	20 53       	subi	r18, 0x30	; 48
    9ea4:	2a 30       	cpi	r18, 0x0A	; 10
    9ea6:	c8 f3       	brcs	.-14     	; 0x9e9a <atoi+0x22>
    9ea8:	1e f4       	brtc	.+6      	; 0x9eb0 <atoi+0x38>
    9eaa:	90 95       	com	r25
    9eac:	81 95       	neg	r24
    9eae:	9f 4f       	sbci	r25, 0xFF	; 255
    9eb0:	08 95       	ret

00009eb2 <__ftoa_engine>:
__ftoa_engine():
    9eb2:	28 30       	cpi	r18, 0x08	; 8
    9eb4:	08 f0       	brcs	.+2      	; 0x9eb8 <__ftoa_engine+0x6>
    9eb6:	27 e0       	ldi	r18, 0x07	; 7
    9eb8:	33 27       	eor	r19, r19
    9eba:	da 01       	movw	r26, r20
    9ebc:	99 0f       	add	r25, r25
    9ebe:	31 1d       	adc	r19, r1
    9ec0:	87 fd       	sbrc	r24, 7
    9ec2:	91 60       	ori	r25, 0x01	; 1
    9ec4:	00 96       	adiw	r24, 0x00	; 0
    9ec6:	61 05       	cpc	r22, r1
    9ec8:	71 05       	cpc	r23, r1
    9eca:	39 f4       	brne	.+14     	; 0x9eda <__ftoa_engine+0x28>
    9ecc:	32 60       	ori	r19, 0x02	; 2
    9ece:	2e 5f       	subi	r18, 0xFE	; 254
    9ed0:	3d 93       	st	X+, r19
    9ed2:	30 e3       	ldi	r19, 0x30	; 48
    9ed4:	2a 95       	dec	r18
    9ed6:	e1 f7       	brne	.-8      	; 0x9ed0 <__ftoa_engine+0x1e>
    9ed8:	08 95       	ret
    9eda:	9f 3f       	cpi	r25, 0xFF	; 255
    9edc:	30 f0       	brcs	.+12     	; 0x9eea <__ftoa_engine+0x38>
    9ede:	80 38       	cpi	r24, 0x80	; 128
    9ee0:	71 05       	cpc	r23, r1
    9ee2:	61 05       	cpc	r22, r1
    9ee4:	09 f0       	breq	.+2      	; 0x9ee8 <__ftoa_engine+0x36>
    9ee6:	3c 5f       	subi	r19, 0xFC	; 252
    9ee8:	3c 5f       	subi	r19, 0xFC	; 252
    9eea:	3d 93       	st	X+, r19
    9eec:	91 30       	cpi	r25, 0x01	; 1
    9eee:	08 f0       	brcs	.+2      	; 0x9ef2 <__ftoa_engine+0x40>
    9ef0:	80 68       	ori	r24, 0x80	; 128
    9ef2:	91 1d       	adc	r25, r1
    9ef4:	df 93       	push	r29
    9ef6:	cf 93       	push	r28
    9ef8:	1f 93       	push	r17
    9efa:	0f 93       	push	r16
    9efc:	ff 92       	push	r15
    9efe:	ef 92       	push	r14
    9f00:	19 2f       	mov	r17, r25
    9f02:	98 7f       	andi	r25, 0xF8	; 248
    9f04:	96 95       	lsr	r25
    9f06:	e9 2f       	mov	r30, r25
    9f08:	96 95       	lsr	r25
    9f0a:	96 95       	lsr	r25
    9f0c:	e9 0f       	add	r30, r25
    9f0e:	ff 27       	eor	r31, r31
    9f10:	e5 51       	subi	r30, 0x15	; 21
    9f12:	fe 4f       	sbci	r31, 0xFE	; 254
    9f14:	99 27       	eor	r25, r25
    9f16:	33 27       	eor	r19, r19
    9f18:	ee 24       	eor	r14, r14
    9f1a:	ff 24       	eor	r15, r15
    9f1c:	a7 01       	movw	r20, r14
    9f1e:	e7 01       	movw	r28, r14
    9f20:	05 90       	lpm	r0, Z+
    9f22:	08 94       	sec
    9f24:	07 94       	ror	r0
    9f26:	28 f4       	brcc	.+10     	; 0x9f32 <__ftoa_engine+0x80>
    9f28:	36 0f       	add	r19, r22
    9f2a:	e7 1e       	adc	r14, r23
    9f2c:	f8 1e       	adc	r15, r24
    9f2e:	49 1f       	adc	r20, r25
    9f30:	51 1d       	adc	r21, r1
    9f32:	66 0f       	add	r22, r22
    9f34:	77 1f       	adc	r23, r23
    9f36:	88 1f       	adc	r24, r24
    9f38:	99 1f       	adc	r25, r25
    9f3a:	06 94       	lsr	r0
    9f3c:	a1 f7       	brne	.-24     	; 0x9f26 <__ftoa_engine+0x74>
    9f3e:	05 90       	lpm	r0, Z+
    9f40:	07 94       	ror	r0
    9f42:	28 f4       	brcc	.+10     	; 0x9f4e <__ftoa_engine+0x9c>
    9f44:	e7 0e       	add	r14, r23
    9f46:	f8 1e       	adc	r15, r24
    9f48:	49 1f       	adc	r20, r25
    9f4a:	56 1f       	adc	r21, r22
    9f4c:	c1 1d       	adc	r28, r1
    9f4e:	77 0f       	add	r23, r23
    9f50:	88 1f       	adc	r24, r24
    9f52:	99 1f       	adc	r25, r25
    9f54:	66 1f       	adc	r22, r22
    9f56:	06 94       	lsr	r0
    9f58:	a1 f7       	brne	.-24     	; 0x9f42 <__ftoa_engine+0x90>
    9f5a:	05 90       	lpm	r0, Z+
    9f5c:	07 94       	ror	r0
    9f5e:	28 f4       	brcc	.+10     	; 0x9f6a <__ftoa_engine+0xb8>
    9f60:	f8 0e       	add	r15, r24
    9f62:	49 1f       	adc	r20, r25
    9f64:	56 1f       	adc	r21, r22
    9f66:	c7 1f       	adc	r28, r23
    9f68:	d1 1d       	adc	r29, r1
    9f6a:	88 0f       	add	r24, r24
    9f6c:	99 1f       	adc	r25, r25
    9f6e:	66 1f       	adc	r22, r22
    9f70:	77 1f       	adc	r23, r23
    9f72:	06 94       	lsr	r0
    9f74:	a1 f7       	brne	.-24     	; 0x9f5e <__ftoa_engine+0xac>
    9f76:	05 90       	lpm	r0, Z+
    9f78:	07 94       	ror	r0
    9f7a:	20 f4       	brcc	.+8      	; 0x9f84 <__ftoa_engine+0xd2>
    9f7c:	49 0f       	add	r20, r25
    9f7e:	56 1f       	adc	r21, r22
    9f80:	c7 1f       	adc	r28, r23
    9f82:	d8 1f       	adc	r29, r24
    9f84:	99 0f       	add	r25, r25
    9f86:	66 1f       	adc	r22, r22
    9f88:	77 1f       	adc	r23, r23
    9f8a:	88 1f       	adc	r24, r24
    9f8c:	06 94       	lsr	r0
    9f8e:	a9 f7       	brne	.-22     	; 0x9f7a <__ftoa_engine+0xc8>
    9f90:	84 91       	lpm	r24, Z
    9f92:	10 95       	com	r17
    9f94:	17 70       	andi	r17, 0x07	; 7
    9f96:	41 f0       	breq	.+16     	; 0x9fa8 <__ftoa_engine+0xf6>
    9f98:	d6 95       	lsr	r29
    9f9a:	c7 95       	ror	r28
    9f9c:	57 95       	ror	r21
    9f9e:	47 95       	ror	r20
    9fa0:	f7 94       	ror	r15
    9fa2:	e7 94       	ror	r14
    9fa4:	1a 95       	dec	r17
    9fa6:	c1 f7       	brne	.-16     	; 0x9f98 <__ftoa_engine+0xe6>
    9fa8:	e1 e9       	ldi	r30, 0x91	; 145
    9faa:	f1 e0       	ldi	r31, 0x01	; 1
    9fac:	68 94       	set
    9fae:	15 90       	lpm	r1, Z+
    9fb0:	15 91       	lpm	r17, Z+
    9fb2:	35 91       	lpm	r19, Z+
    9fb4:	65 91       	lpm	r22, Z+
    9fb6:	95 91       	lpm	r25, Z+
    9fb8:	05 90       	lpm	r0, Z+
    9fba:	7f e2       	ldi	r23, 0x2F	; 47
    9fbc:	73 95       	inc	r23
    9fbe:	e1 18       	sub	r14, r1
    9fc0:	f1 0a       	sbc	r15, r17
    9fc2:	43 0b       	sbc	r20, r19
    9fc4:	56 0b       	sbc	r21, r22
    9fc6:	c9 0b       	sbc	r28, r25
    9fc8:	d0 09       	sbc	r29, r0
    9fca:	c0 f7       	brcc	.-16     	; 0x9fbc <__ftoa_engine+0x10a>
    9fcc:	e1 0c       	add	r14, r1
    9fce:	f1 1e       	adc	r15, r17
    9fd0:	43 1f       	adc	r20, r19
    9fd2:	56 1f       	adc	r21, r22
    9fd4:	c9 1f       	adc	r28, r25
    9fd6:	d0 1d       	adc	r29, r0
    9fd8:	7e f4       	brtc	.+30     	; 0x9ff8 <__ftoa_engine+0x146>
    9fda:	70 33       	cpi	r23, 0x30	; 48
    9fdc:	11 f4       	brne	.+4      	; 0x9fe2 <__ftoa_engine+0x130>
    9fde:	8a 95       	dec	r24
    9fe0:	e6 cf       	rjmp	.-52     	; 0x9fae <__ftoa_engine+0xfc>
    9fe2:	e8 94       	clt
    9fe4:	01 50       	subi	r16, 0x01	; 1
    9fe6:	30 f0       	brcs	.+12     	; 0x9ff4 <__ftoa_engine+0x142>
    9fe8:	08 0f       	add	r16, r24
    9fea:	0a f4       	brpl	.+2      	; 0x9fee <__ftoa_engine+0x13c>
    9fec:	00 27       	eor	r16, r16
    9fee:	02 17       	cp	r16, r18
    9ff0:	08 f4       	brcc	.+2      	; 0x9ff4 <__ftoa_engine+0x142>
    9ff2:	20 2f       	mov	r18, r16
    9ff4:	23 95       	inc	r18
    9ff6:	02 2f       	mov	r16, r18
    9ff8:	7a 33       	cpi	r23, 0x3A	; 58
    9ffa:	28 f0       	brcs	.+10     	; 0xa006 <__ftoa_engine+0x154>
    9ffc:	79 e3       	ldi	r23, 0x39	; 57
    9ffe:	7d 93       	st	X+, r23
    a000:	2a 95       	dec	r18
    a002:	e9 f7       	brne	.-6      	; 0x9ffe <__ftoa_engine+0x14c>
    a004:	10 c0       	rjmp	.+32     	; 0xa026 <__ftoa_engine+0x174>
    a006:	7d 93       	st	X+, r23
    a008:	2a 95       	dec	r18
    a00a:	89 f6       	brne	.-94     	; 0x9fae <__ftoa_engine+0xfc>
    a00c:	06 94       	lsr	r0
    a00e:	97 95       	ror	r25
    a010:	67 95       	ror	r22
    a012:	37 95       	ror	r19
    a014:	17 95       	ror	r17
    a016:	17 94       	ror	r1
    a018:	e1 18       	sub	r14, r1
    a01a:	f1 0a       	sbc	r15, r17
    a01c:	43 0b       	sbc	r20, r19
    a01e:	56 0b       	sbc	r21, r22
    a020:	c9 0b       	sbc	r28, r25
    a022:	d0 09       	sbc	r29, r0
    a024:	98 f0       	brcs	.+38     	; 0xa04c <__ftoa_engine+0x19a>
    a026:	23 95       	inc	r18
    a028:	7e 91       	ld	r23, -X
    a02a:	73 95       	inc	r23
    a02c:	7a 33       	cpi	r23, 0x3A	; 58
    a02e:	08 f0       	brcs	.+2      	; 0xa032 <__ftoa_engine+0x180>
    a030:	70 e3       	ldi	r23, 0x30	; 48
    a032:	7c 93       	st	X, r23
    a034:	20 13       	cpse	r18, r16
    a036:	b8 f7       	brcc	.-18     	; 0xa026 <__ftoa_engine+0x174>
    a038:	7e 91       	ld	r23, -X
    a03a:	70 61       	ori	r23, 0x10	; 16
    a03c:	7d 93       	st	X+, r23
    a03e:	30 f0       	brcs	.+12     	; 0xa04c <__ftoa_engine+0x19a>
    a040:	83 95       	inc	r24
    a042:	71 e3       	ldi	r23, 0x31	; 49
    a044:	7d 93       	st	X+, r23
    a046:	70 e3       	ldi	r23, 0x30	; 48
    a048:	2a 95       	dec	r18
    a04a:	e1 f7       	brne	.-8      	; 0xa044 <__ftoa_engine+0x192>
    a04c:	11 24       	eor	r1, r1
    a04e:	ef 90       	pop	r14
    a050:	ff 90       	pop	r15
    a052:	0f 91       	pop	r16
    a054:	1f 91       	pop	r17
    a056:	cf 91       	pop	r28
    a058:	df 91       	pop	r29
    a05a:	99 27       	eor	r25, r25
    a05c:	87 fd       	sbrc	r24, 7
    a05e:	90 95       	com	r25
    a060:	08 95       	ret

0000a062 <isspace>:
isspace():
    a062:	91 11       	cpse	r25, r1
    a064:	bc c1       	rjmp	.+888    	; 0xa3de <__ctype_isfalse>
    a066:	80 32       	cpi	r24, 0x20	; 32
    a068:	19 f0       	breq	.+6      	; 0xa070 <isspace+0xe>
    a06a:	89 50       	subi	r24, 0x09	; 9
    a06c:	85 50       	subi	r24, 0x05	; 5
    a06e:	d0 f7       	brcc	.-12     	; 0xa064 <isspace+0x2>
    a070:	08 95       	ret

0000a072 <strncasecmp_P>:
strncasecmp_P():
    a072:	fb 01       	movw	r30, r22
    a074:	dc 01       	movw	r26, r24
    a076:	41 50       	subi	r20, 0x01	; 1
    a078:	50 40       	sbci	r21, 0x00	; 0
    a07a:	88 f0       	brcs	.+34     	; 0xa09e <strncasecmp_P+0x2c>
    a07c:	8d 91       	ld	r24, X+
    a07e:	81 34       	cpi	r24, 0x41	; 65
    a080:	1c f0       	brlt	.+6      	; 0xa088 <strncasecmp_P+0x16>
    a082:	8b 35       	cpi	r24, 0x5B	; 91
    a084:	0c f4       	brge	.+2      	; 0xa088 <strncasecmp_P+0x16>
    a086:	80 5e       	subi	r24, 0xE0	; 224
    a088:	65 91       	lpm	r22, Z+
    a08a:	61 34       	cpi	r22, 0x41	; 65
    a08c:	1c f0       	brlt	.+6      	; 0xa094 <strncasecmp_P+0x22>
    a08e:	6b 35       	cpi	r22, 0x5B	; 91
    a090:	0c f4       	brge	.+2      	; 0xa094 <strncasecmp_P+0x22>
    a092:	60 5e       	subi	r22, 0xE0	; 224
    a094:	86 1b       	sub	r24, r22
    a096:	61 11       	cpse	r22, r1
    a098:	71 f3       	breq	.-36     	; 0xa076 <strncasecmp_P+0x4>
    a09a:	99 0b       	sbc	r25, r25
    a09c:	08 95       	ret
    a09e:	88 1b       	sub	r24, r24
    a0a0:	fc cf       	rjmp	.-8      	; 0xa09a <strncasecmp_P+0x28>

0000a0a2 <strnlen_P>:
strnlen_P():
    a0a2:	fc 01       	movw	r30, r24
    a0a4:	05 90       	lpm	r0, Z+
    a0a6:	61 50       	subi	r22, 0x01	; 1
    a0a8:	70 40       	sbci	r23, 0x00	; 0
    a0aa:	01 10       	cpse	r0, r1
    a0ac:	d8 f7       	brcc	.-10     	; 0xa0a4 <strnlen_P+0x2>
    a0ae:	80 95       	com	r24
    a0b0:	90 95       	com	r25
    a0b2:	8e 0f       	add	r24, r30
    a0b4:	9f 1f       	adc	r25, r31
    a0b6:	08 95       	ret

0000a0b8 <strtok>:
strtok():
    a0b8:	4f e7       	ldi	r20, 0x7F	; 127
    a0ba:	50 e7       	ldi	r21, 0x70	; 112
    a0bc:	0b c0       	rjmp	.+22     	; 0xa0d4 <strtok_r>

0000a0be <strnlen>:
strnlen():
    a0be:	fc 01       	movw	r30, r24
    a0c0:	61 50       	subi	r22, 0x01	; 1
    a0c2:	70 40       	sbci	r23, 0x00	; 0
    a0c4:	01 90       	ld	r0, Z+
    a0c6:	01 10       	cpse	r0, r1
    a0c8:	d8 f7       	brcc	.-10     	; 0xa0c0 <strnlen+0x2>
    a0ca:	80 95       	com	r24
    a0cc:	90 95       	com	r25
    a0ce:	8e 0f       	add	r24, r30
    a0d0:	9f 1f       	adc	r25, r31
    a0d2:	08 95       	ret

0000a0d4 <strtok_r>:
strtok_r():
    a0d4:	fa 01       	movw	r30, r20
    a0d6:	a1 91       	ld	r26, Z+
    a0d8:	b0 81       	ld	r27, Z
    a0da:	00 97       	sbiw	r24, 0x00	; 0
    a0dc:	19 f4       	brne	.+6      	; 0xa0e4 <strtok_r+0x10>
    a0de:	10 97       	sbiw	r26, 0x00	; 0
    a0e0:	e1 f0       	breq	.+56     	; 0xa11a <strtok_r+0x46>
    a0e2:	cd 01       	movw	r24, r26
    a0e4:	dc 01       	movw	r26, r24
    a0e6:	cd 01       	movw	r24, r26
    a0e8:	0d 90       	ld	r0, X+
    a0ea:	00 20       	and	r0, r0
    a0ec:	11 f4       	brne	.+4      	; 0xa0f2 <strtok_r+0x1e>
    a0ee:	c0 01       	movw	r24, r0
    a0f0:	13 c0       	rjmp	.+38     	; 0xa118 <strtok_r+0x44>
    a0f2:	fb 01       	movw	r30, r22
    a0f4:	21 91       	ld	r18, Z+
    a0f6:	22 23       	and	r18, r18
    a0f8:	19 f0       	breq	.+6      	; 0xa100 <strtok_r+0x2c>
    a0fa:	20 15       	cp	r18, r0
    a0fc:	d9 f7       	brne	.-10     	; 0xa0f4 <strtok_r+0x20>
    a0fe:	f3 cf       	rjmp	.-26     	; 0xa0e6 <strtok_r+0x12>
    a100:	fb 01       	movw	r30, r22
    a102:	21 91       	ld	r18, Z+
    a104:	20 15       	cp	r18, r0
    a106:	19 f4       	brne	.+6      	; 0xa10e <strtok_r+0x3a>
    a108:	1e 92       	st	-X, r1
    a10a:	11 96       	adiw	r26, 0x01	; 1
    a10c:	06 c0       	rjmp	.+12     	; 0xa11a <strtok_r+0x46>
    a10e:	22 23       	and	r18, r18
    a110:	c1 f7       	brne	.-16     	; 0xa102 <strtok_r+0x2e>
    a112:	0d 90       	ld	r0, X+
    a114:	00 20       	and	r0, r0
    a116:	a1 f7       	brne	.-24     	; 0xa100 <strtok_r+0x2c>
    a118:	d0 01       	movw	r26, r0
    a11a:	fa 01       	movw	r30, r20
    a11c:	a1 93       	st	Z+, r26
    a11e:	b0 83       	st	Z, r27
    a120:	08 95       	ret

0000a122 <__mulhi_const_10>:
__mulhi_const_10():
    a122:	7a e0       	ldi	r23, 0x0A	; 10
    a124:	97 9f       	mul	r25, r23
    a126:	90 2d       	mov	r25, r0
    a128:	87 9f       	mul	r24, r23
    a12a:	80 2d       	mov	r24, r0
    a12c:	91 0d       	add	r25, r1
    a12e:	11 24       	eor	r1, r1
    a130:	08 95       	ret

0000a132 <fputc>:
fputc():
    a132:	0f 93       	push	r16
    a134:	1f 93       	push	r17
    a136:	cf 93       	push	r28
    a138:	df 93       	push	r29
    a13a:	18 2f       	mov	r17, r24
    a13c:	09 2f       	mov	r16, r25
    a13e:	eb 01       	movw	r28, r22
    a140:	8b 81       	ldd	r24, Y+3	; 0x03
    a142:	81 fd       	sbrc	r24, 1
    a144:	09 c0       	rjmp	.+18     	; 0xa158 <fputc+0x26>
    a146:	1f ef       	ldi	r17, 0xFF	; 255
    a148:	0f ef       	ldi	r16, 0xFF	; 255
    a14a:	81 2f       	mov	r24, r17
    a14c:	90 2f       	mov	r25, r16
    a14e:	df 91       	pop	r29
    a150:	cf 91       	pop	r28
    a152:	1f 91       	pop	r17
    a154:	0f 91       	pop	r16
    a156:	08 95       	ret
    a158:	82 ff       	sbrs	r24, 2
    a15a:	14 c0       	rjmp	.+40     	; 0xa184 <fputc+0x52>
    a15c:	2e 81       	ldd	r18, Y+6	; 0x06
    a15e:	3f 81       	ldd	r19, Y+7	; 0x07
    a160:	8c 81       	ldd	r24, Y+4	; 0x04
    a162:	9d 81       	ldd	r25, Y+5	; 0x05
    a164:	28 17       	cp	r18, r24
    a166:	39 07       	cpc	r19, r25
    a168:	3c f4       	brge	.+14     	; 0xa178 <fputc+0x46>
    a16a:	e8 81       	ld	r30, Y
    a16c:	f9 81       	ldd	r31, Y+1	; 0x01
    a16e:	cf 01       	movw	r24, r30
    a170:	01 96       	adiw	r24, 0x01	; 1
    a172:	88 83       	st	Y, r24
    a174:	99 83       	std	Y+1, r25	; 0x01
    a176:	10 83       	st	Z, r17
    a178:	8e 81       	ldd	r24, Y+6	; 0x06
    a17a:	9f 81       	ldd	r25, Y+7	; 0x07
    a17c:	01 96       	adiw	r24, 0x01	; 1
    a17e:	8e 83       	std	Y+6, r24	; 0x06
    a180:	9f 83       	std	Y+7, r25	; 0x07
    a182:	e3 cf       	rjmp	.-58     	; 0xa14a <fputc+0x18>
    a184:	e8 85       	ldd	r30, Y+8	; 0x08
    a186:	f9 85       	ldd	r31, Y+9	; 0x09
    a188:	81 2f       	mov	r24, r17
    a18a:	09 95       	icall
    a18c:	89 2b       	or	r24, r25
    a18e:	a1 f3       	breq	.-24     	; 0xa178 <fputc+0x46>
    a190:	da cf       	rjmp	.-76     	; 0xa146 <fputc+0x14>

0000a192 <__ultoa_invert>:
__ultoa_invert():
    a192:	fa 01       	movw	r30, r20
    a194:	aa 27       	eor	r26, r26
    a196:	28 30       	cpi	r18, 0x08	; 8
    a198:	51 f1       	breq	.+84     	; 0xa1ee <__ultoa_invert+0x5c>
    a19a:	20 31       	cpi	r18, 0x10	; 16
    a19c:	81 f1       	breq	.+96     	; 0xa1fe <__ultoa_invert+0x6c>
    a19e:	e8 94       	clt
    a1a0:	6f 93       	push	r22
    a1a2:	6e 7f       	andi	r22, 0xFE	; 254
    a1a4:	6e 5f       	subi	r22, 0xFE	; 254
    a1a6:	7f 4f       	sbci	r23, 0xFF	; 255
    a1a8:	8f 4f       	sbci	r24, 0xFF	; 255
    a1aa:	9f 4f       	sbci	r25, 0xFF	; 255
    a1ac:	af 4f       	sbci	r26, 0xFF	; 255
    a1ae:	b1 e0       	ldi	r27, 0x01	; 1
    a1b0:	3e d0       	rcall	.+124    	; 0xa22e <__ultoa_invert+0x9c>
    a1b2:	b4 e0       	ldi	r27, 0x04	; 4
    a1b4:	3c d0       	rcall	.+120    	; 0xa22e <__ultoa_invert+0x9c>
    a1b6:	67 0f       	add	r22, r23
    a1b8:	78 1f       	adc	r23, r24
    a1ba:	89 1f       	adc	r24, r25
    a1bc:	9a 1f       	adc	r25, r26
    a1be:	a1 1d       	adc	r26, r1
    a1c0:	68 0f       	add	r22, r24
    a1c2:	79 1f       	adc	r23, r25
    a1c4:	8a 1f       	adc	r24, r26
    a1c6:	91 1d       	adc	r25, r1
    a1c8:	a1 1d       	adc	r26, r1
    a1ca:	6a 0f       	add	r22, r26
    a1cc:	71 1d       	adc	r23, r1
    a1ce:	81 1d       	adc	r24, r1
    a1d0:	91 1d       	adc	r25, r1
    a1d2:	a1 1d       	adc	r26, r1
    a1d4:	20 d0       	rcall	.+64     	; 0xa216 <__ultoa_invert+0x84>
    a1d6:	09 f4       	brne	.+2      	; 0xa1da <__ultoa_invert+0x48>
    a1d8:	68 94       	set
    a1da:	3f 91       	pop	r19
    a1dc:	2a e0       	ldi	r18, 0x0A	; 10
    a1de:	26 9f       	mul	r18, r22
    a1e0:	11 24       	eor	r1, r1
    a1e2:	30 19       	sub	r19, r0
    a1e4:	30 5d       	subi	r19, 0xD0	; 208
    a1e6:	31 93       	st	Z+, r19
    a1e8:	de f6       	brtc	.-74     	; 0xa1a0 <__ultoa_invert+0xe>
    a1ea:	cf 01       	movw	r24, r30
    a1ec:	08 95       	ret
    a1ee:	46 2f       	mov	r20, r22
    a1f0:	47 70       	andi	r20, 0x07	; 7
    a1f2:	40 5d       	subi	r20, 0xD0	; 208
    a1f4:	41 93       	st	Z+, r20
    a1f6:	b3 e0       	ldi	r27, 0x03	; 3
    a1f8:	0f d0       	rcall	.+30     	; 0xa218 <__ultoa_invert+0x86>
    a1fa:	c9 f7       	brne	.-14     	; 0xa1ee <__ultoa_invert+0x5c>
    a1fc:	f6 cf       	rjmp	.-20     	; 0xa1ea <__ultoa_invert+0x58>
    a1fe:	46 2f       	mov	r20, r22
    a200:	4f 70       	andi	r20, 0x0F	; 15
    a202:	40 5d       	subi	r20, 0xD0	; 208
    a204:	4a 33       	cpi	r20, 0x3A	; 58
    a206:	18 f0       	brcs	.+6      	; 0xa20e <__ultoa_invert+0x7c>
    a208:	49 5d       	subi	r20, 0xD9	; 217
    a20a:	31 fd       	sbrc	r19, 1
    a20c:	40 52       	subi	r20, 0x20	; 32
    a20e:	41 93       	st	Z+, r20
    a210:	02 d0       	rcall	.+4      	; 0xa216 <__ultoa_invert+0x84>
    a212:	a9 f7       	brne	.-22     	; 0xa1fe <__ultoa_invert+0x6c>
    a214:	ea cf       	rjmp	.-44     	; 0xa1ea <__ultoa_invert+0x58>
    a216:	b4 e0       	ldi	r27, 0x04	; 4
    a218:	a6 95       	lsr	r26
    a21a:	97 95       	ror	r25
    a21c:	87 95       	ror	r24
    a21e:	77 95       	ror	r23
    a220:	67 95       	ror	r22
    a222:	ba 95       	dec	r27
    a224:	c9 f7       	brne	.-14     	; 0xa218 <__ultoa_invert+0x86>
    a226:	00 97       	sbiw	r24, 0x00	; 0
    a228:	61 05       	cpc	r22, r1
    a22a:	71 05       	cpc	r23, r1
    a22c:	08 95       	ret
    a22e:	9b 01       	movw	r18, r22
    a230:	ac 01       	movw	r20, r24
    a232:	0a 2e       	mov	r0, r26
    a234:	06 94       	lsr	r0
    a236:	57 95       	ror	r21
    a238:	47 95       	ror	r20
    a23a:	37 95       	ror	r19
    a23c:	27 95       	ror	r18
    a23e:	ba 95       	dec	r27
    a240:	c9 f7       	brne	.-14     	; 0xa234 <__ultoa_invert+0xa2>
    a242:	62 0f       	add	r22, r18
    a244:	73 1f       	adc	r23, r19
    a246:	84 1f       	adc	r24, r20
    a248:	95 1f       	adc	r25, r21
    a24a:	a0 1d       	adc	r26, r0
    a24c:	08 95       	ret

0000a24e <__cmpsf2>:
__cmpsf2():
    a24e:	40 d0       	rcall	.+128    	; 0xa2d0 <__fp_cmp>
    a250:	08 f4       	brcc	.+2      	; 0xa254 <__cmpsf2+0x6>
    a252:	81 e0       	ldi	r24, 0x01	; 1
    a254:	08 95       	ret

0000a256 <__floatunsisf>:
__floatunsisf():
    a256:	e8 94       	clt
    a258:	09 c0       	rjmp	.+18     	; 0xa26c <__floatsisf+0x12>

0000a25a <__floatsisf>:
    a25a:	97 fb       	bst	r25, 7
    a25c:	3e f4       	brtc	.+14     	; 0xa26c <__floatsisf+0x12>
    a25e:	90 95       	com	r25
    a260:	80 95       	com	r24
    a262:	70 95       	com	r23
    a264:	61 95       	neg	r22
    a266:	7f 4f       	sbci	r23, 0xFF	; 255
    a268:	8f 4f       	sbci	r24, 0xFF	; 255
    a26a:	9f 4f       	sbci	r25, 0xFF	; 255
    a26c:	99 23       	and	r25, r25
    a26e:	a9 f0       	breq	.+42     	; 0xa29a <__floatsisf+0x40>
    a270:	f9 2f       	mov	r31, r25
    a272:	96 e9       	ldi	r25, 0x96	; 150
    a274:	bb 27       	eor	r27, r27
    a276:	93 95       	inc	r25
    a278:	f6 95       	lsr	r31
    a27a:	87 95       	ror	r24
    a27c:	77 95       	ror	r23
    a27e:	67 95       	ror	r22
    a280:	b7 95       	ror	r27
    a282:	f1 11       	cpse	r31, r1
    a284:	f8 cf       	rjmp	.-16     	; 0xa276 <__floatsisf+0x1c>
    a286:	fa f4       	brpl	.+62     	; 0xa2c6 <__floatsisf+0x6c>
    a288:	bb 0f       	add	r27, r27
    a28a:	11 f4       	brne	.+4      	; 0xa290 <__floatsisf+0x36>
    a28c:	60 ff       	sbrs	r22, 0
    a28e:	1b c0       	rjmp	.+54     	; 0xa2c6 <__floatsisf+0x6c>
    a290:	6f 5f       	subi	r22, 0xFF	; 255
    a292:	7f 4f       	sbci	r23, 0xFF	; 255
    a294:	8f 4f       	sbci	r24, 0xFF	; 255
    a296:	9f 4f       	sbci	r25, 0xFF	; 255
    a298:	16 c0       	rjmp	.+44     	; 0xa2c6 <__floatsisf+0x6c>
    a29a:	88 23       	and	r24, r24
    a29c:	11 f0       	breq	.+4      	; 0xa2a2 <__floatsisf+0x48>
    a29e:	96 e9       	ldi	r25, 0x96	; 150
    a2a0:	11 c0       	rjmp	.+34     	; 0xa2c4 <__floatsisf+0x6a>
    a2a2:	77 23       	and	r23, r23
    a2a4:	21 f0       	breq	.+8      	; 0xa2ae <__floatsisf+0x54>
    a2a6:	9e e8       	ldi	r25, 0x8E	; 142
    a2a8:	87 2f       	mov	r24, r23
    a2aa:	76 2f       	mov	r23, r22
    a2ac:	05 c0       	rjmp	.+10     	; 0xa2b8 <__floatsisf+0x5e>
    a2ae:	66 23       	and	r22, r22
    a2b0:	71 f0       	breq	.+28     	; 0xa2ce <__floatsisf+0x74>
    a2b2:	96 e8       	ldi	r25, 0x86	; 134
    a2b4:	86 2f       	mov	r24, r22
    a2b6:	70 e0       	ldi	r23, 0x00	; 0
    a2b8:	60 e0       	ldi	r22, 0x00	; 0
    a2ba:	2a f0       	brmi	.+10     	; 0xa2c6 <__floatsisf+0x6c>
    a2bc:	9a 95       	dec	r25
    a2be:	66 0f       	add	r22, r22
    a2c0:	77 1f       	adc	r23, r23
    a2c2:	88 1f       	adc	r24, r24
    a2c4:	da f7       	brpl	.-10     	; 0xa2bc <__floatsisf+0x62>
    a2c6:	88 0f       	add	r24, r24
    a2c8:	96 95       	lsr	r25
    a2ca:	87 95       	ror	r24
    a2cc:	97 f9       	bld	r25, 7
    a2ce:	08 95       	ret

0000a2d0 <__fp_cmp>:
__fp_cmp():
    a2d0:	99 0f       	add	r25, r25
    a2d2:	00 08       	sbc	r0, r0
    a2d4:	55 0f       	add	r21, r21
    a2d6:	aa 0b       	sbc	r26, r26
    a2d8:	e0 e8       	ldi	r30, 0x80	; 128
    a2da:	fe ef       	ldi	r31, 0xFE	; 254
    a2dc:	16 16       	cp	r1, r22
    a2de:	17 06       	cpc	r1, r23
    a2e0:	e8 07       	cpc	r30, r24
    a2e2:	f9 07       	cpc	r31, r25
    a2e4:	c0 f0       	brcs	.+48     	; 0xa316 <__fp_cmp+0x46>
    a2e6:	12 16       	cp	r1, r18
    a2e8:	13 06       	cpc	r1, r19
    a2ea:	e4 07       	cpc	r30, r20
    a2ec:	f5 07       	cpc	r31, r21
    a2ee:	98 f0       	brcs	.+38     	; 0xa316 <__fp_cmp+0x46>
    a2f0:	62 1b       	sub	r22, r18
    a2f2:	73 0b       	sbc	r23, r19
    a2f4:	84 0b       	sbc	r24, r20
    a2f6:	95 0b       	sbc	r25, r21
    a2f8:	39 f4       	brne	.+14     	; 0xa308 <__fp_cmp+0x38>
    a2fa:	0a 26       	eor	r0, r26
    a2fc:	61 f0       	breq	.+24     	; 0xa316 <__fp_cmp+0x46>
    a2fe:	23 2b       	or	r18, r19
    a300:	24 2b       	or	r18, r20
    a302:	25 2b       	or	r18, r21
    a304:	21 f4       	brne	.+8      	; 0xa30e <__fp_cmp+0x3e>
    a306:	08 95       	ret
    a308:	0a 26       	eor	r0, r26
    a30a:	09 f4       	brne	.+2      	; 0xa30e <__fp_cmp+0x3e>
    a30c:	a1 40       	sbci	r26, 0x01	; 1
    a30e:	a6 95       	lsr	r26
    a310:	8f ef       	ldi	r24, 0xFF	; 255
    a312:	81 1d       	adc	r24, r1
    a314:	81 1d       	adc	r24, r1
    a316:	08 95       	ret

0000a318 <__mulsf3>:
__mulsf3():
    a318:	0b d0       	rcall	.+22     	; 0xa330 <__mulsf3x>
    a31a:	7b c0       	rjmp	.+246    	; 0xa412 <__fp_round>
    a31c:	6c d0       	rcall	.+216    	; 0xa3f6 <__fp_pscA>
    a31e:	28 f0       	brcs	.+10     	; 0xa32a <__mulsf3+0x12>
    a320:	71 d0       	rcall	.+226    	; 0xa404 <__fp_pscB>
    a322:	18 f0       	brcs	.+6      	; 0xa32a <__mulsf3+0x12>
    a324:	95 23       	and	r25, r21
    a326:	09 f0       	breq	.+2      	; 0xa32a <__mulsf3+0x12>
    a328:	5d c0       	rjmp	.+186    	; 0xa3e4 <__fp_inf>
    a32a:	62 c0       	rjmp	.+196    	; 0xa3f0 <__fp_nan>
    a32c:	11 24       	eor	r1, r1
    a32e:	a5 c0       	rjmp	.+330    	; 0xa47a <__fp_szero>

0000a330 <__mulsf3x>:
__mulsf3x():
    a330:	81 d0       	rcall	.+258    	; 0xa434 <__fp_split3>
    a332:	a0 f3       	brcs	.-24     	; 0xa31c <__mulsf3+0x4>

0000a334 <__mulsf3_pse>:
    a334:	95 9f       	mul	r25, r21
    a336:	d1 f3       	breq	.-12     	; 0xa32c <__mulsf3+0x14>
    a338:	95 0f       	add	r25, r21
    a33a:	50 e0       	ldi	r21, 0x00	; 0
    a33c:	55 1f       	adc	r21, r21
    a33e:	62 9f       	mul	r22, r18
    a340:	f0 01       	movw	r30, r0
    a342:	72 9f       	mul	r23, r18
    a344:	bb 27       	eor	r27, r27
    a346:	f0 0d       	add	r31, r0
    a348:	b1 1d       	adc	r27, r1
    a34a:	63 9f       	mul	r22, r19
    a34c:	aa 27       	eor	r26, r26
    a34e:	f0 0d       	add	r31, r0
    a350:	b1 1d       	adc	r27, r1
    a352:	aa 1f       	adc	r26, r26
    a354:	64 9f       	mul	r22, r20
    a356:	66 27       	eor	r22, r22
    a358:	b0 0d       	add	r27, r0
    a35a:	a1 1d       	adc	r26, r1
    a35c:	66 1f       	adc	r22, r22
    a35e:	82 9f       	mul	r24, r18
    a360:	22 27       	eor	r18, r18
    a362:	b0 0d       	add	r27, r0
    a364:	a1 1d       	adc	r26, r1
    a366:	62 1f       	adc	r22, r18
    a368:	73 9f       	mul	r23, r19
    a36a:	b0 0d       	add	r27, r0
    a36c:	a1 1d       	adc	r26, r1
    a36e:	62 1f       	adc	r22, r18
    a370:	83 9f       	mul	r24, r19
    a372:	a0 0d       	add	r26, r0
    a374:	61 1d       	adc	r22, r1
    a376:	22 1f       	adc	r18, r18
    a378:	74 9f       	mul	r23, r20
    a37a:	33 27       	eor	r19, r19
    a37c:	a0 0d       	add	r26, r0
    a37e:	61 1d       	adc	r22, r1
    a380:	23 1f       	adc	r18, r19
    a382:	84 9f       	mul	r24, r20
    a384:	60 0d       	add	r22, r0
    a386:	21 1d       	adc	r18, r1
    a388:	82 2f       	mov	r24, r18
    a38a:	76 2f       	mov	r23, r22
    a38c:	6a 2f       	mov	r22, r26
    a38e:	11 24       	eor	r1, r1
    a390:	9f 57       	subi	r25, 0x7F	; 127
    a392:	50 40       	sbci	r21, 0x00	; 0
    a394:	8a f0       	brmi	.+34     	; 0xa3b8 <__mulsf3_pse+0x84>
    a396:	e1 f0       	breq	.+56     	; 0xa3d0 <__mulsf3_pse+0x9c>
    a398:	88 23       	and	r24, r24
    a39a:	4a f0       	brmi	.+18     	; 0xa3ae <__mulsf3_pse+0x7a>
    a39c:	ee 0f       	add	r30, r30
    a39e:	ff 1f       	adc	r31, r31
    a3a0:	bb 1f       	adc	r27, r27
    a3a2:	66 1f       	adc	r22, r22
    a3a4:	77 1f       	adc	r23, r23
    a3a6:	88 1f       	adc	r24, r24
    a3a8:	91 50       	subi	r25, 0x01	; 1
    a3aa:	50 40       	sbci	r21, 0x00	; 0
    a3ac:	a9 f7       	brne	.-22     	; 0xa398 <__mulsf3_pse+0x64>
    a3ae:	9e 3f       	cpi	r25, 0xFE	; 254
    a3b0:	51 05       	cpc	r21, r1
    a3b2:	70 f0       	brcs	.+28     	; 0xa3d0 <__mulsf3_pse+0x9c>
    a3b4:	17 c0       	rjmp	.+46     	; 0xa3e4 <__fp_inf>
    a3b6:	61 c0       	rjmp	.+194    	; 0xa47a <__fp_szero>
    a3b8:	5f 3f       	cpi	r21, 0xFF	; 255
    a3ba:	ec f3       	brlt	.-6      	; 0xa3b6 <__mulsf3_pse+0x82>
    a3bc:	98 3e       	cpi	r25, 0xE8	; 232
    a3be:	dc f3       	brlt	.-10     	; 0xa3b6 <__mulsf3_pse+0x82>
    a3c0:	86 95       	lsr	r24
    a3c2:	77 95       	ror	r23
    a3c4:	67 95       	ror	r22
    a3c6:	b7 95       	ror	r27
    a3c8:	f7 95       	ror	r31
    a3ca:	e7 95       	ror	r30
    a3cc:	9f 5f       	subi	r25, 0xFF	; 255
    a3ce:	c1 f7       	brne	.-16     	; 0xa3c0 <__mulsf3_pse+0x8c>
    a3d0:	fe 2b       	or	r31, r30
    a3d2:	88 0f       	add	r24, r24
    a3d4:	91 1d       	adc	r25, r1
    a3d6:	96 95       	lsr	r25
    a3d8:	87 95       	ror	r24
    a3da:	97 f9       	bld	r25, 7
    a3dc:	08 95       	ret

0000a3de <__ctype_isfalse>:
    a3de:	99 27       	eor	r25, r25
    a3e0:	88 27       	eor	r24, r24

0000a3e2 <__ctype_istrue>:
    a3e2:	08 95       	ret

0000a3e4 <__fp_inf>:
    a3e4:	97 f9       	bld	r25, 7
    a3e6:	9f 67       	ori	r25, 0x7F	; 127
    a3e8:	80 e8       	ldi	r24, 0x80	; 128
    a3ea:	70 e0       	ldi	r23, 0x00	; 0
    a3ec:	60 e0       	ldi	r22, 0x00	; 0
    a3ee:	08 95       	ret

0000a3f0 <__fp_nan>:
    a3f0:	9f ef       	ldi	r25, 0xFF	; 255
    a3f2:	80 ec       	ldi	r24, 0xC0	; 192
    a3f4:	08 95       	ret

0000a3f6 <__fp_pscA>:
    a3f6:	00 24       	eor	r0, r0
    a3f8:	0a 94       	dec	r0
    a3fa:	16 16       	cp	r1, r22
    a3fc:	17 06       	cpc	r1, r23
    a3fe:	18 06       	cpc	r1, r24
    a400:	09 06       	cpc	r0, r25
__fp_pscA():
    a402:	08 95       	ret

0000a404 <__fp_pscB>:
__fp_pscB():
    a404:	00 24       	eor	r0, r0
    a406:	0a 94       	dec	r0
    a408:	12 16       	cp	r1, r18
    a40a:	13 06       	cpc	r1, r19
    a40c:	14 06       	cpc	r1, r20
    a40e:	05 06       	cpc	r0, r21
    a410:	08 95       	ret

0000a412 <__fp_round>:
__fp_round():
    a412:	09 2e       	mov	r0, r25
    a414:	03 94       	inc	r0
    a416:	00 0c       	add	r0, r0
    a418:	11 f4       	brne	.+4      	; 0xa41e <__fp_round+0xc>
    a41a:	88 23       	and	r24, r24
    a41c:	52 f0       	brmi	.+20     	; 0xa432 <__fp_round+0x20>
    a41e:	bb 0f       	add	r27, r27
    a420:	40 f4       	brcc	.+16     	; 0xa432 <__fp_round+0x20>
    a422:	bf 2b       	or	r27, r31
    a424:	11 f4       	brne	.+4      	; 0xa42a <__fp_round+0x18>
    a426:	60 ff       	sbrs	r22, 0
    a428:	04 c0       	rjmp	.+8      	; 0xa432 <__fp_round+0x20>
    a42a:	6f 5f       	subi	r22, 0xFF	; 255
    a42c:	7f 4f       	sbci	r23, 0xFF	; 255
    a42e:	8f 4f       	sbci	r24, 0xFF	; 255
    a430:	9f 4f       	sbci	r25, 0xFF	; 255
    a432:	08 95       	ret

0000a434 <__fp_split3>:
__fp_split3():
    a434:	57 fd       	sbrc	r21, 7
    a436:	90 58       	subi	r25, 0x80	; 128
    a438:	44 0f       	add	r20, r20
    a43a:	55 1f       	adc	r21, r21
    a43c:	59 f0       	breq	.+22     	; 0xa454 <__fp_splitA+0x10>
    a43e:	5f 3f       	cpi	r21, 0xFF	; 255
    a440:	71 f0       	breq	.+28     	; 0xa45e <__fp_splitA+0x1a>
    a442:	47 95       	ror	r20

0000a444 <__fp_splitA>:
    a444:	88 0f       	add	r24, r24
    a446:	97 fb       	bst	r25, 7
    a448:	99 1f       	adc	r25, r25
    a44a:	61 f0       	breq	.+24     	; 0xa464 <__fp_splitA+0x20>
    a44c:	9f 3f       	cpi	r25, 0xFF	; 255
    a44e:	79 f0       	breq	.+30     	; 0xa46e <__fp_splitA+0x2a>
    a450:	87 95       	ror	r24
    a452:	08 95       	ret
    a454:	12 16       	cp	r1, r18
    a456:	13 06       	cpc	r1, r19
    a458:	14 06       	cpc	r1, r20
    a45a:	55 1f       	adc	r21, r21
    a45c:	f2 cf       	rjmp	.-28     	; 0xa442 <__fp_split3+0xe>
    a45e:	46 95       	lsr	r20
    a460:	f1 df       	rcall	.-30     	; 0xa444 <__fp_splitA>
    a462:	08 c0       	rjmp	.+16     	; 0xa474 <__fp_splitA+0x30>
    a464:	16 16       	cp	r1, r22
    a466:	17 06       	cpc	r1, r23
    a468:	18 06       	cpc	r1, r24
    a46a:	99 1f       	adc	r25, r25
    a46c:	f1 cf       	rjmp	.-30     	; 0xa450 <__fp_splitA+0xc>
    a46e:	86 95       	lsr	r24
    a470:	71 05       	cpc	r23, r1
    a472:	61 05       	cpc	r22, r1
    a474:	08 94       	sec
    a476:	08 95       	ret

0000a478 <__fp_zero>:
__fp_zero():
    a478:	e8 94       	clt

0000a47a <__fp_szero>:
    a47a:	bb 27       	eor	r27, r27
    a47c:	66 27       	eor	r22, r22
    a47e:	77 27       	eor	r23, r23
    a480:	cb 01       	movw	r24, r22
    a482:	97 f9       	bld	r25, 7
    a484:	08 95       	ret

0000a486 <__mulsi3>:
__mulsi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:648
    a486:	db 01       	movw	r26, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:649
    a488:	8f 93       	push	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:650
    a48a:	9f 93       	push	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:651
    a48c:	76 d0       	rcall	.+236    	; 0xa57a <__muluhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:652
    a48e:	bf 91       	pop	r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:653
    a490:	af 91       	pop	r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:655
    a492:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:656
    a494:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:657
    a496:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:658
    a498:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:659
    a49a:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:660
    a49c:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:661
    a49e:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:662
    a4a0:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:663
    a4a2:	08 95       	ret

0000a4a4 <__udivmodhi4>:
__udivmodhi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1408
    a4a4:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1409
    a4a6:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1410
    a4a8:	51 e1       	ldi	r21, 0x11	; 17
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1411
    a4aa:	07 c0       	rjmp	.+14     	; 0xa4ba <__udivmodhi4_ep>

0000a4ac <__udivmodhi4_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1413
    a4ac:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1414
    a4ae:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1415
    a4b0:	a6 17       	cp	r26, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1416
    a4b2:	b7 07       	cpc	r27, r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1417
    a4b4:	10 f0       	brcs	.+4      	; 0xa4ba <__udivmodhi4_ep>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1418
    a4b6:	a6 1b       	sub	r26, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1419
    a4b8:	b7 0b       	sbc	r27, r23

0000a4ba <__udivmodhi4_ep>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1421
    a4ba:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1422
    a4bc:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1423
    a4be:	5a 95       	dec	r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1424
    a4c0:	a9 f7       	brne	.-22     	; 0xa4ac <__udivmodhi4_loop>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1425
    a4c2:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1426
    a4c4:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1428
    a4c6:	bc 01       	movw	r22, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1430
    a4c8:	cd 01       	movw	r24, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1432
    a4ca:	08 95       	ret

0000a4cc <__divmodhi4>:
__divmodhi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1440
    a4cc:	97 fb       	bst	r25, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1441
    a4ce:	07 2e       	mov	r0, r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1442
    a4d0:	16 f4       	brtc	.+4      	; 0xa4d6 <__divmodhi4+0xa>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1443
    a4d2:	00 94       	com	r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1444
    a4d4:	06 d0       	rcall	.+12     	; 0xa4e2 <__divmodhi4_neg1>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1446
    a4d6:	77 fd       	sbrc	r23, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1447
    a4d8:	08 d0       	rcall	.+16     	; 0xa4ea <__divmodhi4_neg2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1448
    a4da:	e4 df       	rcall	.-56     	; 0xa4a4 <__udivmodhi4>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1449
    a4dc:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1450
    a4de:	05 d0       	rcall	.+10     	; 0xa4ea <__divmodhi4_neg2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1451
    a4e0:	3e f4       	brtc	.+14     	; 0xa4f0 <__divmodhi4_exit>

0000a4e2 <__divmodhi4_neg1>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1454
    a4e2:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1455
    a4e4:	81 95       	neg	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1456
    a4e6:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1457
    a4e8:	08 95       	ret

0000a4ea <__divmodhi4_neg2>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1460
    a4ea:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1461
    a4ec:	61 95       	neg	r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1462
    a4ee:	7f 4f       	sbci	r23, 0xFF	; 255

0000a4f0 <__divmodhi4_exit>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1464
    a4f0:	08 95       	ret

0000a4f2 <__udivmodsi4>:
__udivmodsi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1638
    a4f2:	a1 e2       	ldi	r26, 0x21	; 33
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1639
    a4f4:	1a 2e       	mov	r1, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1640
    a4f6:	aa 1b       	sub	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1641
    a4f8:	bb 1b       	sub	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1642
    a4fa:	fd 01       	movw	r30, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1644
    a4fc:	0d c0       	rjmp	.+26     	; 0xa518 <__udivmodsi4_ep>

0000a4fe <__udivmodsi4_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1646
    a4fe:	aa 1f       	adc	r26, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1647
    a500:	bb 1f       	adc	r27, r27
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1648
    a502:	ee 1f       	adc	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1649
    a504:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1650
    a506:	a2 17       	cp	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1651
    a508:	b3 07       	cpc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1652
    a50a:	e4 07       	cpc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1653
    a50c:	f5 07       	cpc	r31, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1654
    a50e:	20 f0       	brcs	.+8      	; 0xa518 <__udivmodsi4_ep>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1655
    a510:	a2 1b       	sub	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1656
    a512:	b3 0b       	sbc	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1657
    a514:	e4 0b       	sbc	r30, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1658
    a516:	f5 0b       	sbc	r31, r21

0000a518 <__udivmodsi4_ep>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1660
    a518:	66 1f       	adc	r22, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1661
    a51a:	77 1f       	adc	r23, r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1662
    a51c:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1663
    a51e:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1664
    a520:	1a 94       	dec	r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1665
    a522:	69 f7       	brne	.-38     	; 0xa4fe <__udivmodsi4_loop>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1667
    a524:	60 95       	com	r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1668
    a526:	70 95       	com	r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1669
    a528:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1670
    a52a:	90 95       	com	r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1672
    a52c:	9b 01       	movw	r18, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1674
    a52e:	ac 01       	movw	r20, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1676
    a530:	bd 01       	movw	r22, r26
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1678
    a532:	cf 01       	movw	r24, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1680
    a534:	08 95       	ret

0000a536 <__divmodsi4>:
__divmodsi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1686
    a536:	05 2e       	mov	r0, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1687
    a538:	97 fb       	bst	r25, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1688
    a53a:	16 f4       	brtc	.+4      	; 0xa540 <__divmodsi4+0xa>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1689
    a53c:	00 94       	com	r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1690
    a53e:	0f d0       	rcall	.+30     	; 0xa55e <__negsi2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1692
    a540:	57 fd       	sbrc	r21, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1694
    a542:	05 d0       	rcall	.+10     	; 0xa54e <__divmodsi4_neg2>
    a544:	d6 df       	rcall	.-84     	; 0xa4f2 <__udivmodsi4>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1695
    a546:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1697
    a548:	02 d0       	rcall	.+4      	; 0xa54e <__divmodsi4_neg2>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1698
    a54a:	46 f4       	brtc	.+16     	; 0xa55c <__divmodsi4_exit>
    a54c:	08 c0       	rjmp	.+16     	; 0xa55e <__negsi2>

0000a54e <__divmodsi4_neg2>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1701
    a54e:	50 95       	com	r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1702
    a550:	40 95       	com	r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1703
    a552:	30 95       	com	r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1704
    a554:	21 95       	neg	r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1705
    a556:	3f 4f       	sbci	r19, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1706
    a558:	4f 4f       	sbci	r20, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1707
    a55a:	5f 4f       	sbci	r21, 0xFF	; 255

0000a55c <__divmodsi4_exit>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1709
    a55c:	08 95       	ret

0000a55e <__negsi2>:
__negsi2():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1718
    a55e:	90 95       	com	r25
    a560:	80 95       	com	r24
    a562:	70 95       	com	r23
    a564:	61 95       	neg	r22
    a566:	7f 4f       	sbci	r23, 0xFF	; 255
    a568:	8f 4f       	sbci	r24, 0xFF	; 255
    a56a:	9f 4f       	sbci	r25, 0xFF	; 255
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1719
    a56c:	08 95       	ret

0000a56e <__usmulhisi3>:
__usmulhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:545
    a56e:	15 d0       	rcall	.+42     	; 0xa59a <__umulhisi3>

0000a570 <__usmulhisi3_tail>:
__usmulhisi3_tail():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:551
    a570:	b7 ff       	sbrs	r27, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:552
    a572:	08 95       	ret
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:553
    a574:	82 1b       	sub	r24, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:554
    a576:	93 0b       	sbc	r25, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:555
    a578:	08 95       	ret

0000a57a <__muluhisi3>:
__muluhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:626
    a57a:	0f d0       	rcall	.+30     	; 0xa59a <__umulhisi3>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:627
    a57c:	a5 9f       	mul	r26, r21
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:628
    a57e:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:629
    a580:	b4 9f       	mul	r27, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:630
    a582:	90 0d       	add	r25, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:631
    a584:	a4 9f       	mul	r26, r20
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:632
    a586:	80 0d       	add	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:633
    a588:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:634
    a58a:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:635
    a58c:	08 95       	ret

0000a58e <__mulshisi3>:
__mulshisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:603
    a58e:	b7 ff       	sbrs	r27, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:605
    a590:	f4 cf       	rjmp	.-24     	; 0xa57a <__muluhisi3>

0000a592 <__mulohisi3>:
__mulohisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:613
    a592:	f3 df       	rcall	.-26     	; 0xa57a <__muluhisi3>
    a594:	82 1b       	sub	r24, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:615
    a596:	93 0b       	sbc	r25, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:616
    a598:	08 95       	ret

0000a59a <__umulhisi3>:
__umulhisi3():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:617
    a59a:	a2 9f       	mul	r26, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:565
    a59c:	b0 01       	movw	r22, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:566
    a59e:	b3 9f       	mul	r27, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:567
    a5a0:	c0 01       	movw	r24, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:568
    a5a2:	a3 9f       	mul	r26, r19
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:573
    a5a4:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:574
    a5a6:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:575
    a5a8:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:576
    a5aa:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:580
    a5ac:	b2 9f       	mul	r27, r18
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:581
    a5ae:	70 0d       	add	r23, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:582
    a5b0:	81 1d       	adc	r24, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:583
    a5b2:	11 24       	eor	r1, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:584
    a5b4:	91 1d       	adc	r25, r1
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:585
    a5b6:	08 95       	ret

0000a5b8 <__subsf3>:
__subsf3():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:796
    a5b8:	50 58       	subi	r21, 0x80	; 128

0000a5ba <__addsf3>:
    a5ba:	bb 27       	eor	r27, r27
    a5bc:	aa 27       	eor	r26, r26
    a5be:	0e d0       	rcall	.+28     	; 0xa5dc <__addsf3x>
    a5c0:	28 cf       	rjmp	.-432    	; 0xa412 <__fp_round>
__addsf3():
    a5c2:	19 df       	rcall	.-462    	; 0xa3f6 <__fp_pscA>
    a5c4:	30 f0       	brcs	.+12     	; 0xa5d2 <__addsf3+0x18>
    a5c6:	1e df       	rcall	.-452    	; 0xa404 <__fp_pscB>
    a5c8:	20 f0       	brcs	.+8      	; 0xa5d2 <__addsf3+0x18>
    a5ca:	31 f4       	brne	.+12     	; 0xa5d8 <__addsf3+0x1e>
    a5cc:	9f 3f       	cpi	r25, 0xFF	; 255
    a5ce:	11 f4       	brne	.+4      	; 0xa5d4 <__addsf3+0x1a>
    a5d0:	1e f4       	brtc	.+6      	; 0xa5d8 <__addsf3+0x1e>
    a5d2:	0e cf       	rjmp	.-484    	; 0xa3f0 <__fp_nan>
    a5d4:	0e f4       	brtc	.+2      	; 0xa5d8 <__addsf3+0x1e>
    a5d6:	e0 95       	com	r30
    a5d8:	e7 fb       	bst	r30, 7
    a5da:	04 cf       	rjmp	.-504    	; 0xa3e4 <__fp_inf>

0000a5dc <__addsf3x>:
__addsf3x():
    a5dc:	e9 2f       	mov	r30, r25
    a5de:	2a df       	rcall	.-428    	; 0xa434 <__fp_split3>
    a5e0:	80 f3       	brcs	.-32     	; 0xa5c2 <__addsf3+0x8>
    a5e2:	ba 17       	cp	r27, r26
    a5e4:	62 07       	cpc	r22, r18
    a5e6:	73 07       	cpc	r23, r19
    a5e8:	84 07       	cpc	r24, r20
    a5ea:	95 07       	cpc	r25, r21
    a5ec:	18 f0       	brcs	.+6      	; 0xa5f4 <__addsf3x+0x18>
    a5ee:	71 f4       	brne	.+28     	; 0xa60c <__addsf3x+0x30>
    a5f0:	9e f5       	brtc	.+102    	; 0xa658 <__addsf3x+0x7c>
    a5f2:	42 cf       	rjmp	.-380    	; 0xa478 <__fp_zero>
    a5f4:	0e f4       	brtc	.+2      	; 0xa5f8 <__addsf3x+0x1c>
    a5f6:	e0 95       	com	r30
    a5f8:	0b 2e       	mov	r0, r27
    a5fa:	ba 2f       	mov	r27, r26
    a5fc:	a0 2d       	mov	r26, r0
    a5fe:	0b 01       	movw	r0, r22
    a600:	b9 01       	movw	r22, r18
    a602:	90 01       	movw	r18, r0
    a604:	0c 01       	movw	r0, r24
    a606:	ca 01       	movw	r24, r20
    a608:	a0 01       	movw	r20, r0
    a60a:	11 24       	eor	r1, r1
    a60c:	ff 27       	eor	r31, r31
    a60e:	59 1b       	sub	r21, r25
    a610:	99 f0       	breq	.+38     	; 0xa638 <__addsf3x+0x5c>
    a612:	59 3f       	cpi	r21, 0xF9	; 249
    a614:	50 f4       	brcc	.+20     	; 0xa62a <__addsf3x+0x4e>
    a616:	50 3e       	cpi	r21, 0xE0	; 224
    a618:	68 f1       	brcs	.+90     	; 0xa674 <__addsf3x+0x98>
    a61a:	1a 16       	cp	r1, r26
    a61c:	f0 40       	sbci	r31, 0x00	; 0
    a61e:	a2 2f       	mov	r26, r18
    a620:	23 2f       	mov	r18, r19
    a622:	34 2f       	mov	r19, r20
    a624:	44 27       	eor	r20, r20
    a626:	58 5f       	subi	r21, 0xF8	; 248
    a628:	f3 cf       	rjmp	.-26     	; 0xa610 <__addsf3x+0x34>
    a62a:	46 95       	lsr	r20
    a62c:	37 95       	ror	r19
    a62e:	27 95       	ror	r18
    a630:	a7 95       	ror	r26
    a632:	f0 40       	sbci	r31, 0x00	; 0
    a634:	53 95       	inc	r21
    a636:	c9 f7       	brne	.-14     	; 0xa62a <__addsf3x+0x4e>
    a638:	7e f4       	brtc	.+30     	; 0xa658 <__addsf3x+0x7c>
    a63a:	1f 16       	cp	r1, r31
    a63c:	ba 0b       	sbc	r27, r26
    a63e:	62 0b       	sbc	r22, r18
    a640:	73 0b       	sbc	r23, r19
    a642:	84 0b       	sbc	r24, r20
    a644:	ba f0       	brmi	.+46     	; 0xa674 <__addsf3x+0x98>
    a646:	91 50       	subi	r25, 0x01	; 1
    a648:	a1 f0       	breq	.+40     	; 0xa672 <__addsf3x+0x96>
    a64a:	ff 0f       	add	r31, r31
    a64c:	bb 1f       	adc	r27, r27
    a64e:	66 1f       	adc	r22, r22
    a650:	77 1f       	adc	r23, r23
    a652:	88 1f       	adc	r24, r24
    a654:	c2 f7       	brpl	.-16     	; 0xa646 <__addsf3x+0x6a>
    a656:	0e c0       	rjmp	.+28     	; 0xa674 <__addsf3x+0x98>
    a658:	ba 0f       	add	r27, r26
    a65a:	62 1f       	adc	r22, r18
    a65c:	73 1f       	adc	r23, r19
    a65e:	84 1f       	adc	r24, r20
    a660:	48 f4       	brcc	.+18     	; 0xa674 <__addsf3x+0x98>
    a662:	87 95       	ror	r24
    a664:	77 95       	ror	r23
    a666:	67 95       	ror	r22
    a668:	b7 95       	ror	r27
    a66a:	f7 95       	ror	r31
    a66c:	9e 3f       	cpi	r25, 0xFE	; 254
    a66e:	08 f0       	brcs	.+2      	; 0xa672 <__addsf3x+0x96>
    a670:	b3 cf       	rjmp	.-154    	; 0xa5d8 <__addsf3+0x1e>
    a672:	93 95       	inc	r25
    a674:	88 0f       	add	r24, r24
    a676:	08 f0       	brcs	.+2      	; 0xa67a <__addsf3x+0x9e>
    a678:	99 27       	eor	r25, r25
    a67a:	ee 0f       	add	r30, r30
    a67c:	97 95       	ror	r25
    a67e:	87 95       	ror	r24
    a680:	08 95       	ret

0000a682 <__divsf3>:
    a682:	0c d0       	rcall	.+24     	; 0xa69c <__divsf3x>
    a684:	c6 ce       	rjmp	.-628    	; 0xa412 <__fp_round>
    a686:	be de       	rcall	.-644    	; 0xa404 <__fp_pscB>
    a688:	40 f0       	brcs	.+16     	; 0xa69a <__divsf3+0x18>
    a68a:	b5 de       	rcall	.-662    	; 0xa3f6 <__fp_pscA>
    a68c:	30 f0       	brcs	.+12     	; 0xa69a <__divsf3+0x18>
    a68e:	21 f4       	brne	.+8      	; 0xa698 <__divsf3+0x16>
    a690:	5f 3f       	cpi	r21, 0xFF	; 255
    a692:	19 f0       	breq	.+6      	; 0xa69a <__divsf3+0x18>
    a694:	a7 ce       	rjmp	.-690    	; 0xa3e4 <__fp_inf>
    a696:	51 11       	cpse	r21, r1
    a698:	f0 ce       	rjmp	.-544    	; 0xa47a <__fp_szero>
    a69a:	aa ce       	rjmp	.-684    	; 0xa3f0 <__fp_nan>

0000a69c <__divsf3x>:
    a69c:	cb de       	rcall	.-618    	; 0xa434 <__fp_split3>
    a69e:	98 f3       	brcs	.-26     	; 0xa686 <__divsf3+0x4>

0000a6a0 <__divsf3_pse>:
    a6a0:	99 23       	and	r25, r25
    a6a2:	c9 f3       	breq	.-14     	; 0xa696 <__divsf3+0x14>
    a6a4:	55 23       	and	r21, r21
    a6a6:	b1 f3       	breq	.-20     	; 0xa694 <__divsf3+0x12>
__divsf3_pse():
    a6a8:	95 1b       	sub	r25, r21
    a6aa:	55 0b       	sbc	r21, r21
    a6ac:	bb 27       	eor	r27, r27
    a6ae:	aa 27       	eor	r26, r26
    a6b0:	62 17       	cp	r22, r18
    a6b2:	73 07       	cpc	r23, r19
    a6b4:	84 07       	cpc	r24, r20
    a6b6:	38 f0       	brcs	.+14     	; 0xa6c6 <__divsf3_pse+0x26>
    a6b8:	9f 5f       	subi	r25, 0xFF	; 255
    a6ba:	5f 4f       	sbci	r21, 0xFF	; 255
    a6bc:	22 0f       	add	r18, r18
    a6be:	33 1f       	adc	r19, r19
    a6c0:	44 1f       	adc	r20, r20
    a6c2:	aa 1f       	adc	r26, r26
    a6c4:	a9 f3       	breq	.-22     	; 0xa6b0 <__divsf3_pse+0x10>
    a6c6:	33 d0       	rcall	.+102    	; 0xa72e <__divsf3_pse+0x8e>
    a6c8:	0e 2e       	mov	r0, r30
    a6ca:	3a f0       	brmi	.+14     	; 0xa6da <__divsf3_pse+0x3a>
    a6cc:	e0 e8       	ldi	r30, 0x80	; 128
    a6ce:	30 d0       	rcall	.+96     	; 0xa730 <__divsf3_pse+0x90>
    a6d0:	91 50       	subi	r25, 0x01	; 1
    a6d2:	50 40       	sbci	r21, 0x00	; 0
    a6d4:	e6 95       	lsr	r30
    a6d6:	00 1c       	adc	r0, r0
    a6d8:	ca f7       	brpl	.-14     	; 0xa6cc <__divsf3_pse+0x2c>
    a6da:	29 d0       	rcall	.+82     	; 0xa72e <__divsf3_pse+0x8e>
    a6dc:	fe 2f       	mov	r31, r30
    a6de:	27 d0       	rcall	.+78     	; 0xa72e <__divsf3_pse+0x8e>
    a6e0:	66 0f       	add	r22, r22
    a6e2:	77 1f       	adc	r23, r23
    a6e4:	88 1f       	adc	r24, r24
    a6e6:	bb 1f       	adc	r27, r27
    a6e8:	26 17       	cp	r18, r22
    a6ea:	37 07       	cpc	r19, r23
    a6ec:	48 07       	cpc	r20, r24
    a6ee:	ab 07       	cpc	r26, r27
    a6f0:	b0 e8       	ldi	r27, 0x80	; 128
    a6f2:	09 f0       	breq	.+2      	; 0xa6f6 <__divsf3_pse+0x56>
    a6f4:	bb 0b       	sbc	r27, r27
    a6f6:	80 2d       	mov	r24, r0
    a6f8:	bf 01       	movw	r22, r30
    a6fa:	ff 27       	eor	r31, r31
    a6fc:	93 58       	subi	r25, 0x83	; 131
    a6fe:	5f 4f       	sbci	r21, 0xFF	; 255
    a700:	2a f0       	brmi	.+10     	; 0xa70c <__divsf3_pse+0x6c>
    a702:	9e 3f       	cpi	r25, 0xFE	; 254
    a704:	51 05       	cpc	r21, r1
    a706:	68 f0       	brcs	.+26     	; 0xa722 <__divsf3_pse+0x82>
    a708:	6d ce       	rjmp	.-806    	; 0xa3e4 <__fp_inf>
    a70a:	b7 ce       	rjmp	.-658    	; 0xa47a <__fp_szero>
    a70c:	5f 3f       	cpi	r21, 0xFF	; 255
    a70e:	ec f3       	brlt	.-6      	; 0xa70a <__divsf3_pse+0x6a>
    a710:	98 3e       	cpi	r25, 0xE8	; 232
    a712:	dc f3       	brlt	.-10     	; 0xa70a <__divsf3_pse+0x6a>
    a714:	86 95       	lsr	r24
    a716:	77 95       	ror	r23
    a718:	67 95       	ror	r22
    a71a:	b7 95       	ror	r27
    a71c:	f7 95       	ror	r31
    a71e:	9f 5f       	subi	r25, 0xFF	; 255
    a720:	c9 f7       	brne	.-14     	; 0xa714 <__divsf3_pse+0x74>
    a722:	88 0f       	add	r24, r24
    a724:	91 1d       	adc	r25, r1
    a726:	96 95       	lsr	r25
    a728:	87 95       	ror	r24
    a72a:	97 f9       	bld	r25, 7
    a72c:	08 95       	ret
    a72e:	e1 e0       	ldi	r30, 0x01	; 1
    a730:	66 0f       	add	r22, r22
    a732:	77 1f       	adc	r23, r23
    a734:	88 1f       	adc	r24, r24
    a736:	bb 1f       	adc	r27, r27
    a738:	62 17       	cp	r22, r18
    a73a:	73 07       	cpc	r23, r19
    a73c:	84 07       	cpc	r24, r20
    a73e:	ba 07       	cpc	r27, r26
    a740:	20 f0       	brcs	.+8      	; 0xa74a <__divsf3_pse+0xaa>
    a742:	62 1b       	sub	r22, r18
    a744:	73 0b       	sbc	r23, r19
    a746:	84 0b       	sbc	r24, r20
    a748:	ba 0b       	sbc	r27, r26
    a74a:	ee 1f       	adc	r30, r30
    a74c:	88 f7       	brcc	.-30     	; 0xa730 <__divsf3_pse+0x90>
    a74e:	e0 95       	com	r30
    a750:	08 95       	ret

0000a752 <__fixsfsi>:
__fixsfsi():
    a752:	04 d0       	rcall	.+8      	; 0xa75c <__fixunssfsi>
    a754:	68 94       	set
    a756:	b1 11       	cpse	r27, r1
    a758:	90 ce       	rjmp	.-736    	; 0xa47a <__fp_szero>
    a75a:	08 95       	ret

0000a75c <__fixunssfsi>:
__fixunssfsi():
    a75c:	73 de       	rcall	.-794    	; 0xa444 <__fp_splitA>
    a75e:	88 f0       	brcs	.+34     	; 0xa782 <__fixunssfsi+0x26>
    a760:	9f 57       	subi	r25, 0x7F	; 127
    a762:	90 f0       	brcs	.+36     	; 0xa788 <__fixunssfsi+0x2c>
    a764:	b9 2f       	mov	r27, r25
    a766:	99 27       	eor	r25, r25
    a768:	b7 51       	subi	r27, 0x17	; 23
    a76a:	a0 f0       	brcs	.+40     	; 0xa794 <__fixunssfsi+0x38>
    a76c:	d1 f0       	breq	.+52     	; 0xa7a2 <__fixunssfsi+0x46>
    a76e:	66 0f       	add	r22, r22
    a770:	77 1f       	adc	r23, r23
    a772:	88 1f       	adc	r24, r24
    a774:	99 1f       	adc	r25, r25
    a776:	1a f0       	brmi	.+6      	; 0xa77e <__fixunssfsi+0x22>
    a778:	ba 95       	dec	r27
    a77a:	c9 f7       	brne	.-14     	; 0xa76e <__fixunssfsi+0x12>
    a77c:	12 c0       	rjmp	.+36     	; 0xa7a2 <__fixunssfsi+0x46>
    a77e:	b1 30       	cpi	r27, 0x01	; 1
    a780:	81 f0       	breq	.+32     	; 0xa7a2 <__fixunssfsi+0x46>
    a782:	7a de       	rcall	.-780    	; 0xa478 <__fp_zero>
    a784:	b1 e0       	ldi	r27, 0x01	; 1
    a786:	08 95       	ret
    a788:	77 ce       	rjmp	.-786    	; 0xa478 <__fp_zero>
    a78a:	67 2f       	mov	r22, r23
    a78c:	78 2f       	mov	r23, r24
    a78e:	88 27       	eor	r24, r24
    a790:	b8 5f       	subi	r27, 0xF8	; 248
    a792:	39 f0       	breq	.+14     	; 0xa7a2 <__fixunssfsi+0x46>
    a794:	b9 3f       	cpi	r27, 0xF9	; 249
    a796:	cc f3       	brlt	.-14     	; 0xa78a <__fixunssfsi+0x2e>
    a798:	86 95       	lsr	r24
    a79a:	77 95       	ror	r23
    a79c:	67 95       	ror	r22
    a79e:	b3 95       	inc	r27
    a7a0:	d9 f7       	brne	.-10     	; 0xa798 <__fixunssfsi+0x3c>
    a7a2:	3e f4       	brtc	.+14     	; 0xa7b2 <__fixunssfsi+0x56>
    a7a4:	90 95       	com	r25
    a7a6:	80 95       	com	r24
    a7a8:	70 95       	com	r23
    a7aa:	61 95       	neg	r22
    a7ac:	7f 4f       	sbci	r23, 0xFF	; 255
    a7ae:	8f 4f       	sbci	r24, 0xFF	; 255
    a7b0:	9f 4f       	sbci	r25, 0xFF	; 255
    a7b2:	08 95       	ret

0000a7b4 <__gesf2>:
__gesf2():
    a7b4:	8d dd       	rcall	.-1254   	; 0xa2d0 <__fp_cmp>
    a7b6:	08 f4       	brcc	.+2      	; 0xa7ba <__gesf2+0x6>
    a7b8:	8f ef       	ldi	r24, 0xFF	; 255
    a7ba:	08 95       	ret

0000a7bc <log10>:
log10():
    a7bc:	0a d0       	rcall	.+20     	; 0xa7d2 <log>
    a7be:	29 ed       	ldi	r18, 0xD9	; 217
    a7c0:	3b e5       	ldi	r19, 0x5B	; 91
    a7c2:	4e ed       	ldi	r20, 0xDE	; 222
    a7c4:	5e e3       	ldi	r21, 0x3E	; 62
    a7c6:	a8 cd       	rjmp	.-1200   	; 0xa318 <__mulsf3>
    a7c8:	0e f0       	brts	.+2      	; 0xa7cc <log10+0x10>
    a7ca:	65 c0       	rjmp	.+202    	; 0xa896 <__fp_mpack>
    a7cc:	11 ce       	rjmp	.-990    	; 0xa3f0 <__fp_nan>
    a7ce:	68 94       	set
    a7d0:	09 ce       	rjmp	.-1006   	; 0xa3e4 <__fp_inf>

0000a7d2 <log>:
log():
    a7d2:	38 de       	rcall	.-912    	; 0xa444 <__fp_splitA>
    a7d4:	c8 f3       	brcs	.-14     	; 0xa7c8 <log10+0xc>
    a7d6:	99 23       	and	r25, r25
    a7d8:	d1 f3       	breq	.-12     	; 0xa7ce <log10+0x12>
    a7da:	c6 f3       	brts	.-16     	; 0xa7cc <log10+0x10>
    a7dc:	df 93       	push	r29
    a7de:	cf 93       	push	r28
    a7e0:	1f 93       	push	r17
    a7e2:	0f 93       	push	r16
    a7e4:	ff 92       	push	r15
    a7e6:	c9 2f       	mov	r28, r25
    a7e8:	dd 27       	eor	r29, r29
    a7ea:	88 23       	and	r24, r24
    a7ec:	2a f0       	brmi	.+10     	; 0xa7f8 <log+0x26>
    a7ee:	21 97       	sbiw	r28, 0x01	; 1
    a7f0:	66 0f       	add	r22, r22
    a7f2:	77 1f       	adc	r23, r23
    a7f4:	88 1f       	adc	r24, r24
    a7f6:	da f7       	brpl	.-10     	; 0xa7ee <log+0x1c>
    a7f8:	20 e0       	ldi	r18, 0x00	; 0
    a7fa:	30 e0       	ldi	r19, 0x00	; 0
    a7fc:	40 e8       	ldi	r20, 0x80	; 128
    a7fe:	5f eb       	ldi	r21, 0xBF	; 191
    a800:	9f e3       	ldi	r25, 0x3F	; 63
    a802:	88 39       	cpi	r24, 0x98	; 152
    a804:	20 f0       	brcs	.+8      	; 0xa80e <log+0x3c>
    a806:	80 3e       	cpi	r24, 0xE0	; 224
    a808:	30 f0       	brcs	.+12     	; 0xa816 <log+0x44>
    a80a:	21 96       	adiw	r28, 0x01	; 1
    a80c:	8f 77       	andi	r24, 0x7F	; 127
    a80e:	d5 de       	rcall	.-598    	; 0xa5ba <__addsf3>
    a810:	e4 ef       	ldi	r30, 0xF4	; 244
    a812:	f0 e0       	ldi	r31, 0x00	; 0
    a814:	03 c0       	rjmp	.+6      	; 0xa81c <log+0x4a>
    a816:	d1 de       	rcall	.-606    	; 0xa5ba <__addsf3>
    a818:	e1 e2       	ldi	r30, 0x21	; 33
    a81a:	f1 e0       	ldi	r31, 0x01	; 1
    a81c:	4a d0       	rcall	.+148    	; 0xa8b2 <__fp_powser>
    a81e:	8b 01       	movw	r16, r22
    a820:	be 01       	movw	r22, r28
    a822:	ec 01       	movw	r28, r24
    a824:	fb 2e       	mov	r15, r27
    a826:	6f 57       	subi	r22, 0x7F	; 127
    a828:	71 09       	sbc	r23, r1
    a82a:	75 95       	asr	r23
    a82c:	77 1f       	adc	r23, r23
    a82e:	88 0b       	sbc	r24, r24
    a830:	99 0b       	sbc	r25, r25
    a832:	13 dd       	rcall	.-1498   	; 0xa25a <__floatsisf>
    a834:	28 e1       	ldi	r18, 0x18	; 24
    a836:	32 e7       	ldi	r19, 0x72	; 114
    a838:	41 e3       	ldi	r20, 0x31	; 49
    a83a:	5f e3       	ldi	r21, 0x3F	; 63
    a83c:	79 dd       	rcall	.-1294   	; 0xa330 <__mulsf3x>
    a83e:	af 2d       	mov	r26, r15
    a840:	98 01       	movw	r18, r16
    a842:	ae 01       	movw	r20, r28
    a844:	ff 90       	pop	r15
    a846:	0f 91       	pop	r16
    a848:	1f 91       	pop	r17
    a84a:	cf 91       	pop	r28
    a84c:	df 91       	pop	r29
    a84e:	c6 de       	rcall	.-628    	; 0xa5dc <__addsf3x>
    a850:	e0 cd       	rjmp	.-1088   	; 0xa412 <__fp_round>

0000a852 <trunc>:
    a852:	54 d0       	rcall	.+168    	; 0xa8fc <__fp_trunc>
    a854:	20 f0       	brcs	.+8      	; 0xa85e <trunc+0xc>
    a856:	9f 37       	cpi	r25, 0x7F	; 127
    a858:	08 f4       	brcc	.+2      	; 0xa85c <trunc+0xa>
    a85a:	0f ce       	rjmp	.-994    	; 0xa47a <__fp_szero>
    a85c:	01 c0       	rjmp	.+2      	; 0xa860 <__fp_mintl>
    a85e:	1b c0       	rjmp	.+54     	; 0xa896 <__fp_mpack>

0000a860 <__fp_mintl>:
    a860:	88 23       	and	r24, r24
    a862:	71 f4       	brne	.+28     	; 0xa880 <__fp_mintl+0x20>
    a864:	77 23       	and	r23, r23
    a866:	21 f0       	breq	.+8      	; 0xa870 <__fp_mintl+0x10>
    a868:	98 50       	subi	r25, 0x08	; 8
    a86a:	87 2b       	or	r24, r23
    a86c:	76 2f       	mov	r23, r22
    a86e:	07 c0       	rjmp	.+14     	; 0xa87e <__fp_mintl+0x1e>
    a870:	66 23       	and	r22, r22
__fp_mintl():
    a872:	11 f4       	brne	.+4      	; 0xa878 <__fp_mintl+0x18>
    a874:	99 27       	eor	r25, r25
    a876:	0d c0       	rjmp	.+26     	; 0xa892 <__fp_mintl+0x32>
    a878:	90 51       	subi	r25, 0x10	; 16
    a87a:	86 2b       	or	r24, r22
    a87c:	70 e0       	ldi	r23, 0x00	; 0
    a87e:	60 e0       	ldi	r22, 0x00	; 0
    a880:	2a f0       	brmi	.+10     	; 0xa88c <__fp_mintl+0x2c>
    a882:	9a 95       	dec	r25
    a884:	66 0f       	add	r22, r22
    a886:	77 1f       	adc	r23, r23
    a888:	88 1f       	adc	r24, r24
    a88a:	da f7       	brpl	.-10     	; 0xa882 <__fp_mintl+0x22>
    a88c:	88 0f       	add	r24, r24
    a88e:	96 95       	lsr	r25
    a890:	87 95       	ror	r24
    a892:	97 f9       	bld	r25, 7
    a894:	08 95       	ret

0000a896 <__fp_mpack>:
__fp_mpack():
    a896:	9f 3f       	cpi	r25, 0xFF	; 255
    a898:	31 f0       	breq	.+12     	; 0xa8a6 <__fp_mpack_finite+0xc>

0000a89a <__fp_mpack_finite>:
    a89a:	91 50       	subi	r25, 0x01	; 1
    a89c:	20 f4       	brcc	.+8      	; 0xa8a6 <__fp_mpack_finite+0xc>
    a89e:	87 95       	ror	r24
    a8a0:	77 95       	ror	r23
    a8a2:	67 95       	ror	r22
    a8a4:	b7 95       	ror	r27
    a8a6:	88 0f       	add	r24, r24
    a8a8:	91 1d       	adc	r25, r1
    a8aa:	96 95       	lsr	r25
    a8ac:	87 95       	ror	r24
    a8ae:	97 f9       	bld	r25, 7
    a8b0:	08 95       	ret

0000a8b2 <__fp_powser>:
__fp_powser():
    a8b2:	df 93       	push	r29
    a8b4:	cf 93       	push	r28
    a8b6:	1f 93       	push	r17
    a8b8:	0f 93       	push	r16
    a8ba:	ff 92       	push	r15
    a8bc:	ef 92       	push	r14
    a8be:	df 92       	push	r13
    a8c0:	7b 01       	movw	r14, r22
    a8c2:	8c 01       	movw	r16, r24
    a8c4:	68 94       	set
    a8c6:	05 c0       	rjmp	.+10     	; 0xa8d2 <__fp_powser+0x20>
    a8c8:	da 2e       	mov	r13, r26
    a8ca:	ef 01       	movw	r28, r30
    a8cc:	31 dd       	rcall	.-1438   	; 0xa330 <__mulsf3x>
    a8ce:	fe 01       	movw	r30, r28
    a8d0:	e8 94       	clt
    a8d2:	a5 91       	lpm	r26, Z+
    a8d4:	25 91       	lpm	r18, Z+
    a8d6:	35 91       	lpm	r19, Z+
    a8d8:	45 91       	lpm	r20, Z+
    a8da:	55 91       	lpm	r21, Z+
    a8dc:	ae f3       	brts	.-22     	; 0xa8c8 <__fp_powser+0x16>
    a8de:	ef 01       	movw	r28, r30
    a8e0:	7d de       	rcall	.-774    	; 0xa5dc <__addsf3x>
    a8e2:	fe 01       	movw	r30, r28
    a8e4:	97 01       	movw	r18, r14
    a8e6:	a8 01       	movw	r20, r16
    a8e8:	da 94       	dec	r13
    a8ea:	79 f7       	brne	.-34     	; 0xa8ca <__fp_powser+0x18>
    a8ec:	df 90       	pop	r13
    a8ee:	ef 90       	pop	r14
    a8f0:	ff 90       	pop	r15
    a8f2:	0f 91       	pop	r16
    a8f4:	1f 91       	pop	r17
    a8f6:	cf 91       	pop	r28
    a8f8:	df 91       	pop	r29
    a8fa:	08 95       	ret

0000a8fc <__fp_trunc>:
__fp_trunc():
    a8fc:	a3 dd       	rcall	.-1210   	; 0xa444 <__fp_splitA>
    a8fe:	a0 f0       	brcs	.+40     	; 0xa928 <__fp_trunc+0x2c>
    a900:	be e7       	ldi	r27, 0x7E	; 126
    a902:	b9 17       	cp	r27, r25
    a904:	88 f4       	brcc	.+34     	; 0xa928 <__fp_trunc+0x2c>
    a906:	bb 27       	eor	r27, r27
    a908:	9f 38       	cpi	r25, 0x8F	; 143
    a90a:	60 f4       	brcc	.+24     	; 0xa924 <__fp_trunc+0x28>
    a90c:	16 16       	cp	r1, r22
    a90e:	b1 1d       	adc	r27, r1
    a910:	67 2f       	mov	r22, r23
    a912:	78 2f       	mov	r23, r24
    a914:	88 27       	eor	r24, r24
    a916:	98 5f       	subi	r25, 0xF8	; 248
    a918:	f7 cf       	rjmp	.-18     	; 0xa908 <__fp_trunc+0xc>
    a91a:	86 95       	lsr	r24
    a91c:	77 95       	ror	r23
    a91e:	67 95       	ror	r22
    a920:	b1 1d       	adc	r27, r1
    a922:	93 95       	inc	r25
    a924:	96 39       	cpi	r25, 0x96	; 150
    a926:	c8 f3       	brcs	.-14     	; 0xa91a <__fp_trunc+0x1e>
    a928:	08 95       	ret

0000a92a <__tablejump2__>:
__tablejump2__():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2296
    a92a:	ee 0f       	add	r30, r30
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2297
    a92c:	ff 1f       	adc	r31, r31
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2304
    a92e:	00 24       	eor	r0, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2305
    a930:	00 1c       	adc	r0, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2306
    a932:	0b be       	out	0x3b, r0	; 59
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2312
    a934:	07 90       	elpm	r0, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2313
    a936:	f6 91       	elpm	r31, Z
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2314
    a938:	e0 2d       	mov	r30, r0
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2319
    a93a:	09 94       	ijmp

0000a93c <calloc>:
calloc():
c:\Users\bobm\Documents\Arduino\libraries\AVR-IoT-Cellular\src/mqtt_client.cpp:796
    a93c:	0f 93       	push	r16
    a93e:	1f 93       	push	r17
    a940:	cf 93       	push	r28
    a942:	df 93       	push	r29
    a944:	86 9f       	mul	r24, r22
    a946:	80 01       	movw	r16, r0
    a948:	87 9f       	mul	r24, r23
    a94a:	10 0d       	add	r17, r0
    a94c:	96 9f       	mul	r25, r22
    a94e:	10 0d       	add	r17, r0
    a950:	11 24       	eor	r1, r1
    a952:	c8 01       	movw	r24, r16
    a954:	0d d0       	rcall	.+26     	; 0xa970 <malloc>
    a956:	ec 01       	movw	r28, r24
    a958:	00 97       	sbiw	r24, 0x00	; 0
    a95a:	21 f0       	breq	.+8      	; 0xa964 <calloc+0x28>
    a95c:	a8 01       	movw	r20, r16
    a95e:	70 e0       	ldi	r23, 0x00	; 0
    a960:	60 e0       	ldi	r22, 0x00	; 0
    a962:	25 d2       	rcall	.+1098   	; 0xadae <memset>
    a964:	ce 01       	movw	r24, r28
    a966:	df 91       	pop	r29
    a968:	cf 91       	pop	r28
    a96a:	1f 91       	pop	r17
    a96c:	0f 91       	pop	r16
    a96e:	08 95       	ret

0000a970 <malloc>:
malloc():
    a970:	0f 93       	push	r16
    a972:	1f 93       	push	r17
    a974:	cf 93       	push	r28
    a976:	df 93       	push	r29
    a978:	82 30       	cpi	r24, 0x02	; 2
    a97a:	91 05       	cpc	r25, r1
    a97c:	10 f4       	brcc	.+4      	; 0xa982 <malloc+0x12>
    a97e:	82 e0       	ldi	r24, 0x02	; 2
    a980:	90 e0       	ldi	r25, 0x00	; 0
    a982:	e0 91 9d 70 	lds	r30, 0x709D	; 0x80709d <__flp>
    a986:	f0 91 9e 70 	lds	r31, 0x709E	; 0x80709e <__flp+0x1>
    a98a:	30 e0       	ldi	r19, 0x00	; 0
    a98c:	20 e0       	ldi	r18, 0x00	; 0
    a98e:	b0 e0       	ldi	r27, 0x00	; 0
    a990:	a0 e0       	ldi	r26, 0x00	; 0
    a992:	30 97       	sbiw	r30, 0x00	; 0
    a994:	99 f4       	brne	.+38     	; 0xa9bc <malloc+0x4c>
    a996:	21 15       	cp	r18, r1
    a998:	31 05       	cpc	r19, r1
    a99a:	09 f4       	brne	.+2      	; 0xa99e <malloc+0x2e>
    a99c:	4a c0       	rjmp	.+148    	; 0xaa32 <malloc+0xc2>
    a99e:	28 1b       	sub	r18, r24
    a9a0:	39 0b       	sbc	r19, r25
    a9a2:	24 30       	cpi	r18, 0x04	; 4
    a9a4:	31 05       	cpc	r19, r1
    a9a6:	d8 f5       	brcc	.+118    	; 0xaa1e <malloc+0xae>
    a9a8:	8a 81       	ldd	r24, Y+2	; 0x02
    a9aa:	9b 81       	ldd	r25, Y+3	; 0x03
    a9ac:	61 15       	cp	r22, r1
    a9ae:	71 05       	cpc	r23, r1
    a9b0:	89 f1       	breq	.+98     	; 0xaa14 <malloc+0xa4>
    a9b2:	fb 01       	movw	r30, r22
    a9b4:	82 83       	std	Z+2, r24	; 0x02
    a9b6:	93 83       	std	Z+3, r25	; 0x03
    a9b8:	fe 01       	movw	r30, r28
    a9ba:	11 c0       	rjmp	.+34     	; 0xa9de <malloc+0x6e>
    a9bc:	40 81       	ld	r20, Z
    a9be:	51 81       	ldd	r21, Z+1	; 0x01
    a9c0:	02 81       	ldd	r16, Z+2	; 0x02
    a9c2:	13 81       	ldd	r17, Z+3	; 0x03
    a9c4:	48 17       	cp	r20, r24
    a9c6:	59 07       	cpc	r21, r25
    a9c8:	e0 f0       	brcs	.+56     	; 0xaa02 <malloc+0x92>
    a9ca:	48 17       	cp	r20, r24
    a9cc:	59 07       	cpc	r21, r25
    a9ce:	99 f4       	brne	.+38     	; 0xa9f6 <malloc+0x86>
    a9d0:	10 97       	sbiw	r26, 0x00	; 0
    a9d2:	61 f0       	breq	.+24     	; 0xa9ec <malloc+0x7c>
    a9d4:	12 96       	adiw	r26, 0x02	; 2
    a9d6:	0c 93       	st	X, r16
    a9d8:	12 97       	sbiw	r26, 0x02	; 2
    a9da:	13 96       	adiw	r26, 0x03	; 3
    a9dc:	1c 93       	st	X, r17
    a9de:	32 96       	adiw	r30, 0x02	; 2
    a9e0:	cf 01       	movw	r24, r30
    a9e2:	df 91       	pop	r29
    a9e4:	cf 91       	pop	r28
    a9e6:	1f 91       	pop	r17
    a9e8:	0f 91       	pop	r16
    a9ea:	08 95       	ret
    a9ec:	00 93 9d 70 	sts	0x709D, r16	; 0x80709d <__flp>
    a9f0:	10 93 9e 70 	sts	0x709E, r17	; 0x80709e <__flp+0x1>
    a9f4:	f4 cf       	rjmp	.-24     	; 0xa9de <malloc+0x6e>
    a9f6:	21 15       	cp	r18, r1
    a9f8:	31 05       	cpc	r19, r1
    a9fa:	51 f0       	breq	.+20     	; 0xaa10 <malloc+0xa0>
    a9fc:	42 17       	cp	r20, r18
    a9fe:	53 07       	cpc	r21, r19
    aa00:	38 f0       	brcs	.+14     	; 0xaa10 <malloc+0xa0>
    aa02:	a9 01       	movw	r20, r18
    aa04:	db 01       	movw	r26, r22
    aa06:	9a 01       	movw	r18, r20
    aa08:	bd 01       	movw	r22, r26
    aa0a:	df 01       	movw	r26, r30
    aa0c:	f8 01       	movw	r30, r16
    aa0e:	c1 cf       	rjmp	.-126    	; 0xa992 <malloc+0x22>
    aa10:	ef 01       	movw	r28, r30
    aa12:	f9 cf       	rjmp	.-14     	; 0xaa06 <malloc+0x96>
    aa14:	80 93 9d 70 	sts	0x709D, r24	; 0x80709d <__flp>
    aa18:	90 93 9e 70 	sts	0x709E, r25	; 0x80709e <__flp+0x1>
    aa1c:	cd cf       	rjmp	.-102    	; 0xa9b8 <malloc+0x48>
    aa1e:	fe 01       	movw	r30, r28
    aa20:	e2 0f       	add	r30, r18
    aa22:	f3 1f       	adc	r31, r19
    aa24:	81 93       	st	Z+, r24
    aa26:	91 93       	st	Z+, r25
    aa28:	22 50       	subi	r18, 0x02	; 2
    aa2a:	31 09       	sbc	r19, r1
    aa2c:	28 83       	st	Y, r18
    aa2e:	39 83       	std	Y+1, r19	; 0x01
    aa30:	d7 cf       	rjmp	.-82     	; 0xa9e0 <malloc+0x70>
    aa32:	20 91 9b 70 	lds	r18, 0x709B	; 0x80709b <__brkval>
    aa36:	30 91 9c 70 	lds	r19, 0x709C	; 0x80709c <__brkval+0x1>
    aa3a:	23 2b       	or	r18, r19
    aa3c:	41 f4       	brne	.+16     	; 0xaa4e <malloc+0xde>
    aa3e:	20 91 0e 42 	lds	r18, 0x420E	; 0x80420e <__malloc_heap_start>
    aa42:	30 91 0f 42 	lds	r19, 0x420F	; 0x80420f <__malloc_heap_start+0x1>
    aa46:	20 93 9b 70 	sts	0x709B, r18	; 0x80709b <__brkval>
    aa4a:	30 93 9c 70 	sts	0x709C, r19	; 0x80709c <__brkval+0x1>
    aa4e:	20 91 0c 42 	lds	r18, 0x420C	; 0x80420c <__malloc_heap_end>
    aa52:	30 91 0d 42 	lds	r19, 0x420D	; 0x80420d <__malloc_heap_end+0x1>
    aa56:	21 15       	cp	r18, r1
    aa58:	31 05       	cpc	r19, r1
    aa5a:	41 f4       	brne	.+16     	; 0xaa6c <malloc+0xfc>
    aa5c:	2d b7       	in	r18, 0x3d	; 61
    aa5e:	3e b7       	in	r19, 0x3e	; 62
    aa60:	40 91 10 42 	lds	r20, 0x4210	; 0x804210 <__malloc_margin>
    aa64:	50 91 11 42 	lds	r21, 0x4211	; 0x804211 <__malloc_margin+0x1>
    aa68:	24 1b       	sub	r18, r20
    aa6a:	35 0b       	sbc	r19, r21
    aa6c:	e0 91 9b 70 	lds	r30, 0x709B	; 0x80709b <__brkval>
    aa70:	f0 91 9c 70 	lds	r31, 0x709C	; 0x80709c <__brkval+0x1>
    aa74:	e2 17       	cp	r30, r18
    aa76:	f3 07       	cpc	r31, r19
    aa78:	a0 f4       	brcc	.+40     	; 0xaaa2 <malloc+0x132>
    aa7a:	2e 1b       	sub	r18, r30
    aa7c:	3f 0b       	sbc	r19, r31
    aa7e:	28 17       	cp	r18, r24
    aa80:	39 07       	cpc	r19, r25
    aa82:	78 f0       	brcs	.+30     	; 0xaaa2 <malloc+0x132>
    aa84:	ac 01       	movw	r20, r24
    aa86:	4e 5f       	subi	r20, 0xFE	; 254
    aa88:	5f 4f       	sbci	r21, 0xFF	; 255
    aa8a:	24 17       	cp	r18, r20
    aa8c:	35 07       	cpc	r19, r21
    aa8e:	48 f0       	brcs	.+18     	; 0xaaa2 <malloc+0x132>
    aa90:	4e 0f       	add	r20, r30
    aa92:	5f 1f       	adc	r21, r31
    aa94:	40 93 9b 70 	sts	0x709B, r20	; 0x80709b <__brkval>
    aa98:	50 93 9c 70 	sts	0x709C, r21	; 0x80709c <__brkval+0x1>
    aa9c:	81 93       	st	Z+, r24
    aa9e:	91 93       	st	Z+, r25
    aaa0:	9f cf       	rjmp	.-194    	; 0xa9e0 <malloc+0x70>
    aaa2:	f0 e0       	ldi	r31, 0x00	; 0
    aaa4:	e0 e0       	ldi	r30, 0x00	; 0
    aaa6:	9c cf       	rjmp	.-200    	; 0xa9e0 <malloc+0x70>

0000aaa8 <free>:
free():
    aaa8:	cf 93       	push	r28
    aaaa:	df 93       	push	r29
    aaac:	00 97       	sbiw	r24, 0x00	; 0
    aaae:	e9 f0       	breq	.+58     	; 0xaaea <free+0x42>
    aab0:	fc 01       	movw	r30, r24
    aab2:	32 97       	sbiw	r30, 0x02	; 2
    aab4:	12 82       	std	Z+2, r1	; 0x02
    aab6:	13 82       	std	Z+3, r1	; 0x03
    aab8:	a0 91 9d 70 	lds	r26, 0x709D	; 0x80709d <__flp>
    aabc:	b0 91 9e 70 	lds	r27, 0x709E	; 0x80709e <__flp+0x1>
    aac0:	ed 01       	movw	r28, r26
    aac2:	30 e0       	ldi	r19, 0x00	; 0
    aac4:	20 e0       	ldi	r18, 0x00	; 0
    aac6:	10 97       	sbiw	r26, 0x00	; 0
    aac8:	a1 f4       	brne	.+40     	; 0xaaf2 <free+0x4a>
    aaca:	20 81       	ld	r18, Z
    aacc:	31 81       	ldd	r19, Z+1	; 0x01
    aace:	82 0f       	add	r24, r18
    aad0:	93 1f       	adc	r25, r19
    aad2:	20 91 9b 70 	lds	r18, 0x709B	; 0x80709b <__brkval>
    aad6:	30 91 9c 70 	lds	r19, 0x709C	; 0x80709c <__brkval+0x1>
    aada:	28 17       	cp	r18, r24
    aadc:	39 07       	cpc	r19, r25
    aade:	09 f0       	breq	.+2      	; 0xaae2 <free+0x3a>
    aae0:	61 c0       	rjmp	.+194    	; 0xaba4 <free+0xfc>
    aae2:	e0 93 9b 70 	sts	0x709B, r30	; 0x80709b <__brkval>
    aae6:	f0 93 9c 70 	sts	0x709C, r31	; 0x80709c <__brkval+0x1>
    aaea:	df 91       	pop	r29
    aaec:	cf 91       	pop	r28
    aaee:	08 95       	ret
    aaf0:	ea 01       	movw	r28, r20
    aaf2:	ce 17       	cp	r28, r30
    aaf4:	df 07       	cpc	r29, r31
    aaf6:	e8 f5       	brcc	.+122    	; 0xab72 <free+0xca>
    aaf8:	4a 81       	ldd	r20, Y+2	; 0x02
    aafa:	5b 81       	ldd	r21, Y+3	; 0x03
    aafc:	9e 01       	movw	r18, r28
    aafe:	41 15       	cp	r20, r1
    ab00:	51 05       	cpc	r21, r1
    ab02:	b1 f7       	brne	.-20     	; 0xaaf0 <free+0x48>
    ab04:	e9 01       	movw	r28, r18
    ab06:	ea 83       	std	Y+2, r30	; 0x02
    ab08:	fb 83       	std	Y+3, r31	; 0x03
    ab0a:	49 91       	ld	r20, Y+
    ab0c:	59 91       	ld	r21, Y+
    ab0e:	c4 0f       	add	r28, r20
    ab10:	d5 1f       	adc	r29, r21
    ab12:	ec 17       	cp	r30, r28
    ab14:	fd 07       	cpc	r31, r29
    ab16:	61 f4       	brne	.+24     	; 0xab30 <free+0x88>
    ab18:	80 81       	ld	r24, Z
    ab1a:	91 81       	ldd	r25, Z+1	; 0x01
    ab1c:	02 96       	adiw	r24, 0x02	; 2
    ab1e:	84 0f       	add	r24, r20
    ab20:	95 1f       	adc	r25, r21
    ab22:	e9 01       	movw	r28, r18
    ab24:	88 83       	st	Y, r24
    ab26:	99 83       	std	Y+1, r25	; 0x01
    ab28:	82 81       	ldd	r24, Z+2	; 0x02
    ab2a:	93 81       	ldd	r25, Z+3	; 0x03
    ab2c:	8a 83       	std	Y+2, r24	; 0x02
    ab2e:	9b 83       	std	Y+3, r25	; 0x03
    ab30:	f0 e0       	ldi	r31, 0x00	; 0
    ab32:	e0 e0       	ldi	r30, 0x00	; 0
    ab34:	12 96       	adiw	r26, 0x02	; 2
    ab36:	8d 91       	ld	r24, X+
    ab38:	9c 91       	ld	r25, X
    ab3a:	13 97       	sbiw	r26, 0x03	; 3
    ab3c:	00 97       	sbiw	r24, 0x00	; 0
    ab3e:	b9 f5       	brne	.+110    	; 0xabae <free+0x106>
    ab40:	2d 91       	ld	r18, X+
    ab42:	3c 91       	ld	r19, X
    ab44:	11 97       	sbiw	r26, 0x01	; 1
    ab46:	cd 01       	movw	r24, r26
    ab48:	02 96       	adiw	r24, 0x02	; 2
    ab4a:	82 0f       	add	r24, r18
    ab4c:	93 1f       	adc	r25, r19
    ab4e:	20 91 9b 70 	lds	r18, 0x709B	; 0x80709b <__brkval>
    ab52:	30 91 9c 70 	lds	r19, 0x709C	; 0x80709c <__brkval+0x1>
    ab56:	28 17       	cp	r18, r24
    ab58:	39 07       	cpc	r19, r25
    ab5a:	39 f6       	brne	.-114    	; 0xaaea <free+0x42>
    ab5c:	30 97       	sbiw	r30, 0x00	; 0
    ab5e:	51 f5       	brne	.+84     	; 0xabb4 <free+0x10c>
    ab60:	10 92 9d 70 	sts	0x709D, r1	; 0x80709d <__flp>
    ab64:	10 92 9e 70 	sts	0x709E, r1	; 0x80709e <__flp+0x1>
    ab68:	a0 93 9b 70 	sts	0x709B, r26	; 0x80709b <__brkval>
    ab6c:	b0 93 9c 70 	sts	0x709C, r27	; 0x80709c <__brkval+0x1>
    ab70:	bc cf       	rjmp	.-136    	; 0xaaea <free+0x42>
    ab72:	c2 83       	std	Z+2, r28	; 0x02
    ab74:	d3 83       	std	Z+3, r29	; 0x03
    ab76:	40 81       	ld	r20, Z
    ab78:	51 81       	ldd	r21, Z+1	; 0x01
    ab7a:	84 0f       	add	r24, r20
    ab7c:	95 1f       	adc	r25, r21
    ab7e:	c8 17       	cp	r28, r24
    ab80:	d9 07       	cpc	r29, r25
    ab82:	61 f4       	brne	.+24     	; 0xab9c <free+0xf4>
    ab84:	4e 5f       	subi	r20, 0xFE	; 254
    ab86:	5f 4f       	sbci	r21, 0xFF	; 255
    ab88:	88 81       	ld	r24, Y
    ab8a:	99 81       	ldd	r25, Y+1	; 0x01
    ab8c:	48 0f       	add	r20, r24
    ab8e:	59 1f       	adc	r21, r25
    ab90:	40 83       	st	Z, r20
    ab92:	51 83       	std	Z+1, r21	; 0x01
    ab94:	8a 81       	ldd	r24, Y+2	; 0x02
    ab96:	9b 81       	ldd	r25, Y+3	; 0x03
    ab98:	82 83       	std	Z+2, r24	; 0x02
    ab9a:	93 83       	std	Z+3, r25	; 0x03
    ab9c:	21 15       	cp	r18, r1
    ab9e:	31 05       	cpc	r19, r1
    aba0:	09 f0       	breq	.+2      	; 0xaba4 <free+0xfc>
    aba2:	b0 cf       	rjmp	.-160    	; 0xab04 <free+0x5c>
    aba4:	e0 93 9d 70 	sts	0x709D, r30	; 0x80709d <__flp>
    aba8:	f0 93 9e 70 	sts	0x709E, r31	; 0x80709e <__flp+0x1>
    abac:	9e cf       	rjmp	.-196    	; 0xaaea <free+0x42>
    abae:	fd 01       	movw	r30, r26
    abb0:	dc 01       	movw	r26, r24
    abb2:	c0 cf       	rjmp	.-128    	; 0xab34 <free+0x8c>
    abb4:	12 82       	std	Z+2, r1	; 0x02
    abb6:	13 82       	std	Z+3, r1	; 0x03
    abb8:	d7 cf       	rjmp	.-82     	; 0xab68 <free+0xc0>

0000abba <realloc>:
realloc():
    abba:	4f 92       	push	r4
    abbc:	5f 92       	push	r5
    abbe:	6f 92       	push	r6
    abc0:	7f 92       	push	r7
    abc2:	8f 92       	push	r8
    abc4:	9f 92       	push	r9
    abc6:	af 92       	push	r10
    abc8:	bf 92       	push	r11
    abca:	cf 92       	push	r12
    abcc:	df 92       	push	r13
    abce:	ef 92       	push	r14
    abd0:	ff 92       	push	r15
    abd2:	0f 93       	push	r16
    abd4:	1f 93       	push	r17
    abd6:	cf 93       	push	r28
    abd8:	df 93       	push	r29
    abda:	8c 01       	movw	r16, r24
    abdc:	00 97       	sbiw	r24, 0x00	; 0
    abde:	91 f4       	brne	.+36     	; 0xac04 <realloc+0x4a>
    abe0:	cb 01       	movw	r24, r22
    abe2:	df 91       	pop	r29
    abe4:	cf 91       	pop	r28
    abe6:	1f 91       	pop	r17
    abe8:	0f 91       	pop	r16
    abea:	ff 90       	pop	r15
    abec:	ef 90       	pop	r14
    abee:	df 90       	pop	r13
    abf0:	cf 90       	pop	r12
    abf2:	bf 90       	pop	r11
    abf4:	af 90       	pop	r10
    abf6:	9f 90       	pop	r9
    abf8:	8f 90       	pop	r8
    abfa:	7f 90       	pop	r7
    abfc:	6f 90       	pop	r6
    abfe:	5f 90       	pop	r5
    ac00:	4f 90       	pop	r4
    ac02:	b6 ce       	rjmp	.-660    	; 0xa970 <malloc>
    ac04:	fc 01       	movw	r30, r24
    ac06:	e6 0f       	add	r30, r22
    ac08:	f7 1f       	adc	r31, r23
    ac0a:	9c 01       	movw	r18, r24
    ac0c:	22 50       	subi	r18, 0x02	; 2
    ac0e:	31 09       	sbc	r19, r1
    ac10:	e2 17       	cp	r30, r18
    ac12:	f3 07       	cpc	r31, r19
    ac14:	08 f4       	brcc	.+2      	; 0xac18 <realloc+0x5e>
    ac16:	aa c0       	rjmp	.+340    	; 0xad6c <realloc+0x1b2>
    ac18:	d9 01       	movw	r26, r18
    ac1a:	cd 91       	ld	r28, X+
    ac1c:	dc 91       	ld	r29, X
    ac1e:	11 97       	sbiw	r26, 0x01	; 1
    ac20:	c6 17       	cp	r28, r22
    ac22:	d7 07       	cpc	r29, r23
    ac24:	18 f1       	brcs	.+70     	; 0xac6c <realloc+0xb2>
    ac26:	c5 30       	cpi	r28, 0x05	; 5
    ac28:	d1 05       	cpc	r29, r1
    ac2a:	70 f0       	brcs	.+28     	; 0xac48 <realloc+0x8e>
    ac2c:	ce 01       	movw	r24, r28
    ac2e:	04 97       	sbiw	r24, 0x04	; 4
    ac30:	86 17       	cp	r24, r22
    ac32:	97 07       	cpc	r25, r23
    ac34:	48 f0       	brcs	.+18     	; 0xac48 <realloc+0x8e>
    ac36:	c6 1b       	sub	r28, r22
    ac38:	d7 0b       	sbc	r29, r23
    ac3a:	22 97       	sbiw	r28, 0x02	; 2
    ac3c:	c1 93       	st	Z+, r28
    ac3e:	d1 93       	st	Z+, r29
    ac40:	6d 93       	st	X+, r22
    ac42:	7c 93       	st	X, r23
    ac44:	cf 01       	movw	r24, r30
    ac46:	30 df       	rcall	.-416    	; 0xaaa8 <free>
    ac48:	c8 01       	movw	r24, r16
    ac4a:	df 91       	pop	r29
    ac4c:	cf 91       	pop	r28
    ac4e:	1f 91       	pop	r17
    ac50:	0f 91       	pop	r16
    ac52:	ff 90       	pop	r15
    ac54:	ef 90       	pop	r14
    ac56:	df 90       	pop	r13
    ac58:	cf 90       	pop	r12
    ac5a:	bf 90       	pop	r11
    ac5c:	af 90       	pop	r10
    ac5e:	9f 90       	pop	r9
    ac60:	8f 90       	pop	r8
    ac62:	7f 90       	pop	r7
    ac64:	6f 90       	pop	r6
    ac66:	5f 90       	pop	r5
    ac68:	4f 90       	pop	r4
    ac6a:	08 95       	ret
    ac6c:	5b 01       	movw	r10, r22
    ac6e:	ac 1a       	sub	r10, r28
    ac70:	bd 0a       	sbc	r11, r29
    ac72:	4c 01       	movw	r8, r24
    ac74:	8c 0e       	add	r8, r28
    ac76:	9d 1e       	adc	r9, r29
    ac78:	a0 91 9d 70 	lds	r26, 0x709D	; 0x80709d <__flp>
    ac7c:	b0 91 9e 70 	lds	r27, 0x709E	; 0x80709e <__flp+0x1>
    ac80:	51 2c       	mov	r5, r1
    ac82:	41 2c       	mov	r4, r1
    ac84:	f1 2c       	mov	r15, r1
    ac86:	e1 2c       	mov	r14, r1
    ac88:	10 97       	sbiw	r26, 0x00	; 0
    ac8a:	31 f5       	brne	.+76     	; 0xacd8 <realloc+0x11e>
    ac8c:	80 91 9b 70 	lds	r24, 0x709B	; 0x80709b <__brkval>
    ac90:	90 91 9c 70 	lds	r25, 0x709C	; 0x80709c <__brkval+0x1>
    ac94:	88 15       	cp	r24, r8
    ac96:	99 05       	cpc	r25, r9
    ac98:	09 f0       	breq	.+2      	; 0xac9c <realloc+0xe2>
    ac9a:	5c c0       	rjmp	.+184    	; 0xad54 <realloc+0x19a>
    ac9c:	46 16       	cp	r4, r22
    ac9e:	57 06       	cpc	r5, r23
    aca0:	08 f0       	brcs	.+2      	; 0xaca4 <realloc+0xea>
    aca2:	58 c0       	rjmp	.+176    	; 0xad54 <realloc+0x19a>
    aca4:	80 91 0c 42 	lds	r24, 0x420C	; 0x80420c <__malloc_heap_end>
    aca8:	90 91 0d 42 	lds	r25, 0x420D	; 0x80420d <__malloc_heap_end+0x1>
    acac:	00 97       	sbiw	r24, 0x00	; 0
    acae:	41 f4       	brne	.+16     	; 0xacc0 <realloc+0x106>
    acb0:	8d b7       	in	r24, 0x3d	; 61
    acb2:	9e b7       	in	r25, 0x3e	; 62
    acb4:	40 91 10 42 	lds	r20, 0x4210	; 0x804210 <__malloc_margin>
    acb8:	50 91 11 42 	lds	r21, 0x4211	; 0x804211 <__malloc_margin+0x1>
    acbc:	84 1b       	sub	r24, r20
    acbe:	95 0b       	sbc	r25, r21
    acc0:	e8 17       	cp	r30, r24
    acc2:	f9 07       	cpc	r31, r25
    acc4:	08 f0       	brcs	.+2      	; 0xacc8 <realloc+0x10e>
    acc6:	52 c0       	rjmp	.+164    	; 0xad6c <realloc+0x1b2>
    acc8:	e0 93 9b 70 	sts	0x709B, r30	; 0x80709b <__brkval>
    accc:	f0 93 9c 70 	sts	0x709C, r31	; 0x80709c <__brkval+0x1>
    acd0:	f9 01       	movw	r30, r18
    acd2:	60 83       	st	Z, r22
    acd4:	71 83       	std	Z+1, r23	; 0x01
    acd6:	b8 cf       	rjmp	.-144    	; 0xac48 <realloc+0x8e>
    acd8:	8d 91       	ld	r24, X+
    acda:	9c 91       	ld	r25, X
    acdc:	11 97       	sbiw	r26, 0x01	; 1
    acde:	12 96       	adiw	r26, 0x02	; 2
    ace0:	6c 90       	ld	r6, X
    ace2:	12 97       	sbiw	r26, 0x02	; 2
    ace4:	13 96       	adiw	r26, 0x03	; 3
    ace6:	7c 90       	ld	r7, X
    ace8:	13 97       	sbiw	r26, 0x03	; 3
    acea:	a8 15       	cp	r26, r8
    acec:	b9 05       	cpc	r27, r9
    acee:	59 f5       	brne	.+86     	; 0xad46 <realloc+0x18c>
    acf0:	6c 01       	movw	r12, r24
    acf2:	42 e0       	ldi	r20, 0x02	; 2
    acf4:	c4 0e       	add	r12, r20
    acf6:	d1 1c       	adc	r13, r1
    acf8:	ca 14       	cp	r12, r10
    acfa:	db 04       	cpc	r13, r11
    acfc:	20 f1       	brcs	.+72     	; 0xad46 <realloc+0x18c>
    acfe:	ac 01       	movw	r20, r24
    ad00:	4a 19       	sub	r20, r10
    ad02:	5b 09       	sbc	r21, r11
    ad04:	da 01       	movw	r26, r20
    ad06:	12 96       	adiw	r26, 0x02	; 2
    ad08:	15 97       	sbiw	r26, 0x05	; 5
    ad0a:	80 f0       	brcs	.+32     	; 0xad2c <realloc+0x172>
    ad0c:	62 82       	std	Z+2, r6	; 0x02
    ad0e:	73 82       	std	Z+3, r7	; 0x03
    ad10:	40 83       	st	Z, r20
    ad12:	51 83       	std	Z+1, r21	; 0x01
    ad14:	d9 01       	movw	r26, r18
    ad16:	6d 93       	st	X+, r22
    ad18:	7c 93       	st	X, r23
    ad1a:	e1 14       	cp	r14, r1
    ad1c:	f1 04       	cpc	r15, r1
    ad1e:	71 f0       	breq	.+28     	; 0xad3c <realloc+0x182>
    ad20:	d7 01       	movw	r26, r14
    ad22:	12 96       	adiw	r26, 0x02	; 2
    ad24:	ed 93       	st	X+, r30
    ad26:	fc 93       	st	X, r31
    ad28:	13 97       	sbiw	r26, 0x03	; 3
    ad2a:	8e cf       	rjmp	.-228    	; 0xac48 <realloc+0x8e>
    ad2c:	22 96       	adiw	r28, 0x02	; 2
    ad2e:	8c 0f       	add	r24, r28
    ad30:	9d 1f       	adc	r25, r29
    ad32:	f9 01       	movw	r30, r18
    ad34:	80 83       	st	Z, r24
    ad36:	91 83       	std	Z+1, r25	; 0x01
    ad38:	f3 01       	movw	r30, r6
    ad3a:	ef cf       	rjmp	.-34     	; 0xad1a <realloc+0x160>
    ad3c:	e0 93 9d 70 	sts	0x709D, r30	; 0x80709d <__flp>
    ad40:	f0 93 9e 70 	sts	0x709E, r31	; 0x80709e <__flp+0x1>
    ad44:	81 cf       	rjmp	.-254    	; 0xac48 <realloc+0x8e>
    ad46:	48 16       	cp	r4, r24
    ad48:	59 06       	cpc	r5, r25
    ad4a:	08 f4       	brcc	.+2      	; 0xad4e <realloc+0x194>
    ad4c:	2c 01       	movw	r4, r24
    ad4e:	7d 01       	movw	r14, r26
    ad50:	d3 01       	movw	r26, r6
    ad52:	9a cf       	rjmp	.-204    	; 0xac88 <realloc+0xce>
    ad54:	cb 01       	movw	r24, r22
    ad56:	0c de       	rcall	.-1000   	; 0xa970 <malloc>
    ad58:	7c 01       	movw	r14, r24
    ad5a:	00 97       	sbiw	r24, 0x00	; 0
    ad5c:	39 f0       	breq	.+14     	; 0xad6c <realloc+0x1b2>
    ad5e:	ae 01       	movw	r20, r28
    ad60:	b8 01       	movw	r22, r16
    ad62:	1c d0       	rcall	.+56     	; 0xad9c <memcpy>
    ad64:	c8 01       	movw	r24, r16
    ad66:	a0 de       	rcall	.-704    	; 0xaaa8 <free>
    ad68:	87 01       	movw	r16, r14
    ad6a:	6e cf       	rjmp	.-292    	; 0xac48 <realloc+0x8e>
    ad6c:	10 e0       	ldi	r17, 0x00	; 0
    ad6e:	00 e0       	ldi	r16, 0x00	; 0
    ad70:	6b cf       	rjmp	.-298    	; 0xac48 <realloc+0x8e>

0000ad72 <tolower>:
tolower():
    ad72:	91 11       	cpse	r25, r1
    ad74:	08 95       	ret
    ad76:	81 54       	subi	r24, 0x41	; 65
    ad78:	8a 51       	subi	r24, 0x1A	; 26
    ad7a:	08 f4       	brcc	.+2      	; 0xad7e <tolower+0xc>
    ad7c:	80 5e       	subi	r24, 0xE0	; 224
    ad7e:	85 5a       	subi	r24, 0xA5	; 165
    ad80:	08 95       	ret

0000ad82 <memcmp>:
memcmp():
    ad82:	fb 01       	movw	r30, r22
    ad84:	dc 01       	movw	r26, r24
    ad86:	04 c0       	rjmp	.+8      	; 0xad90 <memcmp+0xe>
    ad88:	8d 91       	ld	r24, X+
    ad8a:	01 90       	ld	r0, Z+
    ad8c:	80 19       	sub	r24, r0
    ad8e:	21 f4       	brne	.+8      	; 0xad98 <memcmp+0x16>
    ad90:	41 50       	subi	r20, 0x01	; 1
    ad92:	50 40       	sbci	r21, 0x00	; 0
    ad94:	c8 f7       	brcc	.-14     	; 0xad88 <memcmp+0x6>
    ad96:	88 1b       	sub	r24, r24
    ad98:	99 0b       	sbc	r25, r25
    ad9a:	08 95       	ret

0000ad9c <memcpy>:
memcpy():
    ad9c:	fb 01       	movw	r30, r22
    ad9e:	dc 01       	movw	r26, r24
    ada0:	02 c0       	rjmp	.+4      	; 0xada6 <memcpy+0xa>
    ada2:	01 90       	ld	r0, Z+
    ada4:	0d 92       	st	X+, r0
    ada6:	41 50       	subi	r20, 0x01	; 1
    ada8:	50 40       	sbci	r21, 0x00	; 0
    adaa:	d8 f7       	brcc	.-10     	; 0xada2 <memcpy+0x6>
    adac:	08 95       	ret

0000adae <memset>:
memset():
    adae:	dc 01       	movw	r26, r24
    adb0:	01 c0       	rjmp	.+2      	; 0xadb4 <memset+0x6>
    adb2:	6d 93       	st	X+, r22
    adb4:	41 50       	subi	r20, 0x01	; 1
    adb6:	50 40       	sbci	r21, 0x00	; 0
    adb8:	e0 f7       	brcc	.-8      	; 0xadb2 <memset+0x4>
    adba:	08 95       	ret

0000adbc <strcat>:
strcat():
    adbc:	fb 01       	movw	r30, r22
    adbe:	dc 01       	movw	r26, r24
    adc0:	0d 90       	ld	r0, X+
    adc2:	00 20       	and	r0, r0
    adc4:	e9 f7       	brne	.-6      	; 0xadc0 <strcat+0x4>
    adc6:	11 97       	sbiw	r26, 0x01	; 1
    adc8:	01 90       	ld	r0, Z+
    adca:	0d 92       	st	X+, r0
    adcc:	00 20       	and	r0, r0
    adce:	e1 f7       	brne	.-8      	; 0xadc8 <strcat+0xc>
    add0:	08 95       	ret

0000add2 <strchr>:
strchr():
    add2:	fc 01       	movw	r30, r24
    add4:	81 91       	ld	r24, Z+
    add6:	86 17       	cp	r24, r22
    add8:	21 f0       	breq	.+8      	; 0xade2 <strchr+0x10>
    adda:	88 23       	and	r24, r24
    addc:	d9 f7       	brne	.-10     	; 0xadd4 <strchr+0x2>
    adde:	99 27       	eor	r25, r25
    ade0:	08 95       	ret
    ade2:	31 97       	sbiw	r30, 0x01	; 1
    ade4:	cf 01       	movw	r24, r30
    ade6:	08 95       	ret

0000ade8 <strcmp>:
strcmp():
    ade8:	fb 01       	movw	r30, r22
    adea:	dc 01       	movw	r26, r24
    adec:	8d 91       	ld	r24, X+
    adee:	01 90       	ld	r0, Z+
    adf0:	80 19       	sub	r24, r0
    adf2:	01 10       	cpse	r0, r1
    adf4:	d9 f3       	breq	.-10     	; 0xadec <strcmp+0x4>
    adf6:	99 0b       	sbc	r25, r25
    adf8:	08 95       	ret

0000adfa <strcpy>:
strcpy():
    adfa:	fb 01       	movw	r30, r22
    adfc:	dc 01       	movw	r26, r24
    adfe:	01 90       	ld	r0, Z+
    ae00:	0d 92       	st	X+, r0
    ae02:	00 20       	and	r0, r0
    ae04:	e1 f7       	brne	.-8      	; 0xadfe <strcpy+0x4>
    ae06:	08 95       	ret

0000ae08 <strlen>:
strlen():
    ae08:	fc 01       	movw	r30, r24
    ae0a:	01 90       	ld	r0, Z+
    ae0c:	00 20       	and	r0, r0
    ae0e:	e9 f7       	brne	.-6      	; 0xae0a <strlen+0x2>
    ae10:	80 95       	com	r24
    ae12:	90 95       	com	r25
    ae14:	8e 0f       	add	r24, r30
    ae16:	9f 1f       	adc	r25, r31
    ae18:	08 95       	ret

0000ae1a <strncmp>:
strncmp():
    ae1a:	fb 01       	movw	r30, r22
    ae1c:	dc 01       	movw	r26, r24
    ae1e:	41 50       	subi	r20, 0x01	; 1
    ae20:	50 40       	sbci	r21, 0x00	; 0
    ae22:	30 f0       	brcs	.+12     	; 0xae30 <strncmp+0x16>
    ae24:	8d 91       	ld	r24, X+
    ae26:	01 90       	ld	r0, Z+
    ae28:	80 19       	sub	r24, r0
    ae2a:	19 f4       	brne	.+6      	; 0xae32 <strncmp+0x18>
    ae2c:	00 20       	and	r0, r0
    ae2e:	b9 f7       	brne	.-18     	; 0xae1e <strncmp+0x4>
    ae30:	88 1b       	sub	r24, r24
    ae32:	99 0b       	sbc	r25, r25
    ae34:	08 95       	ret

0000ae36 <strncpy>:
strncpy():
    ae36:	fb 01       	movw	r30, r22
    ae38:	dc 01       	movw	r26, r24
    ae3a:	41 50       	subi	r20, 0x01	; 1
    ae3c:	50 40       	sbci	r21, 0x00	; 0
    ae3e:	48 f0       	brcs	.+18     	; 0xae52 <strncpy+0x1c>
    ae40:	01 90       	ld	r0, Z+
    ae42:	0d 92       	st	X+, r0
    ae44:	00 20       	and	r0, r0
    ae46:	c9 f7       	brne	.-14     	; 0xae3a <strncpy+0x4>
    ae48:	01 c0       	rjmp	.+2      	; 0xae4c <strncpy+0x16>
    ae4a:	1d 92       	st	X+, r1
    ae4c:	41 50       	subi	r20, 0x01	; 1
    ae4e:	50 40       	sbci	r21, 0x00	; 0
    ae50:	e0 f7       	brcc	.-8      	; 0xae4a <strncpy+0x14>
    ae52:	08 95       	ret

0000ae54 <strstr>:
strstr():
    ae54:	fb 01       	movw	r30, r22
    ae56:	51 91       	ld	r21, Z+
    ae58:	55 23       	and	r21, r21
    ae5a:	a9 f0       	breq	.+42     	; 0xae86 <strstr+0x32>
    ae5c:	bf 01       	movw	r22, r30
    ae5e:	dc 01       	movw	r26, r24
    ae60:	4d 91       	ld	r20, X+
    ae62:	45 17       	cp	r20, r21
    ae64:	41 11       	cpse	r20, r1
    ae66:	e1 f7       	brne	.-8      	; 0xae60 <strstr+0xc>
    ae68:	59 f4       	brne	.+22     	; 0xae80 <strstr+0x2c>
    ae6a:	cd 01       	movw	r24, r26
    ae6c:	01 90       	ld	r0, Z+
    ae6e:	00 20       	and	r0, r0
    ae70:	49 f0       	breq	.+18     	; 0xae84 <strstr+0x30>
    ae72:	4d 91       	ld	r20, X+
    ae74:	40 15       	cp	r20, r0
    ae76:	41 11       	cpse	r20, r1
    ae78:	c9 f3       	breq	.-14     	; 0xae6c <strstr+0x18>
    ae7a:	fb 01       	movw	r30, r22
    ae7c:	41 11       	cpse	r20, r1
    ae7e:	ef cf       	rjmp	.-34     	; 0xae5e <strstr+0xa>
    ae80:	81 e0       	ldi	r24, 0x01	; 1
    ae82:	90 e0       	ldi	r25, 0x00	; 0
    ae84:	01 97       	sbiw	r24, 0x01	; 1
    ae86:	08 95       	ret

0000ae88 <printf>:
printf():
    ae88:	cf 93       	push	r28
    ae8a:	df 93       	push	r29
    ae8c:	cd b7       	in	r28, 0x3d	; 61
    ae8e:	de b7       	in	r29, 0x3e	; 62
    ae90:	ae 01       	movw	r20, r28
    ae92:	4b 5f       	subi	r20, 0xFB	; 251
    ae94:	5f 4f       	sbci	r21, 0xFF	; 255
    ae96:	fa 01       	movw	r30, r20
    ae98:	61 91       	ld	r22, Z+
    ae9a:	71 91       	ld	r23, Z+
    ae9c:	af 01       	movw	r20, r30
    ae9e:	80 91 83 70 	lds	r24, 0x7083	; 0x807083 <__iob+0x2>
    aea2:	90 91 84 70 	lds	r25, 0x7084	; 0x807084 <__iob+0x3>
    aea6:	0e 94 84 3a 	call	0x7508	; 0x7508 <vfprintf>
    aeaa:	df 91       	pop	r29
    aeac:	cf 91       	pop	r28
    aeae:	08 95       	ret

0000aeb0 <puts>:
puts():
    aeb0:	0f 93       	push	r16
    aeb2:	1f 93       	push	r17
    aeb4:	cf 93       	push	r28
    aeb6:	df 93       	push	r29
    aeb8:	e0 91 83 70 	lds	r30, 0x7083	; 0x807083 <__iob+0x2>
    aebc:	f0 91 84 70 	lds	r31, 0x7084	; 0x807084 <__iob+0x3>
    aec0:	23 81       	ldd	r18, Z+3	; 0x03
    aec2:	ec 01       	movw	r28, r24
    aec4:	10 e0       	ldi	r17, 0x00	; 0
    aec6:	00 e0       	ldi	r16, 0x00	; 0
    aec8:	21 fd       	sbrc	r18, 1
    aeca:	08 c0       	rjmp	.+16     	; 0xaedc <puts+0x2c>
    aecc:	0f ef       	ldi	r16, 0xFF	; 255
    aece:	1f ef       	ldi	r17, 0xFF	; 255
    aed0:	14 c0       	rjmp	.+40     	; 0xaefa <puts+0x4a>
    aed2:	09 95       	icall
    aed4:	89 2b       	or	r24, r25
    aed6:	11 f0       	breq	.+4      	; 0xaedc <puts+0x2c>
    aed8:	0f ef       	ldi	r16, 0xFF	; 255
    aeda:	1f ef       	ldi	r17, 0xFF	; 255
    aedc:	89 91       	ld	r24, Y+
    aede:	60 91 83 70 	lds	r22, 0x7083	; 0x807083 <__iob+0x2>
    aee2:	70 91 84 70 	lds	r23, 0x7084	; 0x807084 <__iob+0x3>
    aee6:	db 01       	movw	r26, r22
    aee8:	18 96       	adiw	r26, 0x08	; 8
    aeea:	ed 91       	ld	r30, X+
    aeec:	fc 91       	ld	r31, X
    aeee:	81 11       	cpse	r24, r1
    aef0:	f0 cf       	rjmp	.-32     	; 0xaed2 <puts+0x22>
    aef2:	8a e0       	ldi	r24, 0x0A	; 10
    aef4:	09 95       	icall
    aef6:	89 2b       	or	r24, r25
    aef8:	49 f7       	brne	.-46     	; 0xaecc <puts+0x1c>
    aefa:	c8 01       	movw	r24, r16
    aefc:	df 91       	pop	r29
    aefe:	cf 91       	pop	r28
    af00:	1f 91       	pop	r17
    af02:	0f 91       	pop	r16
    af04:	08 95       	ret

0000af06 <snprintf>:
snprintf():
    af06:	0f 93       	push	r16
    af08:	1f 93       	push	r17
    af0a:	cf 93       	push	r28
    af0c:	df 93       	push	r29
    af0e:	cd b7       	in	r28, 0x3d	; 61
    af10:	de b7       	in	r29, 0x3e	; 62
    af12:	2e 97       	sbiw	r28, 0x0e	; 14
    af14:	cd bf       	out	0x3d, r28	; 61
    af16:	de bf       	out	0x3e, r29	; 62
    af18:	0d 89       	ldd	r16, Y+21	; 0x15
    af1a:	1e 89       	ldd	r17, Y+22	; 0x16
    af1c:	8f 89       	ldd	r24, Y+23	; 0x17
    af1e:	98 8d       	ldd	r25, Y+24	; 0x18
    af20:	26 e0       	ldi	r18, 0x06	; 6
    af22:	2c 83       	std	Y+4, r18	; 0x04
    af24:	09 83       	std	Y+1, r16	; 0x01
    af26:	1a 83       	std	Y+2, r17	; 0x02
    af28:	97 ff       	sbrs	r25, 7
    af2a:	02 c0       	rjmp	.+4      	; 0xaf30 <snprintf+0x2a>
    af2c:	80 e0       	ldi	r24, 0x00	; 0
    af2e:	90 e8       	ldi	r25, 0x80	; 128
    af30:	01 97       	sbiw	r24, 0x01	; 1
    af32:	8d 83       	std	Y+5, r24	; 0x05
    af34:	9e 83       	std	Y+6, r25	; 0x06
    af36:	ae 01       	movw	r20, r28
    af38:	45 5e       	subi	r20, 0xE5	; 229
    af3a:	5f 4f       	sbci	r21, 0xFF	; 255
    af3c:	69 8d       	ldd	r22, Y+25	; 0x19
    af3e:	7a 8d       	ldd	r23, Y+26	; 0x1a
    af40:	ce 01       	movw	r24, r28
    af42:	01 96       	adiw	r24, 0x01	; 1
    af44:	0e 94 84 3a 	call	0x7508	; 0x7508 <vfprintf>
    af48:	4d 81       	ldd	r20, Y+5	; 0x05
    af4a:	5e 81       	ldd	r21, Y+6	; 0x06
    af4c:	57 fd       	sbrc	r21, 7
    af4e:	0a c0       	rjmp	.+20     	; 0xaf64 <snprintf+0x5e>
    af50:	2f 81       	ldd	r18, Y+7	; 0x07
    af52:	38 85       	ldd	r19, Y+8	; 0x08
    af54:	42 17       	cp	r20, r18
    af56:	53 07       	cpc	r21, r19
    af58:	0c f4       	brge	.+2      	; 0xaf5c <snprintf+0x56>
    af5a:	9a 01       	movw	r18, r20
    af5c:	02 0f       	add	r16, r18
    af5e:	13 1f       	adc	r17, r19
    af60:	f8 01       	movw	r30, r16
    af62:	10 82       	st	Z, r1
    af64:	2e 96       	adiw	r28, 0x0e	; 14
    af66:	cd bf       	out	0x3d, r28	; 61
    af68:	de bf       	out	0x3e, r29	; 62
    af6a:	df 91       	pop	r29
    af6c:	cf 91       	pop	r28
    af6e:	1f 91       	pop	r17
    af70:	0f 91       	pop	r16
    af72:	08 95       	ret

0000af74 <sprintf>:
sprintf():
    af74:	0f 93       	push	r16
    af76:	1f 93       	push	r17
    af78:	cf 93       	push	r28
    af7a:	df 93       	push	r29
    af7c:	cd b7       	in	r28, 0x3d	; 61
    af7e:	de b7       	in	r29, 0x3e	; 62
    af80:	2e 97       	sbiw	r28, 0x0e	; 14
    af82:	cd bf       	out	0x3d, r28	; 61
    af84:	de bf       	out	0x3e, r29	; 62
    af86:	0d 89       	ldd	r16, Y+21	; 0x15
    af88:	1e 89       	ldd	r17, Y+22	; 0x16
    af8a:	86 e0       	ldi	r24, 0x06	; 6
    af8c:	8c 83       	std	Y+4, r24	; 0x04
    af8e:	09 83       	std	Y+1, r16	; 0x01
    af90:	1a 83       	std	Y+2, r17	; 0x02
    af92:	8f ef       	ldi	r24, 0xFF	; 255
    af94:	9f e7       	ldi	r25, 0x7F	; 127
    af96:	8d 83       	std	Y+5, r24	; 0x05
    af98:	9e 83       	std	Y+6, r25	; 0x06
    af9a:	ae 01       	movw	r20, r28
    af9c:	47 5e       	subi	r20, 0xE7	; 231
    af9e:	5f 4f       	sbci	r21, 0xFF	; 255
    afa0:	6f 89       	ldd	r22, Y+23	; 0x17
    afa2:	78 8d       	ldd	r23, Y+24	; 0x18
    afa4:	ce 01       	movw	r24, r28
    afa6:	01 96       	adiw	r24, 0x01	; 1
    afa8:	0e 94 84 3a 	call	0x7508	; 0x7508 <vfprintf>
    afac:	2f 81       	ldd	r18, Y+7	; 0x07
    afae:	38 85       	ldd	r19, Y+8	; 0x08
    afb0:	02 0f       	add	r16, r18
    afb2:	13 1f       	adc	r17, r19
    afb4:	f8 01       	movw	r30, r16
    afb6:	10 82       	st	Z, r1
    afb8:	2e 96       	adiw	r28, 0x0e	; 14
    afba:	cd bf       	out	0x3d, r28	; 61
    afbc:	de bf       	out	0x3e, r29	; 62
    afbe:	df 91       	pop	r29
    afc0:	cf 91       	pop	r28
    afc2:	1f 91       	pop	r17
    afc4:	0f 91       	pop	r16
    afc6:	08 95       	ret

0000afc8 <sscanf>:
sscanf():
    afc8:	cf 93       	push	r28
    afca:	df 93       	push	r29
    afcc:	cd b7       	in	r28, 0x3d	; 61
    afce:	de b7       	in	r29, 0x3e	; 62
    afd0:	2e 97       	sbiw	r28, 0x0e	; 14
    afd2:	cd bf       	out	0x3d, r28	; 61
    afd4:	de bf       	out	0x3e, r29	; 62
    afd6:	85 e0       	ldi	r24, 0x05	; 5
    afd8:	8c 83       	std	Y+4, r24	; 0x04
    afda:	8b 89       	ldd	r24, Y+19	; 0x13
    afdc:	9c 89       	ldd	r25, Y+20	; 0x14
    afde:	89 83       	std	Y+1, r24	; 0x01
    afe0:	9a 83       	std	Y+2, r25	; 0x02
    afe2:	ae 01       	movw	r20, r28
    afe4:	49 5e       	subi	r20, 0xE9	; 233
    afe6:	5f 4f       	sbci	r21, 0xFF	; 255
    afe8:	6d 89       	ldd	r22, Y+21	; 0x15
    afea:	7e 89       	ldd	r23, Y+22	; 0x16
    afec:	ce 01       	movw	r24, r28
    afee:	01 96       	adiw	r24, 0x01	; 1
    aff0:	9e d1       	rcall	.+828    	; 0xb32e <vfscanf>
    aff2:	2e 96       	adiw	r28, 0x0e	; 14
    aff4:	cd bf       	out	0x3d, r28	; 61
    aff6:	de bf       	out	0x3e, r29	; 62
    aff8:	df 91       	pop	r29
    affa:	cf 91       	pop	r28
    affc:	08 95       	ret

0000affe <putval>:
putval():
    affe:	20 fd       	sbrc	r18, 0
    b000:	09 c0       	rjmp	.+18     	; 0xb014 <putval+0x16>
    b002:	fc 01       	movw	r30, r24
    b004:	23 fd       	sbrc	r18, 3
    b006:	05 c0       	rjmp	.+10     	; 0xb012 <putval+0x14>
    b008:	22 ff       	sbrs	r18, 2
    b00a:	02 c0       	rjmp	.+4      	; 0xb010 <putval+0x12>
    b00c:	73 83       	std	Z+3, r23	; 0x03
    b00e:	62 83       	std	Z+2, r22	; 0x02
    b010:	51 83       	std	Z+1, r21	; 0x01
    b012:	40 83       	st	Z, r20
    b014:	08 95       	ret

0000b016 <mulacc>:
mulacc():
    b016:	44 fd       	sbrc	r20, 4
    b018:	17 c0       	rjmp	.+46     	; 0xb048 <mulacc+0x32>
    b01a:	46 fd       	sbrc	r20, 6
    b01c:	1d c0       	rjmp	.+58     	; 0xb058 <mulacc+0x42>
    b01e:	db 01       	movw	r26, r22
    b020:	fc 01       	movw	r30, r24
    b022:	aa 0f       	add	r26, r26
    b024:	bb 1f       	adc	r27, r27
    b026:	ee 1f       	adc	r30, r30
    b028:	ff 1f       	adc	r31, r31
    b02a:	10 94       	com	r1
    b02c:	d1 f7       	brne	.-12     	; 0xb022 <mulacc+0xc>
    b02e:	6a 0f       	add	r22, r26
    b030:	7b 1f       	adc	r23, r27
    b032:	8e 1f       	adc	r24, r30
    b034:	9f 1f       	adc	r25, r31
    b036:	66 0f       	add	r22, r22
    b038:	77 1f       	adc	r23, r23
    b03a:	88 1f       	adc	r24, r24
    b03c:	99 1f       	adc	r25, r25
    b03e:	62 0f       	add	r22, r18
    b040:	71 1d       	adc	r23, r1
    b042:	81 1d       	adc	r24, r1
    b044:	91 1d       	adc	r25, r1
    b046:	08 95       	ret
    b048:	33 e0       	ldi	r19, 0x03	; 3
    b04a:	66 0f       	add	r22, r22
    b04c:	77 1f       	adc	r23, r23
    b04e:	88 1f       	adc	r24, r24
    b050:	99 1f       	adc	r25, r25
    b052:	31 50       	subi	r19, 0x01	; 1
    b054:	d1 f7       	brne	.-12     	; 0xb04a <mulacc+0x34>
    b056:	f3 cf       	rjmp	.-26     	; 0xb03e <mulacc+0x28>
    b058:	34 e0       	ldi	r19, 0x04	; 4
    b05a:	f7 cf       	rjmp	.-18     	; 0xb04a <mulacc+0x34>

0000b05c <skip_spaces>:
skip_spaces():
    b05c:	0f 93       	push	r16
    b05e:	1f 93       	push	r17
    b060:	cf 93       	push	r28
    b062:	df 93       	push	r29
    b064:	8c 01       	movw	r16, r24
    b066:	c8 01       	movw	r24, r16
    b068:	7a d2       	rcall	.+1268   	; 0xb55e <fgetc>
    b06a:	ec 01       	movw	r28, r24
    b06c:	97 fd       	sbrc	r25, 7
    b06e:	07 c0       	rjmp	.+14     	; 0xb07e <skip_spaces+0x22>
    b070:	0e 94 31 50 	call	0xa062	; 0xa062 <isspace>
    b074:	89 2b       	or	r24, r25
    b076:	b9 f7       	brne	.-18     	; 0xb066 <skip_spaces+0xa>
    b078:	b8 01       	movw	r22, r16
    b07a:	ce 01       	movw	r24, r28
    b07c:	ac d2       	rcall	.+1368   	; 0xb5d6 <ungetc>
    b07e:	ce 01       	movw	r24, r28
    b080:	df 91       	pop	r29
    b082:	cf 91       	pop	r28
    b084:	1f 91       	pop	r17
    b086:	0f 91       	pop	r16
    b088:	08 95       	ret

0000b08a <conv_int>:
conv_int():
    b08a:	8f 92       	push	r8
    b08c:	9f 92       	push	r9
    b08e:	af 92       	push	r10
    b090:	bf 92       	push	r11
    b092:	ef 92       	push	r14
    b094:	ff 92       	push	r15
    b096:	0f 93       	push	r16
    b098:	1f 93       	push	r17
    b09a:	cf 93       	push	r28
    b09c:	df 93       	push	r29
    b09e:	8c 01       	movw	r16, r24
    b0a0:	d6 2f       	mov	r29, r22
    b0a2:	7a 01       	movw	r14, r20
    b0a4:	b2 2e       	mov	r11, r18
    b0a6:	5b d2       	rcall	.+1206   	; 0xb55e <fgetc>
    b0a8:	9c 01       	movw	r18, r24
    b0aa:	33 27       	eor	r19, r19
    b0ac:	2b 32       	cpi	r18, 0x2B	; 43
    b0ae:	31 05       	cpc	r19, r1
    b0b0:	29 f0       	breq	.+10     	; 0xb0bc <conv_int+0x32>
    b0b2:	2d 32       	cpi	r18, 0x2D	; 45
    b0b4:	31 05       	cpc	r19, r1
    b0b6:	a1 f4       	brne	.+40     	; 0xb0e0 <conv_int+0x56>
    b0b8:	68 94       	set
    b0ba:	b7 f8       	bld	r11, 7
    b0bc:	d1 50       	subi	r29, 0x01	; 1
    b0be:	61 f4       	brne	.+24     	; 0xb0d8 <conv_int+0x4e>
    b0c0:	80 e0       	ldi	r24, 0x00	; 0
    b0c2:	df 91       	pop	r29
    b0c4:	cf 91       	pop	r28
    b0c6:	1f 91       	pop	r17
    b0c8:	0f 91       	pop	r16
    b0ca:	ff 90       	pop	r15
    b0cc:	ef 90       	pop	r14
    b0ce:	bf 90       	pop	r11
    b0d0:	af 90       	pop	r10
    b0d2:	9f 90       	pop	r9
    b0d4:	8f 90       	pop	r8
    b0d6:	08 95       	ret
    b0d8:	c8 01       	movw	r24, r16
    b0da:	41 d2       	rcall	.+1154   	; 0xb55e <fgetc>
    b0dc:	97 fd       	sbrc	r25, 7
    b0de:	f0 cf       	rjmp	.-32     	; 0xb0c0 <conv_int+0x36>
    b0e0:	cb 2d       	mov	r28, r11
    b0e2:	cd 7f       	andi	r28, 0xFD	; 253
    b0e4:	2b 2d       	mov	r18, r11
    b0e6:	20 73       	andi	r18, 0x30	; 48
    b0e8:	e9 f4       	brne	.+58     	; 0xb124 <conv_int+0x9a>
    b0ea:	80 33       	cpi	r24, 0x30	; 48
    b0ec:	d9 f4       	brne	.+54     	; 0xb124 <conv_int+0x9a>
    b0ee:	aa 24       	eor	r10, r10
    b0f0:	aa 94       	dec	r10
    b0f2:	ad 0e       	add	r10, r29
    b0f4:	79 f0       	breq	.+30     	; 0xb114 <conv_int+0x8a>
    b0f6:	c8 01       	movw	r24, r16
    b0f8:	32 d2       	rcall	.+1124   	; 0xb55e <fgetc>
    b0fa:	97 fd       	sbrc	r25, 7
    b0fc:	0b c0       	rjmp	.+22     	; 0xb114 <conv_int+0x8a>
    b0fe:	28 2f       	mov	r18, r24
    b100:	2f 7d       	andi	r18, 0xDF	; 223
    b102:	28 35       	cpi	r18, 0x58	; 88
    b104:	59 f4       	brne	.+22     	; 0xb11c <conv_int+0x92>
    b106:	c2 64       	ori	r28, 0x42	; 66
    b108:	d2 50       	subi	r29, 0x02	; 2
    b10a:	21 f0       	breq	.+8      	; 0xb114 <conv_int+0x8a>
    b10c:	c8 01       	movw	r24, r16
    b10e:	27 d2       	rcall	.+1102   	; 0xb55e <fgetc>
    b110:	97 ff       	sbrs	r25, 7
    b112:	08 c0       	rjmp	.+16     	; 0xb124 <conv_int+0x9a>
    b114:	81 2c       	mov	r8, r1
    b116:	91 2c       	mov	r9, r1
    b118:	54 01       	movw	r10, r8
    b11a:	1a c0       	rjmp	.+52     	; 0xb150 <conv_int+0xc6>
    b11c:	b6 fe       	sbrs	r11, 6
    b11e:	29 c0       	rjmp	.+82     	; 0xb172 <conv_int+0xe8>
    b120:	c2 60       	ori	r28, 0x02	; 2
    b122:	da 2d       	mov	r29, r10
    b124:	81 2c       	mov	r8, r1
    b126:	91 2c       	mov	r9, r1
    b128:	54 01       	movw	r10, r8
    b12a:	20 ed       	ldi	r18, 0xD0	; 208
    b12c:	28 0f       	add	r18, r24
    b12e:	28 30       	cpi	r18, 0x08	; 8
    b130:	18 f1       	brcs	.+70     	; 0xb178 <conv_int+0xee>
    b132:	c4 fd       	sbrc	r28, 4
    b134:	09 c0       	rjmp	.+18     	; 0xb148 <conv_int+0xbe>
    b136:	2a 30       	cpi	r18, 0x0A	; 10
    b138:	f8 f0       	brcs	.+62     	; 0xb178 <conv_int+0xee>
    b13a:	c6 ff       	sbrs	r28, 6
    b13c:	05 c0       	rjmp	.+10     	; 0xb148 <conv_int+0xbe>
    b13e:	2f 7d       	andi	r18, 0xDF	; 223
    b140:	3f ee       	ldi	r19, 0xEF	; 239
    b142:	32 0f       	add	r19, r18
    b144:	36 30       	cpi	r19, 0x06	; 6
    b146:	b8 f0       	brcs	.+46     	; 0xb176 <conv_int+0xec>
    b148:	b8 01       	movw	r22, r16
    b14a:	45 d2       	rcall	.+1162   	; 0xb5d6 <ungetc>
    b14c:	c1 ff       	sbrs	r28, 1
    b14e:	b8 cf       	rjmp	.-144    	; 0xb0c0 <conv_int+0x36>
    b150:	c7 ff       	sbrs	r28, 7
    b152:	08 c0       	rjmp	.+16     	; 0xb164 <conv_int+0xda>
    b154:	b0 94       	com	r11
    b156:	a0 94       	com	r10
    b158:	90 94       	com	r9
    b15a:	80 94       	com	r8
    b15c:	81 1c       	adc	r8, r1
    b15e:	91 1c       	adc	r9, r1
    b160:	a1 1c       	adc	r10, r1
    b162:	b1 1c       	adc	r11, r1
    b164:	2c 2f       	mov	r18, r28
    b166:	b5 01       	movw	r22, r10
    b168:	a4 01       	movw	r20, r8
    b16a:	c7 01       	movw	r24, r14
    b16c:	48 df       	rcall	.-368    	; 0xaffe <putval>
    b16e:	81 e0       	ldi	r24, 0x01	; 1
    b170:	a8 cf       	rjmp	.-176    	; 0xb0c2 <conv_int+0x38>
    b172:	c2 61       	ori	r28, 0x12	; 18
    b174:	d6 cf       	rjmp	.-84     	; 0xb122 <conv_int+0x98>
    b176:	27 50       	subi	r18, 0x07	; 7
    b178:	4c 2f       	mov	r20, r28
    b17a:	c5 01       	movw	r24, r10
    b17c:	b4 01       	movw	r22, r8
    b17e:	4b df       	rcall	.-362    	; 0xb016 <mulacc>
    b180:	4b 01       	movw	r8, r22
    b182:	5c 01       	movw	r10, r24
    b184:	c2 60       	ori	r28, 0x02	; 2
    b186:	d1 50       	subi	r29, 0x01	; 1
    b188:	19 f3       	breq	.-58     	; 0xb150 <conv_int+0xc6>
    b18a:	c8 01       	movw	r24, r16
    b18c:	e8 d1       	rcall	.+976    	; 0xb55e <fgetc>
    b18e:	97 ff       	sbrs	r25, 7
    b190:	cc cf       	rjmp	.-104    	; 0xb12a <conv_int+0xa0>
    b192:	dc cf       	rjmp	.-72     	; 0xb14c <conv_int+0xc2>

0000b194 <conv_brk>:
conv_brk():
    b194:	7f 92       	push	r7
    b196:	8f 92       	push	r8
    b198:	9f 92       	push	r9
    b19a:	af 92       	push	r10
    b19c:	bf 92       	push	r11
    b19e:	cf 92       	push	r12
    b1a0:	df 92       	push	r13
    b1a2:	ef 92       	push	r14
    b1a4:	ff 92       	push	r15
    b1a6:	0f 93       	push	r16
    b1a8:	1f 93       	push	r17
    b1aa:	cf 93       	push	r28
    b1ac:	df 93       	push	r29
    b1ae:	cd b7       	in	r28, 0x3d	; 61
    b1b0:	de b7       	in	r29, 0x3e	; 62
    b1b2:	a0 97       	sbiw	r28, 0x20	; 32
    b1b4:	cd bf       	out	0x3d, r28	; 61
    b1b6:	de bf       	out	0x3e, r29	; 62
    b1b8:	5c 01       	movw	r10, r24
    b1ba:	96 2e       	mov	r9, r22
    b1bc:	7a 01       	movw	r14, r20
    b1be:	ce 01       	movw	r24, r28
    b1c0:	01 96       	adiw	r24, 0x01	; 1
    b1c2:	6c 01       	movw	r12, r24
    b1c4:	80 e2       	ldi	r24, 0x20	; 32
    b1c6:	f6 01       	movw	r30, r12
    b1c8:	11 92       	st	Z+, r1
    b1ca:	8a 95       	dec	r24
    b1cc:	e9 f7       	brne	.-6      	; 0xb1c8 <conv_brk+0x34>
    b1ce:	f5 01       	movw	r30, r10
    b1d0:	b3 81       	ldd	r27, Z+3	; 0x03
    b1d2:	89 01       	movw	r16, r18
    b1d4:	30 e0       	ldi	r19, 0x00	; 0
    b1d6:	20 e0       	ldi	r18, 0x00	; 0
    b1d8:	71 2c       	mov	r7, r1
    b1da:	81 2c       	mov	r8, r1
    b1dc:	a0 e0       	ldi	r26, 0x00	; 0
    b1de:	41 e0       	ldi	r20, 0x01	; 1
    b1e0:	50 e0       	ldi	r21, 0x00	; 0
    b1e2:	f8 01       	movw	r30, r16
    b1e4:	b3 fd       	sbrc	r27, 3
    b1e6:	85 91       	lpm	r24, Z+
    b1e8:	b3 ff       	sbrs	r27, 3
    b1ea:	81 91       	ld	r24, Z+
    b1ec:	98 2f       	mov	r25, r24
    b1ee:	8f 01       	movw	r16, r30
    b1f0:	81 11       	cpse	r24, r1
    b1f2:	14 c0       	rjmp	.+40     	; 0xb21c <conv_brk+0x88>
    b1f4:	10 e0       	ldi	r17, 0x00	; 0
    b1f6:	00 e0       	ldi	r16, 0x00	; 0
    b1f8:	c8 01       	movw	r24, r16
    b1fa:	a0 96       	adiw	r28, 0x20	; 32
    b1fc:	cd bf       	out	0x3d, r28	; 61
    b1fe:	de bf       	out	0x3e, r29	; 62
    b200:	df 91       	pop	r29
    b202:	cf 91       	pop	r28
    b204:	1f 91       	pop	r17
    b206:	0f 91       	pop	r16
    b208:	ff 90       	pop	r15
    b20a:	ef 90       	pop	r14
    b20c:	df 90       	pop	r13
    b20e:	cf 90       	pop	r12
    b210:	bf 90       	pop	r11
    b212:	af 90       	pop	r10
    b214:	9f 90       	pop	r9
    b216:	8f 90       	pop	r8
    b218:	7f 90       	pop	r7
    b21a:	08 95       	ret
    b21c:	8e 35       	cpi	r24, 0x5E	; 94
    b21e:	19 f4       	brne	.+6      	; 0xb226 <conv_brk+0x92>
    b220:	21 15       	cp	r18, r1
    b222:	31 05       	cpc	r19, r1
    b224:	41 f1       	breq	.+80     	; 0xb276 <conv_brk+0xe2>
    b226:	a2 17       	cp	r26, r18
    b228:	13 06       	cpc	r1, r19
    b22a:	4c f4       	brge	.+18     	; 0xb23e <conv_brk+0xaa>
    b22c:	8d 35       	cpi	r24, 0x5D	; 93
    b22e:	49 f1       	breq	.+82     	; 0xb282 <conv_brk+0xee>
    b230:	8d 32       	cpi	r24, 0x2D	; 45
    b232:	29 f4       	brne	.+10     	; 0xb23e <conv_brk+0xaa>
    b234:	81 10       	cpse	r8, r1
    b236:	06 c0       	rjmp	.+12     	; 0xb244 <conv_brk+0xb0>
    b238:	88 24       	eor	r8, r8
    b23a:	83 94       	inc	r8
    b23c:	1d c0       	rjmp	.+58     	; 0xb278 <conv_brk+0xe4>
    b23e:	88 20       	and	r8, r8
    b240:	09 f4       	brne	.+2      	; 0xb244 <conv_brk+0xb0>
    b242:	62 c0       	rjmp	.+196    	; 0xb308 <conv_brk+0x174>
    b244:	e9 2f       	mov	r30, r25
    b246:	e6 95       	lsr	r30
    b248:	e6 95       	lsr	r30
    b24a:	e6 95       	lsr	r30
    b24c:	ec 0d       	add	r30, r12
    b24e:	fd 2d       	mov	r31, r13
    b250:	f1 1d       	adc	r31, r1
    b252:	89 2f       	mov	r24, r25
    b254:	87 70       	andi	r24, 0x07	; 7
    b256:	ba 01       	movw	r22, r20
    b258:	01 c0       	rjmp	.+2      	; 0xb25c <conv_brk+0xc8>
    b25a:	66 0f       	add	r22, r22
    b25c:	8a 95       	dec	r24
    b25e:	ea f7       	brpl	.-6      	; 0xb25a <conv_brk+0xc6>
    b260:	80 81       	ld	r24, Z
    b262:	68 2b       	or	r22, r24
    b264:	60 83       	st	Z, r22
    b266:	79 16       	cp	r7, r25
    b268:	51 f0       	breq	.+20     	; 0xb27e <conv_brk+0xea>
    b26a:	97 15       	cp	r25, r7
    b26c:	10 f4       	brcc	.+4      	; 0xb272 <conv_brk+0xde>
    b26e:	9f 5f       	subi	r25, 0xFF	; 255
    b270:	e9 cf       	rjmp	.-46     	; 0xb244 <conv_brk+0xb0>
    b272:	91 50       	subi	r25, 0x01	; 1
    b274:	e7 cf       	rjmp	.-50     	; 0xb244 <conv_brk+0xb0>
    b276:	a1 e0       	ldi	r26, 0x01	; 1
    b278:	2f 5f       	subi	r18, 0xFF	; 255
    b27a:	3f 4f       	sbci	r19, 0xFF	; 255
    b27c:	b2 cf       	rjmp	.-156    	; 0xb1e2 <conv_brk+0x4e>
    b27e:	81 2c       	mov	r8, r1
    b280:	fb cf       	rjmp	.-10     	; 0xb278 <conv_brk+0xe4>
    b282:	88 20       	and	r8, r8
    b284:	19 f0       	breq	.+6      	; 0xb28c <conv_brk+0xf8>
    b286:	8e 81       	ldd	r24, Y+6	; 0x06
    b288:	80 62       	ori	r24, 0x20	; 32
    b28a:	8e 83       	std	Y+6, r24	; 0x06
    b28c:	aa 23       	and	r26, r26
    b28e:	59 f0       	breq	.+22     	; 0xb2a6 <conv_brk+0x112>
    b290:	f6 01       	movw	r30, r12
    b292:	9e 01       	movw	r18, r28
    b294:	2f 5d       	subi	r18, 0xDF	; 223
    b296:	3f 4f       	sbci	r19, 0xFF	; 255
    b298:	80 81       	ld	r24, Z
    b29a:	80 95       	com	r24
    b29c:	80 83       	st	Z, r24
    b29e:	31 96       	adiw	r30, 0x01	; 1
    b2a0:	e2 17       	cp	r30, r18
    b2a2:	f3 07       	cpc	r31, r19
    b2a4:	c9 f7       	brne	.-14     	; 0xb298 <conv_brk+0x104>
    b2a6:	88 24       	eor	r8, r8
    b2a8:	83 94       	inc	r8
    b2aa:	c5 01       	movw	r24, r10
    b2ac:	58 d1       	rcall	.+688    	; 0xb55e <fgetc>
    b2ae:	97 fd       	sbrc	r25, 7
    b2b0:	15 c0       	rjmp	.+42     	; 0xb2dc <conv_brk+0x148>
    b2b2:	e8 2f       	mov	r30, r24
    b2b4:	e6 95       	lsr	r30
    b2b6:	e6 95       	lsr	r30
    b2b8:	e6 95       	lsr	r30
    b2ba:	ec 0d       	add	r30, r12
    b2bc:	fd 2d       	mov	r31, r13
    b2be:	f1 1d       	adc	r31, r1
    b2c0:	20 81       	ld	r18, Z
    b2c2:	30 e0       	ldi	r19, 0x00	; 0
    b2c4:	ac 01       	movw	r20, r24
    b2c6:	47 70       	andi	r20, 0x07	; 7
    b2c8:	55 27       	eor	r21, r21
    b2ca:	02 c0       	rjmp	.+4      	; 0xb2d0 <conv_brk+0x13c>
    b2cc:	35 95       	asr	r19
    b2ce:	27 95       	ror	r18
    b2d0:	4a 95       	dec	r20
    b2d2:	e2 f7       	brpl	.-8      	; 0xb2cc <conv_brk+0x138>
    b2d4:	20 fd       	sbrc	r18, 0
    b2d6:	05 c0       	rjmp	.+10     	; 0xb2e2 <conv_brk+0x14e>
    b2d8:	b5 01       	movw	r22, r10
    b2da:	7d d1       	rcall	.+762    	; 0xb5d6 <ungetc>
    b2dc:	88 20       	and	r8, r8
    b2de:	69 f0       	breq	.+26     	; 0xb2fa <conv_brk+0x166>
    b2e0:	89 cf       	rjmp	.-238    	; 0xb1f4 <conv_brk+0x60>
    b2e2:	e1 14       	cp	r14, r1
    b2e4:	f1 04       	cpc	r15, r1
    b2e6:	29 f0       	breq	.+10     	; 0xb2f2 <conv_brk+0x15e>
    b2e8:	f7 01       	movw	r30, r14
    b2ea:	80 83       	st	Z, r24
    b2ec:	c7 01       	movw	r24, r14
    b2ee:	01 96       	adiw	r24, 0x01	; 1
    b2f0:	7c 01       	movw	r14, r24
    b2f2:	9a 94       	dec	r9
    b2f4:	81 2c       	mov	r8, r1
    b2f6:	91 10       	cpse	r9, r1
    b2f8:	d8 cf       	rjmp	.-80     	; 0xb2aa <conv_brk+0x116>
    b2fa:	e1 14       	cp	r14, r1
    b2fc:	f1 04       	cpc	r15, r1
    b2fe:	09 f4       	brne	.+2      	; 0xb302 <conv_brk+0x16e>
    b300:	7b cf       	rjmp	.-266    	; 0xb1f8 <conv_brk+0x64>
    b302:	f7 01       	movw	r30, r14
    b304:	10 82       	st	Z, r1
    b306:	78 cf       	rjmp	.-272    	; 0xb1f8 <conv_brk+0x64>
    b308:	e8 2f       	mov	r30, r24
    b30a:	e6 95       	lsr	r30
    b30c:	e6 95       	lsr	r30
    b30e:	e6 95       	lsr	r30
    b310:	ec 0d       	add	r30, r12
    b312:	fd 2d       	mov	r31, r13
    b314:	f1 1d       	adc	r31, r1
    b316:	98 2f       	mov	r25, r24
    b318:	97 70       	andi	r25, 0x07	; 7
    b31a:	ba 01       	movw	r22, r20
    b31c:	01 c0       	rjmp	.+2      	; 0xb320 <conv_brk+0x18c>
    b31e:	66 0f       	add	r22, r22
    b320:	9a 95       	dec	r25
    b322:	ea f7       	brpl	.-6      	; 0xb31e <conv_brk+0x18a>
    b324:	90 81       	ld	r25, Z
    b326:	69 2b       	or	r22, r25
    b328:	60 83       	st	Z, r22
    b32a:	78 2e       	mov	r7, r24
    b32c:	a5 cf       	rjmp	.-182    	; 0xb278 <conv_brk+0xe4>

0000b32e <vfscanf>:
vfscanf():
    b32e:	5f 92       	push	r5
    b330:	6f 92       	push	r6
    b332:	7f 92       	push	r7
    b334:	8f 92       	push	r8
    b336:	9f 92       	push	r9
    b338:	af 92       	push	r10
    b33a:	bf 92       	push	r11
    b33c:	cf 92       	push	r12
    b33e:	df 92       	push	r13
    b340:	ef 92       	push	r14
    b342:	ff 92       	push	r15
    b344:	0f 93       	push	r16
    b346:	1f 93       	push	r17
    b348:	cf 93       	push	r28
    b34a:	df 93       	push	r29
    b34c:	6c 01       	movw	r12, r24
    b34e:	eb 01       	movw	r28, r22
    b350:	5a 01       	movw	r10, r20
    b352:	fc 01       	movw	r30, r24
    b354:	16 82       	std	Z+6, r1	; 0x06
    b356:	17 82       	std	Z+7, r1	; 0x07
    b358:	51 2c       	mov	r5, r1
    b35a:	f6 01       	movw	r30, r12
    b35c:	e3 80       	ldd	r14, Z+3	; 0x03
    b35e:	fe 01       	movw	r30, r28
    b360:	e3 fc       	sbrc	r14, 3
    b362:	85 91       	lpm	r24, Z+
    b364:	e3 fe       	sbrs	r14, 3
    b366:	81 91       	ld	r24, Z+
    b368:	18 2f       	mov	r17, r24
    b36a:	ef 01       	movw	r28, r30
    b36c:	88 23       	and	r24, r24
    b36e:	d1 f0       	breq	.+52     	; 0xb3a4 <vfscanf+0x76>
    b370:	90 e0       	ldi	r25, 0x00	; 0
    b372:	0e 94 31 50 	call	0xa062	; 0xa062 <isspace>
    b376:	89 2b       	or	r24, r25
    b378:	19 f0       	breq	.+6      	; 0xb380 <vfscanf+0x52>
    b37a:	c6 01       	movw	r24, r12
    b37c:	6f de       	rcall	.-802    	; 0xb05c <skip_spaces>
    b37e:	ed cf       	rjmp	.-38     	; 0xb35a <vfscanf+0x2c>
    b380:	15 32       	cpi	r17, 0x25	; 37
    b382:	41 f4       	brne	.+16     	; 0xb394 <vfscanf+0x66>
    b384:	fe 01       	movw	r30, r28
    b386:	e3 fc       	sbrc	r14, 3
    b388:	15 91       	lpm	r17, Z+
    b38a:	e3 fe       	sbrs	r14, 3
    b38c:	11 91       	ld	r17, Z+
    b38e:	ef 01       	movw	r28, r30
    b390:	15 32       	cpi	r17, 0x25	; 37
    b392:	59 f4       	brne	.+22     	; 0xb3aa <vfscanf+0x7c>
    b394:	c6 01       	movw	r24, r12
    b396:	e3 d0       	rcall	.+454    	; 0xb55e <fgetc>
    b398:	97 fd       	sbrc	r25, 7
    b39a:	88 c0       	rjmp	.+272    	; 0xb4ac <vfscanf+0x17e>
    b39c:	18 17       	cp	r17, r24
    b39e:	e9 f2       	breq	.-70     	; 0xb35a <vfscanf+0x2c>
    b3a0:	b6 01       	movw	r22, r12
    b3a2:	19 d1       	rcall	.+562    	; 0xb5d6 <ungetc>
    b3a4:	85 2d       	mov	r24, r5
    b3a6:	90 e0       	ldi	r25, 0x00	; 0
    b3a8:	85 c0       	rjmp	.+266    	; 0xb4b4 <vfscanf+0x186>
    b3aa:	00 e0       	ldi	r16, 0x00	; 0
    b3ac:	1a 32       	cpi	r17, 0x2A	; 42
    b3ae:	31 f4       	brne	.+12     	; 0xb3bc <vfscanf+0x8e>
    b3b0:	e3 fc       	sbrc	r14, 3
    b3b2:	15 91       	lpm	r17, Z+
    b3b4:	e3 fe       	sbrs	r14, 3
    b3b6:	11 91       	ld	r17, Z+
    b3b8:	ef 01       	movw	r28, r30
    b3ba:	01 e0       	ldi	r16, 0x01	; 1
    b3bc:	f1 2c       	mov	r15, r1
    b3be:	20 ed       	ldi	r18, 0xD0	; 208
    b3c0:	21 0f       	add	r18, r17
    b3c2:	2a 30       	cpi	r18, 0x0A	; 10
    b3c4:	38 f1       	brcs	.+78     	; 0xb414 <vfscanf+0xe6>
    b3c6:	01 ff       	sbrs	r16, 1
    b3c8:	34 c0       	rjmp	.+104    	; 0xb432 <vfscanf+0x104>
    b3ca:	ff 20       	and	r15, r15
    b3cc:	59 f3       	breq	.-42     	; 0xb3a4 <vfscanf+0x76>
    b3ce:	18 36       	cpi	r17, 0x68	; 104
    b3d0:	99 f1       	breq	.+102    	; 0xb438 <vfscanf+0x10a>
    b3d2:	1c 36       	cpi	r17, 0x6C	; 108
    b3d4:	09 f4       	brne	.+2      	; 0xb3d8 <vfscanf+0xaa>
    b3d6:	3a c0       	rjmp	.+116    	; 0xb44c <vfscanf+0x11e>
    b3d8:	11 23       	and	r17, r17
    b3da:	21 f3       	breq	.-56     	; 0xb3a4 <vfscanf+0x76>
    b3dc:	61 2f       	mov	r22, r17
    b3de:	70 e0       	ldi	r23, 0x00	; 0
    b3e0:	8b e8       	ldi	r24, 0x8B	; 139
    b3e2:	92 e0       	ldi	r25, 0x02	; 2
    b3e4:	b1 d0       	rcall	.+354    	; 0xb548 <strchr_P>
    b3e6:	89 2b       	or	r24, r25
    b3e8:	e9 f2       	breq	.-70     	; 0xb3a4 <vfscanf+0x76>
    b3ea:	91 2c       	mov	r9, r1
    b3ec:	81 2c       	mov	r8, r1
    b3ee:	00 fd       	sbrc	r16, 0
    b3f0:	06 c0       	rjmp	.+12     	; 0xb3fe <vfscanf+0xd0>
    b3f2:	f5 01       	movw	r30, r10
    b3f4:	80 80       	ld	r8, Z
    b3f6:	91 80       	ldd	r9, Z+1	; 0x01
    b3f8:	c5 01       	movw	r24, r10
    b3fa:	02 96       	adiw	r24, 0x02	; 2
    b3fc:	5c 01       	movw	r10, r24
    b3fe:	1e 36       	cpi	r17, 0x6E	; 110
    b400:	69 f5       	brne	.+90     	; 0xb45c <vfscanf+0x12e>
    b402:	f6 01       	movw	r30, r12
    b404:	46 81       	ldd	r20, Z+6	; 0x06
    b406:	57 81       	ldd	r21, Z+7	; 0x07
    b408:	70 e0       	ldi	r23, 0x00	; 0
    b40a:	60 e0       	ldi	r22, 0x00	; 0
    b40c:	20 2f       	mov	r18, r16
    b40e:	c4 01       	movw	r24, r8
    b410:	f6 dd       	rcall	.-1044   	; 0xaffe <putval>
    b412:	a3 cf       	rjmp	.-186    	; 0xb35a <vfscanf+0x2c>
    b414:	02 60       	ori	r16, 0x02	; 2
    b416:	6f 2d       	mov	r22, r15
    b418:	70 e0       	ldi	r23, 0x00	; 0
    b41a:	90 e0       	ldi	r25, 0x00	; 0
    b41c:	80 e0       	ldi	r24, 0x00	; 0
    b41e:	40 e2       	ldi	r20, 0x20	; 32
    b420:	fa dd       	rcall	.-1036   	; 0xb016 <mulacc>
    b422:	f6 2e       	mov	r15, r22
    b424:	fe 01       	movw	r30, r28
    b426:	e3 fc       	sbrc	r14, 3
    b428:	15 91       	lpm	r17, Z+
    b42a:	e3 fe       	sbrs	r14, 3
    b42c:	11 91       	ld	r17, Z+
    b42e:	ef 01       	movw	r28, r30
    b430:	c6 cf       	rjmp	.-116    	; 0xb3be <vfscanf+0x90>
    b432:	ff 24       	eor	r15, r15
    b434:	fa 94       	dec	r15
    b436:	cb cf       	rjmp	.-106    	; 0xb3ce <vfscanf+0xa0>
    b438:	fe 01       	movw	r30, r28
    b43a:	e3 fc       	sbrc	r14, 3
    b43c:	15 91       	lpm	r17, Z+
    b43e:	e3 fe       	sbrs	r14, 3
    b440:	11 91       	ld	r17, Z+
    b442:	ef 01       	movw	r28, r30
    b444:	18 36       	cpi	r17, 0x68	; 104
    b446:	09 f0       	breq	.+2      	; 0xb44a <vfscanf+0x11c>
    b448:	c7 cf       	rjmp	.-114    	; 0xb3d8 <vfscanf+0xaa>
    b44a:	08 60       	ori	r16, 0x08	; 8
    b44c:	04 60       	ori	r16, 0x04	; 4
    b44e:	fe 01       	movw	r30, r28
    b450:	e3 fc       	sbrc	r14, 3
    b452:	15 91       	lpm	r17, Z+
    b454:	e3 fe       	sbrs	r14, 3
    b456:	11 91       	ld	r17, Z+
    b458:	ef 01       	movw	r28, r30
    b45a:	be cf       	rjmp	.-132    	; 0xb3d8 <vfscanf+0xaa>
    b45c:	13 36       	cpi	r17, 0x63	; 99
    b45e:	b9 f4       	brne	.+46     	; 0xb48e <vfscanf+0x160>
    b460:	01 fd       	sbrc	r16, 1
    b462:	02 c0       	rjmp	.+4      	; 0xb468 <vfscanf+0x13a>
    b464:	ff 24       	eor	r15, r15
    b466:	f3 94       	inc	r15
    b468:	c6 01       	movw	r24, r12
    b46a:	79 d0       	rcall	.+242    	; 0xb55e <fgetc>
    b46c:	97 fd       	sbrc	r25, 7
    b46e:	1e c0       	rjmp	.+60     	; 0xb4ac <vfscanf+0x17e>
    b470:	81 14       	cp	r8, r1
    b472:	91 04       	cpc	r9, r1
    b474:	29 f0       	breq	.+10     	; 0xb480 <vfscanf+0x152>
    b476:	f4 01       	movw	r30, r8
    b478:	80 83       	st	Z, r24
    b47a:	c4 01       	movw	r24, r8
    b47c:	01 96       	adiw	r24, 0x01	; 1
    b47e:	4c 01       	movw	r8, r24
    b480:	fa 94       	dec	r15
    b482:	f1 10       	cpse	r15, r1
    b484:	f1 cf       	rjmp	.-30     	; 0xb468 <vfscanf+0x13a>
    b486:	00 fd       	sbrc	r16, 0
    b488:	68 cf       	rjmp	.-304    	; 0xb35a <vfscanf+0x2c>
    b48a:	53 94       	inc	r5
    b48c:	66 cf       	rjmp	.-308    	; 0xb35a <vfscanf+0x2c>
    b48e:	1b 35       	cpi	r17, 0x5B	; 91
    b490:	09 f5       	brne	.+66     	; 0xb4d4 <vfscanf+0x1a6>
    b492:	9e 01       	movw	r18, r28
    b494:	a4 01       	movw	r20, r8
    b496:	6f 2d       	mov	r22, r15
    b498:	c6 01       	movw	r24, r12
    b49a:	7c de       	rcall	.-776    	; 0xb194 <conv_brk>
    b49c:	ec 01       	movw	r28, r24
    b49e:	89 2b       	or	r24, r25
    b4a0:	91 f7       	brne	.-28     	; 0xb486 <vfscanf+0x158>
    b4a2:	f6 01       	movw	r30, r12
    b4a4:	83 81       	ldd	r24, Z+3	; 0x03
    b4a6:	80 73       	andi	r24, 0x30	; 48
    b4a8:	09 f4       	brne	.+2      	; 0xb4ac <vfscanf+0x17e>
    b4aa:	7c cf       	rjmp	.-264    	; 0xb3a4 <vfscanf+0x76>
    b4ac:	8f ef       	ldi	r24, 0xFF	; 255
    b4ae:	9f ef       	ldi	r25, 0xFF	; 255
    b4b0:	51 10       	cpse	r5, r1
    b4b2:	78 cf       	rjmp	.-272    	; 0xb3a4 <vfscanf+0x76>
    b4b4:	df 91       	pop	r29
    b4b6:	cf 91       	pop	r28
    b4b8:	1f 91       	pop	r17
    b4ba:	0f 91       	pop	r16
    b4bc:	ff 90       	pop	r15
    b4be:	ef 90       	pop	r14
    b4c0:	df 90       	pop	r13
    b4c2:	cf 90       	pop	r12
    b4c4:	bf 90       	pop	r11
    b4c6:	af 90       	pop	r10
    b4c8:	9f 90       	pop	r9
    b4ca:	8f 90       	pop	r8
    b4cc:	7f 90       	pop	r7
    b4ce:	6f 90       	pop	r6
    b4d0:	5f 90       	pop	r5
    b4d2:	08 95       	ret
    b4d4:	c6 01       	movw	r24, r12
    b4d6:	c2 dd       	rcall	.-1148   	; 0xb05c <skip_spaces>
    b4d8:	97 fd       	sbrc	r25, 7
    b4da:	e8 cf       	rjmp	.-48     	; 0xb4ac <vfscanf+0x17e>
    b4dc:	1f 36       	cpi	r17, 0x6F	; 111
    b4de:	91 f1       	breq	.+100    	; 0xb544 <vfscanf+0x216>
    b4e0:	30 f4       	brcc	.+12     	; 0xb4ee <vfscanf+0x1c0>
    b4e2:	14 36       	cpi	r17, 0x64	; 100
    b4e4:	41 f0       	breq	.+16     	; 0xb4f6 <vfscanf+0x1c8>
    b4e6:	19 36       	cpi	r17, 0x69	; 105
    b4e8:	39 f0       	breq	.+14     	; 0xb4f8 <vfscanf+0x1ca>
    b4ea:	00 64       	ori	r16, 0x40	; 64
    b4ec:	05 c0       	rjmp	.+10     	; 0xb4f8 <vfscanf+0x1ca>
    b4ee:	13 37       	cpi	r17, 0x73	; 115
    b4f0:	b1 f0       	breq	.+44     	; 0xb51e <vfscanf+0x1f0>
    b4f2:	15 37       	cpi	r17, 0x75	; 117
    b4f4:	d1 f7       	brne	.-12     	; 0xb4ea <vfscanf+0x1bc>
    b4f6:	00 62       	ori	r16, 0x20	; 32
    b4f8:	20 2f       	mov	r18, r16
    b4fa:	a4 01       	movw	r20, r8
    b4fc:	6f 2d       	mov	r22, r15
    b4fe:	c6 01       	movw	r24, r12
    b500:	c4 dd       	rcall	.-1144   	; 0xb08a <conv_int>
    b502:	81 11       	cpse	r24, r1
    b504:	c0 cf       	rjmp	.-128    	; 0xb486 <vfscanf+0x158>
    b506:	cd cf       	rjmp	.-102    	; 0xb4a2 <vfscanf+0x174>
    b508:	81 14       	cp	r8, r1
    b50a:	91 04       	cpc	r9, r1
    b50c:	29 f0       	breq	.+10     	; 0xb518 <vfscanf+0x1ea>
    b50e:	f4 01       	movw	r30, r8
    b510:	60 82       	st	Z, r6
    b512:	c4 01       	movw	r24, r8
    b514:	01 96       	adiw	r24, 0x01	; 1
    b516:	4c 01       	movw	r8, r24
    b518:	fa 94       	dec	r15
    b51a:	ff 20       	and	r15, r15
    b51c:	61 f0       	breq	.+24     	; 0xb536 <vfscanf+0x208>
    b51e:	c6 01       	movw	r24, r12
    b520:	1e d0       	rcall	.+60     	; 0xb55e <fgetc>
    b522:	3c 01       	movw	r6, r24
    b524:	97 fd       	sbrc	r25, 7
    b526:	07 c0       	rjmp	.+14     	; 0xb536 <vfscanf+0x208>
    b528:	0e 94 31 50 	call	0xa062	; 0xa062 <isspace>
    b52c:	89 2b       	or	r24, r25
    b52e:	61 f3       	breq	.-40     	; 0xb508 <vfscanf+0x1da>
    b530:	b6 01       	movw	r22, r12
    b532:	c3 01       	movw	r24, r6
    b534:	50 d0       	rcall	.+160    	; 0xb5d6 <ungetc>
    b536:	81 14       	cp	r8, r1
    b538:	91 04       	cpc	r9, r1
    b53a:	09 f4       	brne	.+2      	; 0xb53e <vfscanf+0x210>
    b53c:	a4 cf       	rjmp	.-184    	; 0xb486 <vfscanf+0x158>
    b53e:	f4 01       	movw	r30, r8
    b540:	10 82       	st	Z, r1
    b542:	a1 cf       	rjmp	.-190    	; 0xb486 <vfscanf+0x158>
    b544:	00 61       	ori	r16, 0x10	; 16
    b546:	d8 cf       	rjmp	.-80     	; 0xb4f8 <vfscanf+0x1ca>

0000b548 <strchr_P>:
strchr_P():
    b548:	fc 01       	movw	r30, r24
    b54a:	05 90       	lpm	r0, Z+
    b54c:	06 16       	cp	r0, r22
    b54e:	21 f0       	breq	.+8      	; 0xb558 <strchr_P+0x10>
    b550:	00 20       	and	r0, r0
    b552:	d9 f7       	brne	.-10     	; 0xb54a <strchr_P+0x2>
    b554:	c0 01       	movw	r24, r0
    b556:	08 95       	ret
    b558:	31 97       	sbiw	r30, 0x01	; 1
    b55a:	cf 01       	movw	r24, r30
    b55c:	08 95       	ret

0000b55e <fgetc>:
fgetc():
    b55e:	cf 93       	push	r28
    b560:	df 93       	push	r29
    b562:	ec 01       	movw	r28, r24
    b564:	2b 81       	ldd	r18, Y+3	; 0x03
    b566:	20 ff       	sbrs	r18, 0
    b568:	1a c0       	rjmp	.+52     	; 0xb59e <fgetc+0x40>
    b56a:	26 ff       	sbrs	r18, 6
    b56c:	0c c0       	rjmp	.+24     	; 0xb586 <fgetc+0x28>
    b56e:	2f 7b       	andi	r18, 0xBF	; 191
    b570:	2b 83       	std	Y+3, r18	; 0x03
    b572:	8e 81       	ldd	r24, Y+6	; 0x06
    b574:	9f 81       	ldd	r25, Y+7	; 0x07
    b576:	01 96       	adiw	r24, 0x01	; 1
    b578:	8e 83       	std	Y+6, r24	; 0x06
    b57a:	9f 83       	std	Y+7, r25	; 0x07
    b57c:	8a 81       	ldd	r24, Y+2	; 0x02
    b57e:	90 e0       	ldi	r25, 0x00	; 0
    b580:	df 91       	pop	r29
    b582:	cf 91       	pop	r28
    b584:	08 95       	ret
    b586:	22 ff       	sbrs	r18, 2
    b588:	18 c0       	rjmp	.+48     	; 0xb5ba <fgetc+0x5c>
    b58a:	e8 81       	ld	r30, Y
    b58c:	f9 81       	ldd	r31, Y+1	; 0x01
    b58e:	80 81       	ld	r24, Z
    b590:	08 2e       	mov	r0, r24
    b592:	00 0c       	add	r0, r0
    b594:	99 0b       	sbc	r25, r25
    b596:	00 97       	sbiw	r24, 0x00	; 0
    b598:	29 f4       	brne	.+10     	; 0xb5a4 <fgetc+0x46>
    b59a:	20 62       	ori	r18, 0x20	; 32
    b59c:	2b 83       	std	Y+3, r18	; 0x03
    b59e:	8f ef       	ldi	r24, 0xFF	; 255
    b5a0:	9f ef       	ldi	r25, 0xFF	; 255
    b5a2:	ee cf       	rjmp	.-36     	; 0xb580 <fgetc+0x22>
    b5a4:	31 96       	adiw	r30, 0x01	; 1
    b5a6:	e8 83       	st	Y, r30
    b5a8:	f9 83       	std	Y+1, r31	; 0x01
    b5aa:	2e 81       	ldd	r18, Y+6	; 0x06
    b5ac:	3f 81       	ldd	r19, Y+7	; 0x07
    b5ae:	2f 5f       	subi	r18, 0xFF	; 255
    b5b0:	3f 4f       	sbci	r19, 0xFF	; 255
    b5b2:	2e 83       	std	Y+6, r18	; 0x06
    b5b4:	3f 83       	std	Y+7, r19	; 0x07
    b5b6:	99 27       	eor	r25, r25
    b5b8:	e3 cf       	rjmp	.-58     	; 0xb580 <fgetc+0x22>
    b5ba:	ea 85       	ldd	r30, Y+10	; 0x0a
    b5bc:	fb 85       	ldd	r31, Y+11	; 0x0b
    b5be:	09 95       	icall
    b5c0:	97 ff       	sbrs	r25, 7
    b5c2:	f3 cf       	rjmp	.-26     	; 0xb5aa <fgetc+0x4c>
    b5c4:	2b 81       	ldd	r18, Y+3	; 0x03
    b5c6:	01 96       	adiw	r24, 0x01	; 1
    b5c8:	21 f0       	breq	.+8      	; 0xb5d2 <fgetc+0x74>
    b5ca:	80 e2       	ldi	r24, 0x20	; 32
    b5cc:	82 2b       	or	r24, r18
    b5ce:	8b 83       	std	Y+3, r24	; 0x03
    b5d0:	e6 cf       	rjmp	.-52     	; 0xb59e <fgetc+0x40>
    b5d2:	80 e1       	ldi	r24, 0x10	; 16
    b5d4:	fb cf       	rjmp	.-10     	; 0xb5cc <fgetc+0x6e>

0000b5d6 <ungetc>:
ungetc():
    b5d6:	fb 01       	movw	r30, r22
    b5d8:	23 81       	ldd	r18, Z+3	; 0x03
    b5da:	20 ff       	sbrs	r18, 0
    b5dc:	11 c0       	rjmp	.+34     	; 0xb600 <ungetc+0x2a>
    b5de:	26 fd       	sbrc	r18, 6
    b5e0:	0f c0       	rjmp	.+30     	; 0xb600 <ungetc+0x2a>
    b5e2:	8f 3f       	cpi	r24, 0xFF	; 255
    b5e4:	98 07       	cpc	r25, r24
    b5e6:	71 f0       	breq	.+28     	; 0xb604 <ungetc+0x2e>
    b5e8:	82 83       	std	Z+2, r24	; 0x02
    b5ea:	2f 7d       	andi	r18, 0xDF	; 223
    b5ec:	20 64       	ori	r18, 0x40	; 64
    b5ee:	23 83       	std	Z+3, r18	; 0x03
    b5f0:	26 81       	ldd	r18, Z+6	; 0x06
    b5f2:	37 81       	ldd	r19, Z+7	; 0x07
    b5f4:	21 50       	subi	r18, 0x01	; 1
    b5f6:	31 09       	sbc	r19, r1
    b5f8:	26 83       	std	Z+6, r18	; 0x06
    b5fa:	37 83       	std	Z+7, r19	; 0x07
    b5fc:	99 27       	eor	r25, r25
    b5fe:	08 95       	ret
    b600:	8f ef       	ldi	r24, 0xFF	; 255
    b602:	9f ef       	ldi	r25, 0xFF	; 255
    b604:	08 95       	ret

0000b606 <__divmodqi4>:
__divmodqi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1366
    b606:	87 fb       	bst	r24, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1367
    b608:	08 2e       	mov	r0, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1368
    b60a:	06 26       	eor	r0, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1369
    b60c:	87 fd       	sbrc	r24, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1370
    b60e:	81 95       	neg	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1371
    b610:	67 fd       	sbrc	r22, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1372
    b612:	61 95       	neg	r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1373
    b614:	0c d0       	rcall	.+24     	; 0xb62e <__udivmodqi4>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1374
    b616:	0e f4       	brtc	.+2      	; 0xb61a <__divmodqi4_1>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1375
    b618:	91 95       	neg	r25

0000b61a <__divmodqi4_1>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1377
    b61a:	07 fc       	sbrc	r0, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1378
    b61c:	81 95       	neg	r24

0000b61e <__divmodqi4_exit>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1380
    b61e:	08 95       	ret

0000b620 <__xload_1>:
__xload_1():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2635
    b620:	57 fd       	sbrc	r21, 7
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2636
    b622:	03 c0       	rjmp	.+6      	; 0xb62a <__xload_1+0xa>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2638
    b624:	5b bf       	out	0x3b, r21	; 59
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2640
    b626:	67 91       	elpm	r22, Z+
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2641
    b628:	08 95       	ret
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2642
    b62a:	60 81       	ld	r22, Z
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2643
    b62c:	08 95       	ret

0000b62e <__udivmodqi4>:
__udivmodqi4():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1346
    b62e:	99 1b       	sub	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1347
    b630:	79 e0       	ldi	r23, 0x09	; 9
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1348
    b632:	04 c0       	rjmp	.+8      	; 0xb63c <__udivmodqi4_ep>

0000b634 <__udivmodqi4_loop>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1350
    b634:	99 1f       	adc	r25, r25
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1351
    b636:	96 17       	cp	r25, r22
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1352
    b638:	08 f0       	brcs	.+2      	; 0xb63c <__udivmodqi4_ep>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1353
    b63a:	96 1b       	sub	r25, r22

0000b63c <__udivmodqi4_ep>:
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1355
    b63c:	88 1f       	adc	r24, r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1356
    b63e:	7a 95       	dec	r23
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1357
    b640:	c9 f7       	brne	.-14     	; 0xb634 <__udivmodqi4_loop>
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1358
    b642:	80 95       	com	r24
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:1360
    b644:	08 95       	ret

0000b646 <_exit>:
exit():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2278
    b646:	f8 94       	cli

0000b648 <__stop_program>:
__stop_program():
/home/admin/Arduino/toolchain-avr-special/gcc-build/avr/avrxmega4/libgcc/../../../../gcc/libgcc/config/avr/lib1funcs.S:2280
    b648:	ff cf       	rjmp	.-2      	; 0xb648 <__stop_program>
